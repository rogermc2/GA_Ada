addBlade[pMV_, pblade_] := AppendTo[pMV, pblade]
 
normedPoint[pe1_, pe2_, pe3_] := {{0, 1}, {1, pe1}, {2, pe2}, {4, pe3}, 
     {8, 0.5*Sqrt[pe1^2 + pe2^2 + pe3^2]}}
 
generalInverse[pMV_, pMetric_] := Module[{mvSize, mMatrix, lMax, i, j, 
      basisBlades, b, gp, invMatrix, v, result = {}}, 
     dim = Dimensions[pMV, 1][[1]]; lMax = BitShiftLeft[1, dim]; 
      mMatrix = Table[0, {i, 1, lMax}, {j, 1, lMax}]; 
      basisBlades = Table[blade[i - 1, 1], {i, 1, lMax}]; 
      Do[b = pMV[[i]]; Do[gp = geometricProduct[b, basisBlades[[j]], 
            pMetric]; mMatrix = addToMatrix[mMatrix, basisBlades[[j]], gp], 
         {j, 1, lMax}], {i, 1, dim}]; Print["generalInverse final mMatrix: ", 
       MatrixForm[mMatrix]]; 
      Print["generalInverse final mMatrix determinant: ", 
       MatrixForm[Det[mMatrix]]]; invMatrix = Inverse[mMatrix]; 
      Print["generalInverse final invMatrix determinant: ", 
       MatrixForm[Det[invMatrix]]]; Print["generalInverse invMatrix: ", 
       MatrixForm[invMatrix]]; Do[v = invMatrix[[j,1]]; 
        If[v != 0, basisBlades[[j,2]] = v; result = AppendTo[result, 
            basisBlades[[j]]]], {j, 1, lMax}]; Return[result]]
 
blade[pBitMap_, pWeight_] := {pBitMap, pWeight}
 
geometricProduct[pBladeA_, pBladeB_] := gpOp[pBladeA, pBladeB, False]
 
gpOp[pBladeA_, pBladeB_, pOuter_] := Module[{bBlade = {0, 0}, bitmap, sign}, 
     If[pOuter == True && BitAnd[pBladeA[[1]], pBladeB[[1]]] != 0, Null, 
       bitmap = BitXor[pBladeA[[1]], pBladeB[[1]]]; 
        sign = canonicalReorderingSign[pBladeA[[1]], pBladeB[[1]]]; 
        bBlade = blade[bitmap, sign*pBladeA[[2]]*pBladeB[[2]]]]; bBlade]
 
canonicalReorderingSign[pA_, pB_] := Module[{a = pA, sum = 0, sign = 1}, 
     If[IntegerQ[pA] && IntegerQ[pB], a = BitShiftRight[a, 1]; 
        While[a != 0, sum = sum + bitCount[BitAnd[a, pB]]; 
          a = BitShiftRight[a, 1]]]; sign = If[BitAnd[sum, 1] == 0, 1, -1, 
        Print[
         "canonicalReorderingSign called with non-integer input parameter!"]]\
; sign]
 
bitCount[pi_] := Module[{i = pi}, 
     i = i - BitAnd[BitShiftRight[i, 1], 1431655765]; 
      i = BitAnd[i, 858993459] + BitAnd[BitShiftRight[i, 2], 858993459]; 
      i = BitAnd[i + BitShiftRight[i, 4], 252645135]; 
      i = i + BitShiftRight[i, 8]; i = i + BitShiftRight[i, 16]; 
      BitAnd[i, 63]]
 
addToMatrix[pMatrix_, pBeta_, pGamma_] := 
    Module[{v, aBlade, result = pMatrix}, 
     Do[aBlade := pGamma[[i]]; v = result[[aBlade[[1]] + 1,pBeta[[1]] + 1]]; 
        result[[aBlade[[1]] + 1,pBeta[[1]] + 1]] = v + aBlade[[2]], 
       {i, 1, Dimensions[pGamma, 1][[1]]}]; result]
 
mvGeometricProduct[pMVa_, pMVb_] := Module[{bladeA = {0, 0}, bladeB = {0, 0}, 
      gp = {0, 0}, result = {{0, 0}}}, 
     Do[bladeA = pMVa[[indexA]]; Do[bladeB = pMVb[[indexB]]; 
          gp = geometricProduct[bladeA, bladeB]; result = AppendTo[result, 
            gp], {indexB, 1, Dimensions[pMVb, 1][[1]]}], 
       {indexA, 1, Dimensions[pMVa, 1][[1]]}]; result = mvSimplify[result]; 
      result]
 
mvSimplify[pBladeList_] := Module[{result = {}, 
      dim = Dimensions[pBladeList][[1]], sortedA = {}, i, current = {}, 
      b = {}}, If[dim == 0, result = pBladeList, 
       Do[b = pBladeList[[i]]; If[b[[2]] != 0., sortedA = AppendTo[sortedA, 
             b]], {i, 1, dim}]; sortedA = SortBy[sortedA, First]; 
        current = sortedA[[1]]; Do[b = sortedA[[i]]; 
          If[b[[1]] == current[[1]], current[[2]] = current[[2]] + b[[2]], 
           If[current[[2]] != 0., result = AppendTo[result, current]]; 
            current = b], {i, 2, Dimensions[sortedA][[1]]}]; 
        If[current[[2]] != 0., result = AppendTo[result, current]]; ]; result]
 
mvOuterProduct[pMVa_, pMVb_] := Module[{bladeA = {0, 0}, bladeB = {0, 0}, 
      op = {0, 0}, result = {{0, 0}}}, 
     Do[bladeA = pMVa[[indexA]]; Do[bladeB = pMVb[[indexB]]; 
          op = outerProduct[bladeA, bladeB]; result = AppendTo[result, op], 
         {indexB, 1, Dimensions[pMVb, 1][[1]]}], 
       {indexA, 1, Dimensions[pMVa, 1][[1]]}]; result = mvSimplify[result]; 
      result]
 
outerProduct[pBladeA_, pBladeB_] := gpOp[pBladeA, pBladeB, True]
 
mvInnerProduct[pMVA_, pMVB_, pType_:leftContraction] := 
    Module[{result = {{0, 0}}, blade1 = {0, 0}, blade2 = {0, 0}, i, j}, 
     Do[blade1 = pMVA[[i]]; Do[blade2 = pMVB[[j]]; AppendTo[result, 
           innerProduct[blade1, blade2, pType]], 
         {j, 1, Dimensions[pMVB, 1][[1]]}], {i, 1, Dimensions[pMVA, 1][[
         1]]}]; result = mvSimplify[result]; result]
 
innerProduct[pBladeA_, pBladeB_, pType_:leftContraction] := 
    Module[{gp = geometricProduct[pBladeA, pBladeB]}, 
     innerProductFilter[pBladeA[[1]], pBladeB[[1]], gp, pType]]
 
innerProduct[pBladeA_, pBladeB_, pMet_, pType_:leftContraction] := 
    Module[{gp = geometricProduct[pBladeA, pBladeB, pMet]}, 
     Print["innerProduct metric gp ", gp]; innerProductFilter[pBladeA[[1]], 
       pBladeB[[1]], gp, pType]]
 
innerProductFilter[pGradeA_, pGradeB_, pBlade_, pType_:leftContraction] := 
    Module[{result = {0, 0}, blade = {0, 0}}, 
     blade = innerProductFilterBlade[pGradeA, pGradeB, pBlade, pType]; 
      If[blade[[2]] != 0., result = blade]; result]
 
innerProductFilterBlade[pGradeA_, pGradeB_, pBlade_, 
     pType_:leftContraction] := Module[{result = pBlade, blade = {0, 0}}, 
     Switch[pType, leftContraction, If[Inequality[pGradeA, Greater, 
         pGradeB*or*pBlade[[1]], Unequal, pGradeB - pGradeA], 
        result = blade], rightContraction, If[Inequality[pGradeA, Less, 
         pGradeB*or*pBlade[[1]], Unequal, pGradeA - pGradeB], 
        result = blade], hestenes, If[pGradeA == 0*or*pGradeA == 0, 
        result = blade, If[Abs[pGradeA - pGradeB] != pBlade[[1]], 
         result = blade]], modifiedHestenes, 
       If[Abs[pGradeA - pGradeB] != pBlade[[1]], result = blade]]; result]
 
scalarProduct[pMV_] := Module[{result = 0, index, blade = {}}, 
     Do[blade = pMV[[index]]; If[blade[[1]] == 0, 
         result = result + blade[[2]]], {index, 1, Dimensions[pMV][[1]]}]; 
      result]
