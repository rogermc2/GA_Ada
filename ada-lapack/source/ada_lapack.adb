-- Copyright (c) 1992-2011 The University of Tennessee and The University
--                         of Tennessee Research Foundation.  All rights
--                         reserved.
-- Copyright (c) 2000-2011 The University of California Berkeley. All
--                         rights reserved.
-- Copyright (c) 2006-2012 The University of Colorado Denver.  All rights
--                         reserved.
--
-- $COPYRIGHT$
--
-- Additional copyrights may follow
--
-- $HEADER$
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
-- - Redistributions of source code must retain the above copyright
--   notice, this list of conditions and the following disclaimer.
--
-- - Redistributions in binary form must reproduce the above copyright
--   notice, this list of conditions and the following disclaimer listed
--   in this license in the documentation and/or other materials
--   provided with the distribution.
--
-- - Neither the name of the copyright holders nor the names of its
--   contributors may be used to endorse or promote products derived from
--   this software without specific prior written permission.
--
-- The copyright holders provide no reassurances that the source code
-- provided does not infringe any patent, copyright, or any other
-- intellectual property rights of third parties.  The copyright holders
-- disclaim any liability to any recipient for claims brought against
-- recipient by any third party for infringement of that parties
-- intellectual property rights.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-- LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-- OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-- 15-Oct-2012 Version 1.1 Leo Brewin <Leo.Brewin@monash.edu>
-- 15-Aug-2012 Version 1.0 Leo Brewin <Leo.Brewin@monash.edu>

with Ada.Text_IO; use Ada.Text_IO;
with Ada.Numerics.Generic_Elementary_Functions;
with Ada.Numerics.Generic_Complex_Elementary_Functions;

package body Ada_Lapack is

   package Real_Maths is new Ada.Numerics.Generic_Elementary_Functions (Real);
   package Complex_Maths is new Ada.Numerics.Generic_Complex_Elementary_Functions (Complex_Types);

   use Real_Maths;
   use Complex_Maths;

   function max (a : Real; b : Real) return Real is
      result : Real := a;
   begin
      if a > b 
         then result := a;
         else result := b;
      end if;
      return result;
   end max;

   function max
     (a    : Real;
      b    : Real;
      c    : Real)
      return Real
   is
   begin
      return max (a, max (b, c));
   end max;

   function max
     (a    : Real;
      b    : Real;
      c    : Real;
      d    : Real)
      return Real
   is
   begin
      return max (a, max (b, max (c, d)));
   end max;

   function max
     (a    : Real;
      b    : Real;
      c    : Real;
      d    : Real;
      e    : Real)
      return Real
   is
   begin
      return max (a, max (b, max (c, max (d, e))));
   end max;

   function max (a : Integer; b : Integer) return Integer is
      result : Integer := a;
   begin
      if a > b 
         then result := a;
         else result := b;
      end if;
      return result;
   end max;

   function max
     (a    : Integer;
      b    : Integer;
      c    : Integer)
      return Integer
   is
   begin
      return max (a, max (b, c));
   end max;

   function min (a : Real; b : Real) return Real is
      result : Real := a;
   begin
      if a < b 
         then result := a;
         else result := b;
      end if;
      return result;
   end min;

   function min
     (a    : Real;
      b    : Real;
      c    : Real)
      return Real
   is
   begin
      return min (a, min (b, c));
   end min;

   function min
     (a    : Real;
      b    : Real;
      c    : Real;
      d    : Real)
      return Real
   is
   begin
      return min (a, min (b, min (c, d)));
   end min;

   function min (a : Integer; b : Integer) return Integer is
      result : Integer := a;
   begin
      if a < b 
         then result := a;
         else result := b;
      end if;
      return result;
   end min;

   function min
     (a    : Integer;
      b    : Integer;
      c    : Integer)
      return Integer
   is
   begin
      return min (a, min (b, c));
   end min;

   function min
     (a    : Integer;
      b    : Integer;
      c    : Integer;
      d    : Integer)
      return Integer
   is
   begin
      return min (a, min (b, min (c, d)));
   end min;

   function DABS (x : Real) return Real is
   begin
      return abs (x);
   end DABS;

   function DCABS1 (z : Complex) return Real is
   begin
      return abs (Re (z)) + abs (Im (z));
   end DCABS1;

   function CABS (z : Complex) return Real is
   begin
      return abs (z);
   end CABS;

   function ABS1 (z : Complex) return Real is
   begin
      return max (abs (Re (z)), abs (Im (z)));
   end ABS1;

   function ABSSQ (z : Complex) return Real is
   begin
      return Re (z) * Re (z) + Im (z) * Im (z);
   end ABSSQ;

   function CABS1 (z : Complex) return Real is
   begin
      return abs (Re (z)) + abs (Im (z));
   end CABS1;

   function CABS2 (z : Complex) return Real is
   begin
      return (abs (Re (z)) + abs (Im (z))) / 2.0e0;
   end CABS2;

   function char (num : Integer) return Character is
   begin
      return Character'Val (num);
   end char;

   function conjg (z : Complex) return Complex is
   begin
      return Complex'(Re (z), -Im (z));
   end conjg;

   function dble (z : Complex) return Real is
   begin
      return Re (z);
   end dble;

   function dimag (z : Complex) return Real is
   begin
      return Im (z);
   end dimag;

   function dcmplx (x, y : Real) return Complex is
   begin
      return Complex'(x, y);
   end dcmplx;

   function dconjg (z : Complex) return Complex is
   begin
      return Complex'(Re (z), -Im (z));
   end dconjg;

   function epsilon (x : Real) return Real is
   begin
      return Real'Model_Epsilon;
   end epsilon;

   function the_digits (x : Real) return Integer is
   begin
      return Integer (Real (1 + Real'Digits) / Log (2.0, 10.0));
   end the_digits;

   function huge (i : Integer) return Integer is
   begin
      return Integer'Last;
   end huge;

   function huge (x : Real) return Real is
   begin
      return Real'Safe_Last;
   end huge;

   function tiny (x : Real) return Real is
   begin
      return Real'Model_Small;
   end tiny;

   function ichar (c : Character) return Integer is
   begin
      return Character'Pos (c);
   end ichar;

   -- int(+6.66) --> +6 and int(-6.66) --> -6
   function int (x : Real) return Integer is
   begin
      return Integer (Real'Truncation (x));
   end int;

   function log2 (x : Real) return Real is
   begin
      return Log (x, 2.0);
   end log2;

   function intlog2 (x : Integer) return Integer is
   begin
      return int (Log (Real (x), 2.0));
   end intlog2;

   function log10 (x : Real) return Real is
   begin
      return Log (x, 10.0);
   end log10;

   function maxexponent (x : Real) return Integer is
   begin
      return Real'Machine_Emax;
   end maxexponent;

   function minexponent (x : Real) return Integer is
   begin
      return Real'Machine_Emin;
   end minexponent;

   -- nint(+1.23) --> +1 and nint(-1.23) --> -1
   -- nint(+1.78) --> +2 and nint(-1.78) --> -2
   function nint (x : Real) return Integer is
   begin
      return Integer (Real'Floor (x + 0.5e0));
   end nint;

   function radix (x : Real) return Integer is
   begin
      return Real'Machine_Radix;
   end radix;

   function sign (i, j : Integer) return Integer is
      result : Integer;
   begin
      if j < 0 
         then result := - abs (i);
         else result := abs (i);
      end if;
      return result;
   end sign;

   function sign (x, y : Real) return Real is
      result : Real;
   begin
      if y < 0.0 
         then result := - abs (x);
         else result := abs (x);
      end if;
      return result;
   end sign;

   function real_part (z : Complex) return Real is
   begin
      return Re (z);
   end real_part;

   function imag_part (z : Complex) return Real is
   begin
      return Im (z);
   end imag_part;

   function Pure_Real (z : Complex) return Complex is
   begin
      return Complex'(Re (z), 0.0);
   end Pure_Real;

   -- pragma Inline (max);
   -- pragma Inline (min);
   -- pragma Inline (DABS);
   -- pragma Inline (DCABS1);
   -- pragma Inline (CABS);
   -- pragma Inline (ABS1);
   -- pragma Inline (ABSSQ);
   -- pragma Inline (CABS1);
   -- pragma Inline (CABS2);
   -- pragma Inline (char);
   -- pragma Inline (conjg);
   -- pragma Inline (dble);
   -- pragma Inline (dimag);
   -- pragma Inline (dcmplx);
   -- pragma Inline (dconjg);
   -- pragma Inline (epsilon);
   -- pragma Inline (the_digits);
   -- pragma Inline (huge);
   -- pragma Inline (tiny);
   -- pragma Inline (ichar);
   -- pragma Inline (int);
   -- pragma Inline (log10);
   -- pragma Inline (maxexponent);
   -- pragma Inline (minexponent);
   -- pragma Inline (nint);
   -- pragma Inline (radix);
   -- pragma Inline (sign);
   -- pragma Inline (real_part);
   -- pragma Inline (imag_part);

----------------------------------------------------------------------------
-- Interface
----------------------------------------------------------------------------

   procedure GEEV
     (JOBVL : Character;
      JOBVR : Character;
      N     : Integer;
      A     : in out Real_Matrix;
      LDA   : Integer;
      WR    : in out Real_Vector;
      WI    : in out Real_Vector;
      VL    : in out Real_Matrix;
      LDVL  : Integer;
      VR    : in out Real_Matrix;
      LDVR  : Integer;
      WORK  : in out Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      Ftn_A    : Ftn_Real_Matrix := Ftn_Real_Matrix (A);
      Ftn_WR   : Ftn_Real_Vector := Ftn_Real_Vector (WR);
      Ftn_WI   : Ftn_Real_Vector := Ftn_Real_Vector (WI);
      Ftn_VL   : Ftn_Real_Matrix := Ftn_Real_Matrix (VL);
      Ftn_VR   : Ftn_Real_Matrix := Ftn_Real_Matrix (VR);
      Ftn_WORK : Ftn_Real_Vector := Ftn_Real_Vector (WORK);
   begin

     DGEEV (JOBVL, JOBVR, N, Ftn_A, LDA, Ftn_WR, Ftn_WI, Ftn_VL, LDVL, Ftn_VR, LDVR, Ftn_WORK, LWORK, INFO);

      A    := Real_Matrix (Ftn_A);
      WR   := Real_Vector (Ftn_WR);
      WI   := Real_Vector (Ftn_WI);
      VL   := Real_Matrix (Ftn_VL);
      VR   := Real_Matrix (Ftn_VR);
      WORK := Real_Vector (Ftn_WORK);

   end GEEV;

   procedure GESDD
     (JOBZ  : Character;
      M     : Integer;
      N     : Integer;
      A     : in out Real_Matrix;
      LDA   : Integer;
      S     : in out Real_Vector;
      U     : in out Real_Matrix;
      LDU   : Integer;
      VT    : in out Real_Matrix;
      LDVT  : Integer;
      WORK  : in out Real_Vector;
      LWORK : Integer;
      IWORK : in out Integer_Vector;
      INFO  : in out Integer)
   is
      Ftn_A     : Ftn_Real_Matrix    := Ftn_Real_Matrix    (A);
      Ftn_S     : Ftn_Real_Vector    := Ftn_Real_Vector    (S);
      Ftn_U     : Ftn_Real_Matrix    := Ftn_Real_Matrix    (U);
      Ftn_VT    : Ftn_Real_Matrix    := Ftn_Real_Matrix    (VT);
      Ftn_WORK  : Ftn_Real_Vector    := Ftn_Real_Vector    (WORK);
      Ftn_IWORK : Ftn_Integer_Vector := Ftn_Integer_Vector (IWORK);
   begin
      
      DGESDD (JOBZ, M, N, Ftn_A, LDA, Ftn_S, Ftn_U, LDU, Ftn_VT, LDVT, Ftn_WORK, LWORK, Ftn_IWORK, INFO);
      
      A     := Real_Matrix    (Ftn_A);
      S     := Real_Vector    (Ftn_S);
      U     := Real_Matrix    (Ftn_U);
      VT    := Real_Matrix    (Ftn_VT);
      WORK  := Real_Vector    (Ftn_WORK);
      IWORK := Integer_Vector (Ftn_IWORK);
      
   end GESDD;

   procedure GESV
     (N    : Integer;
      NRHS : Integer;
      A    : in out Real_Matrix;
      LDA  : Integer;
      IPIV : in out Integer_Vector;
      B    : in out Real_Matrix;
      LDB  : Integer;
      INFO : in out Integer)
   is
      Ftn_A    : Ftn_Real_Matrix    := Ftn_Real_Matrix    (A);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
      Ftn_B    : Ftn_Real_Matrix    := Ftn_Real_Matrix    (B);
   begin
      
      DGESV (N, NRHS, Ftn_A, LDA, Ftn_IPIV, Ftn_B, LDB, INFO);
      
      A    := Real_Matrix    (Ftn_A);
      IPIV := Integer_Vector (Ftn_IPIV);
      B    := Real_Matrix    (Ftn_B);
      
   end GESV;

   procedure GESVD
     (JOBU  : Character;
      JOBVT : Character;
      M     : Integer;
      N     : Integer;
      A     : in out Real_Matrix;
      LDA   : Integer;
      S     : in out Real_Vector;
      U     : in out Real_Matrix;
      LDU   : Integer;
      VT    : in out Real_Matrix;
      LDVT  : Integer;
      WORK  : in out Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      Ftn_A     : Ftn_Real_Matrix := Ftn_Real_Matrix (A);
      Ftn_S     : Ftn_Real_Vector := Ftn_Real_Vector (S);
      Ftn_U     : Ftn_Real_Matrix := Ftn_Real_Matrix (U);
      Ftn_VT    : Ftn_Real_Matrix := Ftn_Real_Matrix (VT);
      Ftn_WORK  : Ftn_Real_Vector := Ftn_Real_Vector (WORK);
   begin

      DGESVD (JOBU, JOBVT, M, N, Ftn_A, LDA, Ftn_S, Ftn_U, LDU, Ftn_VT, LDVT, Ftn_WORK, LWORK, INFO);

      A    := Real_Matrix (Ftn_A);
      S    := Real_Vector (Ftn_S);
      U    := Real_Matrix (Ftn_U);
      VT   := Real_Matrix (Ftn_VT);
      WORK := Real_Vector (Ftn_WORK);

   end GESVD;

   procedure GETRF
     (M    : Integer;
      N    : Integer;
      A    : in out Real_Matrix;
      LDA  : Integer;
      IPIV : in out Integer_Vector;
      INFO : in out Integer)
   is
      Ftn_A    : Ftn_Real_Matrix    := Ftn_Real_Matrix    (A);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
   begin

      DGETRF (M, N, Ftn_A, LDA, Ftn_IPIV, INFO);
      
      A    := Real_Matrix    (Ftn_A);
      IPIV := Integer_Vector (Ftn_IPIV);
      
   end GETRF;
   

   procedure GETRI
     (N     : Integer;
      A     : in out Real_Matrix;
      LDA   : Integer;
      IPIV  : in out Integer_Vector;
      WORK  : in out Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      Ftn_A    : Ftn_Real_Matrix    := Ftn_Real_Matrix    (A);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
      Ftn_WORK : Ftn_Real_Vector    := Ftn_Real_Vector    (WORK);
   begin

      DGETRI (N, Ftn_A, LDA, Ftn_IPIV, Ftn_WORK, LWORK, INFO);
      
      A    := Real_Matrix    (Ftn_A);
      IPIV := Integer_Vector (Ftn_IPIV);
      WORK := Real_Vector    (Ftn_WORK);
      
   end GETRI;

   procedure GETRS
     (TRANS : Character;
      N     : Integer;
      NRHS  : Integer;
      A     : in out Real_Matrix;
      LDA   : Integer;
      IPIV  : in out Integer_Vector;
      B     : in out Real_Matrix;
      LDB   : Integer;
      INFO  : in out Integer)
   is
      Ftn_A    : Ftn_Real_Matrix    := Ftn_Real_Matrix    (A);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
      Ftn_B    : Ftn_Real_Matrix    := Ftn_Real_Matrix    (B);
   begin

      DGETRS (TRANS, N, NRHS, Ftn_A, LDA, Ftn_IPIV, Ftn_B, LDB, INFO);
      
      A    := Real_Matrix    (Ftn_A);
      IPIV := Integer_Vector (Ftn_IPIV);
      B    := Real_Matrix    (Ftn_B);
      
   end GETRS;

   procedure SYEV
     (JOBZ  : Character;
      UPLO  : Character;
      N     : Integer;
      A     : in out Real_Matrix;
      LDA   : Integer;
      W     : in out Real_Vector;
      WORK  : in out Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      Ftn_A    : Ftn_Real_Matrix := Ftn_Real_Matrix (A);
      Ftn_W    : Ftn_Real_Vector := Ftn_Real_Vector (W);
      Ftn_WORK : Ftn_Real_Vector := Ftn_Real_Vector (WORK);
   begin

      DSYEV (JOBZ, UPLO, N, Ftn_A, LDA, Ftn_W, Ftn_WORK, LWORK, INFO);

      A    := Real_Matrix (Ftn_A);
      W    := Real_Vector (Ftn_W);
      WORK := Real_Vector (Ftn_WORK);

   end SYEV;

   procedure SYEVD
      (JOBZ   : Character;
       UPLO   : Character;
       N      : Integer;
       A      : in out Real_Matrix;
       LDA    : Integer;
       W      : in out Real_Vector;
       WORK   : in out Real_Vector;
       LWORK  : Integer;
       IWORK  : in out Integer_Vector;
       LIWORK : Integer;
       INFO   : in out Integer)
   is
      Ftn_A     : Ftn_Real_Matrix := Ftn_Real_Matrix (A);
      Ftn_W     : Ftn_Real_Vector := Ftn_Real_Vector (W);
      Ftn_WORK  : Ftn_Real_Vector := Ftn_Real_Vector (WORK);
      Ftn_IWORK : Ftn_Integer_Vector := Ftn_Integer_Vector (IWORK);
   begin

      DSYEVD (JOBZ, UPLO, N, Ftn_A, LDA, Ftn_W, Ftn_WORK, LWORK, Ftn_IWORK, LIWORK, INFO);

      A     := Real_Matrix (Ftn_A);
      W     := Real_Vector (Ftn_W);
      WORK  := Real_Vector (Ftn_WORK);
      IWORK := Integer_Vector (Ftn_IWORK);

   end SYEVD;

	procedure SYSV
	   (UPLO  : Character;
	    N     : Integer;
	    NRHS  : Integer;
	    A     : in out Real_Matrix;
	    LDA   : Integer;
	    IPIV  : out    Integer_Vector;
	    B     : in out Real_Matrix;
	    LDB   : Integer;
	    WORK  : in out Real_Vector;
	    LWORK : Integer;
	    INFO  : in out Integer)
	is
	   Ftn_A    : Ftn_Real_Matrix := Ftn_Real_Matrix (A);
	   Ftn_B    : Ftn_Real_Matrix := Ftn_Real_Matrix (B);
	   Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
	   Ftn_WORK : Ftn_Real_Vector := Ftn_Real_Vector (WORK);
	begin

	   DSYSV (UPLO, N, NRHS, Ftn_A, LDA, Ftn_IPIV, Ftn_B, LDB, Ftn_WORK, LWORK, INFO);

	   A    := Real_Matrix (Ftn_A);
	   B    := Real_Matrix (Ftn_B);
	   IPIV := Integer_Vector (Ftn_IPIV);
	   WORK := Real_Vector (Ftn_WORK);

	end SYSV;

   procedure GEEV
     (JOBVL : Character;
      JOBVR : Character;
      N     : Integer;
      A     : in out Complex_Matrix;
      LDA   : Integer;
      W     : in out Complex_Vector;
      VL    : in out Complex_Matrix;
      LDVL  : Integer;
      VR    : in out Complex_Matrix;
      LDVR  : Integer;
      WORK  : in out Complex_Vector;
      LWORK : Integer;
      RWORK : in out Real_Vector;
      INFO  : in out Integer)
   is
      Ftn_A     : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_W     : Ftn_Complex_Vector := Ftn_Complex_Vector (W);
      Ftn_VL    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (VL);
      Ftn_VR    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (VR);
      Ftn_WORK  : Ftn_Complex_Vector := Ftn_Complex_Vector (WORK);
      Ftn_RWORK : Ftn_Real_Vector    := Ftn_Real_Vector    (RWORK);
   begin

      ZGEEV (JOBVL, JOBVR, N, Ftn_A, LDA, Ftn_W, Ftn_VL, LDVL, Ftn_VR, LDVR, Ftn_WORK, LWORK, Ftn_RWORK, INFO);

      A     := Complex_Matrix (Ftn_A);
      W     := Complex_Vector (Ftn_W);
      VL    := Complex_Matrix (Ftn_VL);
      VR    := Complex_Matrix (Ftn_VR);
      WORK  := Complex_Vector (Ftn_WORK);
      RWORK := Real_Vector    (Ftn_RWORK);

   end GEEV;

   procedure GESDD
     (JOBZ  : Character;
      M     : Integer;
      N     : Integer;
      A     : in out Complex_Matrix;
      LDA   : Integer;
      S     : in out Real_Vector;
      U     : in out Complex_Matrix;
      LDU   : Integer;
      VT    : in out Complex_Matrix;
      LDVT  : Integer;
      WORK  : in out Complex_Vector;
      LWORK : Integer;
      RWORK : in out Real_Vector;
      IWORK : in out Integer_Vector;
      INFO  : in out Integer)
   is
      Ftn_A     : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_S     : Ftn_Real_Vector    := Ftn_Real_Vector    (S);
      Ftn_U     : Ftn_Complex_Matrix := Ftn_Complex_Matrix (U);
      Ftn_VT    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (VT);
      Ftn_WORK  : Ftn_Complex_Vector := Ftn_Complex_Vector (WORK);
      Ftn_RWORK : Ftn_Real_Vector    := Ftn_Real_Vector    (RWORK);
      Ftn_IWORK : Ftn_Integer_Vector := Ftn_Integer_Vector (IWORK);
   begin

      ZGESDD (JOBZ, M, N, Ftn_A, LDA, Ftn_S, Ftn_U, LDU, Ftn_VT, LDVT, Ftn_WORK, LWORK, Ftn_RWORK, Ftn_IWORK, INFO);

      A     := Complex_Matrix (Ftn_A);
      S     := Real_Vector    (Ftn_S);
      U     := Complex_Matrix (Ftn_U);
      VT    := Complex_Matrix (Ftn_VT);
      WORK  := Complex_Vector (Ftn_WORK);
      RWORK := Real_Vector    (Ftn_RWORK);
      IWORK := Integer_Vector (Ftn_IWORK);

   end GESDD;

   procedure GESV
     (N    : Integer;
      NRHS : Integer;
      A    : in out Complex_Matrix;
      LDA  : Integer;
      IPIV : in out Integer_Vector;
      B    : in out Complex_Matrix;
      LDB  : Integer;
      INFO : in out Integer)
   is
      Ftn_A    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
      Ftn_B    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (B);
   begin

      ZGESV (N, NRHS, Ftn_A, LDA, Ftn_IPIV, Ftn_B, LDB, INFO);

      A    := Complex_Matrix (Ftn_A);
      IPIV := Integer_Vector (Ftn_IPIV);
      B    := Complex_Matrix (Ftn_B);

   end GESV;   

   procedure GESVD
     (JOBU  : Character;
      JOBVT : Character;
      M     : Integer;
      N     : Integer;
      A     : in out Complex_Matrix;
      LDA   : Integer;
      S     : in out Real_Vector;
      U     : in out Complex_Matrix;
      LDU   : Integer;
      VT    : in out Complex_Matrix;
      LDVT  : Integer;
      WORK  : in out Complex_Vector;
      LWORK : Integer;
      RWORK : in out Real_Vector;
      INFO  : in out Integer)
   is
      Ftn_A     : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_S     : Ftn_Real_Vector    := Ftn_Real_Vector    (S);
      Ftn_U     : Ftn_Complex_Matrix := Ftn_Complex_Matrix (U);
      Ftn_VT    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (VT);
      Ftn_WORK  : Ftn_Complex_Vector := Ftn_Complex_Vector (WORK);
      Ftn_RWORK : Ftn_Real_Vector    := Ftn_Real_Vector    (RWORK);
   begin

      ZGESVD (JOBU, JOBVT, M, N, Ftn_A, LDA, Ftn_S, Ftn_U, LDU, Ftn_VT, LDVT, Ftn_WORK, LWORK, Ftn_RWORK, INFO);

      A     := Complex_Matrix (Ftn_A);
      S     := Real_Vector    (Ftn_S);
      U     := Complex_Matrix (Ftn_U);
      VT    := Complex_Matrix (Ftn_VT);
      WORK  := Complex_Vector (Ftn_WORK);
      RWORK := Real_Vector    (Ftn_RWORK);

   end GESVD;

   procedure GETRF
     (M    : Integer;
      N    : Integer;
      A    : in out Complex_Matrix;
      LDA  : Integer;
      IPIV : in out Integer_Vector;
      INFO : in out Integer)
   is
      Ftn_A    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
   begin

      ZGETRF (M, N, Ftn_A, LDA, Ftn_IPIV, INFO);

      A    := Complex_Matrix (Ftn_A);
      IPIV := Integer_Vector (Ftn_IPIV);

   end GETRF;
   

   procedure GETRI
     (N     : Integer;
      A     : in out Complex_Matrix;
      LDA   : Integer;
      IPIV  : in out Integer_Vector;
      WORK  : in out Complex_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      Ftn_A    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
      Ftn_WORK : Ftn_Complex_Vector := Ftn_Complex_Vector (WORK);
   begin

      ZGETRI (N, Ftn_A, LDA, Ftn_IPIV, Ftn_WORK, LWORK, INFO);

      A    := Complex_Matrix (Ftn_A);
      IPIV := Integer_Vector (Ftn_IPIV);
      WORK := Complex_Vector (Ftn_WORK);

   end GETRI;

   procedure GETRS
     (TRANS : Character;
      N     : Integer;
      NRHS  : Integer;
      A     : in out Complex_Matrix;
      LDA   : Integer;
      IPIV  : in out Integer_Vector;
      B     : in out Complex_Matrix;
      LDB   : Integer;
      INFO  : in out Integer)
   is
      Ftn_A    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
      Ftn_B    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (B);
   begin

      ZGETRS (TRANS, N, NRHS, Ftn_A, LDA, Ftn_IPIV, Ftn_B, LDB, INFO);

      A    := Complex_Matrix (Ftn_A);
      IPIV := Integer_Vector (Ftn_IPIV);
      B    := Complex_Matrix (Ftn_B);

   end GETRS;

   procedure HEEV
     (JOBZ  : Character;
      UPLO  : Character;
      N     : Integer;
      A     : in out Complex_Matrix;
      LDA   : Integer;
      W     : in out Real_Vector;
      WORK  : in out Complex_Vector;
      LWORK : Integer;
      RWORK : out Real_Vector;
      INFO  : in out Integer)
   is
      Ftn_A     : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_W     : Ftn_Real_Vector := Ftn_Real_Vector (W);
      Ftn_WORK  : Ftn_Complex_Vector := Ftn_Complex_Vector (WORK);
      Ftn_RWORK : Ftn_Real_Vector := Ftn_Real_Vector (RWORK);
   begin

      ZHEEV (JOBZ, UPLO, N, Ftn_A, LDA, Ftn_W, Ftn_WORK, LWORK, Ftn_RWORK, INFO);

      A     := Complex_Matrix (Ftn_A);
      W     := Real_Vector (Ftn_W);
      WORK  := Complex_Vector (Ftn_WORK);
      RWORK := Real_Vector (Ftn_RWORK);

   end HEEV;

   procedure HEEVD
      (JOBZ   : Character;
       UPLO   : Character;
       N      : Integer;
       A      : in out Complex_Matrix;
       LDA    : Integer;
       W      : in out Real_Vector;
       WORK   : in out Complex_Vector;
       LWORK  : Integer;
       RWORK  : in out Real_Vector;
       LRWORK : Integer;
       IWORK  : in out Integer_Vector;
       LIWORK : Integer;
       INFO   : in out Integer)

   is
      Ftn_A     : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_W     : Ftn_Real_Vector := Ftn_Real_Vector (W);
      Ftn_WORK  : Ftn_Complex_Vector := Ftn_Complex_Vector (WORK);
      Ftn_RWORK : Ftn_Real_Vector := Ftn_Real_Vector (RWORK);
      Ftn_IWORK : Ftn_Integer_Vector := Ftn_Integer_Vector (IWORK);
   begin

      ZHEEVD (JOBZ, UPLO, N, Ftn_A, LDA, Ftn_W, Ftn_WORK, LWORK, Ftn_RWORK, LRWORK, Ftn_IWORK, LIWORK, INFO);

      A     := Complex_Matrix (Ftn_A);
      W     := Real_Vector (Ftn_W);
      WORK  := Complex_Vector (Ftn_WORK);
      RWORK := Real_Vector (Ftn_RWORK);
      IWORK := Integer_Vector (Ftn_IWORK);

   end HEEVD;

   procedure SYSV
      (UPLO  : Character;
       N     : Integer;
       NRHS  : Integer;
       A     : in out Complex_Matrix;
       LDA   : Integer;
       IPIV  : out    Integer_Vector;
       B     : in out Complex_Matrix;
       LDB   : Integer;
       WORK  : in out Complex_Vector;
       LWORK : Integer;
       INFO  : in out Integer)
   is
      Ftn_A    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (A);
      Ftn_B    : Ftn_Complex_Matrix := Ftn_Complex_Matrix (B);
      Ftn_IPIV : Ftn_Integer_Vector := Ftn_Integer_Vector (IPIV);
      Ftn_WORK : Ftn_Complex_Vector := Ftn_Complex_Vector (WORK);
   begin

      ZSYSV (UPLO, N, NRHS, Ftn_A, LDA, Ftn_IPIV, Ftn_B, LDB, Ftn_WORK, LWORK, INFO);

      A    := Complex_Matrix (Ftn_A);
      B    := Complex_Matrix (Ftn_B);
      IPIV := Integer_Vector (Ftn_IPIV);
      WORK := Complex_Vector (Ftn_WORK);

   end SYSV;

----------------------------------------------------------------------------
-- Blas
----------------------------------------------------------------------------

   procedure DAXPY
     (N      : Integer;
      DA     : Real;
      DX_adr : Address;
      INCX   : Integer;
      DY_adr : Address;
      INCY   : Integer)
   is

      DX : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));
      DY : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for DX'Address use DX_adr;
      for DY'Address use DY_adr;

      pragma Import (Ada, DX);
      pragma Import (Ada, DY);

      I   : Integer;
      IX  : Integer;
      IY  : Integer;
      M   : Integer;
      MP1 : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION DA
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION DX(*),DY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DAXPY constant times a vector plus a vector.
   --     uses unrolled loops for increments equal to one.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, linpack, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MOD
   --     ..
   begin
      if N <= 0 then
         return;
      end if;
      if DA = 0.0e0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --        code for both increments equal to 1
         --
         --
         --        clean-up loop
         --
         M := "mod" (N, 4);
         if M /= 0 then
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               DY (I) := DY (I) + DA * DX (I);
            end loop;
         end if;
         if N < 4 then
            return;
         end if;
         MP1 := M + 1;
         I   := MP1;
         while I <= N loop
            DY (I)     := DY (I) + DA * DX (I);
            DY (I + 1) := DY (I + 1) + DA * DX (I + 1);
            DY (I + 2) := DY (I + 2) + DA * DX (I + 2);
            DY (I + 3) := DY (I + 3) + DA * DX (I + 3);
            I          := I + 4;
         end loop;
      else
         --
         --        code for unequal increments or equal increments
         --          not equal to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            DY (IY) := DY (IY) + DA * DX (IX);
            IX      := IX + INCX;
            IY      := IY + INCY;
         end loop;
      end if;
   end DAXPY;

   procedure DCOPY
     (N      : Integer;
      DX_adr : Address;
      INCX   : Integer;
      DY_adr : Address;
      INCY   : Integer)
   is

      DX : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));
      DY : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for DX'Address use DX_adr;
      for DY'Address use DY_adr;

      pragma Import (Ada, DX);
      pragma Import (Ada, DY);

      I   : Integer;
      IX  : Integer;
      IY  : Integer;
      M   : Integer;
      MP1 : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DCOPY(N,DX,INCX,DY,INCY)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION DX(*),DY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DCOPY copies a vector, x, to a vector, y.
   --     uses unrolled loops for increments equal to one.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, linpack, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MOD
   --     ..
   begin
      if N <= 0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --        code for both increments equal to 1
         --
         --
         --        clean-up loop
         --
         M := "mod" (N, 7);
         if M /= 0 then
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               DY (I) := DX (I);
            end loop;
            if N < 7 then
               return;
            end if;
         end if;
         MP1 := M + 1;
         I   := MP1;
         while I <= N loop
            DY (I)     := DX (I);
            DY (I + 1) := DX (I + 1);
            DY (I + 2) := DX (I + 2);
            DY (I + 3) := DX (I + 3);
            DY (I + 4) := DX (I + 4);
            DY (I + 5) := DX (I + 5);
            DY (I + 6) := DX (I + 6);
            I          := I + 7;
         end loop;
      else
         --
         --        code for unequal increments or equal increments
         --          not equal to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            DY (IY) := DX (IX);
            IX      := IX + INCX;
            IY      := IY + INCY;
         end loop;
      end if;
   end DCOPY;

   function DDOT
     (N      : Integer;
      DX_adr : Address;
      INCX   : Integer;
      DY_adr : Address;
      INCY   : Integer)
      return   Real
   is
      DX : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));
      DY : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for DX'Address use DX_adr;
      for DY'Address use DY_adr;

      pragma Import (Ada, DX);
      pragma Import (Ada, DY);

      DTEMP       : Real;
      I           : Integer;
      IX          : Integer;
      IY          : Integer;
      M           : Integer;
      MP1         : Integer;
      DDOT_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION DX(*),DY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DDOT forms the dot product of two vectors.
   --     uses unrolled loops for increments equal to one.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, linpack, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MOD
   --     ..
   begin
      DDOT_Result := 0.0e0;
      DTEMP       := 0.0e0;
      if N <= 0 then
         return DDOT_Result;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --        code for both increments equal to 1
         --
         --
         --        clean-up loop
         --
         M := "mod" (N, 5);
         if M /= 0 then
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               DTEMP := DTEMP + DX (I) * DY (I);
            end loop;
            if N < 5 then
               DDOT_Result := DTEMP;
               return DDOT_Result;
            end if;
         end if;
         MP1 := M + 1;
         I   := MP1;
         while I <= N loop
            DTEMP := DTEMP +
                     DX (I) * DY (I) +
                     DX (I + 1) * DY (I + 1) +
                     DX (I + 2) * DY (I + 2) +
                     DX (I + 3) * DY (I + 3) +
                     DX (I + 4) * DY (I + 4);
            I     := I + 5;
         end loop;
      else
         --
         --        code for unequal increments or equal increments
         --          not equal to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            DTEMP := DTEMP + DX (IX) * DY (IY);
            IX    := IX + INCX;
            IY    := IY + INCY;
         end loop;
      end if;
      DDOT_Result := DTEMP;
      return DDOT_Result;
   end DDOT;

   procedure DGEMM
     (TRANSA : Character;
      TRANSB : Character;
      M      : Integer;
      N      : Integer;
      K      : Integer;
      ALPHA  : Real;
      A_adr  : Address;
      LDA    : Integer;
      B_adr  : Address;
      LDB    : Integer;
      BETA   : Real;
      C_adr  : Address;
      LDC    : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. max (K, M));
      B : Ftn_Real_Matrix (1 .. LDB, 1 .. max (K, N));
      C : Ftn_Real_Matrix (1 .. LDC, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;
      for C'Address use C_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);
      pragma Import (Ada, C);

      TEMP  : Real;
      I     : Integer;
      INFO  : Integer;
      J     : Integer;
      L     : Integer;
      NCOLA : Integer;
      NROWA : Integer;
      NROWB : Integer;
      NOTA  : Boolean;
      NOTB  : Boolean;
      ONE   : constant Real := 1.0e0;
      ZERO  : constant Real := 0.0e0;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA,BETA
   --       INTEGER K,LDA,LDB,LDC,M,N
   --       CHARACTER TRANSA,TRANSB
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEMM  performs one of the matrix-matrix operations
   --
   --     C := alpha*op( A )*op( B ) + beta*C,
   --
   --  where  op( X ) is one of
   --
   --     op( X ) = X   or   op( X ) = X**T,
   --
   --  alpha and beta are scalars, and A, B and C are matrices, with op( A )
   --  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] TRANSA
   --           TRANSA is CHARACTER*1
   --            On entry, TRANSA specifies the form of op( A ) to be used in
   --            the matrix multiplication as follows:
   --
   --               TRANSA = 'N' or 'n',  op( A ) = A.
   --
   --               TRANSA = 'T' or 't',  op( A ) = A**T.
   --
   --               TRANSA = 'C' or 'c',  op( A ) = A**T.
   --
   --  [in] TRANSB
   --           TRANSB is CHARACTER*1
   --            On entry, TRANSB specifies the form of op( B ) to be used in
   --            the matrix multiplication as follows:
   --
   --               TRANSB = 'N' or 'n',  op( B ) = B.
   --
   --               TRANSB = 'T' or 't',  op( B ) = B**T.
   --
   --               TRANSB = 'C' or 'c',  op( B ) = B**T.
   --
   --  [in] M
   --           M is INTEGER
   --            On entry,  M  specifies  the number  of rows  of the  matrix
   --            op( A )  and of the  matrix  C.  M  must  be at least  zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry,  N  specifies the number  of columns of the matrix
   --            op( B ) and the number of columns of the matrix C. N must be
   --            at least zero.
   --
   --  [in] K
   --           K is INTEGER
   --            On entry,  K  specifies  the number of columns of the matrix
   --            op( A ) and the number of rows of the matrix op( B ). K must
   --            be at least  zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
   --            k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
   --            Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
   --            part of the array  A  must contain the matrix  A,  otherwise
   --            the leading  k by m  part of the array  A  must contain  the
   --            matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. When  TRANSA = 'N' or 'n' then
   --            LDA must be at least  max( 1, m ), otherwise  LDA must be at
   --            least  max( 1, k ).
   --
   --  [in] B
   --           B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
   --            n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
   --            Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
   --            part of the array  B  must contain the matrix  B,  otherwise
   --            the leading  n by k  part of the array  B  must contain  the
   --            matrix B.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --            On entry, LDB specifies the first dimension of B as declared
   --            in the calling (sub) program. When  TRANSB = 'N' or 'n' then
   --            LDB must be at least  max( 1, k ), otherwise  LDB must be at
   --            least  max( 1, n ).
   --
   --  [in] BETA
   --           BETA is DOUBLE PRECISION.
   --            On entry,  BETA  specifies the scalar  beta.  When  BETA  is
   --            supplied as zero then C need not be set on input.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
   --            Before entry, the leading  m by n  part of the array  C must
   --            contain the matrix  C,  except when  beta  is zero, in which
   --            case C need not be set on entry.
   --            On exit, the array  C  is overwritten by the  m by n  matrix
   --            ( alpha*op( A )*op( B ) + beta*C ).
   --
   --  [in] LDC
   --           LDC is INTEGER
   --            On entry, LDC specifies the first dimension of C as declared
   --            in  the  calling  (sub)  program.   LDC  must  be  at  least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 3 Blas routine.
   --
   --   -- Written on 8-February-1989.
   --      Jack Dongarra, Argonne National Laboratory.
   --      Iain Duff, AERE Harwell.
   --      Jeremy Du Croz, Numerical Algorithms Group Ltd.
   --      Sven Hammarling, Numerical Algorithms Group Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level3 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
   --     ..
   --
   --     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
   --     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
   --     and  columns of  A  and the  number of  rows  of  B  respectively.
   --
   begin
      NOTA := LSAME (TRANSA, 'N');
      NOTB := LSAME (TRANSB, 'N');
      if NOTA then
         NROWA := M;
         NCOLA := K;
      else
         NROWA := K;
         NCOLA := M;
      end if;
      if NOTB 
         then NROWB := K;
         else NROWB := N;
      end if;
      --
      --     Test the input parameters.
      --
      INFO := 0;
      if (not NOTA) and (not LSAME (TRANSA, 'C')) and (not LSAME (TRANSA, 'T')) then
         INFO := 1;
      elsif (not NOTB) and (not LSAME (TRANSB, 'C')) and (not LSAME (TRANSB, 'T')) then
         INFO := 2;
      elsif M < 0 then
         INFO := 3;
      elsif N < 0 then
         INFO := 4;
      elsif K < 0 then
         INFO := 5;
      elsif LDA < max (1, NROWA) then
         INFO := 8;
      elsif LDB < max (1, NROWB) then
         INFO := 10;
      elsif LDC < max (1, M) then
         INFO := 13;
      end if;
      if INFO /= 0 then
         XERBLA ("DGEMM ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (M = 0) or (N = 0) or (((ALPHA = ZERO) or (K = 0)) and (BETA = ONE)) then
         return;
      end if;
      --
      --     And if  alpha.eq.zero.
      --
      if ALPHA = ZERO then
         if BETA = ZERO then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  C (I, J) := ZERO;
               end loop;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  C (I, J) := BETA * C (I, J);
               end loop;
            end loop;
         end if;
         return;
      end if;
      --
      --     Start the operations.
      --
      if NOTB then
         if NOTA then
            --
            --           Form  C := alpha*A*B + beta*C.
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = ZERO then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if B (L, J) /= ZERO then
                     TEMP := ALPHA * B (L, J);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        C (I, J) := C (I, J) + TEMP * A (I, L);
                     end loop;
                  end if;
               end loop;
            end loop;
         else
            --
            --           Form  C := alpha*A**T*B + beta*C
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := ZERO;
                  L    := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP := TEMP + A (L, I) * B (L, J);
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP;
                     else C (I, J) := ALPHA * TEMP + BETA * C (I, J);
                  end if;
               end loop;
            end loop;
         end if;
      else
         if NOTA then
            --
            --           Form  C := alpha*A*B**T + beta*C
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = ZERO then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if B (J, L) /= ZERO then
                     TEMP := ALPHA * B (J, L);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        C (I, J) := C (I, J) + TEMP * A (I, L);
                     end loop;
                  end if;
               end loop;
            end loop;
         else
            --
            --           Form  C := alpha*A**T*B**T + beta*C
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := ZERO;
                  L    := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP := TEMP + A (L, I) * B (J, L);
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP;
                     else C (I, J) := ALPHA * TEMP + BETA * C (I, J);
                  end if;
               end loop;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of DGEMM .
      --
   end DGEMM;

   procedure DGEMV
     (TRANS : Character;
      M     : Integer;
      N     : Integer;
      ALPHA : Real;
      A_adr : Address;
      LDA   : Integer;
      X_adr : Address;
      INCX  : Integer;
      BETA  : Real;
      Y_adr : Address;
      INCY  : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      X : Ftn_Real_Vector (1 .. 1 + (max (M, N) - 1) * abs (INCX));
      Y : Ftn_Real_Vector (1 .. 1 + (max (M, N) - 1) * abs (INCY));

      for A'Address use A_adr;
      for X'Address use X_adr;
      for Y'Address use Y_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, X);
      pragma Import (Ada, Y);

      ONE  : constant Real := 1.0e0;
      ZERO : constant Real := 0.0e0;
      TEMP : Real;
      I    : Integer;
      INFO : Integer;
      IX   : Integer;
      IY   : Integer;
      J    : Integer;
      JX   : Integer;
      JY   : Integer;
      KX   : Integer;
      KY   : Integer;
      LENX : Integer;
      LENY : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA,BETA
   --       INTEGER INCX,INCY,LDA,M,N
   --       CHARACTER TRANS
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEMV  performs one of the matrix-vector operations
   --
   --     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
   --
   --  where alpha and beta are scalars, x and y are vectors and A is an
   --  m by n matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --            On entry, TRANS specifies the operation to be performed as
   --            follows:
   --
   --               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
   --
   --               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y.
   --
   --               TRANS = 'C' or 'c'   y := alpha*A**T*x + beta*y.
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of the matrix A.
   --            M must be at least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
   --            Before entry, the leading m by n part of the array A must
   --            contain the matrix of coefficients.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, m ).
   --
   --  [in] X
   --           X is DOUBLE PRECISION array of DIMENSION at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
   --            and at least
   --            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
   --            Before entry, the incremented array X must contain the
   --            vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] BETA
   --           BETA is DOUBLE PRECISION.
   --            On entry, BETA specifies the scalar beta. When BETA is
   --            supplied as zero then Y need not be set on input.
   --
   --  [in,out] Y
   --           Y is DOUBLE PRECISION array of DIMENSION at least
   --            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
   --            and at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
   --            Before entry with BETA non-zero, the incremented array Y
   --            must contain the vector y. On exit, Y is overwritten by the
   --            updated vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --   The vector and matrix arguments are not referenced when N = 0, or M = 0
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (TRANS, 'N') and not LSAME (TRANS, 'T') and not LSAME (TRANS, 'C') then
         INFO := 1;
      elsif M < 0 then
         INFO := 2;
      elsif N < 0 then
         INFO := 3;
      elsif LDA < max (1, M) then
         INFO := 6;
      elsif INCX = 0 then
         INFO := 8;
      elsif INCY = 0 then
         INFO := 11;
      end if;
      if INFO /= 0 then
         XERBLA ("DGEMV ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (M = 0) or (N = 0) or ((ALPHA = ZERO) and (BETA = ONE)) then
         return;
      end if;
      --
      --     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
      --     up the start points in  X  and  Y.
      --
      if LSAME (TRANS, 'N') then
         LENX := N;
         LENY := M;
      else
         LENX := M;
         LENY := N;
      end if;
      if INCX > 0 
         then KX := 1;
         else KX := 1 - (LENX - 1) * INCX;
      end if;
      if INCY > 0 
         then KY := 1;
         else KY := 1 - (LENY - 1) * INCY;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through A.
      --
      --     First form  y := beta*y.
      --
      if BETA /= ONE then
         if INCY = 1 then
            if BETA = ZERO then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > LENY;
                  Y (I) := ZERO;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > LENY;
                  Y (I) := BETA * Y (I);
               end loop;
            end if;
         else
            IY := KY;
            if BETA = ZERO then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > LENY;
                  Y (IY) := ZERO;
                  IY     := IY + INCY;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > LENY;
                  Y (IY) := BETA * Y (IY);
                  IY     := IY + INCY;
               end loop;
            end if;
         end if;
      end if;
      if ALPHA = ZERO then
         return;
      end if;
      if LSAME (TRANS, 'N') then
         --
         --        Form  y := alpha*A*x + y.
         --
         JX := KX;
         if INCY = 1 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (JX) /= ZERO then
                  TEMP := ALPHA * X (JX);
                  I    := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     Y (I) := Y (I) + TEMP * A (I, J);
                  end loop;
               end if;
               JX := JX + INCX;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (JX) /= ZERO then
                  TEMP := ALPHA * X (JX);
                  IY   := KY;
                  I    := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     Y (IY) := Y (IY) + TEMP * A (I, J);
                     IY     := IY + INCY;
                  end loop;
               end if;
               JX := JX + INCX;
            end loop;
         end if;
      else
         --
         --        Form  y := alpha*A**T*x + y.
         --
         JY := KY;
         if INCX = 1 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP := ZERO;
               I    := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := TEMP + A (I, J) * X (I);
               end loop;
               Y (JY) := Y (JY) + ALPHA * TEMP;
               JY     := JY + INCY;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP := ZERO;
               IX   := KX;
               I    := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := TEMP + A (I, J) * X (IX);
                  IX   := IX + INCX;
               end loop;
               Y (JY) := Y (JY) + ALPHA * TEMP;
               JY     := JY + INCY;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of DGEMV .
      --
   end DGEMV;

   procedure DGER
     (M     : Integer;
      N     : Integer;
      ALPHA : Real;
      X_adr : Address;
      INCX  : Integer;
      Y_adr : Address;
      INCY  : Integer;
      A_adr : Address;
      LDA   : Integer)
   is

      X : Ftn_Real_Vector (1 .. 1 + (M - 1) * abs (INCX));
      Y : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCY));
      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);

      for X'Address use X_adr;
      for Y'Address use Y_adr;
      for A'Address use A_adr;

      pragma Import (Ada, X);
      pragma Import (Ada, Y);
      pragma Import (Ada, A);

      ZERO : constant Real := 0.0e0;
      TEMP : Real;
      I    : Integer;
      INFO : Integer;
      IX   : Integer;
      J    : Integer;
      JY   : Integer;
      KX   : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGER(M,N,ALPHA,X,INCX,Y,INCY,A,LDA)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA
   --       INTEGER INCX,INCY,LDA,M,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGER   performs the rank 1 operation
   --
   --     A := alpha*x*y**T + A,
   --
   --  where alpha is a scalar, x is an m element vector, y is an n element
   --  vector and A is an m by n matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of the matrix A.
   --            M must be at least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] X
   --           X is DOUBLE PRECISION array of dimension at least
   --            ( 1 + ( m - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the m
   --            element vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] Y
   --           Y is DOUBLE PRECISION array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ).
   --            Before entry, the incremented array Y must contain the n
   --            element vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
   --            Before entry, the leading m by n part of the array A must
   --            contain the matrix of coefficients. On exit, A is
   --            overwritten by the updated matrix.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO=0.0D+0)
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif INCX = 0 then
         INFO := 5;
      elsif INCY = 0 then
         INFO := 7;
      elsif LDA < max (1, M) then
         INFO := 9;
      end if;
      if INFO /= 0 then
         XERBLA ("DGER  ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (M = 0) or (N = 0) or (ALPHA = ZERO) then
         return;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through A.
      --
      if INCY > 0 
         then JY := 1;
         else JY := 1 - (N - 1) * INCY;
      end if;
      if INCX = 1 then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if Y (JY) /= ZERO then
               TEMP := ALPHA * Y (JY);
               I    := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  A (I, J) := A (I, J) + X (I) * TEMP;
               end loop;
            end if;
            JY := JY + INCY;
         end loop;
      else
         if INCX > 0 
            then KX := 1;
            else KX := 1 - (M - 1) * INCX;
         end if;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if Y (JY) /= ZERO then
               TEMP := ALPHA * Y (JY);
               IX   := KX;
               I    := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  A (I, J) := A (I, J) + X (IX) * TEMP;
                  IX       := IX + INCX;
               end loop;
            end if;
            JY := JY + INCY;
         end loop;
      end if;
      --
      return;
      --
      --     End of DGER  .
      --
   end DGER;

   function DNRM2
     (N     : Integer;
      X_adr : Address;
      INCX  : Integer)
      return  Real
   is
      X : Ftn_Real_Vector (1 .. 1 + (N - 1) * INCX);

      for X'Address use X_adr;

      pragma Import (Ada, X);

      ONE          : constant Real := 1.0e0;
      ZERO         : constant Real := 0.0e0;
      ABSXI        : Real;
      NORM         : Real;
      SCALE        : Real;
      SSQ          : Real;
      IX           : Integer;
      DNRM2_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION DNRM2(N,X,INCX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION X(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DNRM2 returns the euclidean norm of a vector via the function
   --  name, so that
   --
   --     DNRM2 := sqrt( x'*x )
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   -- This version written on 25-October-1982.
   --      Modified on 14-October-1993 to inline the call to DLASSQ.
   --      Sven Hammarling, Nag Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC ABS,SQRT
   --     ..
   begin
      if N < 1 or INCX < 1 then
         NORM := ZERO;
      elsif N = 1 then
         NORM := abs (X (1));
      else
         SCALE := ZERO;
         SSQ   := ONE;
         --        The following loop is equivalent to this call to the LAPACK
         --        auxiliary routine:
         --        CALL DLASSQ( N, X, INCX, SCALE, SSQ )
         --
         IX := 1 - INCX;
         loop
            IX := IX + INCX;
            exit when IX > 1 + (N - 1) * INCX;
            if X (IX) /= ZERO then
               ABSXI := abs (X (IX));
               if SCALE < ABSXI then
                  SSQ   := ONE + SSQ * (SCALE / ABSXI) ** 2;
                  SCALE := ABSXI;
               else
                  SSQ := SSQ + (ABSXI / SCALE) ** 2;
               end if;
            end if;
         end loop;
         NORM := SCALE * Sqrt (SSQ);
      end if;
      --
      DNRM2_Result := NORM;
      return DNRM2_Result;
      --
      --     End of DNRM2.
      --
   end DNRM2;

   procedure DROT
     (N      : Integer;
      DX_adr : Address;
      INCX   : Integer;
      DY_adr : Address;
      INCY   : Integer;
      C      : Real;
      S      : Real)
   is

      DX : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));
      DY : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for DX'Address use DX_adr;
      for DY'Address use DY_adr;

      pragma Import (Ada, DX);
      pragma Import (Ada, DY);

      DTEMP : Real;
      I     : Integer;
      IX    : Integer;
      IY    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DROT(N,DX,INCX,DY,INCY,C,S)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION C,S
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION DX(*),DY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DROT applies a plane rotation.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, linpack, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   begin
      if N <= 0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --       code for both increments equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            DTEMP  := C * DX (I) + S * DY (I);
            DY (I) := C * DY (I) - S * DX (I);
            DX (I) := DTEMP;
         end loop;
      else
         --
         --       code for unequal increments or equal increments not equal
         --         to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            DTEMP   := C * DX (IX) + S * DY (IY);
            DY (IY) := C * DY (IY) - S * DX (IX);
            DX (IX) := DTEMP;
            IX      := IX + INCX;
            IY      := IY + INCY;
         end loop;
      end if;
   end DROT;

   procedure DSCAL
     (N      : Integer;
      DA     : Real;
      DX_adr : Address;
      INCX   : Integer)
   is

      DX : Ftn_Real_Vector (1 .. N * INCX);

      for DX'Address use DX_adr;

      pragma Import (Ada, DX);

      I     : Integer;
      M     : Integer;
      MP1   : Integer;
      NINCX : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSCAL(N,DA,DX,INCX)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION DA
   --       INTEGER INCX,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION DX(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DSCAL scales a vector by a constant.
   --     uses unrolled loops for increment equal to one.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, linpack, 3/11/78.
   --      modified 3/93 to return if incx .le. 0.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MOD
   --     ..
   begin
      if N <= 0 or INCX <= 0 then
         return;
      end if;
      if INCX = 1 then
         --
         --        code for increment equal to 1
         --
         --
         --        clean-up loop
         --
         M := "mod" (N, 5);
         if M /= 0 then
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               DX (I) := DA * DX (I);
            end loop;
            if N < 5 then
               return;
            end if;
         end if;
         MP1 := M + 1;
         I   := MP1;
         while I <= N loop
            DX (I)     := DA * DX (I);
            DX (I + 1) := DA * DX (I + 1);
            DX (I + 2) := DA * DX (I + 2);
            DX (I + 3) := DA * DX (I + 3);
            DX (I + 4) := DA * DX (I + 4);
            I          := I + 5;
         end loop;
      else
         --
         --        code for increment not equal to 1
         --
         NINCX := N * INCX;
         I     := 1 - INCX;
         loop
            I := I + INCX;
            exit when I > NINCX;
            DX (I) := DA * DX (I);
         end loop;
      end if;
   end DSCAL;

   procedure DSWAP
     (N      : Integer;
      DX_adr : Address;
      INCX   : Integer;
      DY_adr : Address;
      INCY   : Integer)
   is

      DX : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));
      DY : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for DX'Address use DX_adr;
      for DY'Address use DY_adr;

      pragma Import (Ada, DX);
      pragma Import (Ada, DY);

      DTEMP : Real;
      I     : Integer;
      IX    : Integer;
      IY    : Integer;
      M     : Integer;
      MP1   : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSWAP(N,DX,INCX,DY,INCY)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION DX(*),DY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     interchanges two vectors.
   --     uses unrolled loops for increments equal one.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, linpack, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MOD
   --     ..
   begin
      if N <= 0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --       code for both increments equal to 1
         --
         --
         --       clean-up loop
         --
         M := "mod" (N, 3);
         if M /= 0 then
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               DTEMP  := DX (I);
               DX (I) := DY (I);
               DY (I) := DTEMP;
            end loop;
            if N < 3 then
               return;
            end if;
         end if;
         MP1 := M + 1;
         I   := MP1;
         while I <= N loop
            DTEMP      := DX (I);
            DX (I)     := DY (I);
            DY (I)     := DTEMP;
            DTEMP      := DX (I + 1);
            DX (I + 1) := DY (I + 1);
            DY (I + 1) := DTEMP;
            DTEMP      := DX (I + 2);
            DX (I + 2) := DY (I + 2);
            DY (I + 2) := DTEMP;
            I          := I + 3;
         end loop;
      else
         --
         --       code for unequal increments or equal increments not equal
         --         to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            DTEMP   := DX (IX);
            DX (IX) := DY (IY);
            DY (IY) := DTEMP;
            IX      := IX + INCX;
            IY      := IY + INCY;
         end loop;
      end if;
   end DSWAP;

   procedure DSYMV
     (UPLO  : Character;
      N     : Integer;
      ALPHA : Real;
      A_adr : Address;
      LDA   : Integer;
      X_adr : Address;
      INCX  : Integer;
      BETA  : Real;
      Y_adr : Address;
      INCY  : Integer)
   is
      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      X : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));
      Y : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for A'Address use A_adr;
      for X'Address use X_adr;
      for Y'Address use Y_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, X);
      pragma Import (Ada, Y);

      ONE   : constant Real := 1.0e0;
      ZERO  : constant Real := 0.0e0;
      TEMP1 : Real;
      TEMP2 : Real;
      I     : Integer;
      INFO  : Integer;
      IX    : Integer;
      IY    : Integer;
      J     : Integer;
      JX    : Integer;
      JY    : Integer;
      KX    : Integer;
      KY    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA,BETA
   --       INTEGER INCX,INCY,LDA,N
   --       CHARACTER UPLO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYMV  performs the matrix-vector  operation
   --
   --     y := alpha*A*x + beta*y,
   --
   --  where alpha and beta are scalars, x and y are n element vectors and
   --  A is an n by n symmetric matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the upper or lower
   --            triangular part of the array A is to be referenced as
   --            follows:
   --
   --               UPLO = 'U' or 'u'   Only the upper triangular part of A
   --                                   is to be referenced.
   --
   --               UPLO = 'L' or 'l'   Only the lower triangular part of A
   --                                   is to be referenced.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
   --            Before entry with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular part of the symmetric matrix and the strictly
   --            lower triangular part of A is not referenced.
   --            Before entry with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular part of the symmetric matrix and the strictly
   --            upper triangular part of A is not referenced.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, n ).
   --
   --  [in] X
   --           X is DOUBLE PRECISION array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the n
   --            element vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] BETA
   --           BETA is DOUBLE PRECISION.
   --            On entry, BETA specifies the scalar beta. When BETA is
   --            supplied as zero then Y need not be set on input.
   --
   --  [in,out] Y
   --           Y is DOUBLE PRECISION array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ).
   --            Before entry, the incremented array Y must contain the n
   --            element vector y. On exit, Y is overwritten by the updated
   --            vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --   The vector and matrix arguments are not referenced when N = 0, or M = 0
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif LDA < max (1, N) then
         INFO := 5;
      elsif INCX = 0 then
         INFO := 7;
      elsif INCY = 0 then
         INFO := 10;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYMV ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (N = 0) or ((ALPHA = ZERO) and (BETA = ONE)) then
         return;
      end if;
      --
      --     Set up the start points in  X  and  Y.
      --
      if INCX > 0 
         then KX := 1;
         else KX := 1 - (N - 1) * INCX;
      end if;
      if INCY > 0 
         then KY := 1;
         else KY := 1 - (N - 1) * INCY;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through the triangular part
      --     of A.
      --
      --     First form  y := beta*y.
      --
      if BETA /= ONE then
         if INCY = 1 then
            if BETA = ZERO then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (I) := ZERO;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (I) := BETA * Y (I);
               end loop;
            end if;
         else
            IY := KY;
            if BETA = ZERO then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (IY) := ZERO;
                  IY     := IY + INCY;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (IY) := BETA * Y (IY);
                  IY     := IY + INCY;
               end loop;
            end if;
         end if;
      end if;
      if ALPHA = ZERO then
         return;
      end if;
      if LSAME (UPLO, 'U') then
         --
         --        Form  y  when A is stored in upper triangle.
         --
         if (INCX = 1) and (INCY = 1) then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP1 := ALPHA * X (J);
               TEMP2 := ZERO;
               I     := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J - 1;
                  Y (I) := Y (I) + TEMP1 * A (I, J);
                  TEMP2 := TEMP2 + A (I, J) * X (I);
               end loop;
               Y (J) := Y (J) + TEMP1 * A (J, J) + ALPHA * TEMP2;
            end loop;
         else
            JX := KX;
            JY := KY;
            J  := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP1 := ALPHA * X (JX);
               TEMP2 := ZERO;
               IX    := KX;
               IY    := KY;
               I     := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J - 1;
                  Y (IY) := Y (IY) + TEMP1 * A (I, J);
                  TEMP2  := TEMP2 + A (I, J) * X (IX);
                  IX     := IX + INCX;
                  IY     := IY + INCY;
               end loop;
               Y (JY) := Y (JY) + TEMP1 * A (J, J) + ALPHA * TEMP2;
               JX     := JX + INCX;
               JY     := JY + INCY;
            end loop;
         end if;
      else
         --
         --        Form  y  when A is stored in lower triangle.
         --
         if (INCX = 1) and (INCY = 1) then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP1 := ALPHA * X (J);
               TEMP2 := ZERO;
               Y (J) := Y (J) + TEMP1 * A (J, J);
               I     := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (I) := Y (I) + TEMP1 * A (I, J);
                  TEMP2 := TEMP2 + A (I, J) * X (I);
               end loop;
               Y (J) := Y (J) + ALPHA * TEMP2;
            end loop;
         else
            JX := KX;
            JY := KY;
            J  := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP1  := ALPHA * X (JX);
               TEMP2  := ZERO;
               Y (JY) := Y (JY) + TEMP1 * A (J, J);
               IX     := JX;
               IY     := JY;
               I      := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  IX     := IX + INCX;
                  IY     := IY + INCY;
                  Y (IY) := Y (IY) + TEMP1 * A (I, J);
                  TEMP2  := TEMP2 + A (I, J) * X (IX);
               end loop;
               Y (JY) := Y (JY) + ALPHA * TEMP2;
               JX     := JX + INCX;
               JY     := JY + INCY;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of DSYMV .
      --
   end DSYMV;

   procedure DSYR
     (UPLO  : Character;
      N     : Integer;
      ALPHA : Real;
      X_adr : Address;
      INCX  : Integer;
      A_adr : Address;
      LDA   : Integer)
   is

      X : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));
      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);

      for X'Address use X_adr;
      for A'Address use A_adr;

      pragma Import (Ada, X);
      pragma Import (Ada, A);

      ZERO : constant Real := 0.0e0;
      TEMP : Real;
      I    : Integer;
      INFO : Integer;
      IX   : Integer;
      J    : Integer;
      JX   : Integer;
      KX   : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYR(UPLO,N,ALPHA,X,INCX,A,LDA)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA
   --       INTEGER INCX,LDA,N
   --       CHARACTER UPLO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),X(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYR   performs the symmetric rank 1 operation
   --
   --     A := alpha*x*x**T + A,
   --
   --  where alpha is a real scalar, x is an n element vector and A is an
   --  n by n symmetric matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the upper or lower
   --            triangular part of the array A is to be referenced as
   --            follows:
   --
   --               UPLO = 'U' or 'u'   Only the upper triangular part of A
   --                                   is to be referenced.
   --
   --               UPLO = 'L' or 'l'   Only the lower triangular part of A
   --                                   is to be referenced.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] X
   --           X is DOUBLE PRECISION array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the n
   --            element vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
   --            Before entry with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular part of the symmetric matrix and the strictly
   --            lower triangular part of A is not referenced. On exit, the
   --            upper triangular part of the array A is overwritten by the
   --            upper triangular part of the updated matrix.
   --            Before entry with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular part of the symmetric matrix and the strictly
   --            upper triangular part of A is not referenced. On exit, the
   --            lower triangular part of the array A is overwritten by the
   --            lower triangular part of the updated matrix.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, n ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO=0.0D+0)
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif INCX = 0 then
         INFO := 5;
      elsif LDA < max (1, N) then
         INFO := 7;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYR  ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (N = 0) or (ALPHA = ZERO) then
         return;
      end if;
      --
      --     Set the start point in X if the increment is not unity.
      --
      if INCX <= 0 then
         KX := 1 - (N - 1) * INCX;
      elsif INCX /= 1 then
         KX := 1;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through the triangular part
      --     of A.
      --
      if LSAME (UPLO, 'U') then
         --
         --        Form  A  when A is stored in upper triangle.
         --
         if INCX = 1 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (J) /= ZERO then
                  TEMP := ALPHA * X (J);
                  I    := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     A (I, J) := A (I, J) + X (I) * TEMP;
                  end loop;
               end if;
            end loop;
         else
            JX := KX;
            J  := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (JX) /= ZERO then
                  TEMP := ALPHA * X (JX);
                  IX   := KX;
                  I    := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     A (I, J) := A (I, J) + X (IX) * TEMP;
                     IX       := IX + INCX;
                  end loop;
               end if;
               JX := JX + INCX;
            end loop;
         end if;
      else
         --
         --        Form  A  when A is stored in lower triangle.
         --
         if INCX = 1 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (J) /= ZERO then
                  TEMP := ALPHA * X (J);
                  I    := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     A (I, J) := A (I, J) + X (I) * TEMP;
                  end loop;
               end if;
            end loop;
         else
            JX := KX;
            J  := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (JX) /= ZERO then
                  TEMP := ALPHA * X (JX);
                  IX   := JX;
                  I    := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     A (I, J) := A (I, J) + X (IX) * TEMP;
                     IX       := IX + INCX;
                  end loop;
               end if;
               JX := JX + INCX;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of DSYR  .
      --
   end DSYR;

   procedure DSYR2
     (UPLO  : Character;
      N     : Integer;
      ALPHA : Real;
      X_adr : Address;
      INCX  : Integer;
      Y_adr : Address;
      INCY  : Integer;
      A_adr : Address;
      LDA   : Integer)
   is

      X : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));
      Y : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCY));
      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);

      for X'Address use X_adr;
      for Y'Address use Y_adr;
      for A'Address use A_adr;

      pragma Import (Ada, X);
      pragma Import (Ada, Y);
      pragma Import (Ada, A);

      ZERO  : constant Real := 0.0e0;
      TEMP1 : Real;
      TEMP2 : Real;
      I     : Integer;
      INFO  : Integer;
      IX    : Integer;
      IY    : Integer;
      J     : Integer;
      JX    : Integer;
      JY    : Integer;
      KX    : Integer;
      KY    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYR2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA
   --       INTEGER INCX,INCY,LDA,N
   --       CHARACTER UPLO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYR2  performs the symmetric rank 2 operation
   --
   --     A := alpha*x*y**T + alpha*y*x**T + A,
   --
   --  where alpha is a scalar, x and y are n element vectors and A is an n
   --  by n symmetric matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the upper or lower
   --            triangular part of the array A is to be referenced as
   --            follows:
   --
   --               UPLO = 'U' or 'u'   Only the upper triangular part of A
   --                                   is to be referenced.
   --
   --               UPLO = 'L' or 'l'   Only the lower triangular part of A
   --                                   is to be referenced.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] X
   --           X is DOUBLE PRECISION array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the n
   --            element vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] Y
   --           Y is DOUBLE PRECISION array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ).
   --            Before entry, the incremented array Y must contain the n
   --            element vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
   --            Before entry with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular part of the symmetric matrix and the strictly
   --            lower triangular part of A is not referenced. On exit, the
   --            upper triangular part of the array A is overwritten by the
   --            upper triangular part of the updated matrix.
   --            Before entry with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular part of the symmetric matrix and the strictly
   --            upper triangular part of A is not referenced. On exit, the
   --            lower triangular part of the array A is overwritten by the
   --            lower triangular part of the updated matrix.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, n ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO=0.0D+0)
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif INCX = 0 then
         INFO := 5;
      elsif INCY = 0 then
         INFO := 7;
      elsif LDA < max (1, N) then
         INFO := 9;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYR2 ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (N = 0) or (ALPHA = ZERO) then
         return;
      end if;
      --
      --     Set up the start points in X and Y if the increments are not both
      --     unity.
      --
      if (INCX /= 1) or (INCY /= 1) then
         if INCX > 0 
            then KX := 1;
            else KX := 1 - (N - 1) * INCX;
         end if;
         if INCY > 0 
            then KY := 1;
            else KY := 1 - (N - 1) * INCY;
         end if;
         JX := KX;
         JY := KY;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through the triangular part
      --     of A.
      --
      if LSAME (UPLO, 'U') then
         --
         --        Form  A  when A is stored in the upper triangle.
         --
         if (INCX = 1) and (INCY = 1) then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if (X (J) /= ZERO) or (Y (J) /= ZERO) then
                  TEMP1 := ALPHA * Y (J);
                  TEMP2 := ALPHA * X (J);
                  I     := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     A (I, J) := A (I, J) + X (I) * TEMP1 + Y (I) * TEMP2;
                  end loop;
               end if;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if (X (JX) /= ZERO) or (Y (JY) /= ZERO) then
                  TEMP1 := ALPHA * Y (JY);
                  TEMP2 := ALPHA * X (JX);
                  IX    := KX;
                  IY    := KY;
                  I     := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     A (I, J) := A (I, J) + X (IX) * TEMP1 + Y (IY) * TEMP2;
                     IX       := IX + INCX;
                     IY       := IY + INCY;
                  end loop;
               end if;
               JX := JX + INCX;
               JY := JY + INCY;
            end loop;
         end if;
      else
         --
         --        Form  A  when A is stored in the lower triangle.
         --
         if (INCX = 1) and (INCY = 1) then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if (X (J) /= ZERO) or (Y (J) /= ZERO) then
                  TEMP1 := ALPHA * Y (J);
                  TEMP2 := ALPHA * X (J);
                  I     := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     A (I, J) := A (I, J) + X (I) * TEMP1 + Y (I) * TEMP2;
                  end loop;
               end if;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if (X (JX) /= ZERO) or (Y (JY) /= ZERO) then
                  TEMP1 := ALPHA * Y (JY);
                  TEMP2 := ALPHA * X (JX);
                  IX    := JX;
                  IY    := JY;
                  I     := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     A (I, J) := A (I, J) + X (IX) * TEMP1 + Y (IY) * TEMP2;
                     IX       := IX + INCX;
                     IY       := IY + INCY;
                  end loop;
               end if;
               JX := JX + INCX;
               JY := JY + INCY;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of DSYR2 .
      --
   end DSYR2;

   procedure DSYR2K
     (UPLO  : Character;
      TRANS : Character;
      N     : Integer;
      K     : Integer;
      ALPHA : Real;
      A_adr : Address;
      LDA   : Integer;
      B_adr : Address;
      LDB   : Integer;
      BETA  : Real;
      C_adr : Address;
      LDC   : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      B : Ftn_Real_Matrix (1 .. LDB, 1 .. N);
      C : Ftn_Real_Matrix (1 .. LDC, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;
      for C'Address use C_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);
      pragma Import (Ada, C);

      TEMP1 : Real;
      TEMP2 : Real;
      I     : Integer;
      INFO  : Integer;
      J     : Integer;
      L     : Integer;
      NROWA : Integer;
      UPPER : Boolean;
      ONE   : constant Real := 1.0e0;
      ZERO  : constant Real := 0.0e0;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA,BETA
   --       INTEGER K,LDA,LDB,LDC,N
   --       CHARACTER TRANS,UPLO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYR2K  performs one of the symmetric rank 2k operations
   --
   --     C := alpha*A*B**T + alpha*B*A**T + beta*C,
   --
   --  or
   --
   --     C := alpha*A**T*B + alpha*B**T*A + beta*C,
   --
   --  where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
   --  and  A and B  are  n by k  matrices  in the  first  case  and  k by n
   --  matrices in the second case.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On  entry,   UPLO  specifies  whether  the  upper  or  lower
   --            triangular  part  of the  array  C  is to be  referenced  as
   --            follows:
   --
   --               UPLO = 'U' or 'u'   Only the  upper triangular part of  C
   --                                   is to be referenced.
   --
   --               UPLO = 'L' or 'l'   Only the  lower triangular part of  C
   --                                   is to be referenced.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --            On entry,  TRANS  specifies the operation to be performed as
   --            follows:
   --
   --               TRANS = 'N' or 'n'   C := alpha*A*B**T + alpha*B*A**T +
   --                                         beta*C.
   --
   --               TRANS = 'T' or 't'   C := alpha*A**T*B + alpha*B**T*A +
   --                                         beta*C.
   --
   --               TRANS = 'C' or 'c'   C := alpha*A**T*B + alpha*B**T*A +
   --                                         beta*C.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry,  N specifies the order of the matrix C.  N must be
   --            at least zero.
   --
   --  [in] K
   --           K is INTEGER
   --            On entry with  TRANS = 'N' or 'n',  K  specifies  the number
   --            of  columns  of the  matrices  A and B,  and on  entry  with
   --            TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
   --            of rows of the matrices  A and B.  K must be at least  zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
   --            k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
   --            Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
   --            part of the array  A  must contain the matrix  A,  otherwise
   --            the leading  k by n  part of the array  A  must contain  the
   --            matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
   --            then  LDA must be at least  max( 1, n ), otherwise  LDA must
   --            be at least  max( 1, k ).
   --
   --  [in] B
   --           B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
   --            k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
   --            Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
   --            part of the array  B  must contain the matrix  B,  otherwise
   --            the leading  k by n  part of the array  B  must contain  the
   --            matrix B.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --            On entry, LDB specifies the first dimension of B as declared
   --            in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
   --            then  LDB must be at least  max( 1, n ), otherwise  LDB must
   --            be at least  max( 1, k ).
   --
   --  [in] BETA
   --           BETA is DOUBLE PRECISION.
   --            On entry, BETA specifies the scalar beta.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
   --            Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
   --            upper triangular part of the array C must contain the upper
   --            triangular part  of the  symmetric matrix  and the strictly
   --            lower triangular part of C is not referenced.  On exit, the
   --            upper triangular part of the array  C is overwritten by the
   --            upper triangular part of the updated matrix.
   --            Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
   --            lower triangular part of the array C must contain the lower
   --            triangular part  of the  symmetric matrix  and the strictly
   --            upper triangular part of C is not referenced.  On exit, the
   --            lower triangular part of the array  C is overwritten by the
   --            lower triangular part of the updated matrix.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --            On entry, LDC specifies the first dimension of C as declared
   --            in  the  calling  (sub)  program.   LDC  must  be  at  least
   --            max( 1, n ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 3 Blas routine.
   --
   --
   --   -- Written on 8-February-1989.
   --      Jack Dongarra, Argonne National Laboratory.
   --      Iain Duff, AERE Harwell.
   --      Jeremy Du Croz, Numerical Algorithms Group Ltd.
   --      Sven Hammarling, Numerical Algorithms Group Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level3 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Functions ..
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      if LSAME (TRANS, 'N') 
         then NROWA := N;
         else NROWA := K;
      end if;
      UPPER := LSAME (UPLO, 'U');
      --
      INFO := 0;
      if (not UPPER) and (not LSAME (UPLO, 'L')) then
         INFO := 1;
      elsif (not LSAME (TRANS, 'N')) and (not LSAME (TRANS, 'T')) and (not LSAME (TRANS, 'C')) then
         INFO := 2;
      elsif N < 0 then
         INFO := 3;
      elsif K < 0 then
         INFO := 4;
      elsif LDA < max (1, NROWA) then
         INFO := 7;
      elsif LDB < max (1, NROWA) then
         INFO := 9;
      elsif LDC < max (1, N) then
         INFO := 12;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYR2K", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (N = 0) or (((ALPHA = ZERO) or (K = 0)) and (BETA = ONE)) then
         return;
      end if;
      --
      --     And when  alpha.eq.zero.
      --
      if ALPHA = ZERO then
         if UPPER then
            if BETA = ZERO then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     C (I, J) := ZERO;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end loop;
            end if;
         else
            if BETA = ZERO then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     C (I, J) := ZERO;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end loop;
            end if;
         end if;
         return;
      end if;
      --
      --     Start the operations.
      --
      if LSAME (TRANS, 'N') then
         --
         --        Form  C := alpha*A*B**T + alpha*B*A**T + C.
         --
         if UPPER then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = ZERO then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if (A (J, L) /= ZERO) or (B (J, L) /= ZERO) then
                     TEMP1 := ALPHA * B (J, L);
                     TEMP2 := ALPHA * A (J, L);
                     I     := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J;
                        C (I, J) := C (I, J) + A (I, L) * TEMP1 + B (I, L) * TEMP2;
                     end loop;
                  end if;
               end loop;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = ZERO then
                  I := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if (A (J, L) /= ZERO) or (B (J, L) /= ZERO) then
                     TEMP1 := ALPHA * B (J, L);
                     TEMP2 := ALPHA * A (J, L);
                     I     := J - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        C (I, J) := C (I, J) + A (I, L) * TEMP1 + B (I, L) * TEMP2;
                     end loop;
                  end if;
               end loop;
            end loop;
         end if;
      else
         --
         --        Form  C := alpha*A**T*B + alpha*B**T*A + C.
         --
         if UPPER then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J;
                  TEMP1 := ZERO;
                  TEMP2 := ZERO;
                  L     := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP1 := TEMP1 + A (L, I) * B (L, J);
                     TEMP2 := TEMP2 + B (L, I) * A (L, J);
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP1 + ALPHA * TEMP2;
                     else C (I, J) := BETA * C (I, J) + ALPHA * TEMP1 + ALPHA * TEMP2;
                  end if;
               end loop;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := J - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  TEMP1 := ZERO;
                  TEMP2 := ZERO;
                  L     := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP1 := TEMP1 + A (L, I) * B (L, J);
                     TEMP2 := TEMP2 + B (L, I) * A (L, J);
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP1 + ALPHA * TEMP2;
                     else C (I, J) := BETA * C (I, J) + ALPHA * TEMP1 + ALPHA * TEMP2;
                  end if;
               end loop;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of DSYR2K.
      --
   end DSYR2K;

   procedure DTRMM
     (SIDE   : Character;
      UPLO   : Character;
      TRANSA : Character;
      DIAG   : Character;
      M      : Integer;
      N      : Integer;
      ALPHA  : Real;
      A_adr  : Address;
      LDA    : Integer;
      B_adr  : Address;
      LDB    : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. max (M, N));
      B : Ftn_Real_Matrix (1 .. LDB, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);

      TEMP   : Real;
      I      : Integer;
      INFO   : Integer;
      J      : Integer;
      K      : Integer;
      NROWA  : Integer;
      LSIDE  : Boolean;
      NOUNIT : Boolean;
      UPPER  : Boolean;
      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA
   --       INTEGER LDA,LDB,M,N
   --       CHARACTER DIAG,SIDE,TRANSA,UPLO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),B(LDB,*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DTRMM  performs one of the matrix-matrix operations
   --
   --     B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
   --
   --  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
   --  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
   --
   --     op( A ) = A   or   op( A ) = A**T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --            On entry,  SIDE specifies whether  op( A ) multiplies B from
   --            the left or right as follows:
   --
   --               SIDE = 'L' or 'l'   B := alpha*op( A )*B.
   --
   --               SIDE = 'R' or 'r'   B := alpha*B*op( A ).
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the matrix A is an upper or
   --            lower triangular matrix as follows:
   --
   --               UPLO = 'U' or 'u'   A is an upper triangular matrix.
   --
   --               UPLO = 'L' or 'l'   A is a lower triangular matrix.
   --
   --  [in] TRANSA
   --           TRANSA is CHARACTER*1
   --            On entry, TRANSA specifies the form of op( A ) to be used in
   --            the matrix multiplication as follows:
   --
   --               TRANSA = 'N' or 'n'   op( A ) = A.
   --
   --               TRANSA = 'T' or 't'   op( A ) = A**T.
   --
   --               TRANSA = 'C' or 'c'   op( A ) = A**T.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --            On entry, DIAG specifies whether or not A is unit triangular
   --            as follows:
   --
   --               DIAG = 'U' or 'u'   A is assumed to be unit triangular.
   --
   --               DIAG = 'N' or 'n'   A is not assumed to be unit
   --                                   triangular.
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of B. M must be at
   --            least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of B.  N must be
   --            at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry,  ALPHA specifies the scalar  alpha. When  alpha is
   --            zero then  A is not referenced and  B need not be set before
   --            entry.
   --
   --  [in] A
   --            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
   --            when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
   --            Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
   --            upper triangular part of the array  A must contain the upper
   --            triangular matrix  and the strictly lower triangular part of
   --            A is not referenced.
   --            Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
   --            lower triangular part of the array  A must contain the lower
   --            triangular matrix  and the strictly upper triangular part of
   --            A is not referenced.
   --            Note that when  DIAG = 'U' or 'u',  the diagonal elements of
   --            A  are not referenced either,  but are assumed to be  unity.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
   --            LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
   --            then LDA must be at least max( 1, n ).
   --
   --  [in,out] B
   --           B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
   --            Before entry,  the leading  m by n part of the array  B must
   --            contain the matrix  B,  and  on exit  is overwritten  by the
   --            transformed matrix.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --            On entry, LDB specifies the first dimension of B as declared
   --            in  the  calling  (sub)  program.   LDB  must  be  at  least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 3 Blas routine.
   --
   --   -- Written on 8-February-1989.
   --      Jack Dongarra, Argonne National Laboratory.
   --      Iain Duff, AERE Harwell.
   --      Jeremy Du Croz, Numerical Algorithms Group Ltd.
   --      Sven Hammarling, Numerical Algorithms Group Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level3 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      LSIDE := LSAME (SIDE, 'L');
      if LSIDE 
         then NROWA := M;
         else NROWA := N;
      end if;
      NOUNIT := LSAME (DIAG, 'N');
      UPPER  := LSAME (UPLO, 'U');
      --
      INFO := 0;
      if (not LSIDE) and (not LSAME (SIDE, 'R')) then
         INFO := 1;
      elsif (not UPPER) and (not LSAME (UPLO, 'L')) then
         INFO := 2;
      elsif (not LSAME (TRANSA, 'N')) and (not LSAME (TRANSA, 'T')) and (not LSAME (TRANSA, 'C')) then
         INFO := 3;
      elsif (not LSAME (DIAG, 'U')) and (not LSAME (DIAG, 'N')) then
         INFO := 4;
      elsif M < 0 then
         INFO := 5;
      elsif N < 0 then
         INFO := 6;
      elsif LDA < max (1, NROWA) then
         INFO := 9;
      elsif LDB < max (1, M) then
         INFO := 11;
      end if;
      if INFO /= 0 then
         XERBLA ("DTRMM ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     And when  alpha.eq.zero.
      --
      if ALPHA = ZERO then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := ZERO;
            end loop;
         end loop;
         return;
      end if;
      --
      --     Start the operations.
      --
      if LSIDE then
         if LSAME (TRANSA, 'N') then
            --
            --           Form  B := alpha*A*B.
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > M;
                     if B (K, J) /= ZERO then
                        TEMP := ALPHA * B (K, J);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > K - 1;
                           B (I, J) := B (I, J) + TEMP * A (I, K);
                        end loop;
                        if NOUNIT then
                           TEMP := TEMP * A (K, K);
                        end if;
                        B (K, J) := TEMP;
                     end if;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  K := M + 1;
                  loop
                     K := K - 1;
                     exit when K < 1;
                     if B (K, J) /= ZERO then
                        TEMP     := ALPHA * B (K, J);
                        B (K, J) := TEMP;
                        if NOUNIT then
                           B (K, J) := B (K, J) * A (K, K);
                        end if;
                        I := K + 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * A (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            end if;
         else
            --
            --           Form  B := alpha*A**T*B.
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := M + 1;
                  loop
                     I := I - 1;
                     exit when I < 1;
                     TEMP := B (I, J);
                     if NOUNIT then
                        TEMP := TEMP * A (I, I);
                     end if;
                     K := 1 - 1;
                     loop
                        K := K + 1;
                        exit when K > I - 1;
                        TEMP := TEMP + A (K, I) * B (K, J);
                     end loop;
                     B (I, J) := ALPHA * TEMP;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     TEMP := B (I, J);
                     if NOUNIT then
                        TEMP := TEMP * A (I, I);
                     end if;
                     K := I + 1 - 1;
                     loop
                        K := K + 1;
                        exit when K > M;
                        TEMP := TEMP + A (K, I) * B (K, J);
                     end loop;
                     B (I, J) := ALPHA * TEMP;
                  end loop;
               end loop;
            end if;
         end if;
      else
         if LSAME (TRANSA, 'N') then
            --
            --           Form  B := alpha*B*A.
            --
            if UPPER then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  TEMP := ALPHA;
                  if NOUNIT then
                     TEMP := TEMP * A (J, J);
                  end if;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     B (I, J) := TEMP * B (I, J);
                  end loop;
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > J - 1;
                     if A (K, J) /= ZERO then
                        TEMP := ALPHA * A (K, J);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  TEMP := ALPHA;
                  if NOUNIT then
                     TEMP := TEMP * A (J, J);
                  end if;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     B (I, J) := TEMP * B (I, J);
                  end loop;
                  K := J + 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     if A (K, J) /= ZERO then
                        TEMP := ALPHA * A (K, J);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            end if;
         else
            --
            --           Form  B := alpha*B*A**T.
            --
            if UPPER then
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  J := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > K - 1;
                     if A (J, K) /= ZERO then
                        TEMP := ALPHA * A (J, K);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  TEMP := ALPHA;
                  if NOUNIT then
                     TEMP := TEMP * A (K, K);
                  end if;
                  if TEMP /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := TEMP * B (I, K);
                     end loop;
                  end if;
               end loop;
            else
               K := N + 1;
               loop
                  K := K - 1;
                  exit when K < 1;
                  J := K + 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     if A (J, K) /= ZERO then
                        TEMP := ALPHA * A (J, K);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  TEMP := ALPHA;
                  if NOUNIT then
                     TEMP := TEMP * A (K, K);
                  end if;
                  if TEMP /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := TEMP * B (I, K);
                     end loop;
                  end if;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of DTRMM .
      --
   end DTRMM;

   procedure DTRMV
     (UPLO  : Character;
      TRANS : Character;
      DIAG  : Character;
      N     : Integer;
      A_adr : Address;
      LDA   : Integer;
      X_adr : Address;
      INCX  : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      X : Ftn_Real_Vector (1 .. 1 + (N - 1) * abs (INCX));

      for A'Address use A_adr;
      for X'Address use X_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, X);

      ZERO   : constant Real := 0.0e0;
      TEMP   : Real;
      I      : Integer;
      INFO   : Integer;
      IX     : Integer;
      J      : Integer;
      JX     : Integer;
      KX     : Integer;
      NOUNIT : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,LDA,N
   --       CHARACTER DIAG,TRANS,UPLO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),X(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DTRMV  performs one of the matrix-vector operations
   --
   --     x := A*x,   or   x := A**T*x,
   --
   --  where x is an n element vector and  A is an n by n unit, or non-unit,
   --  upper or lower triangular matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the matrix is an upper or
   --            lower triangular matrix as follows:
   --
   --               UPLO = 'U' or 'u'   A is an upper triangular matrix.
   --
   --               UPLO = 'L' or 'l'   A is a lower triangular matrix.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --            On entry, TRANS specifies the operation to be performed as
   --            follows:
   --
   --               TRANS = 'N' or 'n'   x := A*x.
   --
   --               TRANS = 'T' or 't'   x := A**T*x.
   --
   --               TRANS = 'C' or 'c'   x := A**T*x.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --            On entry, DIAG specifies whether or not A is unit
   --            triangular as follows:
   --
   --               DIAG = 'U' or 'u'   A is assumed to be unit triangular.
   --
   --               DIAG = 'N' or 'n'   A is not assumed to be unit
   --                                   triangular.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
   --            Before entry with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular matrix and the strictly lower triangular part of
   --            A is not referenced.
   --            Before entry with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular matrix and the strictly upper triangular part of
   --            A is not referenced.
   --            Note that when  DIAG = 'U' or 'u', the diagonal elements of
   --            A are not referenced either, but are assumed to be unity.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, n ).
   --
   --  [in,out] X
   --           X is DOUBLE PRECISION array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the n
   --            element vector x. On exit, X is overwritten with the
   --            tranformed vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --   The vector and matrix arguments are not referenced when N = 0, or M = 0
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO=0.0D+0)
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif not LSAME (TRANS, 'N') and not LSAME (TRANS, 'T') and not LSAME (TRANS, 'C') then
         INFO := 2;
      elsif not LSAME (DIAG, 'U') and not LSAME (DIAG, 'N') then
         INFO := 3;
      elsif N < 0 then
         INFO := 4;
      elsif LDA < max (1, N) then
         INFO := 6;
      elsif INCX = 0 then
         INFO := 8;
      end if;
      if INFO /= 0 then
         XERBLA ("DTRMV ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if N = 0 then
         return;
      end if;
      --
      NOUNIT := LSAME (DIAG, 'N');
      --
      --     Set up the start point in X if the increment is not unity. This
      --     will be  ( N - 1 )*INCX  too small for descending loops.
      --
      if INCX <= 0 then
         KX := 1 - (N - 1) * INCX;
      elsif INCX /= 1 then
         KX := 1;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through A.
      --
      if LSAME (TRANS, 'N') then
         --
         --        Form  x := A*x.
         --
         if LSAME (UPLO, 'U') then
            if INCX = 1 then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if X (J) /= ZERO then
                     TEMP := X (J);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        X (I) := X (I) + TEMP * A (I, J);
                     end loop;
                     if NOUNIT then
                        X (J) := X (J) * A (J, J);
                     end if;
                  end if;
               end loop;
            else
               JX := KX;
               J  := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if X (JX) /= ZERO then
                     TEMP := X (JX);
                     IX   := KX;
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        X (IX) := X (IX) + TEMP * A (I, J);
                        IX     := IX + INCX;
                     end loop;
                     if NOUNIT then
                        X (JX) := X (JX) * A (J, J);
                     end if;
                  end if;
                  JX := JX + INCX;
               end loop;
            end if;
         else
            if INCX = 1 then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if X (J) /= ZERO then
                     TEMP := X (J);
                     I    := N + 1;
                     loop
                        I := I - 1;
                        exit when I < J + 1;
                        X (I) := X (I) + TEMP * A (I, J);
                     end loop;
                     if NOUNIT then
                        X (J) := X (J) * A (J, J);
                     end if;
                  end if;
               end loop;
            else
               KX := KX + (N - 1) * INCX;
               JX := KX;
               J  := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if X (JX) /= ZERO then
                     TEMP := X (JX);
                     IX   := KX;
                     I    := N + 1;
                     loop
                        I := I - 1;
                        exit when I < J + 1;
                        X (IX) := X (IX) + TEMP * A (I, J);
                        IX     := IX - INCX;
                     end loop;
                     if NOUNIT then
                        X (JX) := X (JX) * A (J, J);
                     end if;
                  end if;
                  JX := JX - INCX;
               end loop;
            end if;
         end if;
      else
         --
         --        Form  x := A**T*x.
         --
         if LSAME (UPLO, 'U') then
            if INCX = 1 then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  TEMP := X (J);
                  if NOUNIT then
                     TEMP := TEMP * A (J, J);
                  end if;
                  I := J - 1 + 1;
                  loop
                     I := I - 1;
                     exit when I < 1;
                     TEMP := TEMP + A (I, J) * X (I);
                  end loop;
                  X (J) := TEMP;
               end loop;
            else
               JX := KX + (N - 1) * INCX;
               J  := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  TEMP := X (JX);
                  IX   := JX;
                  if NOUNIT then
                     TEMP := TEMP * A (J, J);
                  end if;
                  I := J - 1 + 1;
                  loop
                     I := I - 1;
                     exit when I < 1;
                     IX   := IX - INCX;
                     TEMP := TEMP + A (I, J) * X (IX);
                  end loop;
                  X (JX) := TEMP;
                  JX     := JX - INCX;
               end loop;
            end if;
         else
            if INCX = 1 then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  TEMP := X (J);
                  if NOUNIT then
                     TEMP := TEMP * A (J, J);
                  end if;
                  I := J + 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     TEMP := TEMP + A (I, J) * X (I);
                  end loop;
                  X (J) := TEMP;
               end loop;
            else
               JX := KX;
               J  := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  TEMP := X (JX);
                  IX   := JX;
                  if NOUNIT then
                     TEMP := TEMP * A (J, J);
                  end if;
                  I := J + 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     IX   := IX + INCX;
                     TEMP := TEMP + A (I, J) * X (IX);
                  end loop;
                  X (JX) := TEMP;
                  JX     := JX + INCX;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of DTRMV .
      --
   end DTRMV;

   procedure DTRSM
     (SIDE   : Character;
      UPLO   : Character;
      TRANSA : Character;
      DIAG   : Character;
      M      : Integer;
      N      : Integer;
      ALPHA  : Real;
      A_adr  : Address;
      LDA    : Integer;
      B_adr  : Address;
      LDB    : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. max (M, N));
      B : Ftn_Real_Matrix (1 .. LDB, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);

      TEMP   : Real;
      I      : Integer;
      INFO   : Integer;
      J      : Integer;
      K      : Integer;
      NROWA  : Integer;
      LSIDE  : Boolean;
      NOUNIT : Boolean;
      UPPER  : Boolean;
      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION ALPHA
   --       INTEGER LDA,LDB,M,N
   --       CHARACTER DIAG,SIDE,TRANSA,UPLO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION A(LDA,*),B(LDB,*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DTRSM  solves one of the matrix equations
   --
   --     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
   --
   --  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
   --  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
   --
   --     op( A ) = A   or   op( A ) = A**T.
   --
   --  The matrix X is overwritten on B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --            On entry, SIDE specifies whether op( A ) appears on the left
   --            or right of X as follows:
   --
   --               SIDE = 'L' or 'l'   op( A )*X = alpha*B.
   --
   --               SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the matrix A is an upper or
   --            lower triangular matrix as follows:
   --
   --               UPLO = 'U' or 'u'   A is an upper triangular matrix.
   --
   --               UPLO = 'L' or 'l'   A is a lower triangular matrix.
   --
   --  [in] TRANSA
   --           TRANSA is CHARACTER*1
   --            On entry, TRANSA specifies the form of op( A ) to be used in
   --            the matrix multiplication as follows:
   --
   --               TRANSA = 'N' or 'n'   op( A ) = A.
   --
   --               TRANSA = 'T' or 't'   op( A ) = A**T.
   --
   --               TRANSA = 'C' or 'c'   op( A ) = A**T.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --            On entry, DIAG specifies whether or not A is unit triangular
   --            as follows:
   --
   --               DIAG = 'U' or 'u'   A is assumed to be unit triangular.
   --
   --               DIAG = 'N' or 'n'   A is not assumed to be unit
   --                                   triangular.
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of B. M must be at
   --            least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of B.  N must be
   --            at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION.
   --            On entry,  ALPHA specifies the scalar  alpha. When  alpha is
   --            zero then  A is not referenced and  B need not be set before
   --            entry.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array of DIMENSION ( LDA, k ),
   --            where k is m when SIDE = 'L' or 'l'
   --              and k is n when SIDE = 'R' or 'r'.
   --            Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
   --            upper triangular part of the array  A must contain the upper
   --            triangular matrix  and the strictly lower triangular part of
   --            A is not referenced.
   --            Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
   --            lower triangular part of the array  A must contain the lower
   --            triangular matrix  and the strictly upper triangular part of
   --            A is not referenced.
   --            Note that when  DIAG = 'U' or 'u',  the diagonal elements of
   --            A  are not referenced either,  but are assumed to be  unity.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
   --            LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
   --            then LDA must be at least max( 1, n ).
   --
   --  [in,out] B
   --           B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
   --            Before entry,  the leading  m by n part of the array  B must
   --            contain  the  right-hand  side  matrix  B,  and  on exit  is
   --            overwritten by the solution matrix  X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --            On entry, LDB specifies the first dimension of B as declared
   --            in  the  calling  (sub)  program.   LDB  must  be  at  least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 3 Blas routine.
   --
   --
   --   -- Written on 8-February-1989.
   --      Jack Dongarra, Argonne National Laboratory.
   --      Iain Duff, AERE Harwell.
   --      Jeremy Du Croz, Numerical Algorithms Group Ltd.
   --      Sven Hammarling, Numerical Algorithms Group Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level3 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      LSIDE := LSAME (SIDE, 'L');
      if LSIDE 
         then NROWA := M;
         else NROWA := N;
      end if;
      NOUNIT := LSAME (DIAG, 'N');
      UPPER  := LSAME (UPLO, 'U');
      --
      INFO := 0;
      if (not LSIDE) and (not LSAME (SIDE, 'R')) then
         INFO := 1;
      elsif (not UPPER) and (not LSAME (UPLO, 'L')) then
         INFO := 2;
      elsif (not LSAME (TRANSA, 'N')) and (not LSAME (TRANSA, 'T')) and (not LSAME (TRANSA, 'C')) then
         INFO := 3;
      elsif (not LSAME (DIAG, 'U')) and (not LSAME (DIAG, 'N')) then
         INFO := 4;
      elsif M < 0 then
         INFO := 5;
      elsif N < 0 then
         INFO := 6;
      elsif LDA < max (1, NROWA) then
         INFO := 9;
      elsif LDB < max (1, M) then
         INFO := 11;
      end if;
      if INFO /= 0 then
         XERBLA ("DTRSM ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     And when  alpha.eq.zero.
      --
      if ALPHA = ZERO then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := ZERO;
            end loop;
         end loop;
         return;
      end if;
      --
      --     Start the operations.
      --
      if LSIDE then
         if LSAME (TRANSA, 'N') then
            --
            --           Form  B := alpha*inv( A )*B.
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := ALPHA * B (I, J);
                     end loop;
                  end if;
                  K := M + 1;
                  loop
                     K := K - 1;
                     exit when K < 1;
                     if B (K, J) /= ZERO then
                        if NOUNIT then
                           B (K, J) := B (K, J) / A (K, K);
                        end if;
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > K - 1;
                           B (I, J) := B (I, J) - B (K, J) * A (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := ALPHA * B (I, J);
                     end loop;
                  end if;
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > M;
                     if B (K, J) /= ZERO then
                        if NOUNIT then
                           B (K, J) := B (K, J) / A (K, K);
                        end if;
                        I := K + 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - B (K, J) * A (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            end if;
         else
            --
            --           Form  B := alpha*inv( A**T )*B.
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     TEMP := ALPHA * B (I, J);
                     K    := 1 - 1;
                     loop
                        K := K + 1;
                        exit when K > I - 1;
                        TEMP := TEMP - A (K, I) * B (K, J);
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / A (I, I);
                     end if;
                     B (I, J) := TEMP;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := M + 1;
                  loop
                     I := I - 1;
                     exit when I < 1;
                     TEMP := ALPHA * B (I, J);
                     K    := I + 1 - 1;
                     loop
                        K := K + 1;
                        exit when K > M;
                        TEMP := TEMP - A (K, I) * B (K, J);
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / A (I, I);
                     end if;
                     B (I, J) := TEMP;
                  end loop;
               end loop;
            end if;
         end if;
      else
         if LSAME (TRANSA, 'N') then
            --
            --           Form  B := alpha*B*inv( A ).
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := ALPHA * B (I, J);
                     end loop;
                  end if;
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > J - 1;
                     if A (K, J) /= ZERO then
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - A (K, J) * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  if NOUNIT then
                     TEMP := ONE / A (J, J);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := TEMP * B (I, J);
                     end loop;
                  end if;
               end loop;
            else
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := ALPHA * B (I, J);
                     end loop;
                  end if;
                  K := J + 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     if A (K, J) /= ZERO then
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - A (K, J) * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  if NOUNIT then
                     TEMP := ONE / A (J, J);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := TEMP * B (I, J);
                     end loop;
                  end if;
               end loop;
            end if;
         else
            --
            --           Form  B := alpha*B*inv( A**T ).
            --
            if UPPER then
               K := N + 1;
               loop
                  K := K - 1;
                  exit when K < 1;
                  if NOUNIT then
                     TEMP := ONE / A (K, K);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := TEMP * B (I, K);
                     end loop;
                  end if;
                  J := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > K - 1;
                     if A (J, K) /= ZERO then
                        TEMP := A (J, K);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := ALPHA * B (I, K);
                     end loop;
                  end if;
               end loop;
            else
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  if NOUNIT then
                     TEMP := ONE / A (K, K);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := TEMP * B (I, K);
                     end loop;
                  end if;
                  J := K + 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     if A (J, K) /= ZERO then
                        TEMP := A (J, K);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := ALPHA * B (I, K);
                     end loop;
                  end if;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of DTRSM .
      --
   end DTRSM;

   function DZASUM
     (N      : Integer;
      ZX_adr : Address;
      INCX   : Integer)
      return   Real
   is
      ZX : Ftn_Complex_Vector (1 .. N * INCX);

      for ZX'Address use ZX_adr;

      pragma Import (Ada, ZX);

      STEMP         : Real;
      I             : Integer;
      NINCX         : Integer;
      DZASUM_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION DZASUM(N,ZX,INCX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DZASUM takes the sum of the absolute values.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, 3/11/78.
   --      modified 3/93 to return if incx .le. 0.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL DCABS1
   --     ..
   begin
      DZASUM_Result := 0.0e0;
      STEMP         := 0.0e0;
      if N <= 0 or INCX <= 0 then
         return DZASUM_Result;
      end if;
      if INCX = 1 then
         --
         --        code for increment equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            STEMP := STEMP + DCABS1 (ZX (I));
         end loop;
      else
         --
         --        code for increment not equal to 1
         --
         NINCX := N * INCX;
         I     := 1 - INCX;
         loop
            I := I + INCX;
            exit when I > NINCX;
            STEMP := STEMP + DCABS1 (ZX (I));
         end loop;
      end if;
      DZASUM_Result := STEMP;
      return DZASUM_Result;
   end DZASUM;

   function DZNRM2
     (N     : Integer;
      X_adr : Address;
      INCX  : Integer)
      return  Real
   is
      X : Ftn_Complex_Vector (1 .. 1 + (N - 1) * INCX);

      for X'Address use X_adr;

      pragma Import (Ada, X);

      ONE           : constant Real := 1.0e0;
      ZERO          : constant Real := 0.0e0;
      NORM          : Real;
      SCALE         : Real;
      SSQ           : Real;
      TEMP          : Real;
      IX            : Integer;
      DZNRM2_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION DZNRM2(N,X,INCX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 X(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DZNRM2 returns the euclidean norm of a vector via the function
   --  name, so that
   --
   --     DZNRM2 := sqrt( x**H*x )
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   -- This version written on 25-October-1982.
   --      Modified on 14-October-1993 to inline the call to ZLASSQ.
   --      Sven Hammarling, Nag Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC ABS,DBLE,DIMAG,SQRT
   --     ..
   begin
      if N < 1 or INCX < 1 then
         NORM := ZERO;
      else
         SCALE := ZERO;
         SSQ   := ONE;
         --        The following loop is equivalent to this call to the LAPACK
         --        auxiliary routine:
         --        CALL ZLASSQ( N, X, INCX, SCALE, SSQ )
         --
         IX := 1 - INCX;
         loop
            IX := IX + INCX;
            exit when IX > 1 + (N - 1) * INCX;
            if dble (X (IX)) /= ZERO then
               TEMP := abs (dble (X (IX)));
               if SCALE < TEMP then
                  SSQ   := ONE + SSQ * (SCALE / TEMP) ** 2;
                  SCALE := TEMP;
               else
                  SSQ := SSQ + (TEMP / SCALE) ** 2;
               end if;
            end if;
            if dimag (X (IX)) /= ZERO then
               TEMP := abs (dimag (X (IX)));
               if SCALE < TEMP then
                  SSQ   := ONE + SSQ * (SCALE / TEMP) ** 2;
                  SCALE := TEMP;
               else
                  SSQ := SSQ + (TEMP / SCALE) ** 2;
               end if;
            end if;
         end loop;
         NORM := SCALE * Sqrt (SSQ);
      end if;
      --
      DZNRM2_Result := NORM;
      return DZNRM2_Result;
      --
      --     End of DZNRM2.
      --
   end DZNRM2;

   function IDAMAX
     (N      : Integer;
      DX_adr : Address;
      INCX   : Integer)
      return   Integer
   is
      DX : Ftn_Real_Vector (1 .. 1 + (N - 1) * INCX);

      for DX'Address use DX_adr;

      pragma Import (Ada, DX);

      DMAX          : Real;
      I             : Integer;
      IX            : Integer;
      IDAMAX_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER FUNCTION IDAMAX(N,DX,INCX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION DX(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     IDAMAX finds the index of element having max. absolute value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, linpack, 3/11/78.
   --      modified 3/93 to return if incx .le. 0.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DABS
   --     ..
   begin
      IDAMAX_Result := 0;
      if N < 1 or INCX <= 0 then
         return IDAMAX_Result;
      end if;
      IDAMAX_Result := 1;
      if N = 1 then
         return IDAMAX_Result;
      end if;
      if INCX = 1 then
         --
         --        code for increment equal to 1
         --
         DMAX := DABS (DX (1));
         I    := 2 - 1;
         loop
            I := I + 1;
            exit when I > N;
            if DABS (DX (I)) > DMAX then
               IDAMAX_Result := I;
               DMAX          := DABS (DX (I));
            end if;
         end loop;
      else
         --
         --        code for increment not equal to 1
         --
         IX   := 1;
         DMAX := DABS (DX (1));
         IX   := IX + INCX;
         I    := 2 - 1;
         loop
            I := I + 1;
            exit when I > N;
            if DABS (DX (IX)) > DMAX then
               IDAMAX_Result := I;
               DMAX          := DABS (DX (IX));
            end if;
            IX := IX + INCX;
         end loop;
      end if;
      return IDAMAX_Result;
   end IDAMAX;

   function IZAMAX
     (N      : Integer;
      ZX_adr : Address;
      INCX   : Integer)
      return   Integer
   is
      ZX : Ftn_Complex_Vector (1 .. 1 + (N - 1) * INCX);

      for ZX'Address use ZX_adr;

      pragma Import (Ada, ZX);

      DMAX          : Real;
      I             : Integer;
      IX            : Integer;
      IZAMAX_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER FUNCTION IZAMAX(N,ZX,INCX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     IZAMAX finds the index of element having max. absolute value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, 1/15/85.
   --      modified 3/93 to return if incx .le. 0.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL DCABS1
   --     ..
   begin
      IZAMAX_Result := 0;
      if N < 1 or INCX <= 0 then
         return IZAMAX_Result;
      end if;
      IZAMAX_Result := 1;
      if N = 1 then
         return IZAMAX_Result;
      end if;
      if INCX = 1 then
         --
         --        code for increment equal to 1
         --
         DMAX := DCABS1 (ZX (1));
         I    := 2 - 1;
         loop
            I := I + 1;
            exit when I > N;
            if DCABS1 (ZX (I)) > DMAX then
               IZAMAX_Result := I;
               DMAX          := DCABS1 (ZX (I));
            end if;
         end loop;
      else
         --
         --        code for increment not equal to 1
         --
         IX   := 1;
         DMAX := DCABS1 (ZX (1));
         IX   := IX + INCX;
         I    := 2 - 1;
         loop
            I := I + 1;
            exit when I > N;
            if DCABS1 (ZX (IX)) > DMAX then
               IZAMAX_Result := I;
               DMAX          := DCABS1 (ZX (IX));
            end if;
            IX := IX + INCX;
         end loop;
      end if;
      return IZAMAX_Result;
   end IZAMAX;

   procedure ZAXPY
     (N      : Integer;
      ZA     : Complex;
      ZX_adr : Address;
      INCX   : Integer;
      ZY_adr : Address;
      INCY   : Integer)
   is

      ZX : Ftn_Complex_Vector (1 .. 1 + INCX * (N - 1));
      ZY : Ftn_Complex_Vector (1 .. 1 + INCY * (N - 1));

      for ZX'Address use ZX_adr;
      for ZY'Address use ZY_adr;

      pragma Import (Ada, ZX);
      pragma Import (Ada, ZY);

      I  : Integer;
      IX : Integer;
      IY : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZAXPY(N,ZA,ZX,INCX,ZY,INCY)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ZA
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*),ZY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZAXPY constant times a vector plus a vector.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL DCABS1
   --     ..
   begin
      if N <= 0 then
         return;
      end if;
      if DCABS1 (ZA) = 0.0e0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --        code for both increments equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZY (I) := ZY (I) + ZA * ZX (I);
         end loop;
      else
         --
         --        code for unequal increments or equal increments
         --          not equal to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZY (IY) := ZY (IY) + ZA * ZX (IX);
            IX      := IX + INCX;
            IY      := IY + INCY;
         end loop;
      end if;
      --
   end ZAXPY;

   procedure ZCOPY
     (N      : Integer;
      ZX_adr : Address;
      INCX   : Integer;
      ZY_adr : Address;
      INCY   : Integer)
   is

      ZX : Ftn_Complex_Vector (1 .. 1 + abs (INCX) * (N - 1));
      ZY : Ftn_Complex_Vector (1 .. 1 + abs (INCY) * (N - 1));

      for ZX'Address use ZX_adr;
      for ZY'Address use ZY_adr;

      pragma Import (Ada, ZX);
      pragma Import (Ada, ZY);

      I  : Integer;
      IX : Integer;
      IY : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZCOPY(N,ZX,INCX,ZY,INCY)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*),ZY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZCOPY copies a vector, x, to a vector, y.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, linpack, 4/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   begin
      if N <= 0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --        code for both increments equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZY (I) := ZX (I);
         end loop;
      else
         --
         --        code for unequal increments or equal increments
         --          not equal to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZY (IY) := ZX (IX);
            IX      := IX + INCX;
            IY      := IY + INCY;
         end loop;
      end if;
   end ZCOPY;

   function ZDOTC
     (N      : Integer;
      ZX_adr : Address;
      INCX   : Integer;
      ZY_adr : Address;
      INCY   : Integer)
      return   Complex
   is
      ZX : Ftn_Complex_Vector (1 .. N);
      ZY : Ftn_Complex_Vector (1 .. N);

      for ZX'Address use ZX_adr;
      for ZY'Address use ZY_adr;

      pragma Import (Ada, ZX);
      pragma Import (Ada, ZY);

      ZTEMP        : Complex;
      I            : Integer;
      IX           : Integer;
      IY           : Integer;
      ZDOTC_Result : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       COMPLEX*16 FUNCTION ZDOTC(N,ZX,INCX,ZY,INCY)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*),ZY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZDOTC forms the dot product of a vector.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCONJG
   --     ..
   begin
      ZTEMP        := (0.0e0, 0.0e0);
      ZDOTC_Result := (0.0e0, 0.0e0);
      if N <= 0 then
         return ZDOTC_Result;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --        code for both increments equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZTEMP := ZTEMP + dconjg (ZX (I)) * ZY (I);
         end loop;
      else
         --
         --        code for unequal increments or equal increments
         --          not equal to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZTEMP := ZTEMP + dconjg (ZX (IX)) * ZY (IY);
            IX    := IX + INCX;
            IY    := IY + INCY;
         end loop;
      end if;
      ZDOTC_Result := ZTEMP;
      return ZDOTC_Result;
   end ZDOTC;

   function ZDOTU
     (N      : Integer;
      ZX_adr : Address;
      INCX   : Integer;
      ZY_adr : Address;
      INCY   : Integer)
      return   Complex
   is
      ZX : Ftn_Complex_Vector (1 .. N);
      ZY : Ftn_Complex_Vector (1 .. N);

      for ZX'Address use ZX_adr;
      for ZY'Address use ZY_adr;

      pragma Import (Ada, ZX);
      pragma Import (Ada, ZY);

      ZTEMP        : Complex;
      I            : Integer;
      IX           : Integer;
      IY           : Integer;
      ZDOTU_Result : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       COMPLEX*16 FUNCTION ZDOTU(N,ZX,INCX,ZY,INCY)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*),ZY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZDOTU forms the dot product of two vectors.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   begin
      ZTEMP        := (0.0e0, 0.0e0);
      ZDOTU_Result := (0.0e0, 0.0e0);
      if N <= 0 then
         return ZDOTU_Result;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --        code for both increments equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZTEMP := ZTEMP + ZX (I) * ZY (I);
         end loop;
      else
         --
         --        code for unequal increments or equal increments
         --          not equal to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZTEMP := ZTEMP + ZX (IX) * ZY (IY);
            IX    := IX + INCX;
            IY    := IY + INCY;
         end loop;
      end if;
      ZDOTU_Result := ZTEMP;
      return ZDOTU_Result;
   end ZDOTU;

   procedure ZDROT
     (N      : Integer;
      CX_adr : Address;
      INCX   : Integer;
      CY_adr : Address;
      INCY   : Integer;
      C      : Real;
      S      : Real)
   is

      CX : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCX));
      CY : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for CX'Address use CX_adr;
      for CY'Address use CY_adr;

      pragma Import (Ada, CX);
      pragma Import (Ada, CY);

      I     : Integer;
      IX    : Integer;
      IY    : Integer;
      CTEMP : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZDROT( N, CX, INCX, CY, INCY, C, S )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, INCY, N
   --       DOUBLE PRECISION   C, S
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         CX( * ), CY( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  Applies a plane rotation, where the cos and sin (c and s) are real
   --  and the vectors cx and cy are complex.
   --  jack dongarra, linpack, 3/11/78.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the vectors cx and cy.
   --            N must be at least zero.
   --
   --  [in,out] CX
   --           CX is COMPLEX*16 array, dimension at least
   --            ( 1 + ( N - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array CX must contain the n
   --            element vector cx. On exit, CX is overwritten by the updated
   --            vector cx.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            CX. INCX must not be zero.
   --
   --  [in,out] CY
   --           CY is COMPLEX*16 array, dimension at least
   --            ( 1 + ( N - 1 )*abs( INCY ) ).
   --            Before entry, the incremented array CY must contain the n
   --            element vector cy. On exit, CY is overwritten by the updated
   --            vector cy.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            CY. INCY must not be zero.
   --
   --  [in] C
   --           C is DOUBLE PRECISION
   --            On entry, C specifies the cosine, cos.
   --
   --  [in] S
   --           S is DOUBLE PRECISION
   --            On entry, S specifies the sine, sin.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N <= 0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --        code for both increments equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            CTEMP  := C * CX (I) + S * CY (I);
            CY (I) := C * CY (I) - S * CX (I);
            CX (I) := CTEMP;
         end loop;
      else
         --
         --        code for unequal increments or equal increments not equal
         --          to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            CTEMP   := C * CX (IX) + S * CY (IY);
            CY (IY) := C * CY (IY) - S * CX (IX);
            CX (IX) := CTEMP;
            IX      := IX + INCX;
            IY      := IY + INCY;
         end loop;
      end if;
   end ZDROT;

   procedure ZDSCAL
     (N      : Integer;
      DA     : Real;
      ZX_adr : Address;
      INCX   : Integer)
   is

      ZX : Ftn_Complex_Vector (1 .. N * INCX);

      for ZX'Address use ZX_adr;

      pragma Import (Ada, ZX);

      I     : Integer;
      NINCX : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZDSCAL(N,DA,ZX,INCX)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION DA
   --       INTEGER INCX,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZDSCAL scales a vector by a constant.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, 3/11/78.
   --      modified 3/93 to return if incx .le. 0.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCMPLX
   --     ..
   begin
      if N <= 0 or INCX <= 0 then
         return;
      end if;
      if INCX = 1 then
         --
         --        code for increment equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZX (I) := dcmplx (DA, 0.0e0) * ZX (I);
         end loop;
      else
         --
         --        code for increment not equal to 1
         --
         NINCX := N * INCX;
         I     := 1 - INCX;
         loop
            I := I + INCX;
            exit when I > NINCX;
            ZX (I) := dcmplx (DA, 0.0e0) * ZX (I);
         end loop;
      end if;
   end ZDSCAL;

   procedure ZGEMM
     (TRANSA : Character;
      TRANSB : Character;
      M      : Integer;
      N      : Integer;
      K      : Integer;
      ALPHA  : Complex;
      A_adr  : Address;
      LDA    : Integer;
      B_adr  : Address;
      LDB    : Integer;
      BETA   : Complex;
      C_adr  : Address;
      LDC    : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. max (K, M));
      B : Ftn_Complex_Matrix (1 .. LDB, 1 .. max (K, N));
      C : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;
      for C'Address use C_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);
      pragma Import (Ada, C);

      TEMP  : Complex;
      I     : Integer;
      INFO  : Integer;
      J     : Integer;
      L     : Integer;
      NCOLA : Integer;
      NROWA : Integer;
      NROWB : Integer;
      NOTA  : Boolean;
      NOTB  : Boolean;
      CONJA : Boolean;
      CONJB : Boolean;
      ONE   : constant Complex := (1.0e0, 0.0e0);
      ZERO  : constant Complex := (0.0e0, 0.0e0);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA,BETA
   --       INTEGER K,LDA,LDB,LDC,M,N
   --       CHARACTER TRANSA,TRANSB
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEMM  performs one of the matrix-matrix operations
   --
   --     C := alpha*op( A )*op( B ) + beta*C,
   --
   --  where  op( X ) is one of
   --
   --     op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H,
   --
   --  alpha and beta are scalars, and A, B and C are matrices, with op( A )
   --  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] TRANSA
   --           TRANSA is CHARACTER*1
   --            On entry, TRANSA specifies the form of op( A ) to be used in
   --            the matrix multiplication as follows:
   --
   --               TRANSA = 'N' or 'n',  op( A ) = A.
   --
   --               TRANSA = 'T' or 't',  op( A ) = A**T.
   --
   --               TRANSA = 'C' or 'c',  op( A ) = A**H.
   --
   --  [in] TRANSB
   --           TRANSB is CHARACTER*1
   --            On entry, TRANSB specifies the form of op( B ) to be used in
   --            the matrix multiplication as follows:
   --
   --               TRANSB = 'N' or 'n',  op( B ) = B.
   --
   --               TRANSB = 'T' or 't',  op( B ) = B**T.
   --
   --               TRANSB = 'C' or 'c',  op( B ) = B**H.
   --
   --  [in] M
   --           M is INTEGER
   --            On entry,  M  specifies  the number  of rows  of the  matrix
   --            op( A )  and of the  matrix  C.  M  must  be at least  zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry,  N  specifies the number  of columns of the matrix
   --            op( B ) and the number of columns of the matrix C. N must be
   --            at least zero.
   --
   --  [in] K
   --           K is INTEGER
   --            On entry,  K  specifies  the number of columns of the matrix
   --            op( A ) and the number of rows of the matrix op( B ). K must
   --            be at least  zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
   --            k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
   --            Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
   --            part of the array  A  must contain the matrix  A,  otherwise
   --            the leading  k by m  part of the array  A  must contain  the
   --            matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. When  TRANSA = 'N' or 'n' then
   --            LDA must be at least  max( 1, m ), otherwise  LDA must be at
   --            least  max( 1, k ).
   --
   --  [in] B
   --           B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
   --            n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
   --            Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
   --            part of the array  B  must contain the matrix  B,  otherwise
   --            the leading  n by k  part of the array  B  must contain  the
   --            matrix B.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --            On entry, LDB specifies the first dimension of B as declared
   --            in the calling (sub) program. When  TRANSB = 'N' or 'n' then
   --            LDB must be at least  max( 1, k ), otherwise  LDB must be at
   --            least  max( 1, n ).
   --
   --  [in] BETA
   --           BETA is COMPLEX*16
   --            On entry,  BETA  specifies the scalar  beta.  When  BETA  is
   --            supplied as zero then C need not be set on input.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array of DIMENSION ( LDC, n ).
   --            Before entry, the leading  m by n  part of the array  C must
   --            contain the matrix  C,  except when  beta  is zero, in which
   --            case C need not be set on entry.
   --            On exit, the array  C  is overwritten by the  m by n  matrix
   --            ( alpha*op( A )*op( B ) + beta*C ).
   --
   --  [in] LDC
   --           LDC is INTEGER
   --            On entry, LDC specifies the first dimension of C as declared
   --            in  the  calling  (sub)  program.   LDC  must  be  at  least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 3 Blas routine.
   --
   --   -- Written on 8-February-1989.
   --      Jack Dongarra, Argonne National Laboratory.
   --      Iain Duff, AERE Harwell.
   --      Jeremy Du Croz, Numerical Algorithms Group Ltd.
   --      Sven Hammarling, Numerical Algorithms Group Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level3 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCONJG,MAX
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Parameters ..
   --      PARAMETER (ONE= (1.0D+0,0.0D+0))
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --
   --     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
   --     conjugated or transposed, set  CONJA and CONJB  as true if  A  and
   --     B  respectively are to be  transposed but  not conjugated  and set
   --     NROWA, NCOLA and  NROWB  as the number of rows and  columns  of  A
   --     and the number of rows of  B  respectively.
   --
   begin
      NOTA  := LSAME (TRANSA, 'N');
      NOTB  := LSAME (TRANSB, 'N');
      CONJA := LSAME (TRANSA, 'C');
      CONJB := LSAME (TRANSB, 'C');
      if NOTA then
         NROWA := M;
         NCOLA := K;
      else
         NROWA := K;
         NCOLA := M;
      end if;
      if NOTB 
         then NROWB := K;
         else NROWB := N;
      end if;
      --
      --     Test the input parameters.
      --
      INFO := 0;
      if (not NOTA) and (not CONJA) and (not LSAME (TRANSA, 'T')) then
         INFO := 1;
      elsif (not NOTB) and (not CONJB) and (not LSAME (TRANSB, 'T')) then
         INFO := 2;
      elsif M < 0 then
         INFO := 3;
      elsif N < 0 then
         INFO := 4;
      elsif K < 0 then
         INFO := 5;
      elsif LDA < max (1, NROWA) then
         INFO := 8;
      elsif LDB < max (1, NROWB) then
         INFO := 10;
      elsif LDC < max (1, M) then
         INFO := 13;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGEMM ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (M = 0) or (N = 0) or (((ALPHA = ZERO) or (K = 0)) and (BETA = ONE)) then
         return;
      end if;
      --
      --     And when  alpha.eq.zero.
      --
      if ALPHA = ZERO then
         if BETA = ZERO then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  C (I, J) := ZERO;
               end loop;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  C (I, J) := BETA * C (I, J);
               end loop;
            end loop;
         end if;
         return;
      end if;
      --
      --     Start the operations.
      --
      if NOTB then
         if NOTA then
            --
            --           Form  C := alpha*A*B + beta*C.
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = ZERO then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if B (L, J) /= ZERO then
                     TEMP := ALPHA * B (L, J);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        C (I, J) := C (I, J) + TEMP * A (I, L);
                     end loop;
                  end if;
               end loop;
            end loop;
         elsif CONJA then
            --
            --           Form  C := alpha*A**H*B + beta*C.
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := ZERO;
                  L    := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP := TEMP + dconjg (A (L, I)) * B (L, J);
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP;
                     else C (I, J) := ALPHA * TEMP + BETA * C (I, J);
                  end if;
               end loop;
            end loop;
         else
            --
            --           Form  C := alpha*A**T*B + beta*C
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := ZERO;
                  L    := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP := TEMP + A (L, I) * B (L, J);
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP;
                     else C (I, J) := ALPHA * TEMP + BETA * C (I, J);
                  end if;
               end loop;
            end loop;
         end if;
      elsif NOTA then
         if CONJB then
            --
            --           Form  C := alpha*A*B**H + beta*C.
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = ZERO then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if B (J, L) /= ZERO then
                     TEMP := ALPHA * dconjg (B (J, L));
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        C (I, J) := C (I, J) + TEMP * A (I, L);
                     end loop;
                  end if;
               end loop;
            end loop;
         else
            --
            --           Form  C := alpha*A*B**T          + beta*C
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = ZERO then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if B (J, L) /= ZERO then
                     TEMP := ALPHA * B (J, L);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        C (I, J) := C (I, J) + TEMP * A (I, L);
                     end loop;
                  end if;
               end loop;
            end loop;
         end if;
      elsif CONJA then
         if CONJB then
            --
            --           Form  C := alpha*A**H*B**H + beta*C.
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := ZERO;
                  L    := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP := TEMP + dconjg (A (L, I)) * dconjg (B (J, L));
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP;
                     else C (I, J) := ALPHA * TEMP + BETA * C (I, J);
                  end if;
               end loop;
            end loop;
         else
            --
            --           Form  C := alpha*A**H*B**T + beta*C
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := ZERO;
                  L    := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP := TEMP + dconjg (A (L, I)) * B (J, L);
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP;
                     else C (I, J) := ALPHA * TEMP + BETA * C (I, J);
                  end if;
               end loop;
            end loop;
         end if;
      else
         if CONJB then
            --
            --           Form  C := alpha*A**T*B**H + beta*C
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := ZERO;
                  L    := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP := TEMP + A (L, I) * dconjg (B (J, L));
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP;
                     else C (I, J) := ALPHA * TEMP + BETA * C (I, J);
                  end if;
               end loop;
            end loop;
         else
            --
            --           Form  C := alpha*A**T*B**T + beta*C
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  TEMP := ZERO;
                  L    := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP := TEMP + A (L, I) * B (J, L);
                  end loop;
                  if BETA = ZERO 
                     then C (I, J) := ALPHA * TEMP;
                     else C (I, J) := ALPHA * TEMP + BETA * C (I, J);
                  end if;
               end loop;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZGEMM .
      --
   end ZGEMM;

   procedure ZGEMV
     (TRANS : Character;
      M     : Integer;
      N     : Integer;
      ALPHA : Complex;
      A_adr : Address;
      LDA   : Integer;
      X_adr : Address;
      INCX  : Integer;
      BETA  : Complex;
      Y_adr : Address;
      INCY  : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      X : Ftn_Complex_Vector (1 .. 1 + (max (M, N) - 1) * abs (INCX));
      Y : Ftn_Complex_Vector (1 .. 1 + (max (M, N) - 1) * abs (INCY));

      for A'Address use A_adr;
      for X'Address use X_adr;
      for Y'Address use Y_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, X);
      pragma Import (Ada, Y);

      ONE    : constant Complex := (1.0e0, 0.0e0);
      ZERO   : constant Complex := (0.0e0, 0.0e0);
      TEMP   : Complex;
      I      : Integer;
      INFO   : Integer;
      IX     : Integer;
      IY     : Integer;
      J      : Integer;
      JX     : Integer;
      JY     : Integer;
      KX     : Integer;
      KY     : Integer;
      LENX   : Integer;
      LENY   : Integer;
      NOCONJ : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA,BETA
   --       INTEGER INCX,INCY,LDA,M,N
   --       CHARACTER TRANS
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEMV  performs one of the matrix-vector operations
   --
   --     y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or
   --
   --     y := alpha*A**H*x + beta*y,
   --
   --  where alpha and beta are scalars, x and y are vectors and A is an
   --  m by n matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --            On entry, TRANS specifies the operation to be performed as
   --            follows:
   --
   --               TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
   --
   --               TRANS = 'T' or 't'   y := alpha*A**T*x + beta*y.
   --
   --               TRANS = 'C' or 'c'   y := alpha*A**H*x + beta*y.
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of the matrix A.
   --            M must be at least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, n ).
   --            Before entry, the leading m by n part of the array A must
   --            contain the matrix of coefficients.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, m ).
   --
   --  [in] X
   --           X is COMPLEX*16 array of DIMENSION at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
   --            and at least
   --            ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
   --            Before entry, the incremented array X must contain the
   --            vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] BETA
   --           BETA is COMPLEX*16
   --            On entry, BETA specifies the scalar beta. When BETA is
   --            supplied as zero then Y need not be set on input.
   --
   --  [in,out] Y
   --           Y is COMPLEX*16 array of DIMENSION at least
   --            ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
   --            and at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
   --            Before entry with BETA non-zero, the incremented array Y
   --            must contain the vector y. On exit, Y is overwritten by the
   --            updated vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --   The vector and matrix arguments are not referenced when N = 0, or M = 0
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ONE= (1.0D+0,0.0D+0))
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCONJG,MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (TRANS, 'N') and not LSAME (TRANS, 'T') and not LSAME (TRANS, 'C') then
         INFO := 1;
      elsif M < 0 then
         INFO := 2;
      elsif N < 0 then
         INFO := 3;
      elsif LDA < max (1, M) then
         INFO := 6;
      elsif INCX = 0 then
         INFO := 8;
      elsif INCY = 0 then
         INFO := 11;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGEMV ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (M = 0) or (N = 0) or ((ALPHA = ZERO) and (BETA = ONE)) then
         return;
      end if;
      --
      NOCONJ := LSAME (TRANS, 'T');
      --
      --     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
      --     up the start points in  X  and  Y.
      --
      if LSAME (TRANS, 'N') then
         LENX := N;
         LENY := M;
      else
         LENX := M;
         LENY := N;
      end if;
      if INCX > 0 
         then KX := 1;
         else KX := 1 - (LENX - 1) * INCX;
      end if;
      if INCY > 0 
         then KY := 1;
         else KY := 1 - (LENY - 1) * INCY;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through A.
      --
      --     First form  y := beta*y.
      --
      if BETA /= ONE then
         if INCY = 1 then
            if BETA = ZERO then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > LENY;
                  Y (I) := ZERO;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > LENY;
                  Y (I) := BETA * Y (I);
               end loop;
            end if;
         else
            IY := KY;
            if BETA = ZERO then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > LENY;
                  Y (IY) := ZERO;
                  IY     := IY + INCY;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > LENY;
                  Y (IY) := BETA * Y (IY);
                  IY     := IY + INCY;
               end loop;
            end if;
         end if;
      end if;
      if ALPHA = ZERO then
         return;
      end if;
      if LSAME (TRANS, 'N') then
         --
         --        Form  y := alpha*A*x + y.
         --
         JX := KX;
         if INCY = 1 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (JX) /= ZERO then
                  TEMP := ALPHA * X (JX);
                  I    := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     Y (I) := Y (I) + TEMP * A (I, J);
                  end loop;
               end if;
               JX := JX + INCX;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (JX) /= ZERO then
                  TEMP := ALPHA * X (JX);
                  IY   := KY;
                  I    := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     Y (IY) := Y (IY) + TEMP * A (I, J);
                     IY     := IY + INCY;
                  end loop;
               end if;
               JX := JX + INCX;
            end loop;
         end if;
      else
         --
         --        Form  y := alpha*A**T*x + y  or  y := alpha*A**H*x + y.
         --
         JY := KY;
         if INCX = 1 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP := ZERO;
               if NOCONJ then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     TEMP := TEMP + A (I, J) * X (I);
                  end loop;
               else
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     TEMP := TEMP + dconjg (A (I, J)) * X (I);
                  end loop;
               end if;
               Y (JY) := Y (JY) + ALPHA * TEMP;
               JY     := JY + INCY;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP := ZERO;
               IX   := KX;
               if NOCONJ then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     TEMP := TEMP + A (I, J) * X (IX);
                     IX   := IX + INCX;
                  end loop;
               else
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     TEMP := TEMP + dconjg (A (I, J)) * X (IX);
                     IX   := IX + INCX;
                  end loop;
               end if;
               Y (JY) := Y (JY) + ALPHA * TEMP;
               JY     := JY + INCY;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZGEMV .
      --
   end ZGEMV;

   procedure ZGERC
     (M     : Integer;
      N     : Integer;
      ALPHA : Complex;
      X     : in out Ftn_Complex_Vector;
      INCX  : Integer;
      Y     : in out Ftn_Complex_Vector;
      INCY  : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer)
   is
      ZERO : Complex := Complex'(0.0e0, 0.0e0);
      TEMP : Complex;
      I    : Integer;
      INFO : Integer;
      IX   : Integer;
      J    : Integer;
      JY   : Integer;
      KX   : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGERC(M,N,ALPHA,X,INCX,Y,INCY,A,LDA)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA
   --       INTEGER INCX,INCY,LDA,M,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGERC  performs the rank 1 operation
   --
   --     A := alpha*x*y**H + A,
   --
   --  where alpha is a scalar, x is an m element vector, y is an n element
   --  vector and A is an m by n matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of the matrix A.
   --            M must be at least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] X
   --           X is COMPLEX*16 array of dimension at least
   --            ( 1 + ( m - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the m
   --            element vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] Y
   --           Y is COMPLEX*16 array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ).
   --            Before entry, the incremented array Y must contain the n
   --            element vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, n ).
   --            Before entry, the leading m by n part of the array A must
   --            contain the matrix of coefficients. On exit, A is
   --            overwritten by the updated matrix.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCONJG,MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif INCX = 0 then
         INFO := 5;
      elsif INCY = 0 then
         INFO := 7;
      elsif LDA < max (1, M) then
         INFO := 9;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGERC ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (M = 0) or (N = 0) or (ALPHA = ZERO) then
         return;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through A.
      --
      if INCY > 0 
         then JY := 1;
         else JY := 1 - (N - 1) * INCY;
      end if;
      if INCX = 1 then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if Y (JY) /= ZERO then
               TEMP := ALPHA * dconjg (Y (JY));
               I    := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  A (I, J) := A (I, J) + X (I) * TEMP;
               end loop;
            end if;
            JY := JY + INCY;
         end loop;
      else
         if INCX > 0 
            then KX := 1;
            else KX := 1 - (M - 1) * INCX;
         end if;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if Y (JY) /= ZERO then
               TEMP := ALPHA * dconjg (Y (JY));
               IX   := KX;
               I    := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  A (I, J) := A (I, J) + X (IX) * TEMP;
                  IX       := IX + INCX;
               end loop;
            end if;
            JY := JY + INCY;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZGERC .
      --
   end ZGERC;

   procedure ZGERU
     (M     : Integer;
      N     : Integer;
      ALPHA : Complex;
      X_adr : Address;
      INCX  : Integer;
      Y_adr : Address;
      INCY  : Integer;
      A_adr : Address;
      LDA   : Integer)
   is

      X : Ftn_Complex_Vector (1 .. 1 + (M - 1) * abs (INCX));
      Y : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCY));
      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);

      for X'Address use X_adr;
      for Y'Address use Y_adr;
      for A'Address use A_adr;

      pragma Import (Ada, X);
      pragma Import (Ada, Y);
      pragma Import (Ada, A);

      ZERO : constant Complex := (0.0e0, 0.0e0);
      TEMP : Complex;
      I    : Integer;
      INFO : Integer;
      IX   : Integer;
      J    : Integer;
      JY   : Integer;
      KX   : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGERU(M,N,ALPHA,X,INCX,Y,INCY,A,LDA)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA
   --       INTEGER INCX,INCY,LDA,M,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGERU  performs the rank 1 operation
   --
   --     A := alpha*x*y**T + A,
   --
   --  where alpha is a scalar, x is an m element vector, y is an n element
   --  vector and A is an m by n matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of the matrix A.
   --            M must be at least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] X
   --           X is COMPLEX*16 array of dimension at least
   --            ( 1 + ( m - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the m
   --            element vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] Y
   --           Y is COMPLEX*16 array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ).
   --            Before entry, the incremented array Y must contain the n
   --            element vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, n ).
   --            Before entry, the leading m by n part of the array A must
   --            contain the matrix of coefficients. On exit, A is
   --            overwritten by the updated matrix.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif INCX = 0 then
         INFO := 5;
      elsif INCY = 0 then
         INFO := 7;
      elsif LDA < max (1, M) then
         INFO := 9;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGERU ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (M = 0) or (N = 0) or (ALPHA = ZERO) then
         return;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through A.
      --
      if INCY > 0 
         then JY := 1;
         else JY := 1 - (N - 1) * INCY;
      end if;
      if INCX = 1 then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if Y (JY) /= ZERO then
               TEMP := ALPHA * Y (JY);
               I    := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  A (I, J) := A (I, J) + X (I) * TEMP;
               end loop;
            end if;
            JY := JY + INCY;
         end loop;
      else
         if INCX > 0 
            then KX := 1;
            else KX := 1 - (M - 1) * INCX;
         end if;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if Y (JY) /= ZERO then
               TEMP := ALPHA * Y (JY);
               IX   := KX;
               I    := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  A (I, J) := A (I, J) + X (IX) * TEMP;
                  IX       := IX + INCX;
               end loop;
            end if;
            JY := JY + INCY;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZGERU  .
      --
   end ZGERU;

   procedure ZHEMV
     (UPLO  : Character;
      N     : Integer;
      ALPHA : Complex;
      A_adr : Address;
      LDA   : Integer;
      X_adr : Address;
      INCX  : Integer;
      BETA  : Complex;
      Y_adr : Address;
      INCY  : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      X : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCX));
      Y : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for A'Address use A_adr;
      for X'Address use X_adr;
      for Y'Address use Y_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, X);
      pragma Import (Ada, Y);

      ONE   : constant Complex := (1.0, 0.0);
      ZERO  : constant Complex := (0.0, 0.0);
      TEMP1 : Complex;
      TEMP2 : Complex;
      I     : Integer;
      INFO  : Integer;
      IX    : Integer;
      IY    : Integer;
      J     : Integer;
      JX    : Integer;
      JY    : Integer;
      KX    : Integer;
      KY    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZHEMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA,BETA
   --       INTEGER INCX,INCY,LDA,N
   --       CHARACTER UPLO
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZHEMV  performs the matrix-vector  operation
   --
   --     y := alpha*A*x + beta*y,
   --
   --  where alpha and beta are scalars, x and y are n element vectors and
   --  A is an n by n hermitian matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the upper or lower
   --            triangular part of the array A is to be referenced as
   --            follows:
   --
   --               UPLO = 'U' or 'u'   Only the upper triangular part of A
   --                                   is to be referenced.
   --
   --               UPLO = 'L' or 'l'   Only the lower triangular part of A
   --                                   is to be referenced.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, n ).
   --            Before entry with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular part of the hermitian matrix and the strictly
   --            lower triangular part of A is not referenced.
   --            Before entry with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular part of the hermitian matrix and the strictly
   --            upper triangular part of A is not referenced.
   --            Note that the imaginary parts of the diagonal elements need
   --            not be set and are assumed to be zero.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, n ).
   --
   --  [in] X
   --           X is COMPLEX*16 array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the n
   --            element vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] BETA
   --           BETA is COMPLEX*16
   --            On entry, BETA specifies the scalar beta. When BETA is
   --            supplied as zero then Y need not be set on input.
   --
   --  [in,out] Y
   --           Y is COMPLEX*16 array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ).
   --            Before entry, the incremented array Y must contain the n
   --            element vector y. On exit, Y is overwritten by the updated
   --            vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --   The vector and matrix arguments are not referenced when N = 0, or M = 0
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ONE= (1.0D+0,0.0D+0))
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DBLE,DCONJG,MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif LDA < max (1, N) then
         INFO := 5;
      elsif INCX = 0 then
         INFO := 7;
      elsif INCY = 0 then
         INFO := 10;
      end if;
      if INFO /= 0 then
         XERBLA ("ZHEMV ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (N = 0) or ((ALPHA = ZERO) and (BETA = ONE)) then
         return;
      end if;
      --
      --     Set up the start points in  X  and  Y.
      --
      if INCX > 0 
         then KX := 1;
         else KX := 1 - (N - 1) * INCX;
      end if;
      if INCY > 0 
         then KY := 1;
         else KY := 1 - (N - 1) * INCY;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through the triangular part
      --     of A.
      --
      --     First form  y := beta*y.
      --
      if BETA /= ONE then
         if INCY = 1 then
            if BETA = ZERO then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (I) := ZERO;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (I) := BETA * Y (I);
               end loop;
            end if;
         else
            IY := KY;
            if BETA = ZERO then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (IY) := ZERO;
                  IY     := IY + INCY;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (IY) := BETA * Y (IY);
                  IY     := IY + INCY;
               end loop;
            end if;
         end if;
      end if;
      if ALPHA = ZERO then
         return;
      end if;
      if LSAME (UPLO, 'U') then
         --
         --        Form  y  when A is stored in upper triangle.
         --
         if (INCX = 1) and (INCY = 1) then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP1 := ALPHA * X (J);
               TEMP2 := ZERO;
               I     := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J - 1;
                  Y (I) := Y (I) + TEMP1 * A (I, J);
                  TEMP2 := TEMP2 + dconjg (A (I, J)) * X (I);
               end loop;
               Y (J) := Y (J) + TEMP1 * dble (A (J, J)) + ALPHA * TEMP2;
            end loop;
         else
            JX := KX;
            JY := KY;
            J  := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP1 := ALPHA * X (JX);
               TEMP2 := ZERO;
               IX    := KX;
               IY    := KY;
               I     := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J - 1;
                  Y (IY) := Y (IY) + TEMP1 * A (I, J);
                  TEMP2  := TEMP2 + dconjg (A (I, J)) * X (IX);
                  IX     := IX + INCX;
                  IY     := IY + INCY;
               end loop;
               Y (JY) := Y (JY) + TEMP1 * dble (A (J, J)) + ALPHA * TEMP2;
               JX     := JX + INCX;
               JY     := JY + INCY;
            end loop;
         end if;
      else
         --
         --        Form  y  when A is stored in lower triangle.
         --
         if (INCX = 1) and (INCY = 1) then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP1 := ALPHA * X (J);
               TEMP2 := ZERO;
               Y (J) := Y (J) + TEMP1 * dble (A (J, J));
               I     := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Y (I) := Y (I) + TEMP1 * A (I, J);
                  TEMP2 := TEMP2 + dconjg (A (I, J)) * X (I);
               end loop;
               Y (J) := Y (J) + ALPHA * TEMP2;
            end loop;
         else
            JX := KX;
            JY := KY;
            J  := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               TEMP1  := ALPHA * X (JX);
               TEMP2  := ZERO;
               Y (JY) := Y (JY) + TEMP1 * dble (A (J, J));
               IX     := JX;
               IY     := JY;
               I      := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  IX     := IX + INCX;
                  IY     := IY + INCY;
                  Y (IY) := Y (IY) + TEMP1 * A (I, J);
                  TEMP2  := TEMP2 + dconjg (A (I, J)) * X (IX);
               end loop;
               Y (JY) := Y (JY) + ALPHA * TEMP2;
               JX     := JX + INCX;
               JY     := JY + INCY;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZHEMV .
      --
   end ZHEMV;

   procedure ZHER2
     (UPLO  : Character;
      N     : Integer;
      ALPHA : Complex;
      X_adr : Address;
      INCX  : Integer;
      Y_adr : Address;
      INCY  : Integer;
      A_adr : Address;
      LDA   : Integer)
   is

      X : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCX));
      Y : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCY));
      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);

      for X'Address use X_adr;
      for Y'Address use Y_adr;
      for A'Address use A_adr;

      pragma Import (Ada, X);
      pragma Import (Ada, Y);
      pragma Import (Ada, A);

      ZERO  : constant Complex := (0.0, 0.0);
      TEMP1 : Complex;
      TEMP2 : Complex;
      I     : Integer;
      INFO  : Integer;
      IX    : Integer;
      IY    : Integer;
      J     : Integer;
      JX    : Integer;
      JY    : Integer;
      KX    : Integer;
      KY    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZHER2(UPLO,N,ALPHA,X,INCX,Y,INCY,A,LDA)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA
   --       INTEGER INCX,INCY,LDA,N
   --       CHARACTER UPLO
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),X(*),Y(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZHER2  performs the hermitian rank 2 operation
   --
   --     A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
   --
   --  where alpha is a scalar, x and y are n element vectors and A is an n
   --  by n hermitian matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the upper or lower
   --            triangular part of the array A is to be referenced as
   --            follows:
   --
   --               UPLO = 'U' or 'u'   Only the upper triangular part of A
   --                                   is to be referenced.
   --
   --               UPLO = 'L' or 'l'   Only the lower triangular part of A
   --                                   is to be referenced.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] X
   --           X is COMPLEX*16 array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the n
   --            element vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  [in] Y
   --           Y is COMPLEX*16 array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCY ) ).
   --            Before entry, the incremented array Y must contain the n
   --            element vector y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --            On entry, INCY specifies the increment for the elements of
   --            Y. INCY must not be zero.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, n ).
   --            Before entry with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular part of the hermitian matrix and the strictly
   --            lower triangular part of A is not referenced. On exit, the
   --            upper triangular part of the array A is overwritten by the
   --            upper triangular part of the updated matrix.
   --            Before entry with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular part of the hermitian matrix and the strictly
   --            upper triangular part of A is not referenced. On exit, the
   --            lower triangular part of the array A is overwritten by the
   --            lower triangular part of the updated matrix.
   --            Note that the imaginary parts of the diagonal elements need
   --            not be set, they are assumed to be zero, and on exit they
   --            are set to zero.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, n ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DBLE,DCONJG,MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif INCX = 0 then
         INFO := 5;
      elsif INCY = 0 then
         INFO := 7;
      elsif LDA < max (1, N) then
         INFO := 9;
      end if;
      if INFO /= 0 then
         XERBLA ("ZHER2 ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (N = 0) or (ALPHA = ZERO) then
         return;
      end if;
      --
      --     Set up the start points in X and Y if the increments are not both
      --     unity.
      --
      if (INCX /= 1) or (INCY /= 1) then
         if INCX > 0 
            then KX := 1;
            else KX := 1 - (N - 1) * INCX;
         end if;
         if INCY > 0 
            then KY := 1;
            else KY := 1 - (N - 1) * INCY;
         end if;
         JX := KX;
         JY := KY;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through the triangular part
      --     of A.
      --
      if LSAME (UPLO, 'U') then
         --
         --        Form  A  when A is stored in the upper triangle.
         --
         if (INCX = 1) and (INCY = 1) then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if (X (J) /= ZERO) or (Y (J) /= ZERO) then
                  TEMP1 := ALPHA * dconjg (Y (J));
                  TEMP2 := dconjg (ALPHA * X (J));
                  I     := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J - 1;
                     A (I, J) := A (I, J) + X (I) * TEMP1 + Y (I) * TEMP2;
                  end loop;
                  A (J, J) := Pure_Real (A (J, J)) + Pure_Real (X (J) * TEMP1 + Y (J) * TEMP2);
               else
                  A (J, J) := Pure_Real (A (J, J));
               end if;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if (X (JX) /= ZERO) or (Y (JY) /= ZERO) then
                  TEMP1 := ALPHA * dconjg (Y (JY));
                  TEMP2 := dconjg (ALPHA * X (JX));
                  IX    := KX;
                  IY    := KY;
                  I     := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J - 1;
                     A (I, J) := A (I, J) + X (IX) * TEMP1 + Y (IY) * TEMP2;
                     IX       := IX + INCX;
                     IY       := IY + INCY;
                  end loop;
                  A (J, J) := Pure_Real (A (J, J)) + Pure_Real (X (JX) * TEMP1 + Y (JY) * TEMP2);
               else
                  A (J, J) := Pure_Real (A (J, J));
               end if;
               JX := JX + INCX;
               JY := JY + INCY;
            end loop;
         end if;
      else
         --
         --        Form  A  when A is stored in the lower triangle.
         --
         if (INCX = 1) and (INCY = 1) then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if (X (J) /= ZERO) or (Y (J) /= ZERO) then
                  TEMP1    := ALPHA * dconjg (Y (J));
                  TEMP2    := dconjg (ALPHA * X (J));
                  A (J, J) := Pure_Real (A (J, J)) + Pure_Real (X (J) * TEMP1 + Y (J) * TEMP2);
                  I        := J + 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     A (I, J) := A (I, J) + X (I) * TEMP1 + Y (I) * TEMP2;
                  end loop;
               else
                  A (J, J) := Pure_Real (A (J, J));
               end if;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if (X (JX) /= ZERO) or (Y (JY) /= ZERO) then
                  TEMP1    := ALPHA * dconjg (Y (JY));
                  TEMP2    := dconjg (ALPHA * X (JX));
                  A (J, J) := Pure_Real (A (J, J)) + Pure_Real (X (JX) * TEMP1 + Y (JY) * TEMP2);
                  IX       := JX;
                  IY       := JY;
                  I        := J + 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     IX       := IX + INCX;
                     IY       := IY + INCY;
                     A (I, J) := A (I, J) + X (IX) * TEMP1 + Y (IY) * TEMP2;
                  end loop;
               else
                  A (J, J) := Pure_Real (A (J, J));
               end if;
               JX := JX + INCX;
               JY := JY + INCY;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZHER2 .
      --
   end ZHER2;

   procedure ZHER2K
     (UPLO  : Character;
      TRANS : Character;
      N     : Integer;
      K     : Integer;
      ALPHA : Complex;
      A_adr : Address;
      LDA   : Integer;
      B_adr : Address;
      LDB   : Integer;
      BETA  : Real;
      C_adr : Address;
      LDC   : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      B : Ftn_Complex_Matrix (1 .. LDB, 1 .. N);
      C : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;
      for C'Address use C_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);
      pragma Import (Ada, C);

      TEMP1 : Complex;
      TEMP2 : Complex;
      I     : Integer;
      INFO  : Integer;
      J     : Integer;
      L     : Integer;
      NROWA : Integer;
      UPPER : Boolean;
      ONE   : constant Real    := 1.0e0;
      ZERO  : constant Complex := (0.0, 0.0);
      RZERO : constant Real    := 0.0e0;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZHER2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA
   --       DOUBLE PRECISION BETA
   --       INTEGER K,LDA,LDB,LDC,N
   --       CHARACTER TRANS,UPLO
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZHER2K  performs one of the hermitian rank 2k operations
   --
   --     C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C,
   --
   --  or
   --
   --     C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C,
   --
   --  where  alpha and beta  are scalars with  beta  real,  C is an  n by n
   --  hermitian matrix and  A and B  are  n by k matrices in the first case
   --  and  k by n  matrices in the second case.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On  entry,   UPLO  specifies  whether  the  upper  or  lower
   --            triangular  part  of the  array  C  is to be  referenced  as
   --            follows:
   --
   --               UPLO = 'U' or 'u'   Only the  upper triangular part of  C
   --                                   is to be referenced.
   --
   --               UPLO = 'L' or 'l'   Only the  lower triangular part of  C
   --                                   is to be referenced.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --            On entry,  TRANS  specifies the operation to be performed as
   --            follows:
   --
   --               TRANS = 'N' or 'n'    C := alpha*A*B**H          +
   --                                          conjg( alpha )*B*A**H +
   --                                          beta*C.
   --
   --               TRANS = 'C' or 'c'    C := alpha*A**H*B          +
   --                                          conjg( alpha )*B**H*A +
   --                                          beta*C.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry,  N specifies the order of the matrix C.  N must be
   --            at least zero.
   --
   --  [in] K
   --           K is INTEGER
   --            On entry with  TRANS = 'N' or 'n',  K  specifies  the number
   --            of  columns  of the  matrices  A and B,  and on  entry  with
   --            TRANS = 'C' or 'c',  K  specifies  the number of rows of the
   --            matrices  A and B.  K must be at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16 .
   --            On entry, ALPHA specifies the scalar alpha.
   --
   --  [in] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
   --            k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
   --            Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
   --            part of the array  A  must contain the matrix  A,  otherwise
   --            the leading  k by n  part of the array  A  must contain  the
   --            matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
   --            then  LDA must be at least  max( 1, n ), otherwise  LDA must
   --            be at least  max( 1, k ).
   --
   --  [in] B
   --           B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
   --            k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
   --            Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
   --            part of the array  B  must contain the matrix  B,  otherwise
   --            the leading  k by n  part of the array  B  must contain  the
   --            matrix B.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --            On entry, LDB specifies the first dimension of B as declared
   --            in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
   --            then  LDB must be at least  max( 1, n ), otherwise  LDB must
   --            be at least  max( 1, k ).
   --            Unchanged on exit.
   --
   --  [in] BETA
   --           BETA is DOUBLE PRECISION .
   --            On entry, BETA specifies the scalar beta.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array of DIMENSION ( LDC, n ).
   --            Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
   --            upper triangular part of the array C must contain the upper
   --            triangular part  of the  hermitian matrix  and the strictly
   --            lower triangular part of C is not referenced.  On exit, the
   --            upper triangular part of the array  C is overwritten by the
   --            upper triangular part of the updated matrix.
   --            Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
   --            lower triangular part of the array C must contain the lower
   --            triangular part  of the  hermitian matrix  and the strictly
   --            upper triangular part of C is not referenced.  On exit, the
   --            lower triangular part of the array  C is overwritten by the
   --            lower triangular part of the updated matrix.
   --            Note that the imaginary parts of the diagonal elements need
   --            not be set,  they are assumed to be zero,  and on exit they
   --            are set to zero.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --            On entry, LDC specifies the first dimension of C as declared
   --            in  the  calling  (sub)  program.   LDC  must  be  at  least
   --            max( 1, n ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 3 Blas routine.
   --
   --   -- Written on 8-February-1989.
   --      Jack Dongarra, Argonne National Laboratory.
   --      Iain Duff, AERE Harwell.
   --      Jeremy Du Croz, Numerical Algorithms Group Ltd.
   --      Sven Hammarling, Numerical Algorithms Group Ltd.
   --
   --   -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
   --      Ed Anderson, Cray Research Inc.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level3 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Functions ..
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DBLE,DCONJG,MAX
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Parameters ..
   --      PARAMETER (ONE=1.0D+0)
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      if LSAME (TRANS, 'N') 
         then NROWA := N;
         else NROWA := K;
      end if;
      UPPER := LSAME (UPLO, 'U');
      --
      INFO := 0;
      if (not UPPER) and (not LSAME (UPLO, 'L')) then
         INFO := 1;
      elsif (not LSAME (TRANS, 'N')) and (not LSAME (TRANS, 'C')) then
         INFO := 2;
      elsif N < 0 then
         INFO := 3;
      elsif K < 0 then
         INFO := 4;
      elsif LDA < max (1, NROWA) then
         INFO := 7;
      elsif LDB < max (1, NROWA) then
         INFO := 9;
      elsif LDC < max (1, N) then
         INFO := 12;
      end if;
      if INFO /= 0 then
         XERBLA ("ZHER2K", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (N = 0) or (((ALPHA = ZERO) or (K = 0)) and (BETA = ONE)) then
         return;
      end if;
      --
      --     And when  alpha.eq.zero.
      --
      if ALPHA = ZERO then
         if UPPER then
            if BETA = RZERO then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     C (I, J) := ZERO;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J - 1;
                     C (I, J) := BETA * C (I, J);
                  end loop;
                  C (J, J) := BETA * Pure_Real (C (J, J));
               end loop;
            end if;
         else
            if BETA = RZERO then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     C (I, J) := ZERO;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  C (J, J) := BETA * Pure_Real (C (J, J));
                  I        := J + 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     C (I, J) := BETA * C (I, J);
                  end loop;
               end loop;
            end if;
         end if;
         return;
      end if;
      --
      --     Start the operations.
      --
      if LSAME (TRANS, 'N') then
         --
         --        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H +
         --                   C.
         --
         if UPPER then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = RZERO then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J - 1;
                     C (I, J) := BETA * C (I, J);
                  end loop;
                  C (J, J) := BETA * Pure_Real (C (J, J));
               else
                  C (J, J) := Pure_Real (C (J, J));
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if (A (J, L) /= ZERO) or (B (J, L) /= ZERO) then
                     TEMP1 := ALPHA * dconjg (B (J, L));
                     TEMP2 := dconjg (ALPHA * A (J, L));
                     I     := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        C (I, J) := C (I, J) + A (I, L) * TEMP1 + B (I, L) * TEMP2;
                     end loop;
                     C (J, J) := Pure_Real (C (J, J)) + Pure_Real (A (J, L) * TEMP1 + B (J, L) * TEMP2);
                  end if;
               end loop;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if BETA = RZERO then
                  I := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     C (I, J) := ZERO;
                  end loop;
               elsif BETA /= ONE then
                  I := J + 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     C (I, J) := BETA * C (I, J);
                  end loop;
                  C (J, J) := BETA * Pure_Real (C (J, J));
               else
                  C (J, J) := Pure_Real (C (J, J));
               end if;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > K;
                  if (A (J, L) /= ZERO) or (B (J, L) /= ZERO) then
                     TEMP1 := ALPHA * dconjg (B (J, L));
                     TEMP2 := dconjg (ALPHA * A (J, L));
                     I     := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        C (I, J) := C (I, J) + A (I, L) * TEMP1 + B (I, L) * TEMP2;
                     end loop;
                     C (J, J) := Pure_Real (C (J, J)) + Pure_Real (A (J, L) * TEMP1 + B (J, L) * TEMP2);
                  end if;
               end loop;
            end loop;
         end if;
      else
         --
         --        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A +
         --                   C.
         --
         if UPPER then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J;
                  TEMP1 := ZERO;
                  TEMP2 := ZERO;
                  L     := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP1 := TEMP1 + dconjg (A (L, I)) * B (L, J);
                     TEMP2 := TEMP2 + dconjg (B (L, I)) * A (L, J);
                  end loop;
                  if I = J then
                     if BETA = RZERO 
                        then C (J, J) := Pure_Real (ALPHA * TEMP1 + dconjg (ALPHA) * TEMP2);
                        else C (J, J) := BETA * Pure_Real (C (J, J)) + Pure_Real (ALPHA * TEMP1 + dconjg (ALPHA) * TEMP2);
                     end if;
                  else
                     if BETA = RZERO 
                        then C (I, J) := ALPHA * TEMP1 + dconjg (ALPHA) * TEMP2;
                        else C (I, J) := BETA * C (I, J) + ALPHA * TEMP1 + dconjg (ALPHA) * TEMP2;
                     end if;
                  end if;
               end loop;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := J - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  TEMP1 := ZERO;
                  TEMP2 := ZERO;
                  L     := 1 - 1;
                  loop
                     L := L + 1;
                     exit when L > K;
                     TEMP1 := TEMP1 + dconjg (A (L, I)) * B (L, J);
                     TEMP2 := TEMP2 + dconjg (B (L, I)) * A (L, J);
                  end loop;
                  if I = J then
                     if BETA = RZERO 
                        then C (J, J) := Pure_Real (ALPHA * TEMP1 + dconjg (ALPHA) * TEMP2);
                        else C (J, J) := BETA * Pure_Real (C (J, J)) + Pure_Real (ALPHA * TEMP1 + dconjg (ALPHA) * TEMP2);
                     end if;
                  else
                     if BETA = RZERO 
                        then C (I, J) := ALPHA * TEMP1 + dconjg (ALPHA) * TEMP2;
                        else C (I, J) := BETA * C (I, J) + ALPHA * TEMP1 + dconjg (ALPHA) * TEMP2;
                     end if;
                  end if;
               end loop;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZHER2K.
      --
   end ZHER2K;

   procedure ZSCAL
     (N      : Integer;
      ZA     : Complex;
      ZX_adr : Address;
      INCX   : Integer)
   is

      ZX : Ftn_Complex_Vector (1 .. N * INCX);

      for ZX'Address use ZX_adr;

      pragma Import (Ada, ZX);

      I     : Integer;
      M     : Integer;
      MP1   : Integer;
      NINCX : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSCAL(N,ZA,ZX,INCX)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ZA
   --       INTEGER INCX,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZSCAL scales a vector by a constant.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, 3/11/78.
   --      modified 3/93 to return if incx .le. 0.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   begin
      if N <= 0 or INCX <= 0 then
         return;
      end if;
      if INCX = 1 then
         --
         --        code for increment equal to 1
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZX (I) := ZA * ZX (I);
         end loop;
      else
         --
         --        code for increment not equal to 1
         --
         NINCX := N * INCX;
         I     := 1 - INCX;
         loop
            I := I + INCX;
            exit when I > NINCX;
            ZX (I) := ZA * ZX (I);
         end loop;
      end if;
   end ZSCAL;

   procedure ZSWAP
     (N      : Integer;
      ZX_adr : Address;
      INCX   : Integer;
      ZY_adr : Address;
      INCY   : Integer)
   is

      ZX : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCX));
      ZY : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCY));

      for ZX'Address use ZX_adr;
      for ZY'Address use ZY_adr;

      pragma Import (Ada, ZX);
      pragma Import (Ada, ZY);

      ZTEMP : Complex;
      I     : Integer;
      IX    : Integer;
      IY    : Integer;
      M     : Integer;
      MP1   : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSWAP(N,ZX,INCX,ZY,INCY)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,INCY,N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 ZX(*),ZY(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZSWAP interchanges two vectors.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      jack dongarra, 3/11/78.
   --      modified 12/3/93, array(1) declarations changed to array(*)
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level1 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   begin
      if N <= 0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         --
         --       code for both increments equal to 1
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZTEMP  := ZX (I);
            ZX (I) := ZY (I);
            ZY (I) := ZTEMP;
         end loop;
      else
         --
         --       code for unequal increments or equal increments not equal
         --         to 1
         --
         IX := 1;
         IY := 1;
         if INCX < 0 then
            IX := (-N + 1) * INCX + 1;
         end if;
         if INCY < 0 then
            IY := (-N + 1) * INCY + 1;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            ZTEMP   := ZX (IX);
            ZX (IX) := ZY (IY);
            ZY (IY) := ZTEMP;
            IX      := IX + INCX;
            IY      := IY + INCY;
         end loop;
      end if;
   end ZSWAP;

   procedure ZTRMM
     (SIDE   : Character;
      UPLO   : Character;
      TRANSA : Character;
      DIAG   : Character;
      M      : Integer;
      N      : Integer;
      ALPHA  : Complex;
      A_adr  : Address;
      LDA    : Integer;
      B_adr  : Address;
      LDB    : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. max (M, N));
      B : Ftn_Complex_Matrix (1 .. LDB, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);

      TEMP   : Complex;
      I      : Integer;
      INFO   : Integer;
      J      : Integer;
      K      : Integer;
      NROWA  : Integer;
      LSIDE  : Boolean;
      NOUNIT : Boolean;
      UPPER  : Boolean;
      NOCONJ : Boolean;
      ONE    : constant Complex := (1.0e0, 0.0e0);
      ZERO   : constant Complex := (0.0e0, 0.0e0);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA
   --       INTEGER LDA,LDB,M,N
   --       CHARACTER DIAG,SIDE,TRANSA,UPLO
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),B(LDB,*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZTRMM  performs one of the matrix-matrix operations
   --
   --     B := alpha*op( A )*B,   or   B := alpha*B*op( A )
   --
   --  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
   --  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
   --
   --     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --            On entry,  SIDE specifies whether  op( A ) multiplies B from
   --            the left or right as follows:
   --
   --               SIDE = 'L' or 'l'   B := alpha*op( A )*B.
   --
   --               SIDE = 'R' or 'r'   B := alpha*B*op( A ).
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the matrix A is an upper or
   --            lower triangular matrix as follows:
   --
   --               UPLO = 'U' or 'u'   A is an upper triangular matrix.
   --
   --               UPLO = 'L' or 'l'   A is a lower triangular matrix.
   --
   --  [in] TRANSA
   --           TRANSA is CHARACTER*1
   --            On entry, TRANSA specifies the form of op( A ) to be used in
   --            the matrix multiplication as follows:
   --
   --               TRANSA = 'N' or 'n'   op( A ) = A.
   --
   --               TRANSA = 'T' or 't'   op( A ) = A**T.
   --
   --               TRANSA = 'C' or 'c'   op( A ) = A**H.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --            On entry, DIAG specifies whether or not A is unit triangular
   --            as follows:
   --
   --               DIAG = 'U' or 'u'   A is assumed to be unit triangular.
   --
   --               DIAG = 'N' or 'n'   A is not assumed to be unit
   --                                   triangular.
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of B. M must be at
   --            least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of B.  N must be
   --            at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry,  ALPHA specifies the scalar  alpha. When  alpha is
   --            zero then  A is not referenced and  B need not be set before
   --            entry.
   --
   --  [in] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, k ), where k is m
   --            when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
   --            Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
   --            upper triangular part of the array  A must contain the upper
   --            triangular matrix  and the strictly lower triangular part of
   --            A is not referenced.
   --            Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
   --            lower triangular part of the array  A must contain the lower
   --            triangular matrix  and the strictly upper triangular part of
   --            A is not referenced.
   --            Note that when  DIAG = 'U' or 'u',  the diagonal elements of
   --            A  are not referenced either,  but are assumed to be  unity.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
   --            LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
   --            then LDA must be at least max( 1, n ).
   --
   --  [in] B
   --           B is (input/output) COMPLEX*16 array of DIMENSION ( LDB, n ).
   --            Before entry,  the leading  m by n part of the array  B must
   --            contain the matrix  B,  and  on exit  is overwritten  by the
   --            transformed matrix.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --            On entry, LDB specifies the first dimension of B as declared
   --            in  the  calling  (sub)  program.   LDB  must  be  at  least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 3 Blas routine.
   --
   --   -- Written on 8-February-1989.
   --      Jack Dongarra, Argonne National Laboratory.
   --      Iain Duff, AERE Harwell.
   --      Jeremy Du Croz, Numerical Algorithms Group Ltd.
   --      Sven Hammarling, Numerical Algorithms Group Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level3 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCONJG,MAX
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Parameters ..
   --      PARAMETER (ONE= (1.0D+0,0.0D+0))
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      LSIDE := LSAME (SIDE, 'L');
      if LSIDE 
         then NROWA := M;
         else NROWA := N;
      end if;
      NOCONJ := LSAME (TRANSA, 'T');
      NOUNIT := LSAME (DIAG, 'N');
      UPPER  := LSAME (UPLO, 'U');
      --
      INFO := 0;
      if (not LSIDE) and (not LSAME (SIDE, 'R')) then
         INFO := 1;
      elsif (not UPPER) and (not LSAME (UPLO, 'L')) then
         INFO := 2;
      elsif (not LSAME (TRANSA, 'N')) and (not LSAME (TRANSA, 'T')) and (not LSAME (TRANSA, 'C')) then
         INFO := 3;
      elsif (not LSAME (DIAG, 'U')) and (not LSAME (DIAG, 'N')) then
         INFO := 4;
      elsif M < 0 then
         INFO := 5;
      elsif N < 0 then
         INFO := 6;
      elsif LDA < max (1, NROWA) then
         INFO := 9;
      elsif LDB < max (1, M) then
         INFO := 11;
      end if;
      if INFO /= 0 then
         XERBLA ("ZTRMM ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     And when  alpha.eq.zero.
      --
      if ALPHA = ZERO then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := ZERO;
            end loop;
         end loop;
         return;
      end if;
      --
      --     Start the operations.
      --
      if LSIDE then
         if LSAME (TRANSA, 'N') then
            --
            --           Form  B := alpha*A*B.
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > M;
                     if B (K, J) /= ZERO then
                        TEMP := ALPHA * B (K, J);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > K - 1;
                           B (I, J) := B (I, J) + TEMP * A (I, K);
                        end loop;
                        if NOUNIT then
                           TEMP := TEMP * A (K, K);
                        end if;
                        B (K, J) := TEMP;
                     end if;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  K := M + 1;
                  loop
                     K := K - 1;
                     exit when K < 1;
                     if B (K, J) /= ZERO then
                        TEMP     := ALPHA * B (K, J);
                        B (K, J) := TEMP;
                        if NOUNIT then
                           B (K, J) := B (K, J) * A (K, K);
                        end if;
                        I := K + 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * A (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            end if;
         else
            --
            --           Form  B := alpha*A**T*B   or   B := alpha*A**H*B.
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := M + 1;
                  loop
                     I := I - 1;
                     exit when I < 1;
                     TEMP := B (I, J);
                     if NOCONJ then
                        if NOUNIT then
                           TEMP := TEMP * A (I, I);
                        end if;
                        K := 1 - 1;
                        loop
                           K := K + 1;
                           exit when K > I - 1;
                           TEMP := TEMP + A (K, I) * B (K, J);
                        end loop;
                     else
                        if NOUNIT then
                           TEMP := TEMP * dconjg (A (I, I));
                        end if;
                        K := 1 - 1;
                        loop
                           K := K + 1;
                           exit when K > I - 1;
                           TEMP := TEMP + dconjg (A (K, I)) * B (K, J);
                        end loop;
                     end if;
                     B (I, J) := ALPHA * TEMP;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     TEMP := B (I, J);
                     if NOCONJ then
                        if NOUNIT then
                           TEMP := TEMP * A (I, I);
                        end if;
                        K := I + 1 - 1;
                        loop
                           K := K + 1;
                           exit when K > M;
                           TEMP := TEMP + A (K, I) * B (K, J);
                        end loop;
                     else
                        if NOUNIT then
                           TEMP := TEMP * dconjg (A (I, I));
                        end if;
                        K := I + 1 - 1;
                        loop
                           K := K + 1;
                           exit when K > M;
                           TEMP := TEMP + dconjg (A (K, I)) * B (K, J);
                        end loop;
                     end if;
                     B (I, J) := ALPHA * TEMP;
                  end loop;
               end loop;
            end if;
         end if;
      else
         if LSAME (TRANSA, 'N') then
            --
            --           Form  B := alpha*B*A.
            --
            if UPPER then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  TEMP := ALPHA;
                  if NOUNIT then
                     TEMP := TEMP * A (J, J);
                  end if;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     B (I, J) := TEMP * B (I, J);
                  end loop;
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > J - 1;
                     if A (K, J) /= ZERO then
                        TEMP := ALPHA * A (K, J);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  TEMP := ALPHA;
                  if NOUNIT then
                     TEMP := TEMP * A (J, J);
                  end if;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     B (I, J) := TEMP * B (I, J);
                  end loop;
                  K := J + 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     if A (K, J) /= ZERO then
                        TEMP := ALPHA * A (K, J);
                        I    := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            end if;
         else
            --
            --           Form  B := alpha*B*A**T   or   B := alpha*B*A**H.
            --
            if UPPER then
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  J := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > K - 1;
                     if A (J, K) /= ZERO then
                        if NOCONJ 
                           then TEMP := ALPHA * A (J, K);
                           else TEMP := ALPHA * dconjg (A (J, K));
                        end if;
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  TEMP := ALPHA;
                  if NOUNIT then
                     if NOCONJ 
                        then TEMP := TEMP * A (K, K);
                        else TEMP := TEMP * dconjg (A (K, K));
                     end if;
                  end if;
                  if TEMP /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := TEMP * B (I, K);
                     end loop;
                  end if;
               end loop;
            else
               K := N + 1;
               loop
                  K := K - 1;
                  exit when K < 1;
                  J := K + 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     if A (J, K) /= ZERO then
                        if NOCONJ 
                           then TEMP := ALPHA * A (J, K);
                           else TEMP := ALPHA * dconjg (A (J, K));
                        end if;
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) + TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  TEMP := ALPHA;
                  if NOUNIT then
                     if NOCONJ 
                        then TEMP := TEMP * A (K, K);
                        else TEMP := TEMP * dconjg (A (K, K));
                     end if;
                  end if;
                  if TEMP /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := TEMP * B (I, K);
                     end loop;
                  end if;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of ZTRMM .
      --
   end ZTRMM;

   procedure ZTRMV
     (UPLO  : Character;
      TRANS : Character;
      DIAG  : Character;
      N     : Integer;
      A_adr : Address;
      LDA   : Integer;
      X_adr : Address;
      INCX  : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      X : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCX));

      for A'Address use A_adr;
      for X'Address use X_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, X);

      ZERO   : constant Complex := (0.0e0, 0.0e0);
      TEMP   : Complex;
      I      : Integer;
      INFO   : Integer;
      IX     : Integer;
      J      : Integer;
      JX     : Integer;
      KX     : Integer;
      NOUNIT : Boolean;
      NOCONJ : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,LDA,N
   --       CHARACTER DIAG,TRANS,UPLO
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),X(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZTRMV  performs one of the matrix-vector operations
   --
   --     x := A*x,   or   x := A**T*x,   or   x := A**H*x,
   --
   --  where x is an n element vector and  A is an n by n unit, or non-unit,
   --  upper or lower triangular matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the matrix is an upper or
   --            lower triangular matrix as follows:
   --
   --               UPLO = 'U' or 'u'   A is an upper triangular matrix.
   --
   --               UPLO = 'L' or 'l'   A is a lower triangular matrix.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --            On entry, TRANS specifies the operation to be performed as
   --            follows:
   --
   --               TRANS = 'N' or 'n'   x := A*x.
   --
   --               TRANS = 'T' or 't'   x := A**T*x.
   --
   --               TRANS = 'C' or 'c'   x := A**H*x.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --            On entry, DIAG specifies whether or not A is unit
   --            triangular as follows:
   --
   --               DIAG = 'U' or 'u'   A is assumed to be unit triangular.
   --
   --               DIAG = 'N' or 'n'   A is not assumed to be unit
   --                                   triangular.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --
   --  [in] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, n ).
   --            Before entry with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular matrix and the strictly lower triangular part of
   --            A is not referenced.
   --            Before entry with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular matrix and the strictly upper triangular part of
   --            A is not referenced.
   --            Note that when  DIAG = 'U' or 'u', the diagonal elements of
   --            A are not referenced either, but are assumed to be unity.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, n ).
   --
   --  [in] X
   --           X is (input/output) COMPLEX*16 array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the n
   --            element vector x. On exit, X is overwritten with the
   --            tranformed vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --   The vector and matrix arguments are not referenced when N = 0, or M = 0
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCONJG,MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif not LSAME (TRANS, 'N') and not LSAME (TRANS, 'T') and not LSAME (TRANS, 'C') then
         INFO := 2;
      elsif not LSAME (DIAG, 'U') and not LSAME (DIAG, 'N') then
         INFO := 3;
      elsif N < 0 then
         INFO := 4;
      elsif LDA < max (1, N) then
         INFO := 6;
      elsif INCX = 0 then
         INFO := 8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZTRMV ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if N = 0 then
         return;
      end if;
      --
      NOCONJ := LSAME (TRANS, 'T');
      NOUNIT := LSAME (DIAG, 'N');
      --
      --     Set up the start point in X if the increment is not unity. This
      --     will be  ( N - 1 )*INCX  too small for descending loops.
      --
      if INCX <= 0 then
         KX := 1 - (N - 1) * INCX;
      elsif INCX /= 1 then
         KX := 1;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through A.
      --
      if LSAME (TRANS, 'N') then
         --
         --        Form  x := A*x.
         --
         if LSAME (UPLO, 'U') then
            if INCX = 1 then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if X (J) /= ZERO then
                     TEMP := X (J);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        X (I) := X (I) + TEMP * A (I, J);
                     end loop;
                     if NOUNIT then
                        X (J) := X (J) * A (J, J);
                     end if;
                  end if;
               end loop;
            else
               JX := KX;
               J  := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if X (JX) /= ZERO then
                     TEMP := X (JX);
                     IX   := KX;
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        X (IX) := X (IX) + TEMP * A (I, J);
                        IX     := IX + INCX;
                     end loop;
                     if NOUNIT then
                        X (JX) := X (JX) * A (J, J);
                     end if;
                  end if;
                  JX := JX + INCX;
               end loop;
            end if;
         else
            if INCX = 1 then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if X (J) /= ZERO then
                     TEMP := X (J);
                     I    := N + 1;
                     loop
                        I := I - 1;
                        exit when I < J + 1;
                        X (I) := X (I) + TEMP * A (I, J);
                     end loop;
                     if NOUNIT then
                        X (J) := X (J) * A (J, J);
                     end if;
                  end if;
               end loop;
            else
               KX := KX + (N - 1) * INCX;
               JX := KX;
               J  := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if X (JX) /= ZERO then
                     TEMP := X (JX);
                     IX   := KX;
                     I    := N + 1;
                     loop
                        I := I - 1;
                        exit when I < J + 1;
                        X (IX) := X (IX) + TEMP * A (I, J);
                        IX     := IX - INCX;
                     end loop;
                     if NOUNIT then
                        X (JX) := X (JX) * A (J, J);
                     end if;
                  end if;
                  JX := JX - INCX;
               end loop;
            end if;
         end if;
      else
         --
         --        Form  x := A**T*x  or  x := A**H*x.
         --
         if LSAME (UPLO, 'U') then
            if INCX = 1 then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  TEMP := X (J);
                  if NOCONJ then
                     if NOUNIT then
                        TEMP := TEMP * A (J, J);
                     end if;
                     I := J - 1 + 1;
                     loop
                        I := I - 1;
                        exit when I < 1;
                        TEMP := TEMP + A (I, J) * X (I);
                     end loop;
                  else
                     if NOUNIT then
                        TEMP := TEMP * dconjg (A (J, J));
                     end if;
                     I := J - 1 + 1;
                     loop
                        I := I - 1;
                        exit when I < 1;
                        TEMP := TEMP + dconjg (A (I, J)) * X (I);
                     end loop;
                  end if;
                  X (J) := TEMP;
               end loop;
            else
               JX := KX + (N - 1) * INCX;
               J  := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  TEMP := X (JX);
                  IX   := JX;
                  if NOCONJ then
                     if NOUNIT then
                        TEMP := TEMP * A (J, J);
                     end if;
                     I := J - 1 + 1;
                     loop
                        I := I - 1;
                        exit when I < 1;
                        IX   := IX - INCX;
                        TEMP := TEMP + A (I, J) * X (IX);
                     end loop;
                  else
                     if NOUNIT then
                        TEMP := TEMP * dconjg (A (J, J));
                     end if;
                     I := J - 1 + 1;
                     loop
                        I := I - 1;
                        exit when I < 1;
                        IX   := IX - INCX;
                        TEMP := TEMP + dconjg (A (I, J)) * X (IX);
                     end loop;
                  end if;
                  X (JX) := TEMP;
                  JX     := JX - INCX;
               end loop;
            end if;
         else
            if INCX = 1 then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  TEMP := X (J);
                  if NOCONJ then
                     if NOUNIT then
                        TEMP := TEMP * A (J, J);
                     end if;
                     I := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP := TEMP + A (I, J) * X (I);
                     end loop;
                  else
                     if NOUNIT then
                        TEMP := TEMP * dconjg (A (J, J));
                     end if;
                     I := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP := TEMP + dconjg (A (I, J)) * X (I);
                     end loop;
                  end if;
                  X (J) := TEMP;
               end loop;
            else
               JX := KX;
               J  := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  TEMP := X (JX);
                  IX   := JX;
                  if NOCONJ then
                     if NOUNIT then
                        TEMP := TEMP * A (J, J);
                     end if;
                     I := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        IX   := IX + INCX;
                        TEMP := TEMP + A (I, J) * X (IX);
                     end loop;
                  else
                     if NOUNIT then
                        TEMP := TEMP * dconjg (A (J, J));
                     end if;
                     I := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        IX   := IX + INCX;
                        TEMP := TEMP + dconjg (A (I, J)) * X (IX);
                     end loop;
                  end if;
                  X (JX) := TEMP;
                  JX     := JX + INCX;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of ZTRMV .
      --
   end ZTRMV;

   procedure ZTRSM
     (SIDE   : Character;
      UPLO   : Character;
      TRANSA : Character;
      DIAG   : Character;
      M      : Integer;
      N      : Integer;
      ALPHA  : Complex;
      A_adr  : Address;
      LDA    : Integer;
      B_adr  : Address;
      LDB    : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. max (M, N));
      B : Ftn_Complex_Matrix (1 .. LDB, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);

      TEMP   : Complex;
      I      : Integer;
      INFO   : Integer;
      J      : Integer;
      K      : Integer;
      NROWA  : Integer;
      LSIDE  : Boolean;
      NOUNIT : Boolean;
      NOCONJ : Boolean;
      UPPER  : Boolean;
      ONE    : constant Complex := (1.0e0, 0.0e0);
      ZERO   : constant Complex := (0.0e0, 0.0e0);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16 ALPHA
   --       INTEGER LDA,LDB,M,N
   --       CHARACTER DIAG,SIDE,TRANSA,UPLO
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),B(LDB,*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZTRSM  solves one of the matrix equations
   --
   --     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
   --
   --  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
   --  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
   --
   --     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H.
   --
   --  The matrix X is overwritten on B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --            On entry, SIDE specifies whether op( A ) appears on the left
   --            or right of X as follows:
   --
   --               SIDE = 'L' or 'l'   op( A )*X = alpha*B.
   --
   --               SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the matrix A is an upper or
   --            lower triangular matrix as follows:
   --
   --               UPLO = 'U' or 'u'   A is an upper triangular matrix.
   --
   --               UPLO = 'L' or 'l'   A is a lower triangular matrix.
   --
   --  [in] TRANSA
   --           TRANSA is CHARACTER*1
   --            On entry, TRANSA specifies the form of op( A ) to be used in
   --            the matrix multiplication as follows:
   --
   --               TRANSA = 'N' or 'n'   op( A ) = A.
   --
   --               TRANSA = 'T' or 't'   op( A ) = A**T.
   --
   --               TRANSA = 'C' or 'c'   op( A ) = A**H.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --            On entry, DIAG specifies whether or not A is unit triangular
   --            as follows:
   --
   --               DIAG = 'U' or 'u'   A is assumed to be unit triangular.
   --
   --               DIAG = 'N' or 'n'   A is not assumed to be unit
   --                                   triangular.
   --
   --  [in] M
   --           M is INTEGER
   --            On entry, M specifies the number of rows of B. M must be at
   --            least zero.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the number of columns of B.  N must be
   --            at least zero.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry,  ALPHA specifies the scalar  alpha. When  alpha is
   --            zero then  A is not referenced and  B need not be set before
   --            entry.
   --
   --  [in] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, k ),
   --            where k is m when SIDE = 'L' or 'l'
   --              and k is n when SIDE = 'R' or 'r'.
   --            Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
   --            upper triangular part of the array  A must contain the upper
   --            triangular matrix  and the strictly lower triangular part of
   --            A is not referenced.
   --            Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
   --            lower triangular part of the array  A must contain the lower
   --            triangular matrix  and the strictly upper triangular part of
   --            A is not referenced.
   --            Note that when  DIAG = 'U' or 'u',  the diagonal elements of
   --            A  are not referenced either,  but are assumed to be  unity.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
   --            LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
   --            then LDA must be at least max( 1, n ).
   --
   --  [in,out] B
   --           B is COMPLEX*16 array of DIMENSION ( LDB, n ).
   --            Before entry,  the leading  m by n part of the array  B must
   --            contain  the  right-hand  side  matrix  B,  and  on exit  is
   --            overwritten by the solution matrix  X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --            On entry, LDB specifies the first dimension of B as declared
   --            in  the  calling  (sub)  program.   LDB  must  be  at  least
   --            max( 1, m ).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 3 Blas routine.
   --
   --   -- Written on 8-February-1989.
   --      Jack Dongarra, Argonne National Laboratory.
   --      Iain Duff, AERE Harwell.
   --      Jeremy Du Croz, Numerical Algorithms Group Ltd.
   --      Sven Hammarling, Numerical Algorithms Group Ltd.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level3 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCONJG,MAX
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Parameters ..
   --      PARAMETER (ONE= (1.0D+0,0.0D+0))
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      LSIDE := LSAME (SIDE, 'L');
      if LSIDE 
         then NROWA := M;
         else NROWA := N;
      end if;
      NOCONJ := LSAME (TRANSA, 'T');
      NOUNIT := LSAME (DIAG, 'N');
      UPPER  := LSAME (UPLO, 'U');
      --
      INFO := 0;
      if (not LSIDE) and (not LSAME (SIDE, 'R')) then
         INFO := 1;
      elsif (not UPPER) and (not LSAME (UPLO, 'L')) then
         INFO := 2;
      elsif (not LSAME (TRANSA, 'N')) and (not LSAME (TRANSA, 'T')) and (not LSAME (TRANSA, 'C')) then
         INFO := 3;
      elsif (not LSAME (DIAG, 'U')) and (not LSAME (DIAG, 'N')) then
         INFO := 4;
      elsif M < 0 then
         INFO := 5;
      elsif N < 0 then
         INFO := 6;
      elsif LDA < max (1, NROWA) then
         INFO := 9;
      elsif LDB < max (1, M) then
         INFO := 11;
      end if;
      if INFO /= 0 then
         XERBLA ("ZTRSM ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     And when  alpha.eq.zero.
      --
      if ALPHA = ZERO then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := ZERO;
            end loop;
         end loop;
         return;
      end if;
      --
      --     Start the operations.
      --
      if LSIDE then
         if LSAME (TRANSA, 'N') then
            --
            --           Form  B := alpha*inv( A )*B.
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := ALPHA * B (I, J);
                     end loop;
                  end if;
                  K := M + 1;
                  loop
                     K := K - 1;
                     exit when K < 1;
                     if B (K, J) /= ZERO then
                        if NOUNIT then
                           B (K, J) := B (K, J) / A (K, K);
                        end if;
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > K - 1;
                           B (I, J) := B (I, J) - B (K, J) * A (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := ALPHA * B (I, J);
                     end loop;
                  end if;
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > M;
                     if B (K, J) /= ZERO then
                        if NOUNIT then
                           B (K, J) := B (K, J) / A (K, K);
                        end if;
                        I := K + 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - B (K, J) * A (I, K);
                        end loop;
                     end if;
                  end loop;
               end loop;
            end if;
         else
            --
            --           Form  B := alpha*inv( A**T )*B
            --           or    B := alpha*inv( A**H )*B.
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M;
                     TEMP := ALPHA * B (I, J);
                     if NOCONJ then
                        K := 1 - 1;
                        loop
                           K := K + 1;
                           exit when K > I - 1;
                           TEMP := TEMP - A (K, I) * B (K, J);
                        end loop;
                        if NOUNIT then
                           TEMP := TEMP / A (I, I);
                        end if;
                     else
                        K := 1 - 1;
                        loop
                           K := K + 1;
                           exit when K > I - 1;
                           TEMP := TEMP - dconjg (A (K, I)) * B (K, J);
                        end loop;
                        if NOUNIT then
                           TEMP := TEMP / dconjg (A (I, I));
                        end if;
                     end if;
                     B (I, J) := TEMP;
                  end loop;
               end loop;
            else
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  I := M + 1;
                  loop
                     I := I - 1;
                     exit when I < 1;
                     TEMP := ALPHA * B (I, J);
                     if NOCONJ then
                        K := I + 1 - 1;
                        loop
                           K := K + 1;
                           exit when K > M;
                           TEMP := TEMP - A (K, I) * B (K, J);
                        end loop;
                        if NOUNIT then
                           TEMP := TEMP / A (I, I);
                        end if;
                     else
                        K := I + 1 - 1;
                        loop
                           K := K + 1;
                           exit when K > M;
                           TEMP := TEMP - dconjg (A (K, I)) * B (K, J);
                        end loop;
                        if NOUNIT then
                           TEMP := TEMP / dconjg (A (I, I));
                        end if;
                     end if;
                     B (I, J) := TEMP;
                  end loop;
               end loop;
            end if;
         end if;
      else
         if LSAME (TRANSA, 'N') then
            --
            --           Form  B := alpha*B*inv( A ).
            --
            if UPPER then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := ALPHA * B (I, J);
                     end loop;
                  end if;
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > J - 1;
                     if A (K, J) /= ZERO then
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - A (K, J) * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  if NOUNIT then
                     TEMP := ONE / A (J, J);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := TEMP * B (I, J);
                     end loop;
                  end if;
               end loop;
            else
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := ALPHA * B (I, J);
                     end loop;
                  end if;
                  K := J + 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     if A (K, J) /= ZERO then
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - A (K, J) * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  if NOUNIT then
                     TEMP := ONE / A (J, J);
                     I    := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, J) := TEMP * B (I, J);
                     end loop;
                  end if;
               end loop;
            end if;
         else
            --
            --           Form  B := alpha*B*inv( A**T )
            --           or    B := alpha*B*inv( A**H ).
            --
            if UPPER then
               K := N + 1;
               loop
                  K := K - 1;
                  exit when K < 1;
                  if NOUNIT then
                     if NOCONJ 
                        then TEMP := ONE / A (K, K);
                        else TEMP := ONE / dconjg (A (K, K));
                     end if;
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := TEMP * B (I, K);
                     end loop;
                  end if;
                  J := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > K - 1;
                     if A (J, K) /= ZERO then
                        if NOCONJ 
                           then TEMP := A (J, K);
                           else TEMP := dconjg (A (J, K));
                        end if;
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := ALPHA * B (I, K);
                     end loop;
                  end if;
               end loop;
            else
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  if NOUNIT then
                     if NOCONJ 
                        then TEMP := ONE / A (K, K);
                        else TEMP := ONE / dconjg (A (K, K));
                     end if;
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := TEMP * B (I, K);
                     end loop;
                  end if;
                  J := K + 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     if A (J, K) /= ZERO then
                        if NOCONJ 
                           then TEMP := A (J, K);
                           else TEMP := dconjg (A (J, K));
                        end if;
                        I := 1 - 1;
                        loop
                           I := I + 1;
                           exit when I > M;
                           B (I, J) := B (I, J) - TEMP * B (I, K);
                        end loop;
                     end if;
                  end loop;
                  if ALPHA /= ONE then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        B (I, K) := ALPHA * B (I, K);
                     end loop;
                  end if;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of ZTRSM .
      --
   end ZTRSM;

   procedure ZTRSV
     (UPLO  : Character;
      TRANS : Character;
      DIAG  : Character;
      N     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      X     : in out Ftn_Complex_Vector;
      INCX  : Integer)
   is
      ZERO   : Complex := Complex'(0.0e0, 0.0e0);
      TEMP   : Complex;
      I      : Integer;
      INFO   : Integer;
      IX     : Integer;
      J      : Integer;
      JX     : Integer;
      KX     : Integer;
      NOCONJ : Boolean;
      NOUNIT : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER INCX,LDA,N
   --       CHARACTER DIAG,TRANS,UPLO
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16 A(LDA,*),X(*)
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZTRSV  solves one of the systems of equations
   --
   --     A*x = b,   or   A**T*x = b,   or   A**H*x = b,
   --
   --  where b and x are n element vectors and A is an n by n unit, or
   --  non-unit, upper or lower triangular matrix.
   --
   --  No test for singularity or near-singularity is included in this
   --  routine. Such tests must be performed before calling this routine.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the matrix is an upper or
   --            lower triangular matrix as follows:
   --
   --               UPLO = 'U' or 'u'   A is an upper triangular matrix.
   --
   --               UPLO = 'L' or 'l'   A is a lower triangular matrix.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --            On entry, TRANS specifies the equations to be solved as
   --            follows:
   --
   --               TRANS = 'N' or 'n'   A*x = b.
   --
   --               TRANS = 'T' or 't'   A**T*x = b.
   --
   --               TRANS = 'C' or 'c'   A**H*x = b.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --            On entry, DIAG specifies whether or not A is unit
   --            triangular as follows:
   --
   --               DIAG = 'U' or 'u'   A is assumed to be unit triangular.
   --
   --               DIAG = 'N' or 'n'   A is not assumed to be unit
   --                                   triangular.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --
   --  [in] A
   --           A is COMPLEX*16 array of DIMENSION ( LDA, n ).
   --            Before entry with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular matrix and the strictly lower triangular part of
   --            A is not referenced.
   --            Before entry with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular matrix and the strictly upper triangular part of
   --            A is not referenced.
   --            Note that when  DIAG = 'U' or 'u', the diagonal elements of
   --            A are not referenced either, but are assumed to be unity.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, n ).
   --
   --  [in,out] X
   --           X is COMPLEX*16 array of dimension at least
   --            ( 1 + ( n - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the n
   --            element right-hand side vector b. On exit, X is overwritten
   --            with the solution vector x.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Level 2 Blas routine.
   --
   --   -- Written on 22-October-1986.
   --      Jack Dongarra, Argonne National Lab.
   --      Jeremy Du Croz, Nag Central Office.
   --      Sven Hammarling, Nag Central Office.
   --      Richard Hanson, Sandia National Labs.
   --
   --  =====================================================================
   --
   --  -- Reference BLAS level2 routine (version 3.4.0) --
   --  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER (ZERO= (0.0D+0,0.0D+0))
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL LSAME
   --      EXTERNAL LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC DCONJG,MAX
   --     ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif not LSAME (TRANS, 'N') and not LSAME (TRANS, 'T') and not LSAME (TRANS, 'C') then
         INFO := 2;
      elsif not LSAME (DIAG, 'U') and not LSAME (DIAG, 'N') then
         INFO := 3;
      elsif N < 0 then
         INFO := 4;
      elsif LDA < max (1, N) then
         INFO := 6;
      elsif INCX = 0 then
         INFO := 8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZTRSV ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if N = 0 then
         return;
      end if;
      --
      NOCONJ := LSAME (TRANS, 'T');
      NOUNIT := LSAME (DIAG, 'N');
      --
      --     Set up the start point in X if the increment is not unity. This
      --     will be  ( N - 1 )*INCX  too small for descending loops.
      --
      if INCX <= 0 then
         KX := 1 - (N - 1) * INCX;
      elsif INCX /= 1 then
         KX := 1;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through A.
      --
      if LSAME (TRANS, 'N') then
         --
         --        Form  x := inv( A )*x.
         --
         if LSAME (UPLO, 'U') then
            if INCX = 1 then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if X (J) /= ZERO then
                     if NOUNIT then
                        X (J) := X (J) / A (J, J);
                     end if;
                     TEMP := X (J);
                     I    := J - 1 + 1;
                     loop
                        I := I - 1;
                        exit when I < 1;
                        X (I) := X (I) - TEMP * A (I, J);
                     end loop;
                  end if;
               end loop;
            else
               JX := KX + (N - 1) * INCX;
               J  := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if X (JX) /= ZERO then
                     if NOUNIT then
                        X (JX) := X (JX) / A (J, J);
                     end if;
                     TEMP := X (JX);
                     IX   := JX;
                     I    := J - 1 + 1;
                     loop
                        I := I - 1;
                        exit when I < 1;
                        IX     := IX - INCX;
                        X (IX) := X (IX) - TEMP * A (I, J);
                     end loop;
                  end if;
                  JX := JX - INCX;
               end loop;
            end if;
         else
            if INCX = 1 then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if X (J) /= ZERO then
                     if NOUNIT then
                        X (J) := X (J) / A (J, J);
                     end if;
                     TEMP := X (J);
                     I    := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        X (I) := X (I) - TEMP * A (I, J);
                     end loop;
                  end if;
               end loop;
            else
               JX := KX;
               J  := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if X (JX) /= ZERO then
                     if NOUNIT then
                        X (JX) := X (JX) / A (J, J);
                     end if;
                     TEMP := X (JX);
                     IX   := JX;
                     I    := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        IX     := IX + INCX;
                        X (IX) := X (IX) - TEMP * A (I, J);
                     end loop;
                  end if;
                  JX := JX + INCX;
               end loop;
            end if;
         end if;
      else
         --
         --        Form  x := inv( A**T )*x  or  x := inv( A**H )*x.
         --
         if LSAME (UPLO, 'U') then
            if INCX = 1 then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  TEMP := X (J);
                  if NOCONJ then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        TEMP := TEMP - A (I, J) * X (I);
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / A (J, J);
                     end if;
                  else
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        TEMP := TEMP - dconjg (A (I, J)) * X (I);
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / dconjg (A (J, J));
                     end if;
                  end if;
                  X (J) := TEMP;
               end loop;
            else
               JX := KX;
               J  := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  IX   := KX;
                  TEMP := X (JX);
                  if NOCONJ then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        TEMP := TEMP - A (I, J) * X (IX);
                        IX   := IX + INCX;
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / A (J, J);
                     end if;
                  else
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        TEMP := TEMP - dconjg (A (I, J)) * X (IX);
                        IX   := IX + INCX;
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / dconjg (A (J, J));
                     end if;
                  end if;
                  X (JX) := TEMP;
                  JX     := JX + INCX;
               end loop;
            end if;
         else
            if INCX = 1 then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  TEMP := X (J);
                  if NOCONJ then
                     I := N + 1;
                     loop
                        I := I - 1;
                        exit when I < J + 1;
                        TEMP := TEMP - A (I, J) * X (I);
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / A (J, J);
                     end if;
                  else
                     I := N + 1;
                     loop
                        I := I - 1;
                        exit when I < J + 1;
                        TEMP := TEMP - dconjg (A (I, J)) * X (I);
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / dconjg (A (J, J));
                     end if;
                  end if;
                  X (J) := TEMP;
               end loop;
            else
               KX := KX + (N - 1) * INCX;
               JX := KX;
               J  := N + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  IX   := KX;
                  TEMP := X (JX);
                  if NOCONJ then
                     I := N + 1;
                     loop
                        I := I - 1;
                        exit when I < J + 1;
                        TEMP := TEMP - A (I, J) * X (IX);
                        IX   := IX - INCX;
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / A (J, J);
                     end if;
                  else
                     I := N + 1;
                     loop
                        I := I - 1;
                        exit when I < J + 1;
                        TEMP := TEMP - dconjg (A (I, J)) * X (IX);
                        IX   := IX - INCX;
                     end loop;
                     if NOUNIT then
                        TEMP := TEMP / dconjg (A (J, J));
                     end if;
                  end if;
                  X (JX) := TEMP;
                  JX     := JX - INCX;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of ZTRSV .
      --
   end ZTRSV;

----------------------------------------------------------------------------
-- Lapack
----------------------------------------------------------------------------

   procedure DBDSDC
     (UPLO      : Character;
      COMPQ     : Character;
      N         : Integer;
      D_adr     : Address;
      E_adr     : Address;
      U_adr     : Address;
      LDU       : Integer;
      VT_adr    : Address;
      LDVT      : Integer;
      Q_adr     : Address;
      IQ_adr    : Address;
      WORK_adr  : Address;
      IWORK_adr : Address;
      INFO      : in out Integer)
   is

      D     : Ftn_Real_Vector (1 .. N);
      E     : Ftn_Real_Vector (1 .. N - 1);
      U     : Ftn_Real_Matrix (1 .. LDU, 1 .. N);
      VT    : Ftn_Real_Matrix (1 .. LDVT, 1 .. N);
      Q     : Ftn_Real_Vector (1 .. 2 * N * N);       -- doc. claims 1..LDQ
      IQ    : Ftn_Integer_Vector (1 .. 2 * N * N);    -- doc. claims 1..LDIQ
      WORK  : Ftn_Real_Vector (1 .. 3 * N * N + 4 * N);   -- doc. claims 1..LWORK
      IWORK : Ftn_Integer_Vector (1 .. 8 * N);

      for D'Address use D_adr;
      for E'Address use E_adr;
      for U'Address use U_adr;
      for VT'Address use VT_adr;
      for Q'Address use Q_adr;
      for IQ'Address use IQ_adr;
      for WORK'Address use WORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, U);
      pragma Import (Ada, VT);
      pragma Import (Ada, Q);
      pragma Import (Ada, IQ);
      pragma Import (Ada, WORK);
      pragma Import (Ada, IWORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      DIFL   : Integer;
      DIFR   : Integer;
      GIVCOL : Integer;
      GIVNUM : Integer;
      GIVPTR : Integer;
      I      : Integer;
      IC     : Integer;
      ICOMPQ : Integer;
      IERR   : Integer;
      II     : Integer;
      Ftn_IS : Integer;
      IU     : Integer;
      IUPLO  : Integer;
      IVT    : Integer;
      J      : Integer;
      K      : Integer;
      KK     : Integer;
      MLVL   : Integer;
      NM1    : Integer;
      NSIZE  : Integer;
      PERM   : Integer;
      POLES  : Integer;
      QSTART : Integer;
      SMLSIZ : Integer;
      SMLSZP : Integer;
      SQRE   : Integer;
      START  : Integer;
      WSTART : Integer;
      Z      : Integer;
      CS     : Real;
      EPS    : Real;
      ORGNRM : Real;
      P      : Real;
      R      : Real;
      SN     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DBDSDC( UPLO, COMPQ, N, D, E, U, LDU, VT, LDVT, Q, IQ,
   --                          WORK, IWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          COMPQ, UPLO
   --       INTEGER            INFO, LDU, LDVT, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IQ( * ), IWORK( * )
   --       DOUBLE PRECISION   D( * ), E( * ), Q( * ), U( LDU, * ),
   --      $                   VT( LDVT, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DBDSDC computes the singular value decomposition (SVD) of a real
   --  N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
   --  using a divide and conquer method, where S is a diagonal matrix
   --  with non-negative diagonal elements (the singular values of B), and
   --  U and VT are orthogonal matrices of left and right singular vectors,
   --  respectively. DBDSDC can be used to compute all singular values,
   --  and optionally, singular vectors or singular vectors in compact form.
   --
   --  This code makes very mild assumptions about floating point
   --  arithmetic. It will work on machines with a guard digit in
   --  add/subtract, or on those binary machines without guard digits
   --  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
   --  It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.  See DLASD3 for details.
   --
   --  The code currently calls DLASDQ if singular values only are desired.
   --  However, it can be slightly modified to compute singular values
   --  using the divide and conquer method.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  B is upper bidiagonal.
   --           = 'L':  B is lower bidiagonal.
   --
   --  [in] COMPQ
   --           COMPQ is CHARACTER*1
   --           Specifies whether singular vectors are to be computed
   --           as follows:
   --           = 'N':  Compute singular values only;
   --           = 'P':  Compute singular values and compute singular
   --                   vectors in compact form;
   --           = 'I':  Compute singular values and singular vectors.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix B.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the n diagonal elements of the bidiagonal matrix B.
   --           On exit, if INFO=0, the singular values of B.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           On entry, the elements of E contain the offdiagonal
   --           elements of the bidiagonal matrix whose SVD is desired.
   --           On exit, E has been destroyed.
   --
   --  [out] U
   --           U is DOUBLE PRECISION array, dimension (LDU,N)
   --           If  COMPQ = 'I', then:
   --              On exit, if INFO = 0, U contains the left singular vectors
   --              of the bidiagonal matrix.
   --           For other values of COMPQ, U is not referenced.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --           The leading dimension of the array U.  LDU >= 1.
   --           If singular vectors are desired, then LDU >= max( 1, N ).
   --
   --  [out] VT
   --           VT is DOUBLE PRECISION array, dimension (LDVT,N)
   --           If  COMPQ = 'I', then:
   --              On exit, if INFO = 0, VT**T contains the right singular
   --              vectors of the bidiagonal matrix.
   --           For other values of COMPQ, VT is not referenced.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --           The leading dimension of the array VT.  LDVT >= 1.
   --           If singular vectors are desired, then LDVT >= max( 1, N ).
   --
   --  [out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ)
   --           If  COMPQ = 'P', then:
   --              On exit, if INFO = 0, Q and IQ contain the left
   --              and right singular vectors in a compact form,
   --              requiring O(N log N) space instead of 2*N**2.
   --              In particular, Q contains all the Real PRECISION data in
   --              LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
   --              words of memory, where SMLSIZ is returned by ILAENV and
   --              is equal to the maximum size of the subproblems at the
   --              bottom of the computation tree (usually about 25).
   --           For other values of COMPQ, Q is not referenced.
   --
   --  [out] IQ
   --           IQ is INTEGER array, dimension (LDIQ)
   --           If  COMPQ = 'P', then:
   --              On exit, if INFO = 0, Q and IQ contain the left
   --              and right singular vectors in a compact form,
   --              requiring O(N log N) space instead of 2*N**2.
   --              In particular, IQ contains all INTEGER data in
   --              LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
   --              words of memory, where SMLSIZ is returned by ILAENV and
   --              is equal to the maximum size of the subproblems at the
   --              bottom of the computation tree (usually about 25).
   --           For other values of COMPQ, IQ is not referenced.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           If COMPQ = 'N' then LWORK >= (4 * N).
   --           If COMPQ = 'P' then LWORK >= (6 * N).
   --           If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N).
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (8*N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  The algorithm failed to compute a singular value.
   --                 The update process of divide and conquer failed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --  Changed dimension statement in comment describing E from (N) to
   --  (N-1).  Sven, 17 Feb 05.
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, TWO = 2.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANST
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLARTG, DLASCL, DLASD0, DLASDA, DLASDQ, DLASET, DLASR, DSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, LOG, SIGN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      IUPLO := 0;
      if LSAME (UPLO, 'U') then
         IUPLO := 1;
      end if;
      if LSAME (UPLO, 'L') then
         IUPLO := 2;
      end if;
      if LSAME (COMPQ, 'N') then
         ICOMPQ := 0;
      elsif LSAME (COMPQ, 'P') then
         ICOMPQ := 1;
      elsif LSAME (COMPQ, 'I') then
         ICOMPQ := 2;
      else
         ICOMPQ := -1;
      end if;
      if IUPLO = 0 then
         INFO := -1;
      elsif ICOMPQ < 0 then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif (LDU < 1) or ((ICOMPQ = 2) and (LDU < N)) then
         INFO := -7;
      elsif (LDVT < 1) or ((ICOMPQ = 2) and (LDVT < N)) then
         INFO := -9;
      end if;
      if INFO /= 0 then
         XERBLA ("DBDSDC", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      SMLSIZ := ILAENV (9, "DBDSDC", " ", 0, 0, 0, 0);
      if N = 1 then
         if ICOMPQ = 1 then
            Q (1)              := sign (ONE, D (1));
            Q (1 + SMLSIZ * N) := ONE;
         elsif ICOMPQ = 2 then
            U (1, 1)  := sign (ONE, D (1));
            VT (1, 1) := ONE;
         end if;
         D (1) := abs (D (1));
         return;
      end if;
      NM1 := N - 1;
      --
      --     If matrix lower bidiagonal, rotate to be upper bidiagonal
      --     by applying Givens rotations on the left
      --
      WSTART := 1;
      QSTART := 3;
      if ICOMPQ = 1 then
         DCOPY (N, D'Address, 1, Q (1)'Address, 1);
         DCOPY (N - 1, E'Address, 1, Q (N + 1)'Address, 1);
      end if;
      if IUPLO = 2 then
         QSTART := 5;
         WSTART := 2 * N - 1;
         I      := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            DLARTG (D (I), E (I), CS, SN, R);
            D (I)     := R;
            E (I)     := SN * D (I + 1);
            D (I + 1) := CS * D (I + 1);
            if ICOMPQ = 1 then
               Q (I + 2 * N) := CS;
               Q (I + 3 * N) := SN;
            elsif ICOMPQ = 2 then
               WORK (I)       := CS;
               WORK (NM1 + I) := -SN;
            end if;
         end loop;
      end if;
      --
      --     If ICOMPQ = 0, use DLASDQ to compute the singular values.
      --
      if ICOMPQ = 0 then
         DLASDQ
           ('U',
            0,
            N,
            0,
            0,
            0,
            D'Address,
            E'Address,
            VT'Address,
            LDVT,
            U'Address,
            LDU,
            U'Address,
            LDU,
            WORK (WSTART)'Address,
            INFO);
         goto L40;
      end if;
      --
      --     If N is smaller than the minimum divide size SMLSIZ, then solve
      --     the problem with another solver.
      --
      if N <= SMLSIZ then
         if ICOMPQ = 2 then
            DLASET ('A', N, N, ZERO, ONE, U'Address, LDU);
            DLASET ('A', N, N, ZERO, ONE, VT'Address, LDVT);
            DLASDQ
              ('U',
               0,
               N,
               N,
               N,
               0,
               D'Address,
               E'Address,
               VT'Address,
               LDVT,
               U'Address,
               LDU,
               U'Address,
               LDU,
               WORK (WSTART)'Address,
               INFO);
         elsif ICOMPQ = 1 then
            IU  := 1;
            IVT := IU + N;
            DLASET ('A', N, N, ZERO, ONE, Q (IU + (QSTART - 1) * N)'Address, N);
            DLASET ('A', N, N, ZERO, ONE, Q (IVT + (QSTART - 1) * N)'Address, N);
            DLASDQ
              ('U',
               0,
               N,
               N,
               N,
               0,
               D'Address,
               E'Address,
               Q (IVT + (QSTART - 1) * N)'Address,
               N,
               Q (IU + (QSTART - 1) * N)'Address,
               N,
               Q (IU + (QSTART - 1) * N)'Address,
               N,
               WORK (WSTART)'Address,
               INFO);
         end if;
         goto L40;
      end if;
      --
      if ICOMPQ = 2 then
         DLASET ('A', N, N, ZERO, ONE, U'Address, LDU);
         DLASET ('A', N, N, ZERO, ONE, VT'Address, LDVT);
      end if;
      --
      --     Scale.
      --
      ORGNRM := DLANST ('M', N, D'Address, E'Address);
      if ORGNRM = ZERO then
         return;
      end if;
      DLASCL ('G', 0, 0, ORGNRM, ONE, N, 1, D'Address, N, IERR);
      DLASCL ('G', 0, 0, ORGNRM, ONE, NM1, 1, E'Address, NM1, IERR);
      --
      EPS := (0.9e+0) * DLAMCH ('E');
      --
      MLVL   := int (Log (Real (N) / Real (SMLSIZ + 1)) / Log (TWO)) + 1;
      SMLSZP := SMLSIZ + 1;
      --
      if ICOMPQ = 1 then
         IU     := 1;
         IVT    := 1 + SMLSIZ;
         DIFL   := IVT + SMLSZP;
         DIFR   := DIFL + MLVL;
         Z      := DIFR + MLVL * 2;
         IC     := Z + MLVL;
         Ftn_IS := IC + 1;
         POLES  := Ftn_IS + 1;
         GIVNUM := POLES + 2 * MLVL;
         --
         K      := 1;
         GIVPTR := 2;
         PERM   := 3;
         GIVCOL := PERM + MLVL;
      end if;
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         if abs (D (I)) < EPS then
            D (I) := sign (EPS, D (I));
         end if;
      end loop;
      --
      START := 1;
      SQRE  := 0;
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > NM1;
         if (abs (E (I)) < EPS) or (I = NM1) then
            --
            --        Subproblem found. First determine its size and then
            --        apply divide and conquer on it.
            --
            if I < NM1 then
               --
               --        A subproblem with E(I) small for I < NM1.
               --
               NSIZE := I - START + 1;
            elsif abs (E (I)) >= EPS then
               --
               --        A subproblem with E(NM1) not too small but I = NM1.
               --
               NSIZE := N - START + 1;
            else
               --
               --        A subproblem with E(NM1) small. This implies an
               --        1-by-1 subproblem at D(N). Solve this 1-by-1 problem
               --        first.
               --
               NSIZE := I - START + 1;
               if ICOMPQ = 2 then
                  U (N, N)  := sign (ONE, D (N));
                  VT (N, N) := ONE;
               elsif ICOMPQ = 1 then
                  Q (N + (QSTART - 1) * N)            := sign (ONE, D (N));
                  Q (N + (SMLSIZ + QSTART - 1) * N)   := ONE;
               end if;
               D (N) := abs (D (N));
            end if;
            if ICOMPQ = 2 then
               DLASD0
                 (NSIZE,
                  SQRE,
                  D (START)'Address,
                  E (START)'Address,
                  U (START, START)'Address,
                  LDU,
                  VT (START, START)'Address,
                  LDVT,
                  SMLSIZ,
                  IWORK'Address,
                  WORK (WSTART)'Address,
                  INFO);
            else
               DLASDA
                 (ICOMPQ,
                  SMLSIZ,
                  NSIZE,
                  SQRE,
                  D (START)'Address,
                  E (START)'Address,
                  Q (START + (IU + QSTART - 2) * N)'Address,
                  N,
                  Q (START + (IVT + QSTART - 2) * N)'Address,
                  IQ (START + K * N)'Address,
                  Q (START + (DIFL + QSTART - 2) * N)'Address,
                  Q (START + (DIFR + QSTART - 2) * N)'Address,
                  Q (START + (Z + QSTART - 2) * N)'Address,
                  Q (START + (POLES + QSTART - 2) * N)'Address,
                  IQ (START + GIVPTR * N)'Address,
                  IQ (START + GIVCOL * N)'Address,
                  N,
                  IQ (START + PERM * N)'Address,
                  Q (START + (GIVNUM + QSTART - 2) * N)'Address,
                  Q (START + (IC + QSTART - 2) * N)'Address,
                  Q (START + (Ftn_IS + QSTART - 2) * N)'Address,
                  WORK (WSTART)'Address,
                  IWORK'Address,
                  INFO);
            end if;
            if INFO /= 0 then
               return;
            end if;
            START := I + 1;
         end if;
      end loop;
      --
      --     Unscale
      --
      DLASCL ('G', 0, 0, ONE, ORGNRM, N, 1, D'Address, N, IERR);
      <<L40>> null;
      --
      --     Use Selection Sort to minimize swaps of singular vectors
      --
      II := 2 - 1;
      loop
         II := II + 1;
         exit when II > N;
         I  := II - 1;
         KK := I;
         P  := D (I);
         J  := II - 1;
         loop
            J := J + 1;
            exit when J > N;
            if D (J) > P then
               KK := J;
               P  := D (J);
            end if;
         end loop;
         if KK /= I then
            D (KK) := D (I);
            D (I)  := P;
            if ICOMPQ = 1 then
               IQ (I) := KK;
            elsif ICOMPQ = 2 then
               DSWAP (N, U (1, I)'Address, 1, U (1, KK)'Address, 1);
               DSWAP (N, VT (I, 1)'Address, LDVT, VT (KK, 1)'Address, LDVT);
            end if;
         elsif ICOMPQ = 1 then
            IQ (I) := I;
         end if;
      end loop;
      --
      --     If ICOMPQ = 1, use IQ(N,1) as the indicator for UPLO
      --
      if ICOMPQ = 1 then
         if IUPLO = 1 
            then IQ (N) := 1;
            else IQ (N) := 0;
         end if;
      end if;
      --
      --     If B is lower bidiagonal, update U by those Givens rotations
      --     which rotated B to be upper bidiagonal
      --
      if (IUPLO = 2) and (ICOMPQ = 2) then
         DLASR ('L', 'V', 'B', N, N, WORK (1)'Address, WORK (N)'Address, U'Address, LDU);
      end if;
      --
      return;
      --
      --     End of DBDSDC
      --
   end DBDSDC;

   procedure DBDSQR
     (UPLO     : Character;
      N        : Integer;
      NCVT     : Integer;
      NRU      : Integer;
      NCC      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      VT_adr   : Address;
      LDVT     : Integer;
      U_adr    : Address;
      LDU      : Integer;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      D    : Ftn_Real_Vector (1 .. N);
      E    : Ftn_Real_Vector (1 .. N - 1);
      VT   : Ftn_Real_Matrix (1 .. LDVT, 1 .. NCVT);
      U    : Ftn_Real_Matrix (1 .. LDU, 1 .. N);
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. NCC);
      WORK : Ftn_Real_Vector (1 .. 4 * N);

      for D'Address use D_adr;
      for E'Address use E_adr;
      for VT'Address use VT_adr;
      for U'Address use U_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, VT);
      pragma Import (Ada, U);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      NEGONE : constant Real    := -1.0e0;
      HNDRTH : constant Real    := 0.01e0;
      TEN    : constant Real    := 10.0e0;
      HNDRD  : constant Real    := 100.0e0;
      MEIGTH : constant Real    := -0.125e0;
      MAXITR : constant Integer := 6;
      LOWER  : Boolean;
      ROTATE : Boolean;
      I      : Integer;
      IDIR   : Integer;
      ISUB   : Integer;
      ITER   : Integer;
      J      : Integer;
      LL     : Integer;
      LLL    : Integer;
      M      : Integer;
      MAXIT  : Integer;
      NM1    : Integer;
      NM12   : Integer;
      NM13   : Integer;
      OLDLL  : Integer;
      OLDM   : Integer;
      ABSE   : Real;
      ABSS   : Real;
      COSL   : Real;
      COSR   : Real;
      CS     : Real;
      EPS    : Real;
      F      : Real;
      G      : Real;
      H      : Real;
      MU     : Real;
      OLDCS  : Real;
      OLDSN  : Real;
      R      : Real;
      SHIFT  : Real;
      SIGMN  : Real;
      SIGMX  : Real;
      SINL   : Real;
      SINR   : Real;
      SLL    : Real;
      SMAX   : Real;
      SMIN   : Real;
      SMINL  : Real;
      SMINOA : Real;
      SN     : Real;
      THRESH : Real;
      TOL    : Real;
      TOLMUL : Real;
      UNFL   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DBDSQR( UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U,
   --                          LDU, C, LDC, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDC, LDU, LDVT, N, NCC, NCVT, NRU
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   C( LDC, * ), D( * ), E( * ), U( LDU, * ),
   --      $                   VT( LDVT, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DBDSQR computes the singular values and, optionally, the right and/or
   --  left singular vectors from the singular value decomposition (SVD) of
   --  a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
   --  zero-shift QR algorithm.  The SVD of B has the form
   --
   --     B = Q * S * P**T
   --
   --  where S is the diagonal matrix of singular values, Q is an orthogonal
   --  matrix of left singular vectors, and P is an orthogonal matrix of
   --  right singular vectors.  If left singular vectors are requested, this
   --  subroutine actually returns U*Q instead of Q, and, if right singular
   --  vectors are requested, this subroutine returns P**T*VT instead of
   --  P**T, for given real input matrices U and VT.  When U and VT are the
   --  orthogonal matrices that reduce a general matrix A to bidiagonal
   --  form:  A = U*B*VT, as computed by DGEBRD, then
   --
   --     A = (U*Q) * S * (P**T*VT)
   --
   --  is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
   --  for a given real input matrix C.
   --
   --  See "Computing  Small Singular Values of Bidiagonal Matrices With
   --  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
   --  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
   --  no. 5, pp. 873-912, Sept 1990) and
   --  "Accurate singular values and differential qd algorithms," by
   --  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
   --  Department, University of California at Berkeley, July 1992
   --  for a detailed description of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  B is upper bidiagonal;
   --           = 'L':  B is lower bidiagonal.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix B.  N >= 0.
   --
   --  [in] NCVT
   --           NCVT is INTEGER
   --           The number of columns of the matrix VT. NCVT >= 0.
   --
   --  [in] NRU
   --           NRU is INTEGER
   --           The number of rows of the matrix U. NRU >= 0.
   --
   --  [in] NCC
   --           NCC is INTEGER
   --           The number of columns of the matrix C. NCC >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the n diagonal elements of the bidiagonal matrix B.
   --           On exit, if INFO=0, the singular values of B in decreasing
   --           order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           On entry, the N-1 offdiagonal elements of the bidiagonal
   --           matrix B.
   --           On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
   --           will contain the diagonal and superdiagonal elements of a
   --           bidiagonal matrix orthogonally equivalent to the one given
   --           as input.
   --
   --  [in,out] VT
   --           VT is DOUBLE PRECISION array, dimension (LDVT, NCVT)
   --           On entry, an N-by-NCVT matrix VT.
   --           On exit, VT is overwritten by P**T * VT.
   --           Not referenced if NCVT = 0.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --           The leading dimension of the array VT.
   --           LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
   --
   --  [in,out] U
   --           U is DOUBLE PRECISION array, dimension (LDU, N)
   --           On entry, an NRU-by-N matrix U.
   --           On exit, U is overwritten by U * Q.
   --           Not referenced if NRU = 0.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --           The leading dimension of the array U.  LDU >= max(1,NRU).
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC, NCC)
   --           On entry, an N-by-NCC matrix C.
   --           On exit, C is overwritten by Q**T * C.
   --           Not referenced if NCC = 0.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C.
   --           LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (4*N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  If INFO = -i, the i-th argument had an illegal value
   --           > 0:
   --              if NCVT = NRU = NCC = 0,
   --                 = 1, a split was marked by a positive value in E
   --                 = 2, current block of Z not diagonalized after 30*N
   --                      iterations (in inner while loop)
   --                 = 3, termination criterion of outer while loop not met
   --                      (program created more than N unreduced blocks)
   --              else NCVT = NRU = NCC = 0,
   --                    the algorithm did not converge; D and E contain the
   --                    elements of a bidiagonal matrix which is orthogonally
   --                    similar to the input matrix B;  if INFO = i, i
   --                    elements of E have not converged to zero.
   --
   --  Internal Parameters:
   --  =========================
   --
   --   TOLMUL  DOUBLE PRECISION, default = max(10,min(100,EPS**(-1/8)))
   --           TOLMUL controls the convergence criterion of the QR loop.
   --           If it is positive, TOLMUL*EPS is the desired relative
   --              precision in the computed singular values.
   --           If it is negative, abs(TOLMUL*EPS*sigma_max) is the
   --              desired absolute accuracy in the computed singular
   --              values (corresponds to relative accuracy
   --              abs(TOLMUL*EPS) in the largest singular value).
   --           abs(TOLMUL) should be between 1 and 1/EPS, and preferably
   --              between 10 (for fast convergence) and .1/EPS
   --              (for there to be some accuracy in the results).
   --           Default is to lose at either one eighth or 2 of the
   --              available decimal digits in each computed singular value
   --              (whichever is smaller).
   --
   --   MAXITR  INTEGER, default = 6
   --           MAXITR controls the maximum number of passes of the
   --           algorithm through its inner loop. The algorithms stops
   --           (and so fails to converge) if the number of passes
   --           through the inner loop exceeds MAXITR*N**2.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --      PARAMETER          ( ONE = 1.0D0 )
   --      PARAMETER          ( NEGONE = -1.0D0 )
   --      PARAMETER          ( HNDRTH = 0.01D0 )
   --      PARAMETER          ( TEN = 10.0D0 )
   --      PARAMETER          ( HNDRD = 100.0D0 )
   --      PARAMETER          ( MEIGTH = -0.125D0 )
   --      PARAMETER          ( MAXITR = 6 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARTG, DLAS2, DLASQ1, DLASR, DLASV2, DROT, DSCAL, DSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, MAX, MIN, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO  := 0;
      LOWER := LSAME (UPLO, 'L');
      if not LSAME (UPLO, 'U') and not LOWER then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NCVT < 0 then
         INFO := -3;
      elsif NRU < 0 then
         INFO := -4;
      elsif NCC < 0 then
         INFO := -5;
      elsif (NCVT = 0 and LDVT < 1) or (NCVT > 0 and LDVT < max (1, N)) then
         INFO := -9;
      elsif LDU < max (1, NRU) then
         INFO := -11;
      elsif (NCC = 0 and LDC < 1) or (NCC > 0 and LDC < max (1, N)) then
         INFO := -13;
      end if;
      if INFO /= 0 then
         XERBLA ("DBDSQR", -INFO);
         return;
      end if;
      if N = 0 then
         return;
      end if;
      if N = 1 then
         goto L160;
      end if;
      --
      --     ROTATE is true if any singular vectors desired, false otherwise
      --
      ROTATE := (NCVT > 0) or (NRU > 0) or (NCC > 0);
      --
      --     If no singular vectors desired, use qd algorithm
      --
      if not ROTATE then
         DLASQ1 (N, D, E, WORK, INFO);
         --
         --     If INFO equals 2, dqds didn't finish, try to finish
         --
         if INFO /= 2 then
            return;
         end if;
         INFO := 0;
      end if;
      --
      NM1  := N - 1;
      NM12 := NM1 + NM1;
      NM13 := NM12 + NM1;
      IDIR := 0;
      --
      --     Get machine constants
      --
      EPS  := DLAMCH ('E');
      UNFL := DLAMCH ('S');
      --
      --     If matrix lower bidiagonal, rotate to be upper bidiagonal
      --     by applying Givens rotations on the left
      --
      if LOWER then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            DLARTG (D (I), E (I), CS, SN, R);
            D (I)          := R;
            E (I)          := SN * D (I + 1);
            D (I + 1)      := CS * D (I + 1);
            WORK (I)       := CS;
            WORK (NM1 + I) := SN;
         end loop;
         --
         --        Update singular vectors if desired
         --
         if NRU > 0 then
            DLASR ('R', 'V', 'F', NRU, N, WORK (1)'Address, WORK (N)'Address, U'Address, LDU);
         end if;
         if NCC > 0 then
            DLASR ('L', 'V', 'F', N, NCC, WORK (1)'Address, WORK (N)'Address, C'Address, LDC);
         end if;
      end if;
      --
      --     Compute singular values to relative accuracy TOL
      --     (By setting TOL to be negative, algorithm will compute
      --     singular values to absolute accuracy ABS(TOL)*norm(input matrix))
      --
      TOLMUL := max (TEN, min (HNDRD, EPS ** MEIGTH));
      TOL    := TOLMUL * EPS;
      --
      --     Compute approximate maximum, minimum singular values
      --
      SMAX := ZERO;
      I    := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         SMAX := max (SMAX, abs (D (I)));
      end loop;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         SMAX := max (SMAX, abs (E (I)));
      end loop;
      SMINL := ZERO;
      if TOL >= ZERO then
         --
         --        Relative accuracy desired
         --
         SMINOA := abs (D (1));
         if SMINOA = ZERO then
            goto L50;
         end if;
         MU := SMINOA;
         I  := 2 - 1;
         loop
            I := I + 1;
            exit when I > N;
            MU     := abs (D (I)) * (MU / (MU + abs (E (I - 1))));
            SMINOA := min (SMINOA, MU);
            if SMINOA = ZERO then
               goto L50;
            end if;
         end loop;
         <<L50>> null;
         SMINOA := SMINOA / Sqrt (Real (N));
         THRESH := max (TOL * SMINOA, Real (MAXITR * N * N) * UNFL);
      else
         --
         --        Absolute accuracy desired
         --
         THRESH := max (abs (TOL) * SMAX, Real (MAXITR * N * N) * UNFL);
      end if;
      --
      --     Prepare for main iteration loop for the singular values
      --     (MAXIT is the maximum number of passes through the inner
      --     loop permitted before nonconvergence signalled.)
      --
      MAXIT := MAXITR * N * N;
      ITER  := 0;
      OLDLL := -1;
      OLDM  := -1;
      --
      --     M points to last element of unconverged part of matrix
      --
      M := N;
      --
      --     Begin main iteration loop
      --
      <<L60>> null;
      --
      --     Check for convergence or exceeding iteration count
      --
      if M <= 1 then
         goto L160;
      end if;
      if ITER > MAXIT then
         goto L200;
      end if;
      --
      --     Find diagonal block of matrix to work on
      --
      if TOL < ZERO and abs (D (M)) <= THRESH then
         D (M) := ZERO;
      end if;
      SMAX := abs (D (M));
      SMIN := SMAX;
      LLL  := 1 - 1;
      loop
         LLL := LLL + 1;
         exit when LLL > M - 1;
         LL   := M - LLL;
         ABSS := abs (D (LL));
         ABSE := abs (E (LL));
         if TOL < ZERO and ABSS <= THRESH then
            D (LL) := ZERO;
         end if;
         if ABSE <= THRESH then
            goto L80;
         end if;
         SMIN := min (SMIN, ABSS);
         SMAX := max (SMAX, ABSS, ABSE);
      end loop;
      LL := 0;
      goto L90;
      <<L80>> null;
      E (LL) := ZERO;
      --
      --     Matrix splits since E(LL) = 0
      --
      if LL = M - 1 then
         --
         --        Convergence of bottom singular value, return to top of loop
         --
         M := M - 1;
         goto L60;
      end if;
      <<L90>> null;
      LL := LL + 1;
      --
      --     E(LL) through E(M-1) are nonzero, E(LL-1) is zero
      --
      if LL = M - 1 then
         --
         --        2 by 2 block, handle separately
         --
         DLASV2 (D (M - 1), E (M - 1), D (M), SIGMN, SIGMX, SINR, COSR, SINL, COSL);
         D (M - 1) := SIGMX;
         E (M - 1) := ZERO;
         D (M)     := SIGMN;
         --
         --        Compute singular vectors, if desired
         --
         if NCVT > 0 then
            DROT (NCVT, VT (M - 1, 1)'Address, LDVT, VT (M, 1)'Address, LDVT, COSR, SINR);
         end if;
         if NRU > 0 then
            DROT (NRU, U (1, M - 1)'Address, 1, U (1, M)'Address, 1, COSL, SINL);
         end if;
         if NCC > 0 then
            DROT (NCC, C (M - 1, 1)'Address, LDC, C (M, 1)'Address, LDC, COSL, SINL);
         end if;
         M := M - 2;
         goto L60;
      end if;
      --
      --     If working on new submatrix, choose shift direction
      --     (from larger end diagonal element towards smaller)
      --
      if LL > OLDM or M < OLDLL then
         if abs (D (LL)) >= abs (D (M)) then
            --
            --           Chase bulge from top (big end) to bottom (small end)
            --
            IDIR := 1;
         else
            --
            --           Chase bulge from bottom (big end) to top (small end)
            --
            IDIR := 2;
         end if;
      end if;
      --
      --     Apply convergence tests
      --
      if IDIR = 1 then
         --
         --        Run convergence test in forward direction
         --        First apply standard test to bottom of matrix
         --
         if abs (E (M - 1)) <= abs (TOL) * abs (D (M)) or (TOL < ZERO and abs (E (M - 1)) <= THRESH) then
            E (M - 1) := ZERO;
            goto L60;
         end if;
         --
         if TOL >= ZERO then
            --
            --           If relative accuracy desired,
            --           apply convergence criterion forward
            --
            MU    := abs (D (LL));
            SMINL := MU;
            LLL   := LL - 1;
            loop
               LLL := LLL + 1;
               exit when LLL > M - 1;
               if abs (E (LLL)) <= TOL * MU then
                  E (LLL) := ZERO;
                  goto L60;
               end if;
               MU    := abs (D (LLL + 1)) * (MU / (MU + abs (E (LLL))));
               SMINL := min (SMINL, MU);
            end loop;
         end if;
      --
      else
         --
         --        Run convergence test in backward direction
         --        First apply standard test to top of matrix
         --
         if abs (E (LL)) <= abs (TOL) * abs (D (LL)) or (TOL < ZERO and abs (E (LL)) <= THRESH) then
            E (LL) := ZERO;
            goto L60;
         end if;
         --
         if TOL >= ZERO then
            --
            --           If relative accuracy desired,
            --           apply convergence criterion backward
            --
            MU    := abs (D (M));
            SMINL := MU;
            LLL   := M - 1 + 1;
            loop
               LLL := LLL - 1;
               exit when LLL < LL;
               if abs (E (LLL)) <= TOL * MU then
                  E (LLL) := ZERO;
                  goto L60;
               end if;
               MU    := abs (D (LLL)) * (MU / (MU + abs (E (LLL))));
               SMINL := min (SMINL, MU);
            end loop;
         end if;
      end if;
      OLDLL := LL;
      OLDM  := M;
      --
      --     Compute shift.  First, test if shifting would ruin relative
      --     accuracy, and if so set the shift to zero.
      --
      if TOL >= ZERO and Real (N) * TOL * (SMINL / SMAX) <= max (EPS, HNDRTH * TOL) then
         --
         --        Use a zero shift to avoid loss of relative accuracy
         --
         SHIFT := ZERO;
      else
         --
         --        Compute the shift from 2-by-2 block at end of matrix
         --
         if IDIR = 1 then
            SLL := abs (D (LL));
            DLAS2 (D (M - 1), E (M - 1), D (M), SHIFT, R);
         else
            SLL := abs (D (M));
            DLAS2 (D (LL), E (LL), D (LL + 1), SHIFT, R);
         end if;
         --
         --        Test if shift negligible, and if so set to zero
         --
         if SLL > ZERO then
            if (SHIFT / SLL) ** 2 < EPS then
               SHIFT := ZERO;
            end if;
         end if;
      end if;
      --
      --     Increment iteration count
      --
      ITER := ITER + M - LL;
      --
      --     If SHIFT = 0, do simplified QR iteration
      --
      if SHIFT = ZERO then
         if IDIR = 1 then
            --
            --           Chase bulge from top to bottom
            --           Save cosines and sines for later singular vector updates
            --
            CS    := ONE;
            OLDCS := ONE;
            I     := LL - 1;
            loop
               I := I + 1;
               exit when I > M - 1;
               DLARTG (D (I) * CS, E (I), CS, SN, R);
               if I > LL then
                  E (I - 1) := OLDSN * R;
               end if;
               DLARTG (OLDCS * R, D (I + 1) * SN, OLDCS, OLDSN, D (I));
               WORK (I - LL + 1)        := CS;
               WORK (I - LL + 1 + NM1)  := SN;
               WORK (I - LL + 1 + NM12) := OLDCS;
               WORK (I - LL + 1 + NM13) := OLDSN;
            end loop;
            H         := D (M) * CS;
            D (M)     := H * OLDCS;
            E (M - 1) := H * OLDSN;
            --
            --           Update singular vectors
            --
            if NCVT > 0 then
               DLASR ('L', 'V', 'F', M - LL + 1, NCVT, WORK (1)'Address, WORK (N)'Address, VT (LL, 1)'Address, LDVT);
            end if;
            if NRU > 0 then
               DLASR
                 ('R',
                  'V',
                  'F',
                  NRU,
                  M - LL + 1,
                  WORK (NM12 + 1)'Address,
                  WORK (NM13 + 1)'Address,
                  U (1, LL)'Address,
                  LDU);
            end if;
            if NCC > 0 then
               DLASR
                 ('L',
                  'V',
                  'F',
                  M - LL + 1,
                  NCC,
                  WORK (NM12 + 1)'Address,
                  WORK (NM13 + 1)'Address,
                  C (LL, 1)'Address,
                  LDC);
            end if;
            --
            --           Test convergence
            --
            if abs (E (M - 1)) <= THRESH then
               E (M - 1) := ZERO;
            end if;
         --
         else
            --
            --           Chase bulge from bottom to top
            --           Save cosines and sines for later singular vector updates
            --
            CS    := ONE;
            OLDCS := ONE;
            I     := M + 1;
            loop
               I := I - 1;
               exit when I < LL + 1;
               DLARTG (D (I) * CS, E (I - 1), CS, SN, R);
               if I < M then
                  E (I) := OLDSN * R;
               end if;
               DLARTG (OLDCS * R, D (I - 1) * SN, OLDCS, OLDSN, D (I));
               WORK (I - LL)        := CS;
               WORK (I - LL + NM1)  := -SN;
               WORK (I - LL + NM12) := OLDCS;
               WORK (I - LL + NM13) := -OLDSN;
            end loop;
            H      := D (LL) * CS;
            D (LL) := H * OLDCS;
            E (LL) := H * OLDSN;
            --
            --           Update singular vectors
            --
            if NCVT > 0 then
               DLASR
                 ('L',
                  'V',
                  'B',
                  M - LL + 1,
                  NCVT,
                  WORK (NM12 + 1)'Address,
                  WORK (NM13 + 1)'Address,
                  VT (LL, 1)'Address,
                  LDVT);
            end if;
            if NRU > 0 then
               DLASR ('R', 'V', 'B', NRU, M - LL + 1, WORK (1)'Address, WORK (N)'Address, U (1, LL)'Address, LDU);
            end if;
            if NCC > 0 then
               DLASR ('L', 'V', 'B', M - LL + 1, NCC, WORK (1)'Address, WORK (N)'Address, C (LL, 1)'Address, LDC);
            end if;
            --
            --           Test convergence
            --
            if abs (E (LL)) <= THRESH then
               E (LL) := ZERO;
            end if;
         end if;
      else
         --
         --        Use nonzero shift
         --
         if IDIR = 1 then
            --
            --           Chase bulge from top to bottom
            --           Save cosines and sines for later singular vector updates
            --
            F := (abs (D (LL)) - SHIFT) * (sign (ONE, D (LL)) + SHIFT / D (LL));
            G := E (LL);
            I := LL - 1;
            loop
               I := I + 1;
               exit when I > M - 1;
               DLARTG (F, G, COSR, SINR, R);
               if I > LL then
                  E (I - 1) := R;
               end if;
               F         := COSR * D (I) + SINR * E (I);
               E (I)     := COSR * E (I) - SINR * D (I);
               G         := SINR * D (I + 1);
               D (I + 1) := COSR * D (I + 1);
               DLARTG (F, G, COSL, SINL, R);
               D (I)     := R;
               F         := COSL * E (I) + SINL * D (I + 1);
               D (I + 1) := COSL * D (I + 1) - SINL * E (I);
               if I < M - 1 then
                  G         := SINL * E (I + 1);
                  E (I + 1) := COSL * E (I + 1);
               end if;
               WORK (I - LL + 1)        := COSR;
               WORK (I - LL + 1 + NM1)  := SINR;
               WORK (I - LL + 1 + NM12) := COSL;
               WORK (I - LL + 1 + NM13) := SINL;
            end loop;
            E (M - 1) := F;
            --
            --           Update singular vectors
            --
            if NCVT > 0 then
               DLASR ('L', 'V', 'F', M - LL + 1, NCVT, WORK (1)'Address, WORK (N)'Address, VT (LL, 1)'Address, LDVT);
            end if;
            if NRU > 0 then
               DLASR
                 ('R',
                  'V',
                  'F',
                  NRU,
                  M - LL + 1,
                  WORK (NM12 + 1)'Address,
                  WORK (NM13 + 1)'Address,
                  U (1, LL)'Address,
                  LDU);
            end if;
            if NCC > 0 then
               DLASR
                 ('L',
                  'V',
                  'F',
                  M - LL + 1,
                  NCC,
                  WORK (NM12 + 1)'Address,
                  WORK (NM13 + 1)'Address,
                  C (LL, 1)'Address,
                  LDC);
            end if;
            --
            --           Test convergence
            --
            if abs (E (M - 1)) <= THRESH then
               E (M - 1) := ZERO;
            end if;
         --
         else
            --
            --           Chase bulge from bottom to top
            --           Save cosines and sines for later singular vector updates
            --
            F := (abs (D (M)) - SHIFT) * (sign (ONE, D (M)) + SHIFT / D (M));
            G := E (M - 1);
            I := M + 1;
            loop
               I := I - 1;
               exit when I < LL + 1;
               DLARTG (F, G, COSR, SINR, R);
               if I < M then
                  E (I) := R;
               end if;
               F         := COSR * D (I) + SINR * E (I - 1);
               E (I - 1) := COSR * E (I - 1) - SINR * D (I);
               G         := SINR * D (I - 1);
               D (I - 1) := COSR * D (I - 1);
               DLARTG (F, G, COSL, SINL, R);
               D (I)     := R;
               F         := COSL * E (I - 1) + SINL * D (I - 1);
               D (I - 1) := COSL * D (I - 1) - SINL * E (I - 1);
               if I > LL + 1 then
                  G         := SINL * E (I - 2);
                  E (I - 2) := COSL * E (I - 2);
               end if;
               WORK (I - LL)        := COSR;
               WORK (I - LL + NM1)  := -SINR;
               WORK (I - LL + NM12) := COSL;
               WORK (I - LL + NM13) := -SINL;
            end loop;
            E (LL) := F;
            --
            --           Test convergence
            --
            if abs (E (LL)) <= THRESH then
               E (LL) := ZERO;
            end if;
            --
            --           Update singular vectors if desired
            --
            if NCVT > 0 then
               DLASR
                 ('L',
                  'V',
                  'B',
                  M - LL + 1,
                  NCVT,
                  WORK (NM12 + 1)'Address,
                  WORK (NM13 + 1)'Address,
                  VT (LL, 1)'Address,
                  LDVT);
            end if;
            if NRU > 0 then
               DLASR ('R', 'V', 'B', NRU, M - LL + 1, WORK (1)'Address, WORK (N)'Address, U (1, LL)'Address, LDU);
            end if;
            if NCC > 0 then
               DLASR ('L', 'V', 'B', M - LL + 1, NCC, WORK (1)'Address, WORK (N)'Address, C (LL, 1)'Address, LDC);
            end if;
         end if;
      end if;
      --
      --     QR iteration finished, go back and check convergence
      --
      goto L60;
      --
      --     All singular values converged, so make them positive
      --
      <<L160>> null;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         if D (I) < ZERO then
            D (I) := -D (I);
            --
            --           Change sign of singular vectors, if desired
            --
            if NCVT > 0 then
               DSCAL (NCVT, NEGONE, VT (I, 1)'Address, LDVT);
            end if;
         end if;
      end loop;
      --
      --     Sort the singular values into decreasing order (insertion sort on
      --     singular values, but only one transposition per singular vector)
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         --
         --        Scan for smallest D(I)
         --
         ISUB := 1;
         SMIN := D (1);
         J    := 2 - 1;
         loop
            J := J + 1;
            exit when J > N + 1 - I;
            if D (J) <= SMIN then
               ISUB := J;
               SMIN := D (J);
            end if;
         end loop;
         if ISUB /= N + 1 - I then
            --
            --           Swap singular values and vectors
            --
            D (ISUB)      := D (N + 1 - I);
            D (N + 1 - I) := SMIN;
            if NCVT > 0 then
               DSWAP (NCVT, VT (ISUB, 1)'Address, LDVT, VT (N + 1 - I, 1)'Address, LDVT);
            end if;
            if NRU > 0 then
               DSWAP (NRU, U (1, ISUB)'Address, 1, U (1, N + 1 - I)'Address, 1);
            end if;
            if NCC > 0 then
               DSWAP (NCC, C (ISUB, 1)'Address, LDC, C (N + 1 - I, 1)'Address, LDC);
            end if;
         end if;
      end loop;
      goto L220;
      --
      --     Maximum number of iterations exceeded, failure to converge
      --
      <<L200>> null;
      INFO := 0;
      I    := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         if E (I) /= ZERO then
            INFO := INFO + 1;
         end if;
      end loop;
      <<L220>> null;
      return;
      --
      --     End of DBDSQR
      --
   end DBDSQR;

   procedure DGEBAK
     (JOB       : Character;
      SIDE      : Character;
      N         : Integer;
      ILO       : Integer;
      IHI       : Integer;
      SCALE_adr : Address;
      M         : Integer;
      V_adr     : Address;
      LDV       : Integer;
      INFO      : in out Integer)
   is

      SCALE : Ftn_Real_Vector (1 .. N);
      V     : Ftn_Real_Matrix (1 .. LDV, 1 .. M);

      for SCALE'Address use SCALE_adr;
      for V'Address use V_adr;

      pragma Import (Ada, SCALE);
      pragma Import (Ada, V);

      ONE    : constant Real := 1.0e0;
      LEFTV  : Boolean;
      RIGHTV : Boolean;
      I      : Integer;
      II     : Integer;
      K      : Integer;
      S      : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEBAK( JOB, SIDE, N, ILO, IHI, SCALE, M, V, LDV,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOB, SIDE
   --       INTEGER            IHI, ILO, INFO, LDV, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   SCALE( * ), V( LDV, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEBAK forms the right or left eigenvectors of a real general matrix
   --  by backward transformation on the computed eigenvectors of the
   --  balanced matrix output by DGEBAL.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOB
   --           JOB is CHARACTER*1
   --           Specifies the type of backward transformation required:
   --           = 'N', do nothing, return immediately;
   --           = 'P', do backward transformation for permutation only;
   --           = 'S', do backward transformation for scaling only;
   --           = 'B', do backward transformations for both permutation and
   --                  scaling.
   --           JOB must be the same as the argument JOB supplied to DGEBAL.
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'R':  V contains right eigenvectors;
   --           = 'L':  V contains left eigenvectors.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of rows of the matrix V.  N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --           The integers ILO and IHI determined by DGEBAL.
   --           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
   --
   --  [in] SCALE
   --           SCALE is DOUBLE PRECISION array, dimension (N)
   --           Details of the permutation and scaling factors, as returned
   --           by DGEBAL.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of columns of the matrix V.  M >= 0.
   --
   --  [in,out] V
   --           V is DOUBLE PRECISION array, dimension (LDV,M)
   --           On entry, the matrix of right or left eigenvectors to be
   --           transformed, as returned by DHSEIN or DTREVC.
   --           On exit, V is overwritten by the transformed eigenvectors.
   --
   --  [in] LDV
   --           LDV is INTEGER
   --           The leading dimension of the array V. LDV >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DSCAL, DSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Decode and Test the input parameters
   --
   begin
      RIGHTV := LSAME (SIDE, 'R');
      LEFTV  := LSAME (SIDE, 'L');
      --
      INFO := 0;
      if not LSAME (JOB, 'N') and not LSAME (JOB, 'P') and not LSAME (JOB, 'S') and not LSAME (JOB, 'B') then
         INFO := -1;
      elsif not RIGHTV and not LEFTV then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -4;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -5;
      elsif M < 0 then
         INFO := -7;
      elsif LDV < max (1, N) then
         INFO := -9;
      end if;
      if INFO /= 0 then
         XERBLA ("DGEBAK", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      if M = 0 then
         return;
      end if;
      if LSAME (JOB, 'N') then
         return;
      end if;
      --
      if ILO = IHI then
         goto L30;
      end if;
      --
      --     Backward balance
      --
      if LSAME (JOB, 'S') or LSAME (JOB, 'B') then
         --
         if RIGHTV then
            I := ILO - 1;
            loop
               I := I + 1;
               exit when I > IHI;
               S := SCALE (I);
               DSCAL (M, S, V (I, 1)'Address, LDV);
            end loop;
         end if;
         --
         if LEFTV then
            I := ILO - 1;
            loop
               I := I + 1;
               exit when I > IHI;
               S := ONE / SCALE (I);
               DSCAL (M, S, V (I, 1)'Address, LDV);
            end loop;
         end if;
         --
      end if;
      --
      --     Backward permutation
      --
      --     For  I = ILO-1 step -1 until 1,
      --              IHI+1 step 1 until N do --
      --
      <<L30>> null;
      if LSAME (JOB, 'P') or LSAME (JOB, 'B') then
         if RIGHTV then
            II := 1 - 1;
            loop
               II := II + 1;
               exit when II > N;
               I := II;
               if I >= ILO and I <= IHI then
                  goto L40;
               end if;
               if I < ILO then
                  I := ILO - II;
               end if;
               K := int (SCALE (I));
               if K = I then
                  goto L40;
               end if;
               DSWAP (M, V (I, 1)'Address, LDV, V (K, 1)'Address, LDV);
               <<L40>> null;
            end loop;
         end if;
         --
         if LEFTV then
            II := 1 - 1;
            loop
               II := II + 1;
               exit when II > N;
               I := II;
               if I >= ILO and I <= IHI then
                  goto L50;
               end if;
               if I < ILO then
                  I := ILO - II;
               end if;
               K := int (SCALE (I));
               if K = I then
                  goto L50;
               end if;
               DSWAP (M, V (I, 1)'Address, LDV, V (K, 1)'Address, LDV);
               <<L50>> null;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of DGEBAK
      --
   end DGEBAK;

   procedure DGEBAL
     (JOB       : Character;
      N         : Integer;
      A_adr     : Address;
      LDA       : Integer;
      ILO       : in out Integer;
      IHI       : in out Integer;
      SCALE_adr : Address;
      INFO      : in out Integer)
   is

      A     : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      SCALE : Ftn_Real_Vector (1 .. N);

      for A'Address use A_adr;
      for SCALE'Address use SCALE_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, SCALE);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      SCLFAC : constant Real := 2.0e0;
      FACTOR : constant Real := 0.95e0;
      NOCONV : Boolean;
      I      : Integer;
      ICA    : Integer;
      IEXC   : Integer;
      IRA    : Integer;
      J      : Integer;
      K      : Integer;
      L      : Integer;
      M      : Integer;
      C      : Real;
      CA     : Real;
      F      : Real;
      G      : Real;
      R      : Real;
      RA     : Real;
      S      : Real;
      SFMAX1 : Real;
      SFMAX2 : Real;
      SFMIN1 : Real;
      SFMIN2 : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEBAL( JOB, N, A, LDA, ILO, IHI, SCALE, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOB
   --       INTEGER            IHI, ILO, INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), SCALE( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEBAL balances a general real matrix A.  This involves, first,
   --  permuting A by a similarity transformation to isolate eigenvalues
   --  in the first 1 to ILO-1 and last IHI+1 to N elements on the
   --  diagonal; and second, applying a diagonal similarity transformation
   --  to rows and columns ILO to IHI to make the rows and columns as
   --  close in norm as possible.  Both steps are optional.
   --
   --  Balancing may reduce the 1-norm of the matrix, and improve the
   --  accuracy of the computed eigenvalues and/or eigenvectors.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOB
   --           JOB is CHARACTER*1
   --           Specifies the operations to be performed on A:
   --           = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
   --                   for i = 1,...,N;
   --           = 'P':  permute only;
   --           = 'S':  scale only;
   --           = 'B':  both permute and scale.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is Real array, dimension (LDA,N)
   --           On entry, the input matrix A.
   --           On exit,  A is overwritten by the balanced matrix.
   --           If JOB = 'N', A is not referenced.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] ILO
   --           ILO is INTEGER
   --  [out] IHI
   --           IHI is INTEGER
   --           ILO and IHI are set to integers such that on exit
   --           A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
   --           If JOB = 'N' or 'S', ILO = 1 and IHI = N.
   --
   --  [out] SCALE
   --           SCALE is Real array, dimension (N)
   --           Details of the permutations and scaling factors applied to
   --           A.  If P(j) is the index of the row and column interchanged
   --           with row and column j and D(j) is the scaling factor
   --           applied to row and column j, then
   --           SCALE(j) = P(j)    for j = 1,...,ILO-1
   --                    = D(j)    for j = ILO,...,IHI
   --                    = P(j)    for j = IHI+1,...,N.
   --           The order in which the interchanges are made is N to IHI+1,
   --           then 1 to ILO-1.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The permutations consist of row and column interchanges which put
   --   the matrix in the form
   --
   --              ( T1   X   Y  )
   --      P A P = (  0   B   Z  )
   --              (  0   0   T2 )
   --
   --   where T1 and T2 are upper triangular matrices whose eigenvalues lie
   --   along the diagonal.  The column indices ILO and IHI mark the starting
   --   and ending columns of the submatrix B. Balancing consists of applying
   --   a diagonal similarity transformation inv(D) * B * D to make the
   --   1-norms of each row of B and its corresponding column nearly equal.
   --   The output matrix is
   --
   --      ( T1     X*D          Y    )
   --      (  0  inv(D)*B*D  inv(D)*Z ).
   --      (  0      0           T2   )
   --
   --   Information about the permutations P and the diagonal matrix D is
   --   returned in the vector SCALE.
   --
   --   This subroutine is based on the EISPACK routine BALANC.
   --
   --   Modified by Tzu-Yi Chen, Computer Science Division, University of
   --     California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( SCLFAC = 2.0D+0 )
   --      PARAMETER          ( FACTOR = 0.95D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            DISNAN, LSAME
   --      INTEGER            IDAMAX
   --      DOUBLE PRECISION   DLAMCH
   --      EXTERNAL           DISNAN, LSAME, IDAMAX, DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DSCAL, DSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO := 0;
      if not LSAME (JOB, 'N') and not LSAME (JOB, 'P') and not LSAME (JOB, 'S') and not LSAME (JOB, 'B') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("DGEBAL", -INFO);
         return;
      end if;
      --
      K := 1;
      L := N;
      --
      if N = 0 then
         goto L210;
      end if;
      --
      if LSAME (JOB, 'N') then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            SCALE (I) := ONE;
         end loop;
         goto L210;
      end if;
      --
      if LSAME (JOB, 'S') then
         goto L120;
      end if;
      --
      --     Permutation to isolate eigenvalues if possible
      --
      goto L50;
      --
      --     Row and column exchange.
      --
      <<L20>> null;
      SCALE (M) := Real (J);
      if J = M then
         goto L30;
      end if;
      --
      DSWAP (L, A (1, J)'Address, 1, A (1, M)'Address, 1);
      DSWAP (N - K + 1, A (J, K)'Address, LDA, A (M, K)'Address, LDA);
      --
      <<L30>> null;
      --      GO TO ( 40, 80 )IEXC
      if IEXC = 1 then
         goto L40;
      elsif IEXC = 2 then
         goto L80;
      end if;
      --
      --     Search for rows isolating an eigenvalue and push them down.
      --
      <<L40>> null;
      if L = 1 then
         goto L210;
      end if;
      L := L - 1;
      --
      <<L50>> null;
      J := L + 1;
      loop
         J := J - 1;
         exit when J < 1;
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > L;
            if I = J then
               goto L60;
            end if;
            if A (J, I) /= ZERO then
               goto L70;
            end if;
            <<L60>> null;
         end loop;
         --
         M    := L;
         IEXC := 1;
         goto L20;
         <<L70>> null;
      end loop;
      --
      goto L90;
      --
      --     Search for columns isolating an eigenvalue and push them left.
      --
      <<L80>> null;
      K := K + 1;
      --
      <<L90>> null;
      J := K - 1;
      loop
         J := J + 1;
         exit when J > L;
         --
         I := K - 1;
         loop
            I := I + 1;
            exit when I > L;
            if I = J then
               goto L100;
            end if;
            if A (I, J) /= ZERO then
               goto L110;
            end if;
            <<L100>> null;
         end loop;
         --
         M    := K;
         IEXC := 2;
         goto L20;
         <<L110>> null;
      end loop;
      --
      <<L120>> null;
      I := K - 1;
      loop
         I := I + 1;
         exit when I > L;
         SCALE (I) := ONE;
      end loop;
      --
      if LSAME (JOB, 'P') then
         goto L210;
      end if;
      --
      --     Balance the submatrix in rows K to L.
      --
      --     Iterative loop for norm reduction
      --
      SFMIN1 := DLAMCH ('S') / DLAMCH ('P');
      SFMAX1 := ONE / SFMIN1;
      SFMIN2 := SFMIN1 * SCLFAC;
      SFMAX2 := ONE / SFMIN2;
      <<L140>> null;
      NOCONV := False;
      --
      I := K - 1;
      loop
         I := I + 1;
         exit when I > L;
         C := ZERO;
         R := ZERO;
         --
         J := K - 1;
         loop
            J := J + 1;
            exit when J > L;
            if J = I then
               goto L150;
            end if;
            C := C + abs (A (J, I));
            R := R + abs (A (I, J));
            <<L150>> null;
         end loop;
         ICA := IDAMAX (L, A (1, I)'Address, 1);
         CA  := abs (A (ICA, I));
         IRA := IDAMAX (N - K + 1, A (I, K)'Address, LDA);
         RA  := abs (A (I, IRA + K - 1));
         --
         --        Guard against zero C or R due to underflow.
         --
         if C = ZERO or R = ZERO then
            goto L200;
         end if;
         G := R / SCLFAC;
         F := ONE;
         S := C + R;
         <<L160>> null;
         if C >= G or max (F, C, CA) >= SFMAX2 or min (R, G, RA) <= SFMIN2 then
            -- ?? ---------------------------
            goto L170;
            -- ?? ---------------------------
         end if;
         if DISNAN (C + F + CA + R + G + RA) then
            --
            --           Exit if NaN to avoid infinite loop
            --
            INFO := -3;
            XERBLA ("DGEBAL", -INFO);
            return;
         end if;
         F  := F * SCLFAC;
         C  := C * SCLFAC;
         CA := CA * SCLFAC;
         R  := R / SCLFAC;
         G  := G / SCLFAC;
         RA := RA / SCLFAC;
         -- ?? ---------------------------
         goto L160;
         -- ?? ---------------------------
         --
         <<L170>> null;
         G := C / SCLFAC;
         <<L180>> null;
         if G < R or max (R, RA) >= SFMAX2 or min (F, C, G, CA) <= SFMIN2 then
            -- ?? ---------------------------
            goto L190;
            -- ?? ---------------------------
         end if;
         F  := F / SCLFAC;
         C  := C / SCLFAC;
         G  := G / SCLFAC;
         CA := CA / SCLFAC;
         R  := R * SCLFAC;
         RA := RA * SCLFAC;
         -- ?? ---------------------------
         goto L180;
         -- ?? ---------------------------
         --
         --        Now balance.
         --
         <<L190>> null;
         if (C + R) >= FACTOR * S then
            goto L200;
         end if;
         if F < ONE and SCALE (I) < ONE then
            if F * SCALE (I) <= SFMIN1 then
               goto L200;
            end if;
         end if;
         if F > ONE and SCALE (I) > ONE then
            if SCALE (I) >= SFMAX1 / F then
               goto L200;
            end if;
         end if;
         G         := ONE / F;
         SCALE (I) := SCALE (I) * F;
         NOCONV    := True;
         --
         DSCAL (N - K + 1, G, A (I, K)'Address, LDA);
         DSCAL (L, F, A (1, I)'Address, 1);
         --
         <<L200>> null;
      end loop;
      --
      if NOCONV then
         goto L140;
      end if;
      --
      <<L210>> null;
      ILO := K;
      IHI := L;
      --
      return;
      --
      --     End of DGEBAL
      --
   end DGEBAL;

   procedure DGEBD2
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      TAUQ_adr : Address;
      TAUP_adr : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      D    : Ftn_Real_Vector (1 .. min (M, N));
      E    : Ftn_Real_Vector (1 .. min (M, N) - 1);
      TAUQ : Ftn_Real_Vector (1 .. min (M, N));
      TAUP : Ftn_Real_Vector (1 .. min (M, N));
      WORK : Ftn_Real_Vector (1 .. max (M, N));

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAUQ'Address use TAUQ_adr;
      for TAUP'Address use TAUP_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAUQ);
      pragma Import (Ada, TAUP);
      pragma Import (Ada, WORK);

      ZERO : constant Real := 0.0e0;
      ONE  : constant Real := 1.0e0;
      I    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEBD2( M, N, A, LDA, D, E, TAUQ, TAUP, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAUP( * ),
   --      $                   TAUQ( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEBD2 reduces a real general m by n matrix A to upper or lower
   --  bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
   --
   --  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows in the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns in the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the m by n general matrix to be reduced.
   --           On exit,
   --           if m >= n, the diagonal and the first superdiagonal are
   --             overwritten with the upper bidiagonal matrix B; the
   --             elements below the diagonal, with the array TAUQ, represent
   --             the orthogonal matrix Q as a product of elementary
   --             reflectors, and the elements above the first superdiagonal,
   --             with the array TAUP, represent the orthogonal matrix P as
   --             a product of elementary reflectors;
   --           if m < n, the diagonal and the first subdiagonal are
   --             overwritten with the lower bidiagonal matrix B; the
   --             elements below the first subdiagonal, with the array TAUQ,
   --             represent the orthogonal matrix Q as a product of
   --             elementary reflectors, and the elements above the diagonal,
   --             with the array TAUP, represent the orthogonal matrix P as
   --             a product of elementary reflectors.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (min(M,N))
   --           The diagonal elements of the bidiagonal matrix B:
   --           D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (min(M,N)-1)
   --           The off-diagonal elements of the bidiagonal matrix B:
   --           if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
   --           if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
   --
   --  [out] TAUQ
   --           TAUQ is DOUBLE PRECISION array dimension (min(M,N))
   --           The scalar factors of the elementary reflectors which
   --           represent the orthogonal matrix Q. See Further Details.
   --
   --  [out] TAUP
   --           TAUP is DOUBLE PRECISION array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors which
   --           represent the orthogonal matrix P. See Further Details.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (max(M,N))
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit.
   --           < 0: if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrices Q and P are represented as products of elementary
   --   reflectors:
   --
   --   If m >= n,
   --
   --      Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
   --
   --   where tauq and taup are real scalars, and v and u are real vectors;
   --   v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
   --   u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
   --   tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   If m < n,
   --
   --      Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
   --
   --   where tauq and taup are real scalars, and v and u are real vectors;
   --   v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
   --   u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
   --   tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   The contents of A on exit are illustrated by the following examples:
   --
   --   m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
   --
   --     (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
   --     (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
   --     (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
   --     (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
   --     (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
   --     (  v1  v2  v3  v4  v5 )
   --
   --   where d and e denote diagonal and off-diagonal elements of B, vi
   --   denotes an element of the vector defining H(i), and ui an element of
   --   the vector defining G(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, DLARFG, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO < 0 then
         XERBLA ("DGEBD2", -INFO);
         return;
      end if;
      --
      if M >= N then
         --
         --        Reduce to upper bidiagonal form
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            --
            --           Generate elementary reflector H(i) to annihilate A(i+1:m,i)
            --
            DLARFG (M - I + 1, A (I, I), A (min (I + 1, M), I)'Address, 1, TAUQ (I));
            D (I)    := A (I, I);
            A (I, I) := ONE;
            --
            --           Apply H(i) to A(i:m,i+1:n) from the left
            --
            if I < N then
               DLARF ('L', M - I + 1, N - I, A (I, I)'Address, 1, TAUQ (I), A (I, I + 1)'Address, LDA, WORK'Address);
            end if;
            A (I, I) := D (I);
            --
            if I < N then
               --
               --              Generate elementary reflector G(i) to annihilate
               --              A(i,i+2:n)
               --
               DLARFG (N - I, A (I, I + 1), A (I, min (I + 2, N))'Address, LDA, TAUP (I));
               E (I)        := A (I, I + 1);
               A (I, I + 1) := ONE;
               --
               --              Apply G(i) to A(i+1:m,i+1:n) from the right
               --
               DLARF ('R', M - I, N - I, A (I, I + 1)'Address, LDA, TAUP (I), A (I + 1, I + 1)'Address, LDA, WORK'Address);
               A (I, I + 1) := E (I);
            else
               TAUP (I) := ZERO;
            end if;
         end loop;
      else
         --
         --        Reduce to lower bidiagonal form
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            --
            --           Generate elementary reflector G(i) to annihilate A(i,i+1:n)
            --
            DLARFG (N - I + 1, A (I, I), A (I, min (I + 1, N))'Address, LDA, TAUP (I));
            D (I)    := A (I, I);
            A (I, I) := ONE;
            --
            --           Apply G(i) to A(i+1:m,i:n) from the right
            --
            if I < M then
               DLARF ('R', M - I, N - I + 1, A (I, I)'Address, LDA, TAUP (I), A (I + 1, I)'Address, LDA, WORK'Address);
            end if;
            A (I, I) := D (I);
            --
            if I < M then
               --
               --              Generate elementary reflector H(i) to annihilate
               --              A(i+2:m,i)
               --
               DLARFG (M - I, A (I + 1, I), A (min (I + 2, M), I)'Address, 1, TAUQ (I));
               E (I)        := A (I + 1, I);
               A (I + 1, I) := ONE;
               --
               --              Apply H(i) to A(i+1:m,i+1:n) from the left
               --
               DLARF ('L', M - I, N - I, A (I + 1, I)'Address, 1, TAUQ (I), A (I + 1, I + 1)'Address, LDA, WORK'Address);
               A (I + 1, I) := E (I);
            else
               TAUQ (I) := ZERO;
            end if;
         end loop;
      end if;
      return;
      --
      --     End of DGEBD2
      --
   end DGEBD2;

   procedure DGEBRD
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      TAUQ_adr : Address;
      TAUP_adr : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      D    : Ftn_Real_Vector (1 .. min (M, N));
      E    : Ftn_Real_Vector (1 .. min (M, N) - 1);
      TAUQ : Ftn_Real_Vector (1 .. min (M, N));
      TAUP : Ftn_Real_Vector (1 .. min (M, N));
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAUQ'Address use TAUQ_adr;
      for TAUP'Address use TAUP_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAUQ);
      pragma Import (Ada, TAUP);
      pragma Import (Ada, WORK);

      ONE    : constant Real := 1.0e0;
      LQUERY : Boolean;
      I      : Integer;
      IINFO  : Integer;
      J      : Integer;
      LDWRKX : Integer;
      LDWRKY : Integer;
      LWKOPT : Integer;
      MINMN  : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
      WS     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEBRD( M, N, A, LDA, D, E, TAUQ, TAUP, WORK, LWORK,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAUP( * ),
   --      $                   TAUQ( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEBRD reduces a general real M-by-N matrix A to upper or lower
   --  bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.
   --
   --  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows in the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns in the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the M-by-N general matrix to be reduced.
   --           On exit,
   --           if m >= n, the diagonal and the first superdiagonal are
   --             overwritten with the upper bidiagonal matrix B; the
   --             elements below the diagonal, with the array TAUQ, represent
   --             the orthogonal matrix Q as a product of elementary
   --             reflectors, and the elements above the first superdiagonal,
   --             with the array TAUP, represent the orthogonal matrix P as
   --             a product of elementary reflectors;
   --           if m < n, the diagonal and the first subdiagonal are
   --             overwritten with the lower bidiagonal matrix B; the
   --             elements below the first subdiagonal, with the array TAUQ,
   --             represent the orthogonal matrix Q as a product of
   --             elementary reflectors, and the elements above the diagonal,
   --             with the array TAUP, represent the orthogonal matrix P as
   --             a product of elementary reflectors.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (min(M,N))
   --           The diagonal elements of the bidiagonal matrix B:
   --           D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (min(M,N)-1)
   --           The off-diagonal elements of the bidiagonal matrix B:
   --           if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
   --           if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
   --
   --  [out] TAUQ
   --           TAUQ is DOUBLE PRECISION array dimension (min(M,N))
   --           The scalar factors of the elementary reflectors which
   --           represent the orthogonal matrix Q. See Further Details.
   --
   --  [out] TAUP
   --           TAUP is DOUBLE PRECISION array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors which
   --           represent the orthogonal matrix P. See Further Details.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of the array WORK.  LWORK >= max(1,M,N).
   --           For optimum performance LWORK >= (M+N)*NB, where NB
   --           is the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrices Q and P are represented as products of elementary
   --   reflectors:
   --
   --   If m >= n,
   --
   --      Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
   --
   --   where tauq and taup are real scalars, and v and u are real vectors;
   --   v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
   --   u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
   --   tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   If m < n,
   --
   --      Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
   --
   --   where tauq and taup are real scalars, and v and u are real vectors;
   --   v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
   --   u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
   --   tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   The contents of A on exit are illustrated by the following examples:
   --
   --   m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
   --
   --     (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
   --     (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
   --     (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
   --     (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
   --     (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
   --     (  v1  v2  v3  v4  v5 )
   --
   --   where d and e denote diagonal and off-diagonal elements of B, vi
   --   denotes an element of the vector defining H(i), and ui an element of
   --   the vector defining G(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEBD2, DGEMM, DLABRD, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO     := 0;
      NB       := max (1, ILAENV (1, "DGEBRD", " ", M, N, -1, -1));
      LWKOPT   := (M + N) * NB;
      WORK (1) := Real (LWKOPT);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      elsif LWORK < max (1, M, N) and not LQUERY then
         INFO := -10;
      end if;
      if INFO < 0 then
         XERBLA ("DGEBRD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      MINMN := min (M, N);
      if MINMN = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      WS     := Real (max (M, N));
      LDWRKX := M;
      LDWRKY := N;
      --
      if NB > 1 and NB < MINMN then
         --
         --        Set the crossover point NX.
         --
         NX := max (NB, ILAENV (3, "DGEBRD", " ", M, N, -1, -1));
         --
         --        Determine when to switch from blocked to unblocked code.
         --
         if NX < MINMN then
            WS := Real ((M + N) * NB);
            if Real (LWORK) < WS then
               --
               --              Not enough work space for the optimal NB, consider using
               --              a smaller block size.
               --
               NBMIN := ILAENV (2, "DGEBRD", " ", M, N, -1, -1);
               if LWORK >= (M + N) * NBMIN then
                  NB := LWORK / (M + N);
               else
                  NB := 1;
                  NX := MINMN;
               end if;
            end if;
         end if;
      else
         NX := MINMN;
      end if;
      --
      I := 1 - NB;
      loop
         I := I + NB;
         exit when I > MINMN - NX;
         --
         --        Reduce rows and columns i:i+nb-1 to bidiagonal form and return
         --        the matrices X and Y which are needed to update the unreduced
         --        part of the matrix
         --
         DLABRD
           (M - I + 1,
            N - I + 1,
            NB,
            A (I, I)'Address,
            LDA,
            D (I)'Address,
            E (I)'Address,
            TAUQ (I)'Address,
            TAUP (I)'Address,
            WORK'Address,
            LDWRKX,
            WORK (LDWRKX * NB + 1)'Address,
            LDWRKY);
         --
         --        Update the trailing submatrix A(i+nb:m,i+nb:n), using an update
         --        of the form  A := A - V*Y**T - X*U**T
         --
         DGEMM
           ('N',
            'T',
            M - I - NB + 1,
            N - I - NB + 1,
            NB,
            -ONE,
            A (I + NB, I)'Address,
            LDA,
            WORK (LDWRKX * NB + NB + 1)'Address,
            LDWRKY,
            ONE,
            A (I + NB, I + NB)'Address,
            LDA);
         DGEMM
           ('N',
            'N',
            M - I - NB + 1,
            N - I - NB + 1,
            NB,
            -ONE,
            WORK (NB + 1)'Address,
            LDWRKX,
            A (I, I + NB)'Address,
            LDA,
            ONE,
            A (I + NB, I + NB)'Address,
            LDA);
         --
         --        Copy diagonal and off-diagonal elements of B back into A
         --
         if M >= N then
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + NB - 1;
               A (J, J)     := D (J);
               A (J, J + 1) := E (J);
            end loop;
         else
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + NB - 1;
               A (J, J)     := D (J);
               A (J + 1, J) := E (J);
            end loop;
         end if;
      end loop;
      --
      --     Use unblocked code to reduce the remainder of the matrix
      --
      DGEBD2
        (M - I + 1,
         N - I + 1,
         A (I, I)'Address,
         LDA,
         D (I)'Address,
         E (I)'Address,
         TAUQ (I)'Address,
         TAUP (I)'Address,
         WORK'Address,
         IINFO);
      WORK (1) := WS;
      return;
      --
      --     End of DGEBRD
      --
   end DGEBRD;

   procedure DGEEV
     (JOBVL : Character;
      JOBVR : Character;
      N     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      WR    : in out Ftn_Real_Vector;
      WI    : in out Ftn_Real_Vector;
      VL    : in out Ftn_Real_Matrix;
      LDVL  : Integer;
      VR    : in out Ftn_Real_Matrix;
      LDVR  : Integer;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      ZERO       : constant Real := 0.0e0;
      ONE        : constant Real := 1.0e0;
      LQUERY     : Boolean;
      SCALEA     : Boolean;
      WANTVL     : Boolean;
      WANTVR     : Boolean;
      SIDE       : Character;
      HSWORK     : Integer;
      I          : Integer;
      IBAL       : Integer;
      IERR       : Integer;
      IHI        : Integer;
      ILO        : Integer;
      ITAU       : Integer;
      IWRK       : Integer;
      K          : Integer;
      MAXWRK     : Integer;
      MINWRK     : Integer;
      NOUT       : Integer;
      ANRM       : Real;
      BIGNUM     : Real;
      CS         : Real;
      CSCALE     : Real;
      EPS        : Real;
      R          : Real;
      SCL        : Real;
      SMLNUM     : Real;
      SN         : Real;
      the_SELECT : Ftn_Boolean_Vector (1 .. 1);
      DUM        : Ftn_Real_Vector (1 .. 1);
   --  DGEEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEEV( JOBVL, JOBVR, N, A, LDA, WR, WI, VL, LDVL, VR,
   --                         LDVR, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBVL, JOBVR
   --       INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),
   --      $                   WI( * ), WORK( * ), WR( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEEV computes for an N-by-N real nonsymmetric matrix A, the
   --  eigenvalues and, optionally, the left and/or right eigenvectors.
   --
   --  The right eigenvector v(j) of A satisfies
   --                   A * v(j) = lambda(j) * v(j)
   --  where lambda(j) is its eigenvalue.
   --  The left eigenvector u(j) of A satisfies
   --                u(j)**T * A = lambda(j) * u(j)**T
   --  where u(j)**T denotes the transpose of u(j).
   --
   --  The computed eigenvectors are normalized to have Euclidean norm
   --  equal to 1 and largest component real.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBVL
   --           JOBVL is CHARACTER*1
   --           = 'N': left eigenvectors of A are not computed;
   --           = 'V': left eigenvectors of A are computed.
   --
   --  [in] JOBVR
   --           JOBVR is CHARACTER*1
   --           = 'N': right eigenvectors of A are not computed;
   --           = 'V': right eigenvectors of A are computed.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A. N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the N-by-N matrix A.
   --           On exit, A has been overwritten.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] WR
   --           WR is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] WI
   --           WI is DOUBLE PRECISION array, dimension (N)
   --           WR and WI contain the real and imaginary parts,
   --           respectively, of the computed eigenvalues.  Complex
   --           conjugate pairs of eigenvalues appear consecutively
   --           with the eigenvalue having the positive imaginary part
   --           first.
   --
   --  [out] VL
   --           VL is DOUBLE PRECISION array, dimension (LDVL,N)
   --           If JOBVL = 'V', the left eigenvectors u(j) are stored one
   --           after another in the columns of VL, in the same order
   --           as their eigenvalues.
   --           If JOBVL = 'N', VL is not referenced.
   --           If the j-th eigenvalue is real, then u(j) = VL(:,j),
   --           the j-th column of VL.
   --           If the j-th and (j+1)-st eigenvalues form a complex
   --           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
   --           u(j+1) = VL(:,j) - i*VL(:,j+1).
   --
   --  [in] LDVL
   --           LDVL is INTEGER
   --           The leading dimension of the array VL.  LDVL >= 1; if
   --           JOBVL = 'V', LDVL >= N.
   --
   --  [out] VR
   --           VR is DOUBLE PRECISION array, dimension (LDVR,N)
   --           If JOBVR = 'V', the right eigenvectors v(j) are stored one
   --           after another in the columns of VR, in the same order
   --           as their eigenvalues.
   --           If JOBVR = 'N', VR is not referenced.
   --           If the j-th eigenvalue is real, then v(j) = VR(:,j),
   --           the j-th column of VR.
   --           If the j-th and (j+1)-st eigenvalues form a complex
   --           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
   --           v(j+1) = VR(:,j) - i*VR(:,j+1).
   --
   --  [in] LDVR
   --           LDVR is INTEGER
   --           The leading dimension of the array VR.  LDVR >= 1; if
   --           JOBVR = 'V', LDVR >= N.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= max(1,3*N), and
   --           if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
   --           performance, LWORK must generally be larger.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = i, the QR algorithm failed to compute all the
   --                 eigenvalues, and no eigenvectors have been computed;
   --                 elements i+1:N of WR and WI contain eigenvalues which
   --                 have converged.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEBAK, DGEBAL, DGEHRD, DHSEQR, DLABAD, DLACPY,
   --     $                   DLARTG, DLASCL, DORGHR, DROT, DSCAL, DTREVC,
   --     $                   XERBLA
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      INTEGER            IDAMAX, ILAENV
   --      DOUBLE PRECISION   DLAMCH, DLANGE, DLAPY2, DNRM2
   --      EXTERNAL           LSAME, IDAMAX, ILAENV, DLAMCH, DLANGE, DLAPY2,
   --     $                   DNRM2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1);
      WANTVL := LSAME (JOBVL, 'V');
      WANTVR := LSAME (JOBVR, 'V');
      if (not WANTVL) and (not LSAME (JOBVL, 'N')) then
         INFO := -1;
      elsif (not WANTVR) and (not LSAME (JOBVR, 'N')) then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDVL < 1 or (WANTVL and LDVL < N) then
         INFO := -9;
      elsif LDVR < 1 or (WANTVR and LDVR < N) then
         INFO := -11;
      end if;
      --
      --     Compute workspace
      --      (Note: Comments in the code beginning "Workspace:" describe the
      --       minimal amount of workspace needed at that point in the code,
      --       as well as the preferred amount for good performance.
      --       NB refers to the optimal block size for the immediately
      --       following subroutine, as returned by ILAENV.
      --       HSWORK refers to the workspace preferred by DHSEQR, as
      --       calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
      --       the worst case.)
      --
      if INFO = 0 then
         if N = 0 then
            MINWRK := 1;
            MAXWRK := 1;
         else
            MAXWRK := 2 * N + N * ILAENV (1, "DGEHRD", " ", N, 1, N, 0);
            if WANTVL then
               MINWRK := 4 * N;
               MAXWRK := max (MAXWRK, 2 * N + (N - 1) * ILAENV (1, "DORGHR", " ", N, 1, N, -1));
               DHSEQR ('S', 'V', N, 1, N, A'Address, LDA, WR'Address, WI'Address, VL'Address, LDVL, WORK'Address, -1, INFO);
               HSWORK := int (WORK (1));
               MAXWRK := max (MAXWRK, N + 1, N + HSWORK);
               MAXWRK := max (MAXWRK, 4 * N);
            elsif WANTVR then
               MINWRK := 4 * N;
               MAXWRK := max (MAXWRK, 2 * N + (N - 1) * ILAENV (1, "DORGHR", " ", N, 1, N, -1));
               DHSEQR ('S', 'V', N, 1, N, A'Address, LDA, WR'Address, WI'Address, VR'Address, LDVR, WORK'Address, -1, INFO);
               HSWORK := int (WORK (1));
               MAXWRK := max (MAXWRK, N + 1, N + HSWORK);
               MAXWRK := max (MAXWRK, 4 * N);
            else
               MINWRK := 3 * N;
               DHSEQR ('E', 'N', N, 1, N, A'Address, LDA, WR'Address, WI'Address, VR'Address, LDVR, WORK'Address, -1, INFO);
               HSWORK := int (WORK (1));
               MAXWRK := max (MAXWRK, N + 1, N + HSWORK);
            end if;
            MAXWRK := max (MAXWRK, MINWRK);
         end if;
         WORK (1) := Real (MAXWRK);
         --
         if LWORK < MINWRK and not LQUERY then
            INFO := -13;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DGEEV ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     Get machine constants
      --
      EPS    := DLAMCH ('P');
      SMLNUM := DLAMCH ('S');
      BIGNUM := ONE / SMLNUM;
      DLABAD (SMLNUM, BIGNUM);
      SMLNUM := Sqrt (SMLNUM) / EPS;
      BIGNUM := ONE / SMLNUM;
      --
      --     Scale A if max element outside range [SMLNUM,BIGNUM]
      --
      ANRM   := DLANGE ('M', N, N, A, LDA, DUM);
      SCALEA := False;
      if ANRM > ZERO and ANRM < SMLNUM then
         SCALEA := True;
         CSCALE := SMLNUM;
      elsif ANRM > BIGNUM then
         SCALEA := True;
         CSCALE := BIGNUM;
      end if;
      if SCALEA then
         DLASCL ('G', 0, 0, ANRM, CSCALE, N, N, A'Address, LDA, IERR);
      end if;
      --
      --     Balance the matrix
      --     (Workspace: need N)
      --
      IBAL := 1;
      DGEBAL ('B', N, A'Address, LDA, ILO, IHI, WORK (IBAL)'Address, IERR);
      --
      --     Reduce to upper Hessenberg form
      --     (Workspace: need 3*N, prefer 2*N+N*NB)
      --
      ITAU := IBAL + N;
      IWRK := ITAU + N;
      DGEHRD (N, ILO, IHI, A'Address, LDA, WORK (ITAU)'Address, WORK (IWRK)'Address, LWORK - IWRK + 1, IERR);
      --
      if WANTVL then
         --
         --        Want left eigenvectors
         --        Copy Householder vectors to VL
         --
         SIDE := 'L';
         DLACPY ('L', N, N, A'Address, LDA, VL'Address, LDVL);
         --
         --        Generate orthogonal matrix in VL
         --        (Workspace: need 3*N-1, prefer 2*N+(N-1)*NB)
         --
         DORGHR (N, ILO, IHI, VL'Address, LDVL, WORK (ITAU)'Address, WORK (IWRK)'Address, LWORK - IWRK + 1, IERR);
         --
         --        Perform QR iteration, accumulating Schur vectors in VL
         --        (Workspace: need N+1, prefer N+HSWORK (see comments) )
         --
         IWRK := ITAU;
         DHSEQR
           ('S',
            'V',
            N,
            ILO,
            IHI,
            A'Address,
            LDA,
            WR'Address,
            WI'Address,
            VL'Address,
            LDVL,
            WORK (IWRK)'Address,
            LWORK - IWRK + 1,
            INFO);
         --
         if WANTVR then
            --
            --           Want left and right eigenvectors
            --           Copy Schur vectors to VR
            --
            SIDE := 'B';
            DLACPY ('F', N, N, VL'Address, LDVL, VR'Address, LDVR);
         end if;
      --
      elsif WANTVR then
         --
         --        Want right eigenvectors
         --        Copy Householder vectors to VR
         --
         SIDE := 'R';
         DLACPY ('L', N, N, A'Address, LDA, VR'Address, LDVR);
         --
         --        Generate orthogonal matrix in VR
         --        (Workspace: need 3*N-1, prefer 2*N+(N-1)*NB)
         --
         DORGHR (N, ILO, IHI, VR'Address, LDVR, WORK (ITAU)'Address, WORK (IWRK)'Address, LWORK - IWRK + 1, IERR);
         --
         --        Perform QR iteration, accumulating Schur vectors in VR
         --        (Workspace: need N+1, prefer N+HSWORK (see comments) )
         --
         IWRK := ITAU;
         DHSEQR
           ('S',
            'V',
            N,
            ILO,
            IHI,
            A'Address,
            LDA,
            WR'Address,
            WI'Address,
            VR'Address,
            LDVR,
            WORK (IWRK)'Address,
            LWORK - IWRK + 1,
            INFO);
      --
      else
         --
         --        Compute eigenvalues only
         --        (Workspace: need N+1, prefer N+HSWORK (see comments) )
         --
         IWRK := ITAU;
         DHSEQR
           ('E',
            'N',
            N,
            ILO,
            IHI,
            A'Address,
            LDA,
            WR'Address,
            WI'Address,
            VR'Address,
            LDVR,
            WORK (IWRK)'Address,
            LWORK - IWRK + 1,
            INFO);
      end if;
      --
      --     If INFO > 0 from DHSEQR, then quit
      --
      if INFO > 0 then
         goto L50;
      end if;
      --
      if WANTVL or WANTVR then
         --
         --        Compute left and/or right eigenvectors
         --        (Workspace: need 4*N)
         --
         DTREVC
           (SIDE,
            'B',
            the_SELECT'Address,
            N,
            A'Address,
            LDA,
            VL'Address,
            LDVL,
            VR'Address,
            LDVR,
            N,
            NOUT,
            WORK (IWRK)'Address,
            IERR);
      end if;
      --
      if WANTVL then
         --
         --        Undo balancing of left eigenvectors
         --        (Workspace: need N)
         --
         DGEBAK ('B', 'L', N, ILO, IHI, WORK (IBAL)'Address, N, VL'Address, LDVL, IERR);
         --
         --        Normalize left eigenvectors and make largest component real
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            if WI (I) = ZERO then
               SCL := ONE / DNRM2 (N, VL (1, I)'Address, 1);
               DSCAL (N, SCL, VL (1, I)'Address, 1);
            elsif WI (I) > ZERO then
               ---------------------------------------------------------------------------
               -- LCB: this block declared to overcome limitation of the 'Address parser
               declare
                  tmp1, tmp2 : Real;
               begin
                  tmp1 := DNRM2 (N, VL (1, I)'Address, 1);
                  tmp2 := DNRM2 (N, VL (1, I + 1)'Address, 1);
                  SCL  := ONE / DLAPY2 (tmp1, tmp2);
               end;
               ---------------------------------------------------------------------------
               DSCAL (N, SCL, VL (1, I)'Address, 1);
               DSCAL (N, SCL, VL (1, I + 1)'Address, 1);
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  WORK (IWRK + K - 1) := VL (K, I) ** 2 + VL (K, I + 1) ** 2;
               end loop;
               K := IDAMAX (N, WORK (IWRK)'Address, 1);
               DLARTG (VL (K, I), VL (K, I + 1), CS, SN, R);
               DROT (N, VL (1, I)'Address, 1, VL (1, I + 1)'Address, 1, CS, SN);
               VL (K, I + 1) := ZERO;
            end if;
         end loop;
      end if;
      --
      if WANTVR then
         --
         --        Undo balancing of right eigenvectors
         --        (Workspace: need N)
         --
         DGEBAK ('B', 'R', N, ILO, IHI, WORK (IBAL)'Address, N, VR'Address, LDVR, IERR);
         --
         --        Normalize right eigenvectors and make largest component real
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            if WI (I) = ZERO then
               SCL := ONE / DNRM2 (N, VR (1, I)'Address, 1);
               DSCAL (N, SCL, VR (1, I)'Address, 1);
            elsif WI (I) > ZERO then
               ---------------------------------------------------------------------------
               -- LCB: this block declared to overcome limitation of the 'Address parser
               declare
                  tmp1, tmp2 : Real;
               begin
                  tmp1 := DNRM2 (N, VR (1, I)'Address, 1);
                  tmp2 := DNRM2 (N, VR (1, I + 1)'Address, 1);
                  SCL  := ONE / DLAPY2 (tmp1, tmp2);
               end;
               ---------------------------------------------------------------------------
               DSCAL (N, SCL, VR (1, I)'Address, 1);
               DSCAL (N, SCL, VR (1, I + 1)'Address, 1);
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  WORK (IWRK + K - 1) := VR (K, I) ** 2 + VR (K, I + 1) ** 2;
               end loop;
               K := IDAMAX (N, WORK (IWRK)'Address, 1);
               DLARTG (VR (K, I), VR (K, I + 1), CS, SN, R);
               DROT (N, VR (1, I)'Address, 1, VR (1, I + 1)'Address, 1, CS, SN);
               VR (K, I + 1) := ZERO;
            end if;
         end loop;
      end if;
      --
      --     Undo scaling if necessary
      --
      <<L50>> null;
      if SCALEA then
         DLASCL ('G', 0, 0, CSCALE, ANRM, N - INFO, 1, WR (INFO + 1)'Address, max (N - INFO, 1), IERR);
         DLASCL ('G', 0, 0, CSCALE, ANRM, N - INFO, 1, WI (INFO + 1)'Address, max (N - INFO, 1), IERR);
         if INFO > 0 then
            DLASCL ('G', 0, 0, CSCALE, ANRM, ILO - 1, 1, WR'Address, N, IERR);
            DLASCL ('G', 0, 0, CSCALE, ANRM, ILO - 1, 1, WI'Address, N, IERR);
         end if;
      end if;
      --
      WORK (1) := Real (MAXWRK);
      return;
      --
      --     End of DGEEV
      --
   end DGEEV;

   procedure DGEHD2
     (N    : Integer;
      ILO  : Integer;
      IHI  : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer;
      TAU  : in out Ftn_Real_Vector;
      WORK : in out Ftn_Real_Vector;
      INFO : in out Integer)
   is
      ONE : constant Real := 1.0e0;
      I   : Integer;
      AII : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEHD2( N, ILO, IHI, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEHD2 reduces a real general matrix A to upper Hessenberg form H by
   --  an orthogonal similarity transformation:  Q**T * A * Q = H .
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --           It is assumed that A is already upper triangular in rows
   --           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
   --           set by a previous call to DGEBAL; otherwise they should be
   --           set to 1 and N respectively. See Further Details.
   --           1 <= ILO <= IHI <= max(1,N).
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the n by n general matrix to be reduced.
   --           On exit, the upper triangle and the first subdiagonal of A
   --           are overwritten with the upper Hessenberg matrix H, and the
   --           elements below the first subdiagonal, with the array TAU,
   --           represent the orthogonal matrix Q as a product of elementary
   --           reflectors. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (N-1)
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of (ihi-ilo) elementary
   --   reflectors
   --
   --      Q = H(ilo) H(ilo+1) . . . H(ihi-1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
   --   exit in A(i+2:ihi,i), and tau in TAU(i).
   --
   --   The contents of A are illustrated by the following example, with
   --   n = 7, ilo = 2 and ihi = 6:
   --
   --   on entry,                        on exit,
   --
   --   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
   --   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
   --   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
   --   (                         a )    (                          a )
   --
   --   where a denotes an element of the original matrix A, h denotes a
   --   modified element of the upper Hessenberg matrix H, and vi denotes an
   --   element of the vector defining H(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, DLARFG, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO := 0;
      if N < 0 then
         INFO := -1;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -2;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("DGEHD2", -INFO);
         return;
      end if;
      --
      I := ILO - 1;
      loop
         I := I + 1;
         exit when I > IHI - 1;
         --
         --        Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
         --
         DLARFG (IHI - I, A (I + 1, I), A (min (I + 2, N), I)'Address, 1, TAU (I));
         AII          := A (I + 1, I);
         A (I + 1, I) := ONE;
         --
         --        Apply H(i) to A(1:ihi,i+1:ihi) from the right
         --
         DLARF ('R', IHI, IHI - I, A (I + 1, I)'Address, 1, TAU (I), A (1, I + 1)'Address, LDA, WORK'Address);
         --
         --        Apply H(i) to A(i+1:ihi,i+1:n) from the left
         --
         DLARF ('L', IHI - I, N - I, A (I + 1, I)'Address, 1, TAU (I), A (I + 1, I + 1)'Address, LDA, WORK'Address);
         --
         A (I + 1, I) := AII;
      end loop;
      --
      return;
      --
      --     End of DGEHD2
      --
   end DGEHD2;

   procedure DGEHRD
     (N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. N - 1);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      NBMAX  : constant Integer := 64;
      LDT    : constant Integer := NBMAX + 1;
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NH     : Integer;
      NX     : Integer;
      EI     : Real;
      T      : Ftn_Real_Matrix (1 .. LDT, 1 .. NBMAX);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEHRD( N, ILO, IHI, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION  A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEHRD reduces a real general matrix A to upper Hessenberg form H by
   --  an orthogonal similarity transformation:  Q**T * A * Q = H .
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --           It is assumed that A is already upper triangular in rows
   --           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
   --           set by a previous call to DGEBAL; otherwise they should be
   --           set to 1 and N respectively. See Further Details.
   --           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the N-by-N general matrix to be reduced.
   --           On exit, the upper triangle and the first subdiagonal of A
   --           are overwritten with the upper Hessenberg matrix H, and the
   --           elements below the first subdiagonal, with the array TAU,
   --           represent the orthogonal matrix Q as a product of elementary
   --           reflectors. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (N-1)
   --           The scalar factors of the elementary reflectors (see Further
   --           Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
   --           zero.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (LWORK)
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of the array WORK.  LWORK >= max(1,N).
   --           For optimum performance LWORK >= N*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of (ihi-ilo) elementary
   --   reflectors
   --
   --      Q = H(ilo) H(ilo+1) . . . H(ihi-1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
   --   exit in A(i+2:ihi,i), and tau in TAU(i).
   --
   --   The contents of A are illustrated by the following example, with
   --   n = 7, ilo = 2 and ihi = 6:
   --
   --   on entry,                        on exit,
   --
   --   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
   --   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
   --   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
   --   (                         a )    (                          a )
   --
   --   where a denotes an element of the original matrix A, h denotes a
   --   modified element of the upper Hessenberg matrix H, and vi denotes an
   --   element of the vector defining H(i).
   --
   --   This file is a slight modification of LAPACK-3.0's DGEHRD
   --   subroutine incorporating improvements proposed by Quintana-Orti and
   --   Van de Geijn (2006). (See DLAHR2.)
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
   --      PARAMETER          ( ZERO = 0.0D+0,
   --     $                     ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DAXPY, DGEHD2, DGEMM, DLAHR2, DLARFB, DTRMM,
   --     $                   XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      INTEGER            ILAENV
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO     := 0;
      NB       := min (NBMAX, ILAENV (1, "DGEHRD", " ", N, ILO, IHI, -1));
      LWKOPT   := N * NB;
      WORK (1) := Real (LWKOPT);
      LQUERY   := (LWORK = -1);
      if N < 0 then
         INFO := -1;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -2;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("DGEHRD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Set elements 1:ILO-1 and IHI:N-1 of TAU to zero
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > ILO - 1;
         TAU (I) := ZERO;
      end loop;
      I := max (1, IHI) - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         TAU (I) := ZERO;
      end loop;
      --
      --     Quick return if possible
      --
      NH := IHI - ILO + 1;
      if NH <= 1 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      --     Determine the block size
      --
      NB    := min (NBMAX, ILAENV (1, "DGEHRD", " ", N, ILO, IHI, -1));
      NBMIN := 2;
      IWS   := 1;
      if NB > 1 and NB < NH then
         --
         --        Determine when to cross over from blocked to unblocked code
         --        (last block is always handled by unblocked code)
         --
         NX := max (NB, ILAENV (3, "DGEHRD", " ", N, ILO, IHI, -1));
         if NX < NH then
            --
            --           Determine if workspace is large enough for blocked code
            --
            IWS := N * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  determine the
               --              minimum value of NB, and reduce NB or force use of
               --              unblocked code
               --
               NBMIN := max (2, ILAENV (2, "DGEHRD", " ", N, ILO, IHI, -1));
               if LWORK >= N * NBMIN 
                  then NB := LWORK / N;
                  else NB := 1;
               end if;
            end if;
         end if;
      end if;
      LDWORK := N;
      --
      if NB < NBMIN or NB >= NH then
         --
         --        Use unblocked code below
         --
         I := ILO;
      --
      else
         --
         --        Use blocked code
         --
         I := ILO - NB;
         loop
            I := I + NB;
            exit when I > IHI - 1 - NX;
            IB := min (NB, IHI - I);
            --
            --           Reduce columns i:i+ib-1 to Hessenberg form, returning the
            --           matrices V and T of the block reflector H = I - V*T*V**T
            --           which performs the reduction, and also the matrix Y = A*V*T
            --
            DLAHR2 (IHI, I, IB, A (1, I)'Address, LDA, TAU (I)'Address, T'Address, LDT, WORK'Address, LDWORK);
            --
            --           Apply the block reflector H to A(1:ihi,i+ib:ihi) from the
            --           right, computing  A := A - Y * V**T. V(i+ib,ib-1) must be set
            --           to 1
            --
            EI                     := A (I + IB, I + IB - 1);
            A (I + IB, I + IB - 1) := ONE;
            DGEMM
              ('N',
               'T',
               IHI,
               IHI - I - IB + 1,
               IB,
               -ONE,
               WORK'Address,
               LDWORK,
               A (I + IB, I)'Address,
               LDA,
               ONE,
               A (1, I + IB)'Address,
               LDA);
            A (I + IB, I + IB - 1) := EI;
            --
            --           Apply the block reflector H to A(1:i,i+1:i+ib-1) from the
            --           right
            --
            DTRMM ('R', 'L', 'T', 'U', I, IB - 1, ONE, A (I + 1, I)'Address, LDA, WORK'Address, LDWORK);
            J := 0 - 1;
            loop
               J := J + 1;
               exit when J > IB - 2;
               DAXPY (I, -ONE, WORK (LDWORK * J + 1)'Address, 1, A (1, I + J + 1)'Address, 1);
            end loop;
            --
            --           Apply the block reflector H to A(i+1:ihi,i+ib:n) from the
            --           left
            --
            DLARFB
              ('L',
               'T',
               'F',
               'C',
               IHI - I,
               N - I - IB + 1,
               IB,
               A (I + 1, I)'Address,
               LDA,
               T'Address,
               LDT,
               A (I + 1, I + IB)'Address,
               LDA,
               WORK'Address,
               LDWORK);
         end loop;
      end if;
      --
      --     Use unblocked code to reduce the rest of the matrix
      --
      DGEHD2 (N, I, IHI, A, LDA, TAU, WORK, IINFO);
      WORK (1) := Real (IWS);
      --
      return;
      --
      --     End of DGEHRD
      --
   end DGEHRD;

   procedure DGELQ2
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. min (M, N));
      WORK : Ftn_Real_Vector (1 .. M);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE : constant Real := 1.0e0;
      I   : Integer;
      K   : Integer;
      AII : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGELQ2( M, N, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGELQ2 computes an LQ factorization of a real m by n matrix A:
   --  A = L * Q.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the m by n matrix A.
   --           On exit, the elements on and below the diagonal of the array
   --           contain the m by min(m,n) lower trapezoidal matrix L (L is
   --           lower triangular if m <= n); the elements above the diagonal,
   --           with the array TAU, represent the orthogonal matrix Q as a
   --           product of elementary reflectors (see Further Details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (M)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of elementary reflectors
   --
   --      Q = H(k) . . . H(2) H(1), where k = min(m,n).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
   --   and tau in TAU(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, DLARFG, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("DGELQ2", -INFO);
         return;
      end if;
      --
      K := min (M, N);
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         --
         --        Generate elementary reflector H(i) to annihilate A(i,i+1:n)
         --
         DLARFG (N - I + 1, A (I, I), A (I, min (I + 1, N))'Address, LDA, TAU (I));
         if I < M then
            --
            --           Apply H(i) to A(i+1:m,i:n) from the right
            --
            AII      := A (I, I);
            A (I, I) := ONE;
            DLARF ('R', M - I, N - I + 1, A (I, I)'Address, LDA, TAU (I), A (I + 1, I)'Address, LDA, WORK'Address);
            A (I, I) := AII;
         end if;
      end loop;
      return;
      --
      --     End of DGELQ2
      --
   end DGELQ2;

   procedure DGELQF
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. min (M, N));
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      K      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGELQF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGELQF computes an LQ factorization of a real M-by-N matrix A:
   --  A = L * Q.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the M-by-N matrix A.
   --           On exit, the elements on and below the diagonal of the array
   --           contain the m-by-min(m,n) lower trapezoidal matrix L (L is
   --           lower triangular if m <= n); the elements above the diagonal,
   --           with the array TAU, represent the orthogonal matrix Q as a
   --           product of elementary reflectors (see Further Details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= max(1,M).
   --           For optimum performance LWORK >= M*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of elementary reflectors
   --
   --      Q = H(k) . . . H(2) H(1), where k = min(m,n).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
   --   and tau in TAU(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGELQ2, DLARFB, DLARFT, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "DGELQF", " ", M, N, -1, -1);
      LWKOPT   := M * NB;
      WORK (1) := Real (LWKOPT);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      elsif LWORK < max (1, M) and not LQUERY then
         INFO := -7;
      end if;
      if INFO /= 0 then
         XERBLA ("DGELQF", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      K := min (M, N);
      if K = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := M;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "DGELQF", " ", M, N, -1, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := M;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "DGELQF", " ", M, N, -1, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code initially
         --
         I := 1 - NB;
         loop
            I := I + NB;
            exit when I > K - NX;
            IB := min (K - I + 1, NB);
            --
            --           Compute the LQ factorization of the current block
            --           A(i:i+ib-1,i:n)
            --
            DGELQ2 (IB, N - I + 1, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            if I + IB <= M then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i) H(i+1) . . . H(i+ib-1)
               --
               DLARFT ('F', 'R', N - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, LDWORK);
               --
               --              Apply H to A(i+ib:m,i:n) from the right
               --
               DLARFB
                 ('R',
                  'N',
                  'F',
                  'R',
                  M - I - IB + 1,
                  N - I + 1,
                  IB,
                  A (I, I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A (I + IB, I)'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
         end loop;
      else
         I := 1;
      end if;
      --
      --     Use unblocked code to factor the last or only block.
      --
      if I <= K then
         DGELQ2 (M - I + 1, N - I + 1, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
      end if;
      --
      WORK (1) := Real (IWS);
      return;
      --
      --     End of DGELQF
      --
   end DGELQF;

   procedure DGEQR2
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. min (M, N));
      WORK : Ftn_Real_Vector (1 .. N);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE : constant Real := 1.0e0;
      I   : Integer;
      K   : Integer;
      AII : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEQR2( M, N, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEQR2 computes a QR factorization of a real m by n matrix A:
   --  A = Q * R.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the m by n matrix A.
   --           On exit, the elements on and above the diagonal of the array
   --           contain the min(m,n) by n upper trapezoidal matrix R (R is
   --           upper triangular if m >= n); the elements below the diagonal,
   --           with the array TAU, represent the orthogonal matrix Q as a
   --           product of elementary reflectors (see Further Details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of elementary reflectors
   --
   --      Q = H(1) H(2) . . . H(k), where k = min(m,n).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
   --   and tau in TAU(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, DLARFG, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("DGEQR2", -INFO);
         return;
      end if;
      --
      K := min (M, N);
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         --
         --        Generate elementary reflector H(i) to annihilate A(i+1:m,i)
         --
         DLARFG (M - I + 1, A (I, I), A (min (I + 1, M), I)'Address, 1, TAU (I));
         if I < N then
            --
            --           Apply H(i) to A(i:m,i+1:n) from the left
            --
            AII      := A (I, I);
            A (I, I) := ONE;
            DLARF ('L', M - I + 1, N - I, A (I, I)'Address, 1, TAU (I), A (I, I + 1)'Address, LDA, WORK'Address);
            A (I, I) := AII;
         end if;
      end loop;
      return;
      --
      --     End of DGEQR2
      --
   end DGEQR2;

   procedure DGEQRF
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. min (M, N));
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      K      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGEQRF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGEQRF computes a QR factorization of a real M-by-N matrix A:
   --  A = Q * R.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the M-by-N matrix A.
   --           On exit, the elements on and above the diagonal of the array
   --           contain the min(M,N)-by-N upper trapezoidal matrix R (R is
   --           upper triangular if m >= n); the elements below the diagonal,
   --           with the array TAU, represent the orthogonal matrix Q as a
   --           product of min(m,n) elementary reflectors (see Further
   --           Details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= max(1,N).
   --           For optimum performance LWORK >= N*NB, where NB is
   --           the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of elementary reflectors
   --
   --      Q = H(1) H(2) . . . H(k), where k = min(m,n).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
   --   and tau in TAU(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEQR2, DLARFB, DLARFT, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "DGEQRF", " ", M, N, -1, -1);
      LWKOPT   := N * NB;
      WORK (1) := Real (LWKOPT);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -7;
      end if;
      if INFO /= 0 then
         XERBLA ("DGEQRF", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      K := min (M, N);
      if K = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := N;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "DGEQRF", " ", M, N, -1, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := N;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "DGEQRF", " ", M, N, -1, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code initially
         --
         I := 1 - NB;
         loop
            I := I + NB;
            exit when I > K - NX;
            IB := min (K - I + 1, NB);
            --
            --           Compute the QR factorization of the current block
            --           A(i:m,i:i+ib-1)
            --
            DGEQR2 (M - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            if I + IB <= N then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i) H(i+1) . . . H(i+ib-1)
               --
               DLARFT ('F', 'C', M - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, LDWORK);
               --
               --              Apply H**T to A(i:m,i+ib:n) from the left
               --
               DLARFB
                 ('L',
                  'T',
                  'F',
                  'C',
                  M - I + 1,
                  N - I - IB + 1,
                  IB,
                  A (I, I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A (I, I + IB)'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
         end loop;
      else
         I := 1;
      end if;
      --
      --     Use unblocked code to factor the last or only block.
      --
      if I <= K then
         DGEQR2 (M - I + 1, N - I + 1, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
      end if;
      --
      WORK (1) := Real (IWS);
      return;
      --
      --     End of DGEQRF
      --
   end DGEQRF;

   procedure DGESDD
     (JOBZ  : Character;
      M     : Integer;
      N     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      S     : in out Ftn_Real_Vector;
      U     : in out Ftn_Real_Matrix;
      LDU   : Integer;
      VT    : in out Ftn_Real_Matrix;
      LDVT  : Integer;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      IWORK : in out Ftn_Integer_Vector;
      INFO  : in out Integer)
   is
      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      LQUERY : Boolean;
      WNTQA  : Boolean;
      WNTQAS : Boolean;
      WNTQN  : Boolean;
      WNTQO  : Boolean;
      WNTQS  : Boolean;
      BDSPAC : Integer;
      BLK    : Integer;
      CHUNK  : Integer;
      I      : Integer;
      IE     : Integer;
      IERR   : Integer;
      IL     : Integer;
      IR     : Integer;
      ISCL   : Integer;
      ITAU   : Integer;
      ITAUP  : Integer;
      ITAUQ  : Integer;
      IU     : Integer;
      IVT    : Integer;
      LDWKVT : Integer;
      LDWRKL : Integer;
      LDWRKR : Integer;
      LDWRKU : Integer;
      MAXWRK : Integer;
      MINMN  : Integer;
      MINWRK : Integer;
      MNTHR  : Integer;
      NWORK  : Integer;
      WRKBL  : Integer;
      ANRM   : Real;
      BIGNUM : Real;
      EPS    : Real;
      SMLNUM : Real;
      IDUM   : Ftn_Integer_Vector (1 .. 1);
      DUM    : Ftn_Real_Vector (1 .. 1);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGESDD( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK,
   --                          LWORK, IWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBZ
   --       INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   A( LDA, * ), S( * ), U( LDU, * ),
   --      $                   VT( LDVT, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGESDD computes the singular value decomposition (SVD) of a real
   --  M-by-N matrix A, optionally computing the left and right singular
   --  vectors.  If singular vectors are desired, it uses a
   --  divide-and-conquer algorithm.
   --
   --  The SVD is written
   --
   --       A = U * SIGMA * transpose(V)
   --
   --  where SIGMA is an M-by-N matrix which is zero except for its
   --  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
   --  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
   --  are the singular values of A; they are real and non-negative, and
   --  are returned in descending order.  The first min(m,n) columns of
   --  U and V are the left and right singular vectors of A.
   --
   --  Note that the routine returns VT = V**T, not V.
   --
   --  The divide and conquer algorithm makes very mild assumptions about
   --  floating point arithmetic. It will work on machines with a guard
   --  digit in add/subtract, or on those binary machines without guard
   --  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
   --  Cray-2. It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBZ
   --           JOBZ is CHARACTER*1
   --           Specifies options for computing all or part of the matrix U:
   --           = 'A':  all M columns of U and all N rows of V**T are
   --                   returned in the arrays U and VT;
   --           = 'S':  the first min(M,N) columns of U and the first
   --                   min(M,N) rows of V**T are returned in the arrays U
   --                   and VT;
   --           = 'O':  If M >= N, the first N columns of U are overwritten
   --                   on the array A and all rows of V**T are returned in
   --                   the array VT;
   --                   otherwise, all columns of U are returned in the
   --                   array U and the first M rows of V**T are overwritten
   --                   in the array A;
   --           = 'N':  no columns of U or rows of V**T are computed.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the input matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the input matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the M-by-N matrix A.
   --           On exit,
   --           if JOBZ = 'O',  A is overwritten with the first N columns
   --                           of U (the left singular vectors, stored
   --                           columnwise) if M >= N;
   --                           A is overwritten with the first M rows
   --                           of V**T (the right singular vectors, stored
   --                           rowwise) otherwise.
   --           if JOBZ .ne. 'O', the contents of A are destroyed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] S
   --           S is DOUBLE PRECISION array, dimension (min(M,N))
   --           The singular values of A, sorted so that S(i) >= S(i+1).
   --
   --  [out] U
   --           U is DOUBLE PRECISION array, dimension (LDU,UCOL)
   --           UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
   --           UCOL = min(M,N) if JOBZ = 'S'.
   --           If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
   --           orthogonal matrix U;
   --           if JOBZ = 'S', U contains the first min(M,N) columns of U
   --           (the left singular vectors, stored columnwise);
   --           if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --           The leading dimension of the array U.  LDU >= 1; if
   --           JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.
   --
   --  [out] VT
   --           VT is DOUBLE PRECISION array, dimension (LDVT,N)
   --           If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
   --           N-by-N orthogonal matrix V**T;
   --           if JOBZ = 'S', VT contains the first min(M,N) rows of
   --           V**T (the right singular vectors, stored rowwise);
   --           if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --           The leading dimension of the array VT.  LDVT >= 1; if
   --           JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
   --           if JOBZ = 'S', LDVT >= min(M,N).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= 1.
   --           If JOBZ = 'N',
   --             LWORK >= 3*min(M,N) + max(max(M,N),7*min(M,N)).
   --           If JOBZ = 'O',
   --             LWORK >= 3*min(M,N) +
   --                      max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
   --           If JOBZ = 'S' or 'A'
   --             LWORK >= 3*min(M,N) +
   --                      max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
   --           For good performance, LWORK should generally be larger.
   --           If LWORK = -1 but other input arguments are legal, WORK(1)
   --           returns the optimal LWORK.
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (8*min(M,N))
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  DBDSDC did not converge, updating process failed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DBDSDC, DGEBRD, DGELQF, DGEMM, DGEQRF, DLACPY, DLASCL, DLASET, DORGBR, DORGLQ, DORGQR, DORMBR,
   --XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH, DLANGE, ILAENV, LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          INT, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      MINMN  := min (M, N);
      WNTQA  := LSAME (JOBZ, 'A');
      WNTQS  := LSAME (JOBZ, 'S');
      WNTQAS := WNTQA or WNTQS;
      WNTQO  := LSAME (JOBZ, 'O');
      WNTQN  := LSAME (JOBZ, 'N');
      LQUERY := (LWORK = -1);
      --
      if not (WNTQA or WNTQS or WNTQO or WNTQN) then
         INFO := -1;
      elsif M < 0 then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      elsif LDU < 1 or (WNTQAS and LDU < M) or (WNTQO and M < N and LDU < M) then
         INFO := -8;
      elsif LDVT < 1 or (WNTQA and LDVT < N) or (WNTQS and LDVT < MINMN) or (WNTQO and M >= N and LDVT < N) then
         INFO := -10;
      end if;
      --
      --     Compute workspace
      --      (Note: Comments in the code beginning "Workspace:" describe the
      --       minimal amount of workspace needed at that point in the code,
      --       as well as the preferred amount for good performance.
      --       NB refers to the optimal block size for the immediately
      --       following subroutine, as returned by ILAENV.)
      --
      if INFO = 0 then
         MINWRK := 1;
         MAXWRK := 1;
         if M >= N and MINMN > 0 then
            --
            --           Compute space needed for DBDSDC
            --
            MNTHR := int (Real (MINMN) * 11.0e0 / 6.0e0);
            if WNTQN 
               then BDSPAC := 7 * N;
               else BDSPAC := 3 * N * N + 4 * N;
            end if;
            if M >= MNTHR then
               if WNTQN then
                  --
                  --                 Path 1 (M much larger than N, JOBZ='N')
                  --
                  WRKBL  := N + N * ILAENV (1, "DGEQRF", " ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, 3 * N + 2 * N * ILAENV (1, "DGEBRD", " ", N, N, -1, -1));
                  MAXWRK := max (WRKBL, BDSPAC + N);
                  MINWRK := BDSPAC + N;
               elsif WNTQO then
                  --
                  --                 Path 2 (M much larger than N, JOBZ='O')
                  --
                  WRKBL  := N + N * ILAENV (1, "DGEQRF", " ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, N + N * ILAENV (1, "DORGQR", " ", M, N, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + 2 * N * ILAENV (1, "DGEBRD", " ", N, N, -1, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "QLN", N, N, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "PRT", N, N, N, -1));
                  WRKBL  := max (WRKBL, BDSPAC + 3 * N);
                  MAXWRK := WRKBL + 2 * N * N;
                  MINWRK := BDSPAC + 2 * N * N + 3 * N;
               elsif WNTQS then
                  --
                  --                 Path 3 (M much larger than N, JOBZ='S')
                  --
                  WRKBL  := N + N * ILAENV (1, "DGEQRF", " ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, N + N * ILAENV (1, "DORGQR", " ", M, N, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + 2 * N * ILAENV (1, "DGEBRD", " ", N, N, -1, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "QLN", N, N, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "PRT", N, N, N, -1));
                  WRKBL  := max (WRKBL, BDSPAC + 3 * N);
                  MAXWRK := WRKBL + N * N;
                  MINWRK := BDSPAC + N * N + 3 * N;
               elsif WNTQA then
                  --
                  --                 Path 4 (M much larger than N, JOBZ='A')
                  --
                  WRKBL  := N + N * ILAENV (1, "DGEQRF", " ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, N + M * ILAENV (1, "DORGQR", " ", M, M, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + 2 * N * ILAENV (1, "DGEBRD", " ", N, N, -1, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "QLN", N, N, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "PRT", N, N, N, -1));
                  WRKBL  := max (WRKBL, BDSPAC + 3 * N);
                  MAXWRK := WRKBL + N * N;
                  MINWRK := BDSPAC + N * N + 3 * N;
               end if;
            else
               --
               --              Path 5 (M at least N, but not much larger)
               --
               WRKBL := 3 * N + (M + N) * ILAENV (1, "DGEBRD", " ", M, N, -1, -1);
               if WNTQN then
                  MAXWRK := max (WRKBL, BDSPAC + 3 * N);
                  MINWRK := 3 * N + max (M, BDSPAC);
               elsif WNTQO then
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "QLN", M, N, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "PRT", N, N, N, -1));
                  WRKBL  := max (WRKBL, BDSPAC + 3 * N);
                  MAXWRK := WRKBL + M * N;
                  MINWRK := 3 * N + max (M, N * N + BDSPAC);
               elsif WNTQS then
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "QLN", M, N, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "PRT", N, N, N, -1));
                  MAXWRK := max (WRKBL, BDSPAC + 3 * N);
                  MINWRK := 3 * N + max (M, BDSPAC);
               elsif WNTQA then
                  WRKBL  := max (WRKBL, 3 * N + M * ILAENV (1, "DORMBR", "QLN", M, M, N, -1));
                  WRKBL  := max (WRKBL, 3 * N + N * ILAENV (1, "DORMBR", "PRT", N, N, N, -1));
                  MAXWRK := max (MAXWRK, BDSPAC + 3 * N);
                  MINWRK := 3 * N + max (M, BDSPAC);
               end if;
            end if;
         elsif MINMN > 0 then
            --
            --           Compute space needed for DBDSDC
            --
            MNTHR := int (Real (MINMN) * 11.0e0 / 6.0e0);
            if WNTQN 
               then BDSPAC := 7 * M;
               else BDSPAC := 3 * M * M + 4 * M;
            end if;
            if N >= MNTHR then
               if WNTQN then
                  --
                  --                 Path 1t (N much larger than M, JOBZ='N')
                  --
                  WRKBL  := M + M * ILAENV (1, "DGELQF", " ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, 3 * M + 2 * M * ILAENV (1, "DGEBRD", " ", M, M, -1, -1));
                  MAXWRK := max (WRKBL, BDSPAC + M);
                  MINWRK := BDSPAC + M;
               elsif WNTQO then
                  --
                  --                 Path 2t (N much larger than M, JOBZ='O')
                  --
                  WRKBL  := M + M * ILAENV (1, "DGELQF", " ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, M + M * ILAENV (1, "DORGLQ", " ", M, N, M, -1));
                  WRKBL  := max (WRKBL, 3 * M + 2 * M * ILAENV (1, "DGEBRD", " ", M, M, -1, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "QLN", M, M, M, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "PRT", M, M, M, -1));
                  WRKBL  := max (WRKBL, BDSPAC + 3 * M);
                  MAXWRK := WRKBL + 2 * M * M;
                  MINWRK := BDSPAC + 2 * M * M + 3 * M;
               elsif WNTQS then
                  --
                  --                 Path 3t (N much larger than M, JOBZ='S')
                  --
                  WRKBL  := M + M * ILAENV (1, "DGELQF", " ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, M + M * ILAENV (1, "DORGLQ", " ", M, N, M, -1));
                  WRKBL  := max (WRKBL, 3 * M + 2 * M * ILAENV (1, "DGEBRD", " ", M, M, -1, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "QLN", M, M, M, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "PRT", M, M, M, -1));
                  WRKBL  := max (WRKBL, BDSPAC + 3 * M);
                  MAXWRK := WRKBL + M * M;
                  MINWRK := BDSPAC + M * M + 3 * M;
               elsif WNTQA then
                  --
                  --                 Path 4t (N much larger than M, JOBZ='A')
                  --
                  WRKBL  := M + M * ILAENV (1, "DGELQF", " ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, M + N * ILAENV (1, "DORGLQ", " ", N, N, M, -1));
                  WRKBL  := max (WRKBL, 3 * M + 2 * M * ILAENV (1, "DGEBRD", " ", M, M, -1, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "QLN", M, M, M, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "PRT", M, M, M, -1));
                  WRKBL  := max (WRKBL, BDSPAC + 3 * M);
                  MAXWRK := WRKBL + M * M;
                  MINWRK := BDSPAC + M * M + 3 * M;
               end if;
            else
               --
               --              Path 5t (N greater than M, but not much larger)
               --
               WRKBL := 3 * M + (M + N) * ILAENV (1, "DGEBRD", " ", M, N, -1, -1);
               if WNTQN then
                  MAXWRK := max (WRKBL, BDSPAC + 3 * M);
                  MINWRK := 3 * M + max (N, BDSPAC);
               elsif WNTQO then
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "QLN", M, M, N, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "PRT", M, N, M, -1));
                  WRKBL  := max (WRKBL, BDSPAC + 3 * M);
                  MAXWRK := WRKBL + M * N;
                  MINWRK := 3 * M + max (N, M * M + BDSPAC);
               elsif WNTQS then
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "QLN", M, M, N, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "PRT", M, N, M, -1));
                  MAXWRK := max (WRKBL, BDSPAC + 3 * M);
                  MINWRK := 3 * M + max (N, BDSPAC);
               elsif WNTQA then
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "QLN", M, M, N, -1));
                  WRKBL  := max (WRKBL, 3 * M + M * ILAENV (1, "DORMBR", "PRT", N, N, M, -1));
                  MAXWRK := max (WRKBL, BDSPAC + 3 * M);
                  MINWRK := 3 * M + max (N, BDSPAC);
               end if;
            end if;
         end if;
         MAXWRK   := max (MAXWRK, MINWRK);
         WORK (1) := Real (MAXWRK);
         --
         if LWORK < MINWRK and not LQUERY then
            INFO := -12;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DGESDD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     Get machine constants
      --
      EPS    := DLAMCH ('P');
      SMLNUM := Sqrt (DLAMCH ('S')) / EPS;
      BIGNUM := ONE / SMLNUM;
      --
      --     Scale A if max element outside range [SMLNUM,BIGNUM]
      --
      ANRM := DLANGE ('M', M, N, A, LDA, DUM);
      ISCL := 0;
      if ANRM > ZERO and ANRM < SMLNUM then
         ISCL := 1;
         DLASCL ('G', 0, 0, ANRM, SMLNUM, M, N, A'Address, LDA, IERR);
      elsif ANRM > BIGNUM then
         ISCL := 1;
         DLASCL ('G', 0, 0, ANRM, BIGNUM, M, N, A'Address, LDA, IERR);
      end if;
      --
      if M >= N then
         --
         --        A has at least as many rows as columns. If A has sufficiently
         --        more rows than columns, first reduce using the QR
         --        decomposition (if sufficient workspace available)
         --
         if M >= MNTHR then
            --
            if WNTQN then
               --
               --              Path 1 (M much larger than N, JOBZ='N')
               --              No singular vectors to be computed
               --
               ITAU  := 1;
               NWORK := ITAU + N;
               --
               --              Compute A=Q*R
               --              (Workspace: need 2*N, prefer N+N*NB)
               --
               DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Zero out below R
               --
               DLASET ('L', N - 1, N - 1, ZERO, ZERO, A (2, 1)'Address, LDA);
               IE    := 1;
               ITAUQ := IE + N;
               ITAUP := ITAUQ + N;
               NWORK := ITAUP + N;
               --
               --              Bidiagonalize R in A
               --              (Workspace: need 4*N, prefer 3*N+2*N*NB)
               --
               DGEBRD
                 (N,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               NWORK := IE + N;
               --
               --              Perform bidiagonal SVD, computing singular values only
               --              (Workspace: need N+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'N',
                  N,
                  S'Address,
                  WORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
            --
            elsif WNTQO then
               --
               --              Path 2 (M much larger than N, JOBZ = 'O')
               --              N left singular vectors to be overwritten on A and
               --              N right singular vectors to be computed in VT
               --
               IR := 1;
               --
               --              WORK(IR) is LDWRKR by N
               --
               if LWORK >= LDA * N + N * N + 3 * N + BDSPAC 
                  then LDWRKR := LDA;
                  else LDWRKR := (LWORK - N * N - 3 * N - BDSPAC) / N;
               end if;
               ITAU  := IR + LDWRKR * N;
               NWORK := ITAU + N;
               --
               --              Compute A=Q*R
               --              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
               --
               DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy R to WORK(IR), zeroing out below it
               --
               DLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
               DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IR + 1)'Address, LDWRKR);
               --
               --              Generate Q in A
               --              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
               --
               DORGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               IE    := ITAU;
               ITAUQ := IE + N;
               ITAUP := ITAUQ + N;
               NWORK := ITAUP + N;
               --
               --              Bidiagonalize R in VT, copying result to WORK(IR)
               --              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
               --
               DGEBRD
                 (N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              WORK(IU) is N by N
               --
               IU    := NWORK;
               NWORK := IU + N * N;
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in WORK(IU) and computing right
               --              singular vectors of bidiagonal matrix in VT
               --              (Workspace: need N+N*N+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (IU)'Address,
                  N,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite WORK(IU) by left singular vectors of R
               --              and VT by right singular vectors of R
               --              (Workspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  N,
                  N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  WORK (ITAUQ)'Address,
                  WORK (IU)'Address,
                  N,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  N,
                  N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply Q in A by left singular vectors of R in
               --              WORK(IU), storing result in WORK(IR) and copying to A
               --              (Workspace: need 2*N*N, prefer N*N+M*N)
               --
               I := 1 - LDWRKR;
               loop
                  I := I + LDWRKR;
                  exit when I > M;
                  CHUNK := min (M - I + 1, LDWRKR);
                  DGEMM
                    ('N',
                     'N',
                     CHUNK,
                     N,
                     N,
                     ONE,
                     A (I, 1)'Address,
                     LDA,
                     WORK (IU)'Address,
                     N,
                     ZERO,
                     WORK (IR)'Address,
                     LDWRKR);
                  DLACPY ('F', CHUNK, N, WORK (IR)'Address, LDWRKR, A (I, 1)'Address, LDA);
               end loop;
            --
            elsif WNTQS then
               --
               --              Path 3 (M much larger than N, JOBZ='S')
               --              N left singular vectors to be computed in U and
               --              N right singular vectors to be computed in VT
               --
               IR := 1;
               --
               --              WORK(IR) is N by N
               --
               LDWRKR := N;
               ITAU   := IR + LDWRKR * N;
               NWORK  := ITAU + N;
               --
               --              Compute A=Q*R
               --              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
               --
               DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy R to WORK(IR), zeroing out below it
               --
               DLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
               DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IR + 1)'Address, LDWRKR);
               --
               --              Generate Q in A
               --              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
               --
               DORGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               IE    := ITAU;
               ITAUQ := IE + N;
               ITAUP := ITAUQ + N;
               NWORK := ITAUP + N;
               --
               --              Bidiagonalize R in WORK(IR)
               --              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
               --
               DGEBRD
                 (N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagoal matrix in U and computing right singular
               --              vectors of bidiagonal matrix in VT
               --              (Workspace: need N+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite U by left singular vectors of R and VT
               --              by right singular vectors of R
               --              (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  N,
                  N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               DORMBR
                 ('P',
                  'R',
                  'T',
                  N,
                  N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply Q in A by left singular vectors of R in
               --              WORK(IR), storing result in U
               --              (Workspace: need N*N)
               --
               DLACPY ('F', N, N, U'Address, LDU, WORK (IR)'Address, LDWRKR);
               DGEMM ('N', 'N', M, N, N, ONE, A'Address, LDA, WORK (IR)'Address, LDWRKR, ZERO, U'Address, LDU);
            --
            elsif WNTQA then
               --
               --              Path 4 (M much larger than N, JOBZ='A')
               --              M left singular vectors to be computed in U and
               --              N right singular vectors to be computed in VT
               --
               IU := 1;
               --
               --              WORK(IU) is N by N
               --
               LDWRKU := N;
               ITAU   := IU + LDWRKU * N;
               NWORK  := ITAU + N;
               --
               --              Compute A=Q*R, copying result to U
               --              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
               --
               DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
               --
               --              Generate Q in U
               --              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
               DORGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Produce R in A, zeroing out other entries
               --
               DLASET ('L', N - 1, N - 1, ZERO, ZERO, A (2, 1)'Address, LDA);
               IE    := ITAU;
               ITAUQ := IE + N;
               ITAUP := ITAUQ + N;
               NWORK := ITAUP + N;
               --
               --              Bidiagonalize R in A
               --              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
               --
               DGEBRD
                 (N,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in WORK(IU) and computing right
               --              singular vectors of bidiagonal matrix in VT
               --              (Workspace: need N+N*N+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (IU)'Address,
                  N,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite WORK(IU) by left singular vectors of R and VT
               --              by right singular vectors of R
               --              (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  WORK (IU)'Address,
                  LDWRKU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply Q in U by left singular vectors of R in
               --              WORK(IU), storing result in A
               --              (Workspace: need N*N)
               --
               DGEMM ('N', 'N', M, N, N, ONE, U'Address, LDU, WORK (IU)'Address, LDWRKU, ZERO, A'Address, LDA);
               --
               --              Copy left singular vectors of A from A to U
               --
               DLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
               --
            end if;
         --
         else
            --
            --           M .LT. MNTHR
            --
            --           Path 5 (M at least N, but not much larger)
            --           Reduce to bidiagonal form without QR decomposition
            --
            IE    := 1;
            ITAUQ := IE + N;
            ITAUP := ITAUQ + N;
            NWORK := ITAUP + N;
            --
            --           Bidiagonalize A
            --           (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
            --
            DGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               WORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (NWORK)'Address,
               LWORK - NWORK + 1,
               IERR);
            if WNTQN then
               --
               --              Perform bidiagonal SVD, only computing singular values
               --              (Workspace: need N+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'N',
                  N,
                  S'Address,
                  WORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
            elsif WNTQO then
               IU := NWORK;
               if LWORK >= M * N + 3 * N + BDSPAC then
                  --
                  --                 WORK( IU ) is M by N
                  --
                  LDWRKU := M;
                  NWORK  := IU + LDWRKU * N;
                  DLASET ('F', M, N, ZERO, ZERO, WORK (IU)'Address, LDWRKU);
               else
                  --
                  --                 WORK( IU ) is N by N
                  --
                  LDWRKU := N;
                  NWORK  := IU + LDWRKU * N;
                  --
                  --                 WORK(IR) is LDWRKR by N
                  --
                  IR     := NWORK;
                  LDWRKR := (LWORK - N * N - 3 * N) / N;
               end if;
               NWORK := IU + LDWRKU * N;
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in WORK(IU) and computing right
               --              singular vectors of bidiagonal matrix in VT
               --              (Workspace: need N+N*N+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (IU)'Address,
                  LDWRKU,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite VT by right singular vectors of A
               --              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
               --
               DORMBR
                 ('P',
                  'R',
                  'T',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               if LWORK >= M * N + 3 * N + BDSPAC then
                  --
                  --                 Overwrite WORK(IU) by left singular vectors of A
                  --                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --
                  DORMBR
                    ('Q',
                     'L',
                     'N',
                     M,
                     N,
                     N,
                     A'Address,
                     LDA,
                     WORK (ITAUQ)'Address,
                     WORK (IU)'Address,
                     LDWRKU,
                     WORK (NWORK)'Address,
                     LWORK - NWORK + 1,
                     IERR);
                  --
                  --                 Copy left singular vectors of A from WORK(IU) to A
                  --
                  DLACPY ('F', M, N, WORK (IU)'Address, LDWRKU, A'Address, LDA);
               else
                  --
                  --                 Generate Q in A
                  --                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --
                  DORGBR ('Q', M, N, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
                  --
                  --                 Multiply Q in A by left singular vectors of
                  --                 bidiagonal matrix in WORK(IU), storing result in
                  --                 WORK(IR) and copying to A
                  --                 (Workspace: need 2*N*N, prefer N*N+M*N)
                  --
                  I := 1 - LDWRKR;
                  loop
                     I := I + LDWRKR;
                     exit when I > M;
                     CHUNK := min (M - I + 1, LDWRKR);
                     DGEMM
                       ('N',
                        'N',
                        CHUNK,
                        N,
                        N,
                        ONE,
                        A (I, 1)'Address,
                        LDA,
                        WORK (IU)'Address,
                        LDWRKU,
                        ZERO,
                        WORK (IR)'Address,
                        LDWRKR);
                     DLACPY ('F', CHUNK, N, WORK (IR)'Address, LDWRKR, A (I, 1)'Address, LDA);
                  end loop;
               end if;
            --
            elsif WNTQS then
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in U and computing right singular
               --              vectors of bidiagonal matrix in VT
               --              (Workspace: need N+BDSPAC)
               --
               DLASET ('F', M, N, ZERO, ZERO, U'Address, LDU);
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite U by left singular vectors of A and VT
               --              by right singular vectors of A
               --              (Workspace: need 3*N, prefer 2*N+N*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
            elsif WNTQA then
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in U and computing right singular
               --              vectors of bidiagonal matrix in VT
               --              (Workspace: need N+BDSPAC)
               --
               DLASET ('F', M, M, ZERO, ZERO, U'Address, LDU);
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Set the right corner of U to identity matrix
               --
               if M > N then
                  DLASET ('F', M - N, M - N, ZERO, ONE, U (N + 1, N + 1)'Address, LDU);
               end if;
               --
               --              Overwrite U by left singular vectors of A and VT
               --              by right singular vectors of A
               --              (Workspace: need N*N+2*N+M, prefer N*N+2*N+M*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  N,
                  N,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
            end if;
            --
         end if;
      --
      else
         --
         --        A has more columns than rows. If A has sufficiently more
         --        columns than rows, first reduce using the LQ decomposition (if
         --        sufficient workspace available)
         --
         if N >= MNTHR then
            --
            if WNTQN then
               --
               --              Path 1t (N much larger than M, JOBZ='N')
               --              No singular vectors to be computed
               --
               ITAU  := 1;
               NWORK := ITAU + M;
               --
               --              Compute A=L*Q
               --              (Workspace: need 2*M, prefer M+M*NB)
               --
               DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Zero out above L
               --
               DLASET ('U', M - 1, M - 1, ZERO, ZERO, A (1, 2)'Address, LDA);
               IE    := 1;
               ITAUQ := IE + M;
               ITAUP := ITAUQ + M;
               NWORK := ITAUP + M;
               --
               --              Bidiagonalize L in A
               --              (Workspace: need 4*M, prefer 3*M+2*M*NB)
               --
               DGEBRD
                 (M,
                  M,
                  A'Address,
                  LDA,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               NWORK := IE + M;
               --
               --              Perform bidiagonal SVD, computing singular values only
               --              (Workspace: need M+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'N',
                  M,
                  S'Address,
                  WORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
            --
            elsif WNTQO then
               --
               --              Path 2t (N much larger than M, JOBZ='O')
               --              M right singular vectors to be overwritten on A and
               --              M left singular vectors to be computed in U
               --
               IVT := 1;
               --
               --              IVT is M by M
               --
               IL := IVT + M * M;
               if LWORK >= M * N + M * M + 3 * M + BDSPAC then
                  --
                  --                 WORK(IL) is M by N
                  --
                  LDWRKL := M;
                  CHUNK  := N;
               else
                  LDWRKL := M;
                  CHUNK  := (LWORK - M * M) / M;
               end if;
               ITAU  := IL + LDWRKL * M;
               NWORK := ITAU + M;
               --
               --              Compute A=L*Q
               --              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
               --
               DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy L to WORK(IL), zeroing about above it
               --
               DLACPY ('L', M, M, A'Address, LDA, WORK (IL)'Address, LDWRKL);
               DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IL + LDWRKL)'Address, LDWRKL);
               --
               --              Generate Q in A
               --              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
               --
               DORGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               IE    := ITAU;
               ITAUQ := IE + M;
               ITAUP := ITAUQ + M;
               NWORK := ITAUP + M;
               --
               --              Bidiagonalize L in WORK(IL)
               --              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
               --
               DGEBRD
                 (M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in U, and computing right singular
               --              vectors of bidiagonal matrix in WORK(IVT)
               --              (Workspace: need M+M*M+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  M,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  WORK (IVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite U by left singular vectors of L and WORK(IVT)
               --              by right singular vectors of L
               --              (Workspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  M,
                  M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  WORK (ITAUP)'Address,
                  WORK (IVT)'Address,
                  M,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply right singular vectors of L in WORK(IVT) by Q
               --              in A, storing result in WORK(IL) and copying to A
               --              (Workspace: need 2*M*M, prefer M*M+M*N)
               --
               I := 1 - CHUNK;
               loop
                  I := I + CHUNK;
                  exit when I > N;
                  BLK := min (N - I + 1, CHUNK);
                  DGEMM
                    ('N',
                     'N',
                     M,
                     BLK,
                     M,
                     ONE,
                     WORK (IVT)'Address,
                     M,
                     A (1, I)'Address,
                     LDA,
                     ZERO,
                     WORK (IL)'Address,
                     LDWRKL);
                  DLACPY ('F', M, BLK, WORK (IL)'Address, LDWRKL, A (1, I)'Address, LDA);
               end loop;
            --
            elsif WNTQS then
               --
               --              Path 3t (N much larger than M, JOBZ='S')
               --              M right singular vectors to be computed in VT and
               --              M left singular vectors to be computed in U
               --
               IL := 1;
               --
               --              WORK(IL) is M by M
               --
               LDWRKL := M;
               ITAU   := IL + LDWRKL * M;
               NWORK  := ITAU + M;
               --
               --              Compute A=L*Q
               --              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
               --
               DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy L to WORK(IL), zeroing out above it
               --
               DLACPY ('L', M, M, A'Address, LDA, WORK (IL)'Address, LDWRKL);
               DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IL + LDWRKL)'Address, LDWRKL);
               --
               --              Generate Q in A
               --              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
               --
               DORGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               IE    := ITAU;
               ITAUQ := IE + M;
               ITAUP := ITAUQ + M;
               NWORK := ITAUP + M;
               --
               --              Bidiagonalize L in WORK(IU), copying result to U
               --              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
               --
               DGEBRD
                 (M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in U and computing right singular
               --              vectors of bidiagonal matrix in VT
               --              (Workspace: need M+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  M,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite U by left singular vectors of L and VT
               --              by right singular vectors of L
               --              (Workspace: need M*M+3*M, prefer M*M+2*M+M*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  M,
                  M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply right singular vectors of L in WORK(IL) by
               --              Q in A, storing result in VT
               --              (Workspace: need M*M)
               --
               DLACPY ('F', M, M, VT'Address, LDVT, WORK (IL)'Address, LDWRKL);
               DGEMM ('N', 'N', M, N, M, ONE, WORK (IL)'Address, LDWRKL, A'Address, LDA, ZERO, VT'Address, LDVT);
            --
            elsif WNTQA then
               --
               --              Path 4t (N much larger than M, JOBZ='A')
               --              N right singular vectors to be computed in VT and
               --              M left singular vectors to be computed in U
               --
               IVT := 1;
               --
               --              WORK(IVT) is M by M
               --
               LDWKVT := M;
               ITAU   := IVT + LDWKVT * M;
               NWORK  := ITAU + M;
               --
               --              Compute A=L*Q, copying result to VT
               --              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
               --
               DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
               --
               --              Generate Q in VT
               --              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
               --
               DORGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Produce L in A, zeroing out other entries
               --
               DLASET ('U', M - 1, M - 1, ZERO, ZERO, A (1, 2)'Address, LDA);
               IE    := ITAU;
               ITAUQ := IE + M;
               ITAUP := ITAUQ + M;
               NWORK := ITAUP + M;
               --
               --              Bidiagonalize L in A
               --              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
               --
               DGEBRD
                 (M,
                  M,
                  A'Address,
                  LDA,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in U and computing right singular
               --              vectors of bidiagonal matrix in WORK(IVT)
               --              (Workspace: need M+M*M+BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  M,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  WORK (IVT)'Address,
                  LDWKVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite U by left singular vectors of L and WORK(IVT)
               --              by right singular vectors of L
               --              (Workspace: need M*M+3*M, prefer M*M+2*M+M*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  M,
                  M,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  WORK (IVT)'Address,
                  LDWKVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply right singular vectors of L in WORK(IVT) by
               --              Q in VT, storing result in A
               --              (Workspace: need M*M)
               --
               DGEMM ('N', 'N', M, N, M, ONE, WORK (IVT)'Address, LDWKVT, VT'Address, LDVT, ZERO, A'Address, LDA);
               --
               --              Copy right singular vectors of A from A to VT
               --
               DLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
               --
            end if;
         --
         else
            --
            --           N .LT. MNTHR
            --
            --           Path 5t (N greater than M, but not much larger)
            --           Reduce to bidiagonal form without LQ decomposition
            --
            IE    := 1;
            ITAUQ := IE + M;
            ITAUP := ITAUQ + M;
            NWORK := ITAUP + M;
            --
            --           Bidiagonalize A
            --           (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
            --
            DGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               WORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (NWORK)'Address,
               LWORK - NWORK + 1,
               IERR);
            if WNTQN then
               --
               --              Perform bidiagonal SVD, only computing singular values
               --              (Workspace: need M+BDSPAC)
               --
               DBDSDC
                 ('L',
                  'N',
                  M,
                  S'Address,
                  WORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
            elsif WNTQO then
               LDWKVT := M;
               IVT    := NWORK;
               if LWORK >= M * N + 3 * M + BDSPAC then
                  --
                  --                 WORK( IVT ) is M by N
                  --
                  DLASET ('F', M, N, ZERO, ZERO, WORK (IVT)'Address, LDWKVT);
                  NWORK := IVT + LDWKVT * N;
               else
                  --
                  --                 WORK( IVT ) is M by M
                  --
                  NWORK := IVT + LDWKVT * M;
                  IL    := NWORK;
                  --
                  --                 WORK(IL) is M by CHUNK
                  --
                  CHUNK := (LWORK - M * M - 3 * M) / M;
               end if;
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in U and computing right singular
               --              vectors of bidiagonal matrix in WORK(IVT)
               --              (Workspace: need M*M+BDSPAC)
               --
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  WORK (IVT)'Address,
                  LDWKVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite U by left singular vectors of A
               --              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               if LWORK >= M * N + 3 * M + BDSPAC then
                  --
                  --                 Overwrite WORK(IVT) by left singular vectors of A
                  --                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --
                  DORMBR
                    ('P',
                     'R',
                     'T',
                     M,
                     N,
                     M,
                     A'Address,
                     LDA,
                     WORK (ITAUP)'Address,
                     WORK (IVT)'Address,
                     LDWKVT,
                     WORK (NWORK)'Address,
                     LWORK - NWORK + 1,
                     IERR);
                  --
                  --                 Copy right singular vectors of A from WORK(IVT) to A
                  --
                  DLACPY ('F', M, N, WORK (IVT)'Address, LDWKVT, A'Address, LDA);
               else
                  --
                  --                 Generate P**T in A
                  --                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --
                  DORGBR ('P', M, N, M, A'Address, LDA, WORK (ITAUP)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
                  --
                  --                 Multiply Q in A by right singular vectors of
                  --                 bidiagonal matrix in WORK(IVT), storing result in
                  --                 WORK(IL) and copying to A
                  --                 (Workspace: need 2*M*M, prefer M*M+M*N)
                  --
                  I := 1 - CHUNK;
                  loop
                     I := I + CHUNK;
                     exit when I > N;
                     BLK := min (N - I + 1, CHUNK);
                     DGEMM
                       ('N',
                        'N',
                        M,
                        BLK,
                        M,
                        ONE,
                        WORK (IVT)'Address,
                        LDWKVT,
                        A (1, I)'Address,
                        LDA,
                        ZERO,
                        WORK (IL)'Address,
                        M);
                     DLACPY ('F', M, BLK, WORK (IL)'Address, M, A (1, I)'Address, LDA);
                  end loop;
               end if;
            elsif WNTQS then
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in U and computing right singular
               --              vectors of bidiagonal matrix in VT
               --              (Workspace: need M+BDSPAC)
               --
               DLASET ('F', M, N, ZERO, ZERO, VT'Address, LDVT);
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Overwrite U by left singular vectors of A and VT
               --              by right singular vectors of A
               --              (Workspace: need 3*M, prefer 2*M+M*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  M,
                  N,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
            elsif WNTQA then
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in U and computing right singular
               --              vectors of bidiagonal matrix in VT
               --              (Workspace: need M+BDSPAC)
               --
               DLASET ('F', N, N, ZERO, ZERO, VT'Address, LDVT);
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  WORK (IE)'Address,
                  U'Address,
                  LDU,
                  VT'Address,
                  LDVT,
                  DUM'Address,
                  IDUM'Address,
                  WORK (NWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Set the right corner of VT to identity matrix
               --
               if N > M then
                  DLASET ('F', N - M, N - M, ZERO, ONE, VT (M + 1, M + 1)'Address, LDVT);
               end if;
               --
               --              Overwrite U by left singular vectors of A and VT
               --              by right singular vectors of A
               --              (Workspace: need 2*M+N, prefer 2*M+N*NB)
               --
               DORMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               DORMBR
                 ('P',
                  'R',
                  'T',
                  N,
                  N,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
            end if;
            --
         end if;
         --
      end if;
      --
      --     Undo scaling if necessary
      --
      if ISCL = 1 then
         if ANRM > BIGNUM then
            DLASCL ('G', 0, 0, BIGNUM, ANRM, MINMN, 1, S'Address, MINMN, IERR);
         end if;
         if ANRM < SMLNUM then
            DLASCL ('G', 0, 0, SMLNUM, ANRM, MINMN, 1, S'Address, MINMN, IERR);
         end if;
      end if;
      --
      --     Return optimal workspace in WORK(1)
      --
      WORK (1) := Real (MAXWRK);
      --
      return;
      --
      --     End of DGESDD
      --
   end DGESDD;

   procedure DGESV
     (N    : Integer;
      NRHS : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer;
      IPIV : in out Ftn_Integer_Vector;
      B    : in out Ftn_Real_Matrix;
      LDB  : Integer;
      INFO : in out Integer)
   is
   --  DGESV computes the solution to system of linear equations A * X = B for GE matrices
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LDB, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGESV computes the solution to a real system of linear equations
   --     A * X = B,
   --  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
   --
   --  The LU decomposition with partial pivoting and row interchanges is
   --  used to factor A as
   --     A = P * L * U,
   --  where P is a permutation matrix, L is unit lower triangular, and U is
   --  upper triangular.  The factored form of A is then used to solve the
   --  system of equations A * X = B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The number of linear equations, i.e., the order of the
   --           matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the N-by-N coefficient matrix A.
   --           On exit, the factors L and U from the factorization
   --           A = P*L*U; the unit diagonal elements of L are not stored.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           The pivot indices that define the permutation matrix P;
   --           row i of the matrix was interchanged with row IPIV(i).
   --
   --  [in,out] B
   --           B is DOUBLE PRECISION array, dimension (LDB,NRHS)
   --           On entry, the N-by-NRHS matrix of right hand side matrix B.
   --           On exit, if INFO = 0, the N-by-NRHS solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
   --                 has been completed, but the factor U is exactly
   --                 singular, so the solution could not be computed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Subroutines ..
   --      EXTERNAL           DGETRF, DGETRS, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if N < 0 then
         INFO := -1;
      elsif NRHS < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      elsif LDB < max (1, N) then
         INFO := -7;
      end if;
      if INFO /= 0 then
         XERBLA ("DGESV ", -INFO);
         return;
      end if;
      --
      --     Compute the LU factorization of A.
      --
      DGETRF (N, N, A, LDA, IPIV, INFO);
      if INFO = 0 then
         --
         --        Solve the system A*X = B, overwriting B with X.
         --
         DGETRS ('N', N, NRHS, A, LDA, IPIV, B, LDB, INFO);
      end if;
      return;
      --
      --     End of DGESV
      --
   end DGESV;

   procedure DGESVD
     (JOBU  : Character;
      JOBVT : Character;
      M     : Integer;
      N     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      S     : in out Ftn_Real_Vector;
      U     : in out Ftn_Real_Matrix;
      LDU   : Integer;
      VT    : in out Ftn_Real_Matrix;
      LDVT  : Integer;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      ZERO           : constant Real := 0.0e0;
      ONE            : constant Real := 1.0e0;
      LQUERY         : Boolean;
      WNTUA          : Boolean;
      WNTUAS         : Boolean;
      WNTUN          : Boolean;
      WNTUO          : Boolean;
      WNTUS          : Boolean;
      WNTVA          : Boolean;
      WNTVAS         : Boolean;
      WNTVN          : Boolean;
      WNTVO          : Boolean;
      WNTVS          : Boolean;
      BDSPAC         : Integer;
      BLK            : Integer;
      CHUNK          : Integer;
      I              : Integer;
      IE             : Integer;
      IERR           : Integer;
      IR             : Integer;
      ISCL           : Integer;
      ITAU           : Integer;
      ITAUP          : Integer;
      ITAUQ          : Integer;
      IU             : Integer;
      IWORK          : Integer;
      LDWRKR         : Integer;
      LDWRKU         : Integer;
      MAXWRK         : Integer;
      MINMN          : Integer;
      MINWRK         : Integer;
      MNTHR          : Integer;
      NCU            : Integer;
      NCVT           : Integer;
      NRU            : Integer;
      NRVT           : Integer;
      WRKBL          : Integer;
      LWORK_DGEQRF   : Integer;
      LWORK_DORGQR_N : Integer;
      LWORK_DORGQR_M : Integer;
      LWORK_DGEBRD   : Integer;
      LWORK_DORGBR_P : Integer;
      LWORK_DORGBR_Q : Integer;
      LWORK_DGELQF   : Integer;
      LWORK_DORGLQ_N : Integer;
      LWORK_DORGLQ_M : Integer;
      ANRM           : Real;
      BIGNUM         : Real;
      EPS            : Real;
      SMLNUM         : Real;
      DUM            : Ftn_Real_Vector (1 .. 1);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBU, JOBVT
   --       INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), S( * ), U( LDU, * ),
   --      $                   VT( LDVT, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGESVD computes the singular value decomposition (SVD) of a real
   --  M-by-N matrix A, optionally computing the left and/or right singular
   --  vectors. The SVD is written
   --
   --       A = U * SIGMA * transpose(V)
   --
   --  where SIGMA is an M-by-N matrix which is zero except for its
   --  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
   --  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
   --  are the singular values of A; they are real and non-negative, and
   --  are returned in descending order.  The first min(m,n) columns of
   --  U and V are the left and right singular vectors of A.
   --
   --  Note that the routine returns V**T, not V.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBU
   --           JOBU is CHARACTER*1
   --           Specifies options for computing all or part of the matrix U:
   --           = 'A':  all M columns of U are returned in array U:
   --           = 'S':  the first min(m,n) columns of U (the left singular
   --                   vectors) are returned in the array U;
   --           = 'O':  the first min(m,n) columns of U (the left singular
   --                   vectors) are overwritten on the array A;
   --           = 'N':  no columns of U (no left singular vectors) are
   --                   computed.
   --
   --  [in] JOBVT
   --           JOBVT is CHARACTER*1
   --           Specifies options for computing all or part of the matrix
   --           V**T:
   --           = 'A':  all N rows of V**T are returned in the array VT;
   --           = 'S':  the first min(m,n) rows of V**T (the right singular
   --                   vectors) are returned in the array VT;
   --           = 'O':  the first min(m,n) rows of V**T (the right singular
   --                   vectors) are overwritten on the array A;
   --           = 'N':  no rows of V**T (no right singular vectors) are
   --                   computed.
   --
   --           JOBVT and JOBU cannot both be 'O'.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the input matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the input matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the M-by-N matrix A.
   --           On exit,
   --           if JOBU = 'O',  A is overwritten with the first min(m,n)
   --                           columns of U (the left singular vectors,
   --                           stored columnwise);
   --           if JOBVT = 'O', A is overwritten with the first min(m,n)
   --                           rows of V**T (the right singular vectors,
   --                           stored rowwise);
   --           if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
   --                           are destroyed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] S
   --           S is DOUBLE PRECISION array, dimension (min(M,N))
   --           The singular values of A, sorted so that S(i) >= S(i+1).
   --
   --  [out] U
   --           U is DOUBLE PRECISION array, dimension (LDU,UCOL)
   --           (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
   --           If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
   --           if JOBU = 'S', U contains the first min(m,n) columns of U
   --           (the left singular vectors, stored columnwise);
   --           if JOBU = 'N' or 'O', U is not referenced.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --           The leading dimension of the array U.  LDU >= 1; if
   --           JOBU = 'S' or 'A', LDU >= M.
   --
   --  [out] VT
   --           VT is DOUBLE PRECISION array, dimension (LDVT,N)
   --           If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
   --           V**T;
   --           if JOBVT = 'S', VT contains the first min(m,n) rows of
   --           V**T (the right singular vectors, stored rowwise);
   --           if JOBVT = 'N' or 'O', VT is not referenced.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --           The leading dimension of the array VT.  LDVT >= 1; if
   --           JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
   --           if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
   --           superdiagonal elements of an upper bidiagonal matrix B
   --           whose diagonal is in S (not necessarily sorted). B
   --           satisfies A = U * B * VT, so it has the same singular values
   --           as A, and singular vectors related by U and VT.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           LWORK >= MAX(1,5*MIN(M,N)) for the paths (see comments inside code):
   --              - PATH 1  (M much larger than N, JOBU='N')
   --              - PATH 1t (N much larger than M, JOBVT='N')
   --           LWORK >= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)) for the other paths
   --           For good performance, LWORK should generally be larger.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if DBDSQR did not converge, INFO specifies how many
   --                 superdiagonals of an intermediate bidiagonal form B
   --                 did not converge to zero. See the description of WORK
   --                 above for details.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DBDSQR, DGEBRD, DGELQF, DGEMM, DGEQRF, DLACPY, DLASCL, DLASET, DORGBR, DORGLQ, DORGQR, DORMBR,
   --XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANGE
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      MINMN  := min (M, N);
      WNTUA  := LSAME (JOBU, 'A');
      WNTUS  := LSAME (JOBU, 'S');
      WNTUAS := WNTUA or WNTUS;
      WNTUO  := LSAME (JOBU, 'O');
      WNTUN  := LSAME (JOBU, 'N');
      WNTVA  := LSAME (JOBVT, 'A');
      WNTVS  := LSAME (JOBVT, 'S');
      WNTVAS := WNTVA or WNTVS;
      WNTVO  := LSAME (JOBVT, 'O');
      WNTVN  := LSAME (JOBVT, 'N');
      LQUERY := (LWORK = -1);
      --
      if not (WNTUA or WNTUS or WNTUO or WNTUN) then
         INFO := -1;
      elsif not (WNTVA or WNTVS or WNTVO or WNTVN) or (WNTVO and WNTUO) then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif LDA < max (1, M) then
         INFO := -6;
      elsif LDU < 1 or (WNTUAS and LDU < M) then
         INFO := -9;
      elsif LDVT < 1 or (WNTVA and LDVT < N) or (WNTVS and LDVT < MINMN) then
         INFO := -11;
      end if;
      --
      --     Compute workspace
      --      (Note: Comments in the code beginning "Workspace:" describe the
      --       minimal amount of workspace needed at that point in the code,
      --       as well as the preferred amount for good performance.
      --       NB refers to the optimal block size for the immediately
      --       following subroutine, as returned by ILAENV.)
      --
      if INFO = 0 then
         MINWRK := 1;
         MAXWRK := 1;
         if M >= N and MINMN > 0 then
            --
            --           Compute space needed for DBDSQR
            --
            MNTHR  := ILAENV (6, "DGESVD", JOBU & JOBVT, M, N, 0, 0);
            BDSPAC := 5 * N;
            --           Compute space needed for DGEQRF
            DGEQRF (M, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DGEQRF := int (DUM (1));
            --           Compute space needed for DORGQR
            DORGQR (M, N, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DORGQR_N := int (DUM (1));
            DORGQR (M, M, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DORGQR_M := int (DUM (1));
            --           Compute space needed for DGEBRD
            DGEBRD
              (N,
               N,
               A'Address,
               LDA,
               S'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               -1,
               IERR);
            LWORK_DGEBRD := int (DUM (1));
            --           Compute space needed for DORGBR P
            DORGBR ('P', N, N, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DORGBR_P := int (DUM (1));
            --           Compute space needed for DORGBR Q
            DORGBR ('Q', N, N, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DORGBR_Q := int (DUM (1));
            --
            if M >= MNTHR then
               if WNTUN then
                  --
                  --                 Path 1 (M much larger than N, JOBU='N')
                  --
                  MAXWRK := N + LWORK_DGEQRF;
                  MAXWRK := max (MAXWRK, 3 * N + LWORK_DGEBRD);
                  if WNTVO or WNTVAS then
                     MAXWRK := max (MAXWRK, 3 * N + LWORK_DORGBR_P);
                  end if;
                  MAXWRK := max (MAXWRK, BDSPAC);
                  MINWRK := max (4 * N, BDSPAC);
               elsif WNTUO and WNTVN then
                  --
                  --                 Path 2 (M much larger than N, JOBU='O', JOBVT='N')
                  --
                  WRKBL  := N + LWORK_DGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_DORGQR_N);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := max (N * N + WRKBL, N * N + M * N + N);
                  MINWRK := max (3 * N + M, BDSPAC);
               elsif WNTUO and WNTVAS then
                  --
                  --                 Path 3 (M much larger than N, JOBU='O', JOBVT='S' or
                  --                 'A')
                  --
                  WRKBL  := N + LWORK_DGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_DORGQR_N);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := max (N * N + WRKBL, N * N + M * N + N);
                  MINWRK := max (3 * N + M, BDSPAC);
               elsif WNTUS and WNTVN then
                  --
                  --                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
                  --
                  WRKBL  := N + LWORK_DGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_DORGQR_N);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := N * N + WRKBL;
                  MINWRK := max (3 * N + M, BDSPAC);
               elsif WNTUS and WNTVO then
                  --
                  --                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
                  --
                  WRKBL  := N + LWORK_DGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_DORGQR_N);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := 2 * N * N + WRKBL;
                  MINWRK := max (3 * N + M, BDSPAC);
               elsif WNTUS and WNTVAS then
                  --
                  --                 Path 6 (M much larger than N, JOBU='S', JOBVT='S' or
                  --                 'A')
                  --
                  WRKBL  := N + LWORK_DGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_DORGQR_N);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := N * N + WRKBL;
                  MINWRK := max (3 * N + M, BDSPAC);
               elsif WNTUA and WNTVN then
                  --
                  --                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
                  --
                  WRKBL  := N + LWORK_DGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_DORGQR_M);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := N * N + WRKBL;
                  MINWRK := max (3 * N + M, BDSPAC);
               elsif WNTUA and WNTVO then
                  --
                  --                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
                  --
                  WRKBL  := N + LWORK_DGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_DORGQR_M);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := 2 * N * N + WRKBL;
                  MINWRK := max (3 * N + M, BDSPAC);
               elsif WNTUA and WNTVAS then
                  --
                  --                 Path 9 (M much larger than N, JOBU='A', JOBVT='S' or
                  --                 'A')
                  --
                  WRKBL  := N + LWORK_DGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_DORGQR_M);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, 3 * N + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := N * N + WRKBL;
                  MINWRK := max (3 * N + M, BDSPAC);
               end if;
            else
               --
               --              Path 10 (M at least N, but not much larger)
               --
               DGEBRD
                 (M,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  -1,
                  IERR);
               LWORK_DGEBRD := int (DUM (1));
               MAXWRK       := 3 * N + LWORK_DGEBRD;
               if WNTUS or WNTUO then
                  DORGBR ('Q', M, N, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
                  LWORK_DORGBR_Q := int (DUM (1));
                  MAXWRK         := max (MAXWRK, 3 * N + LWORK_DORGBR_Q);
               end if;
               if WNTUA then
                  DORGBR ('Q', M, M, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
                  LWORK_DORGBR_Q := int (DUM (1));
                  MAXWRK         := max (MAXWRK, 3 * N + LWORK_DORGBR_Q);
               end if;
               if not WNTVN then
                  MAXWRK := max (MAXWRK, 3 * N + LWORK_DORGBR_P);
               end if;
               MAXWRK := max (MAXWRK, BDSPAC);
               MINWRK := max (3 * N + M, BDSPAC);
            end if;
         elsif MINMN > 0 then
            --
            --           Compute space needed for DBDSQR
            --
            MNTHR  := ILAENV (6, "DGESVD", JOBU & JOBVT, M, N, 0, 0);
            BDSPAC := 5 * M;
            --           Compute space needed for DGELQF
            DGELQF (M, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DGELQF := int (DUM (1));
            --           Compute space needed for DORGLQ
            DORGLQ (N, N, M, DUM (1)'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DORGLQ_N := int (DUM (1));
            DORGLQ (M, N, M, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DORGLQ_M := int (DUM (1));
            --           Compute space needed for DGEBRD
            DGEBRD
              (M,
               M,
               A'Address,
               LDA,
               S'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               -1,
               IERR);
            LWORK_DGEBRD := int (DUM (1));
            --            Compute space needed for DORGBR P
            DORGBR ('P', M, M, M, A'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DORGBR_P := int (DUM (1));
            --           Compute space needed for DORGBR Q
            DORGBR ('Q', M, M, M, A'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_DORGBR_Q := int (DUM (1));
            if N >= MNTHR then
               if WNTVN then
                  --
                  --                 Path 1t(N much larger than M, JOBVT='N')
                  --
                  MAXWRK := M + LWORK_DGELQF;
                  MAXWRK := max (MAXWRK, 3 * M + LWORK_DGEBRD);
                  if WNTUO or WNTUAS then
                     MAXWRK := max (MAXWRK, 3 * M + LWORK_DORGBR_Q);
                  end if;
                  MAXWRK := max (MAXWRK, BDSPAC);
                  MINWRK := max (4 * M, BDSPAC);
               elsif WNTVO and WNTUN then
                  --
                  --                 Path 2t(N much larger than M, JOBU='N', JOBVT='O')
                  --
                  WRKBL  := M + LWORK_DGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_DORGLQ_M);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := max (M * M + WRKBL, M * M + M * N + M);
                  MINWRK := max (3 * M + N, BDSPAC);
               elsif WNTVO and WNTUAS then
                  --
                  --                 Path 3t(N much larger than M, JOBU='S' or 'A',
                  --                 JOBVT='O')
                  --
                  WRKBL  := M + LWORK_DGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_DORGLQ_M);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := max (M * M + WRKBL, M * M + M * N + M);
                  MINWRK := max (3 * M + N, BDSPAC);
               elsif WNTVS and WNTUN then
                  --
                  --                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
                  --
                  WRKBL  := M + LWORK_DGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_DORGLQ_M);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := M * M + WRKBL;
                  MINWRK := max (3 * M + N, BDSPAC);
               elsif WNTVS and WNTUO then
                  --
                  --                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
                  --
                  WRKBL  := M + LWORK_DGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_DORGLQ_M);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := 2 * M * M + WRKBL;
                  MINWRK := max (3 * M + N, BDSPAC);
               elsif WNTVS and WNTUAS then
                  --
                  --                 Path 6t(N much larger than M, JOBU='S' or 'A',
                  --                 JOBVT='S')
                  --
                  WRKBL  := M + LWORK_DGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_DORGLQ_M);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := M * M + WRKBL;
                  MINWRK := max (3 * M + N, BDSPAC);
               elsif WNTVA and WNTUN then
                  --
                  --                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
                  --
                  WRKBL  := M + LWORK_DGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_DORGLQ_N);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := M * M + WRKBL;
                  MINWRK := max (3 * M + N, BDSPAC);
               elsif WNTVA and WNTUO then
                  --
                  --                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
                  --
                  WRKBL  := M + LWORK_DGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_DORGLQ_N);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := 2 * M * M + WRKBL;
                  MINWRK := max (3 * M + N, BDSPAC);
               elsif WNTVA and WNTUAS then
                  --
                  --                 Path 9t(N much larger than M, JOBU='S' or 'A',
                  --                 JOBVT='A')
                  --
                  WRKBL  := M + LWORK_DGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_DORGLQ_N);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DGEBRD);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_P);
                  WRKBL  := max (WRKBL, 3 * M + LWORK_DORGBR_Q);
                  WRKBL  := max (WRKBL, BDSPAC);
                  MAXWRK := M * M + WRKBL;
                  MINWRK := max (3 * M + N, BDSPAC);
               end if;
            else
               --
               --              Path 10t(N greater than M, but not much larger)
               --
               DGEBRD
                 (M,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  -1,
                  IERR);
               LWORK_DGEBRD := int (DUM (1));
               MAXWRK       := 3 * M + LWORK_DGEBRD;
               if WNTVS or WNTVO then
                  --                Compute space needed for DORGBR P
                  DORGBR ('P', M, N, M, A'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
                  LWORK_DORGBR_P := int (DUM (1));
                  MAXWRK         := max (MAXWRK, 3 * M + LWORK_DORGBR_P);
               end if;
               if WNTVA then
                  DORGBR ('P', N, N, M, A'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
                  LWORK_DORGBR_P := int (DUM (1));
                  MAXWRK         := max (MAXWRK, 3 * M + LWORK_DORGBR_P);
               end if;
               if not WNTUN then
                  MAXWRK := max (MAXWRK, 3 * M + LWORK_DORGBR_Q);
               end if;
               MAXWRK := max (MAXWRK, BDSPAC);
               MINWRK := max (3 * M + N, BDSPAC);
            end if;
         end if;
         MAXWRK   := max (MAXWRK, MINWRK);
         WORK (1) := Real (MAXWRK);
         --
         if LWORK < MINWRK and not LQUERY then
            INFO := -13;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DGESVD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     Get machine constants
      --
      EPS    := DLAMCH ('P');
      SMLNUM := Sqrt (DLAMCH ('S')) / EPS;
      BIGNUM := ONE / SMLNUM;
      --
      --     Scale A if max element outside range [SMLNUM,BIGNUM]
      --
      ANRM := DLANGE ('M', M, N, A, LDA, DUM);
      ISCL := 0;
      if ANRM > ZERO and ANRM < SMLNUM then
         ISCL := 1;
         DLASCL ('G', 0, 0, ANRM, SMLNUM, M, N, A'Address, LDA, IERR);
      elsif ANRM > BIGNUM then
         ISCL := 1;
         DLASCL ('G', 0, 0, ANRM, BIGNUM, M, N, A'Address, LDA, IERR);
      end if;
      --
      if M >= N then
         --
         --        A has at least as many rows as columns. If A has sufficiently
         --        more rows than columns, first reduce using the QR
         --        decomposition (if sufficient workspace available)
         --
         if M >= MNTHR then
            --
            if WNTUN then
               --
               --              Path 1 (M much larger than N, JOBU='N')
               --              No left singular vectors to be computed
               --
               ITAU  := 1;
               IWORK := ITAU + N;
               --
               --              Compute A=Q*R
               --              (Workspace: need 2*N, prefer N+N*NB)
               --
               DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
               --
               --              Zero out below R
               --
               DLASET ('L', N - 1, N - 1, ZERO, ZERO, A (2, 1)'Address, LDA);
               IE    := 1;
               ITAUQ := IE + N;
               ITAUP := ITAUQ + N;
               IWORK := ITAUP + N;
               --
               --              Bidiagonalize R in A
               --              (Workspace: need 4*N, prefer 3*N+2*N*NB)
               --
               DGEBRD
                 (N,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (IWORK)'Address,
                  LWORK - IWORK + 1,
                  IERR);
               NCVT := 0;
               if WNTVO or WNTVAS then
                  --
                  --                 If right singular vectors desired, generate P'.
                  --                 (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
                  --
                  DORGBR ('P', N, N, N, A'Address, LDA, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  NCVT := N;
               end if;
               IWORK := IE + N;
               --
               --              Perform bidiagonal QR iteration, computing right
               --              singular vectors of A in A if desired
               --              (Workspace: need BDSPAC)
               --
               DBDSQR
                 ('U',
                  N,
                  NCVT,
                  0,
                  0,
                  S'Address,
                  WORK (IE)'Address,
                  A'Address,
                  LDA,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  WORK (IWORK)'Address,
                  INFO);
               --
               --              If right singular vectors desired in VT, copy them there
               --
               if WNTVAS then
                  DLACPY ('F', N, N, A'Address, LDA, VT'Address, LDVT);
               end if;
            --
            elsif WNTUO and WNTVN then
               --
               --              Path 2 (M much larger than N, JOBU='O', JOBVT='N')
               --              N left singular vectors to be overwritten on A and
               --              no right singular vectors to be computed
               --
               if LWORK >= N * N + max (4 * N, BDSPAC) then
                  --
                  --                 Sufficient workspace for a fast algorithm
                  --
                  IR := 1;
                  if LWORK >= max (WRKBL, LDA * N + N) + LDA * N then
                     --
                     --                    WORK(IU) is LDA by N, WORK(IR) is LDA by N
                     --
                     LDWRKU := LDA;
                     LDWRKR := LDA;
                  elsif LWORK >= max (WRKBL, LDA * N + N) + N * N then
                     --
                     --                    WORK(IU) is LDA by N, WORK(IR) is N by N
                     --
                     LDWRKU := LDA;
                     LDWRKR := N;
                  else
                     --
                     --                    WORK(IU) is LDWRKU by N, WORK(IR) is N by N
                     --
                     LDWRKU := (LWORK - N * N - N) / N;
                     LDWRKR := N;
                  end if;
                  ITAU  := IR + LDWRKR * N;
                  IWORK := ITAU + N;
                  --
                  --                 Compute A=Q*R
                  --                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --
                  DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy R to WORK(IR) and zero out below it
                  --
                  DLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                  DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IR + 1)'Address, LDWRKR);
                  --
                  --                 Generate Q in A
                  --                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --
                  DORGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := ITAU;
                  ITAUQ := IE + N;
                  ITAUP := ITAUQ + N;
                  IWORK := ITAUP + N;
                  --
                  --                 Bidiagonalize R in WORK(IR)
                  --                 (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
                  --
                  DGEBRD
                    (N,
                     N,
                     WORK (IR)'Address,
                     LDWRKR,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate left vectors bidiagonalizing R
                  --                 (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
                  --
                  DORGBR
                    ('Q',
                     N,
                     N,
                     N,
                     WORK (IR)'Address,
                     LDWRKR,
                     WORK (ITAUQ)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  IWORK := IE + N;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of R in WORK(IR)
                  --                 (Workspace: need N*N+BDSPAC)
                  --
                  DBDSQR
                    ('U',
                     N,
                     0,
                     N,
                     0,
                     S'Address,
                     WORK (IE)'Address,
                     DUM'Address,
                     1,
                     WORK (IR)'Address,
                     LDWRKR,
                     DUM'Address,
                     1,
                     WORK (IWORK)'Address,
                     INFO);
                  IU := IE + N;
                  --
                  --                 Multiply Q in A by left singular vectors of R in
                  --                 WORK(IR), storing result in WORK(IU) and copying to A
                  --                 (Workspace: need N*N+2*N, prefer N*N+M*N+N)
                  --
                  I := 1 - LDWRKU;
                  loop
                     I := I + LDWRKU;
                     exit when I > M;
                     CHUNK := min (M - I + 1, LDWRKU);
                     DGEMM
                       ('N',
                        'N',
                        CHUNK,
                        N,
                        N,
                        ONE,
                        A (I, 1)'Address,
                        LDA,
                        WORK (IR)'Address,
                        LDWRKR,
                        ZERO,
                        WORK (IU)'Address,
                        LDWRKU);
                     DLACPY ('F', CHUNK, N, WORK (IU)'Address, LDWRKU, A (I, 1)'Address, LDA);
                  end loop;
               --
               else
                  --
                  --                 Insufficient workspace for a fast algorithm
                  --
                  IE    := 1;
                  ITAUQ := IE + N;
                  ITAUP := ITAUQ + N;
                  IWORK := ITAUP + N;
                  --
                  --                 Bidiagonalize A
                  --                 (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
                  --
                  DGEBRD
                    (M,
                     N,
                     A'Address,
                     LDA,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate left vectors bidiagonalizing A
                  --                 (Workspace: need 4*N, prefer 3*N+N*NB)
                  --
                  DORGBR ('Q', M, N, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IWORK := IE + N;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of A in A
                  --                 (Workspace: need BDSPAC)
                  --
                  DBDSQR
                    ('U',
                     N,
                     0,
                     M,
                     0,
                     S'Address,
                     WORK (IE)'Address,
                     DUM'Address,
                     1,
                     A'Address,
                     LDA,
                     DUM'Address,
                     1,
                     WORK (IWORK)'Address,
                     INFO);
                  --
               end if;
            --
            elsif WNTUO and WNTVAS then
               --
               --              Path 3 (M much larger than N, JOBU='O', JOBVT='S' or 'A')
               --              N left singular vectors to be overwritten on A and
               --              N right singular vectors to be computed in VT
               --
               if LWORK >= N * N + max (4 * N, BDSPAC) then
                  --
                  --                 Sufficient workspace for a fast algorithm
                  --
                  IR := 1;
                  if LWORK >= max (WRKBL, LDA * N + N) + LDA * N then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is LDA by N
                     --
                     LDWRKU := LDA;
                     LDWRKR := LDA;
                  elsif LWORK >= max (WRKBL, LDA * N + N) + N * N then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is N by N
                     --
                     LDWRKU := LDA;
                     LDWRKR := N;
                  else
                     --
                     --                    WORK(IU) is LDWRKU by N and WORK(IR) is N by N
                     --
                     LDWRKU := (LWORK - N * N - N) / N;
                     LDWRKR := N;
                  end if;
                  ITAU  := IR + LDWRKR * N;
                  IWORK := ITAU + N;
                  --
                  --                 Compute A=Q*R
                  --                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --
                  DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy R to VT, zeroing out below it
                  --
                  DLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
                  if N > 1 then
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, VT (2, 1)'Address, LDVT);
                  end if;
                  --
                  --                 Generate Q in A
                  --                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --
                  DORGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := ITAU;
                  ITAUQ := IE + N;
                  ITAUP := ITAUQ + N;
                  IWORK := ITAUP + N;
                  --
                  --                 Bidiagonalize R in VT, copying result to WORK(IR)
                  --                 (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
                  --
                  DGEBRD
                    (N,
                     N,
                     VT'Address,
                     LDVT,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  DLACPY ('L', N, N, VT'Address, LDVT, WORK (IR)'Address, LDWRKR);
                  --
                  --                 Generate left vectors bidiagonalizing R in WORK(IR)
                  --                 (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
                  --
                  DORGBR
                    ('Q',
                     N,
                     N,
                     N,
                     WORK (IR)'Address,
                     LDWRKR,
                     WORK (ITAUQ)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate right vectors bidiagonalizing R in VT
                  --                 (Workspace: need N*N+4*N-1, prefer N*N+3*N+(N-1)*NB)
                  --
                  DORGBR
                    ('P',
                     N,
                     N,
                     N,
                     VT'Address,
                     LDVT,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  IWORK := IE + N;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of R in WORK(IR) and computing right
                  --                 singular vectors of R in VT
                  --                 (Workspace: need N*N+BDSPAC)
                  --
                  DBDSQR
                    ('U',
                     N,
                     N,
                     N,
                     0,
                     S'Address,
                     WORK (IE)'Address,
                     VT'Address,
                     LDVT,
                     WORK (IR)'Address,
                     LDWRKR,
                     DUM'Address,
                     1,
                     WORK (IWORK)'Address,
                     INFO);
                  IU := IE + N;
                  --
                  --                 Multiply Q in A by left singular vectors of R in
                  --                 WORK(IR), storing result in WORK(IU) and copying to A
                  --                 (Workspace: need N*N+2*N, prefer N*N+M*N+N)
                  --
                  I := 1 - LDWRKU;
                  loop
                     I := I + LDWRKU;
                     exit when I > M;
                     CHUNK := min (M - I + 1, LDWRKU);
                     DGEMM
                       ('N',
                        'N',
                        CHUNK,
                        N,
                        N,
                        ONE,
                        A (I, 1)'Address,
                        LDA,
                        WORK (IR)'Address,
                        LDWRKR,
                        ZERO,
                        WORK (IU)'Address,
                        LDWRKU);
                     DLACPY ('F', CHUNK, N, WORK (IU)'Address, LDWRKU, A (I, 1)'Address, LDA);
                  end loop;
               --
               else
                  --
                  --                 Insufficient workspace for a fast algorithm
                  --
                  ITAU  := 1;
                  IWORK := ITAU + N;
                  --
                  --                 Compute A=Q*R
                  --                 (Workspace: need 2*N, prefer N+N*NB)
                  --
                  DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy R to VT, zeroing out below it
                  --
                  DLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
                  if N > 1 then
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, VT (2, 1)'Address, LDVT);
                  end if;
                  --
                  --                 Generate Q in A
                  --                 (Workspace: need 2*N, prefer N+N*NB)
                  --
                  DORGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := ITAU;
                  ITAUQ := IE + N;
                  ITAUP := ITAUQ + N;
                  IWORK := ITAUP + N;
                  --
                  --                 Bidiagonalize R in VT
                  --                 (Workspace: need 4*N, prefer 3*N+2*N*NB)
                  --
                  DGEBRD
                    (N,
                     N,
                     VT'Address,
                     LDVT,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Multiply Q in A by left vectors bidiagonalizing R
                  --                 (Workspace: need 3*N+M, prefer 3*N+M*NB)
                  --
                  DORMBR
                    ('Q',
                     'R',
                     'N',
                     M,
                     N,
                     N,
                     VT'Address,
                     LDVT,
                     WORK (ITAUQ)'Address,
                     A'Address,
                     LDA,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate right vectors bidiagonalizing R in VT
                  --                 (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
                  --
                  DORGBR
                    ('P',
                     N,
                     N,
                     N,
                     VT'Address,
                     LDVT,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  IWORK := IE + N;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of A in A and computing right
                  --                 singular vectors of A in VT
                  --                 (Workspace: need BDSPAC)
                  --
                  DBDSQR
                    ('U',
                     N,
                     N,
                     M,
                     0,
                     S'Address,
                     WORK (IE)'Address,
                     VT'Address,
                     LDVT,
                     A'Address,
                     LDA,
                     DUM'Address,
                     1,
                     WORK (IWORK)'Address,
                     INFO);
                  --
               end if;
            --
            elsif WNTUS then
               --
               if WNTVN then
                  --
                  --                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
                  --                 N left singular vectors to be computed in U and
                  --                 no right singular vectors to be computed
                  --
                  if LWORK >= N * N + max (4 * N, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IR := 1;
                     if LWORK >= WRKBL + LDA * N then
                        --
                        --                       WORK(IR) is LDA by N
                        --
                        LDWRKR := LDA;
                     else
                        --
                        --                       WORK(IR) is N by N
                        --
                        LDWRKR := N;
                     end if;
                     ITAU  := IR + LDWRKR * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R
                     --                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IR), zeroing out below it
                     --
                     DLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IR + 1)'Address, LDWRKR);
                     --
                     --                    Generate Q in A
                     --                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --
                     DORGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IR)
                     --                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left vectors bidiagonalizing R in WORK(IR)
                     --                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
                     --
                     DORGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IR)
                     --                    (Workspace: need N*N+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        0,
                        N,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        DUM'Address,
                        1,
                        WORK (IR)'Address,
                        LDWRKR,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in A by left singular vectors of R in
                     --                    WORK(IR), storing result in U
                     --                    (Workspace: need N*N)
                     --
                     DGEMM ('N', 'N', M, N, N, ONE, A'Address, LDA, WORK (IR)'Address, LDWRKR, ZERO, U'Address, LDU);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DORGQR (M, N, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Zero out below R in A
                     --
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, A (2, 1)'Address, LDA);
                     --
                     --                    Bidiagonalize R in A
                     --                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        A'Address,
                        LDA,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left vectors bidiagonalizing R
                     --                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
                     --
                     DORMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        0,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        DUM'Address,
                        1,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTVO then
                  --
                  --                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
                  --                 N left singular vectors to be computed in U and
                  --                 N right singular vectors to be overwritten on A
                  --
                  if LWORK >= 2 * N * N + max (4 * N, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + 2 * LDA * N then
                        --
                        --                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := LDA;
                     elsif LWORK >= WRKBL + (LDA + N) * N then
                        --
                        --                       WORK(IU) is LDA by N and WORK(IR) is N by N
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := N;
                     else
                        --
                        --                       WORK(IU) is N by N and WORK(IR) is N by N
                        --
                        LDWRKU := N;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := N;
                     end if;
                     ITAU  := IR + LDWRKR * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R
                     --                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IU), zeroing out below it
                     --
                     DLACPY ('U', N, N, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IU + 1)'Address, LDWRKU);
                     --
                     --                    Generate Q in A
                     --                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
                     --
                     DORGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IU), copying result to
                     --                    WORK(IR)
                     --                    (Workspace: need 2*N*N+4*N,
                     --                                prefer 2*N*N+3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     DLACPY ('U', N, N, WORK (IU)'Address, LDWRKU, WORK (IR)'Address, LDWRKR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IU)
                     --                    (Workspace: need 2*N*N+4*N, prefer 2*N*N+3*N+N*NB)
                     --
                     DORGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IR)
                     --                    (Workspace: need 2*N*N+4*N-1,
                     --                                prefer 2*N*N+3*N+(N-1)*NB)
                     --
                     DORGBR
                       ('P',
                        N,
                        N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IU) and computing
                     --                    right singular vectors of R in WORK(IR)
                     --                    (Workspace: need 2*N*N+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        N,
                        N,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (IU)'Address,
                        LDWRKU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in A by left singular vectors of R in
                     --                    WORK(IU), storing result in U
                     --                    (Workspace: need N*N)
                     --
                     DGEMM ('N', 'N', M, N, N, ONE, A'Address, LDA, WORK (IU)'Address, LDWRKU, ZERO, U'Address, LDU);
                     --
                     --                    Copy right singular vectors of R to A
                     --                    (Workspace: need N*N)
                     --
                     DLACPY ('F', N, N, WORK (IR)'Address, LDWRKR, A'Address, LDA);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DORGQR (M, N, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Zero out below R in A
                     --
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, A (2, 1)'Address, LDA);
                     --
                     --                    Bidiagonalize R in A
                     --                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        A'Address,
                        LDA,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left vectors bidiagonalizing R
                     --                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
                     --
                     DORMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right vectors bidiagonalizing R in A
                     --                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
                     --
                     DORGBR
                       ('P',
                        N,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in A
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        N,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        A'Address,
                        LDA,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTVAS then
                  --
                  --                 Path 6 (M much larger than N, JOBU='S', JOBVT='S'
                  --                         or 'A')
                  --                 N left singular vectors to be computed in U and
                  --                 N right singular vectors to be computed in VT
                  --
                  if LWORK >= N * N + max (4 * N, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + LDA * N then
                        --
                        --                       WORK(IU) is LDA by N
                        --
                        LDWRKU := LDA;
                     else
                        --
                        --                       WORK(IU) is N by N
                        --
                        LDWRKU := N;
                     end if;
                     ITAU  := IU + LDWRKU * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R
                     --                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IU), zeroing out below it
                     --
                     DLACPY ('U', N, N, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IU + 1)'Address, LDWRKU);
                     --
                     --                    Generate Q in A
                     --                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --
                     DORGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IU), copying result to VT
                     --                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     DLACPY ('U', N, N, WORK (IU)'Address, LDWRKU, VT'Address, LDVT);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IU)
                     --                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
                     --
                     DORGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in VT
                     --                    (Workspace: need N*N+4*N-1,
                     --                                prefer N*N+3*N+(N-1)*NB)
                     --
                     DORGBR
                       ('P',
                        N,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IU) and computing
                     --                    right singular vectors of R in VT
                     --                    (Workspace: need N*N+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        N,
                        N,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IU)'Address,
                        LDWRKU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in A by left singular vectors of R in
                     --                    WORK(IU), storing result in U
                     --                    (Workspace: need N*N)
                     --
                     DGEMM ('N', 'N', M, N, N, ONE, A'Address, LDA, WORK (IU)'Address, LDWRKU, ZERO, U'Address, LDU);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DORGQR (M, N, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to VT, zeroing out below it
                     --
                     DLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
                     if N > 1 then
                        DLASET ('L', N - 1, N - 1, ZERO, ZERO, VT (2, 1)'Address, LDVT);
                     end if;
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in VT
                     --                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        VT'Address,
                        LDVT,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left bidiagonalizing vectors
                     --                    in VT
                     --                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
                     --
                     DORMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in VT
                     --                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
                     --
                     DORGBR
                       ('P',
                        N,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in VT
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        N,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
                  --
               end if;
            --
            elsif WNTUA then
               --
               if WNTVN then
                  --
                  --                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
                  --                 M left singular vectors to be computed in U and
                  --                 no right singular vectors to be computed
                  --
                  if LWORK >= N * N + max (N + M, 4 * N, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IR := 1;
                     if LWORK >= WRKBL + LDA * N then
                        --
                        --                       WORK(IR) is LDA by N
                        --
                        LDWRKR := LDA;
                     else
                        --
                        --                       WORK(IR) is N by N
                        --
                        LDWRKR := N;
                     end if;
                     ITAU  := IR + LDWRKR * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Copy R to WORK(IR), zeroing out below it
                     --
                     DLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IR + 1)'Address, LDWRKR);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need N*N+N+M, prefer N*N+N+M*NB)
                     --
                     DORGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IR)
                     --                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IR)
                     --                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
                     --
                     DORGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IR)
                     --                    (Workspace: need N*N+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        0,
                        N,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        DUM'Address,
                        1,
                        WORK (IR)'Address,
                        LDWRKR,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in U by left singular vectors of R in
                     --                    WORK(IR), storing result in A
                     --                    (Workspace: need N*N)
                     --
                     DGEMM ('N', 'N', M, N, N, ONE, U'Address, LDU, WORK (IR)'Address, LDWRKR, ZERO, A'Address, LDA);
                     --
                     --                    Copy left singular vectors of A from A to U
                     --
                     DLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need N+M, prefer N+M*NB)
                     --
                     DORGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Zero out below R in A
                     --
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, A (2, 1)'Address, LDA);
                     --
                     --                    Bidiagonalize R in A
                     --                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        A'Address,
                        LDA,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left bidiagonalizing vectors
                     --                    in A
                     --                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
                     --
                     DORMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        0,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        DUM'Address,
                        1,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTVO then
                  --
                  --                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
                  --                 M left singular vectors to be computed in U and
                  --                 N right singular vectors to be overwritten on A
                  --
                  if LWORK >= 2 * N * N + max (N + M, 4 * N, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + 2 * LDA * N then
                        --
                        --                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := LDA;
                     elsif LWORK >= WRKBL + (LDA + N) * N then
                        --
                        --                       WORK(IU) is LDA by N and WORK(IR) is N by N
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := N;
                     else
                        --
                        --                       WORK(IU) is N by N and WORK(IR) is N by N
                        --
                        LDWRKU := N;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := N;
                     end if;
                     ITAU  := IR + LDWRKR * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need 2*N*N+N+M, prefer 2*N*N+N+M*NB)
                     --
                     DORGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IU), zeroing out below it
                     --
                     DLACPY ('U', N, N, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IU + 1)'Address, LDWRKU);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IU), copying result to
                     --                    WORK(IR)
                     --                    (Workspace: need 2*N*N+4*N,
                     --                                prefer 2*N*N+3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     DLACPY ('U', N, N, WORK (IU)'Address, LDWRKU, WORK (IR)'Address, LDWRKR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IU)
                     --                    (Workspace: need 2*N*N+4*N, prefer 2*N*N+3*N+N*NB)
                     --
                     DORGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IR)
                     --                    (Workspace: need 2*N*N+4*N-1,
                     --                                prefer 2*N*N+3*N+(N-1)*NB)
                     --
                     DORGBR
                       ('P',
                        N,
                        N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IU) and computing
                     --                    right singular vectors of R in WORK(IR)
                     --                    (Workspace: need 2*N*N+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        N,
                        N,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (IU)'Address,
                        LDWRKU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in U by left singular vectors of R in
                     --                    WORK(IU), storing result in A
                     --                    (Workspace: need N*N)
                     --
                     DGEMM ('N', 'N', M, N, N, ONE, U'Address, LDU, WORK (IU)'Address, LDWRKU, ZERO, A'Address, LDA);
                     --
                     --                    Copy left singular vectors of A from A to U
                     --
                     DLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Copy right singular vectors of R from WORK(IR) to A
                     --
                     DLACPY ('F', N, N, WORK (IR)'Address, LDWRKR, A'Address, LDA);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need N+M, prefer N+M*NB)
                     --
                     DORGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Zero out below R in A
                     --
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, A (2, 1)'Address, LDA);
                     --
                     --                    Bidiagonalize R in A
                     --                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        A'Address,
                        LDA,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left bidiagonalizing vectors
                     --                    in A
                     --                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
                     --
                     DORMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in A
                     --                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
                     --
                     DORGBR
                       ('P',
                        N,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in A
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        N,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        A'Address,
                        LDA,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTVAS then
                  --
                  --                 Path 9 (M much larger than N, JOBU='A', JOBVT='S'
                  --                         or 'A')
                  --                 M left singular vectors to be computed in U and
                  --                 N right singular vectors to be computed in VT
                  --
                  if LWORK >= N * N + max (N + M, 4 * N, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + LDA * N then
                        --
                        --                       WORK(IU) is LDA by N
                        --
                        LDWRKU := LDA;
                     else
                        --
                        --                       WORK(IU) is N by N
                        --
                        LDWRKU := N;
                     end if;
                     ITAU  := IU + LDWRKU * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need N*N+N+M, prefer N*N+N+M*NB)
                     --
                     DORGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IU), zeroing out below it
                     --
                     DLACPY ('U', N, N, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     DLASET ('L', N - 1, N - 1, ZERO, ZERO, WORK (IU + 1)'Address, LDWRKU);
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IU), copying result to VT
                     --                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     DLACPY ('U', N, N, WORK (IU)'Address, LDWRKU, VT'Address, LDVT);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IU)
                     --                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
                     --
                     DORGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in VT
                     --                    (Workspace: need N*N+4*N-1,
                     --                                prefer N*N+3*N+(N-1)*NB)
                     --
                     DORGBR
                       ('P',
                        N,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IU) and computing
                     --                    right singular vectors of R in VT
                     --                    (Workspace: need N*N+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        N,
                        N,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IU)'Address,
                        LDWRKU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in U by left singular vectors of R in
                     --                    WORK(IU), storing result in A
                     --                    (Workspace: need N*N)
                     --
                     DGEMM ('N', 'N', M, N, N, ONE, U'Address, LDU, WORK (IU)'Address, LDWRKU, ZERO, A'Address, LDA);
                     --
                     --                    Copy left singular vectors of A from A to U
                     --
                     DLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (Workspace: need 2*N, prefer N+N*NB)
                     --
                     DGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (Workspace: need N+M, prefer N+M*NB)
                     --
                     DORGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R from A to VT, zeroing out below it
                     --
                     DLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
                     if N > 1 then
                        DLASET ('L', N - 1, N - 1, ZERO, ZERO, VT (2, 1)'Address, LDVT);
                     end if;
                     IE    := ITAU;
                     ITAUQ := IE + N;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in VT
                     --                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
                     --
                     DGEBRD
                       (N,
                        N,
                        VT'Address,
                        LDVT,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left bidiagonalizing vectors
                     --                    in VT
                     --                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
                     --
                     DORMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in VT
                     --                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
                     --
                     DORGBR
                       ('P',
                        N,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in VT
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        N,
                        N,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
                  --
               end if;
               --
            end if;
         --
         else
            --
            --           M .LT. MNTHR
            --
            --           Path 10 (M at least N, but not much larger)
            --           Reduce to bidiagonal form without QR decomposition
            --
            IE    := 1;
            ITAUQ := IE + N;
            ITAUP := ITAUQ + N;
            IWORK := ITAUP + N;
            --
            --           Bidiagonalize A
            --           (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
            --
            DGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               WORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (IWORK)'Address,
               LWORK - IWORK + 1,
               IERR);
            if WNTUAS then
               --
               --              If left singular vectors desired in U, copy result to U
               --              and generate left bidiagonalizing vectors in U
               --              (Workspace: need 3*N+NCU, prefer 3*N+NCU*NB)
               --
               DLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
               if WNTUS then
                  NCU := N;
               end if;
               if WNTUA then
                  NCU := M;
               end if;
               DORGBR ('Q', M, NCU, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTVAS then
               --
               --              If right singular vectors desired in VT, copy result to
               --              VT and generate right bidiagonalizing vectors in VT
               --              (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
               --
               DLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
               DORGBR ('P', N, N, N, VT'Address, LDVT, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTUO then
               --
               --              If left singular vectors desired in A, generate left
               --              bidiagonalizing vectors in A
               --              (Workspace: need 4*N, prefer 3*N+N*NB)
               --
               DORGBR ('Q', M, N, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTVO then
               --
               --              If right singular vectors desired in A, generate right
               --              bidiagonalizing vectors in A
               --              (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
               --
               DORGBR ('P', N, N, N, A'Address, LDA, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            IWORK := IE + N;
            if WNTUAS or WNTUO then
               NRU := M;
            end if;
            if WNTUN then
               NRU := 0;
            end if;
            if WNTVAS or WNTVO then
               NCVT := N;
            end if;
            if WNTVN then
               NCVT := 0;
            end if;
            if (not WNTUO) and (not WNTVO) then
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in U and computing right singular
               --              vectors in VT
               --              (Workspace: need BDSPAC)
               --
               DBDSQR
                 ('U',
                  N,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  WORK (IE)'Address,
                  VT'Address,
                  LDVT,
                  U'Address,
                  LDU,
                  DUM'Address,
                  1,
                  WORK (IWORK)'Address,
                  INFO);
            elsif (not WNTUO) and WNTVO then
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in U and computing right singular
               --              vectors in A
               --              (Workspace: need BDSPAC)
               --
               DBDSQR
                 ('U',
                  N,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  WORK (IE)'Address,
                  A'Address,
                  LDA,
                  U'Address,
                  LDU,
                  DUM'Address,
                  1,
                  WORK (IWORK)'Address,
                  INFO);
            else
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in A and computing right singular
               --              vectors in VT
               --              (Workspace: need BDSPAC)
               --
               DBDSQR
                 ('U',
                  N,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  WORK (IE)'Address,
                  VT'Address,
                  LDVT,
                  A'Address,
                  LDA,
                  DUM'Address,
                  1,
                  WORK (IWORK)'Address,
                  INFO);
            end if;
            --
         end if;
      --
      else
         --
         --        A has more columns than rows. If A has sufficiently more
         --        columns than rows, first reduce using the LQ decomposition (if
         --        sufficient workspace available)
         --
         if N >= MNTHR then
            --
            if WNTVN then
               --
               --              Path 1t(N much larger than M, JOBVT='N')
               --              No right singular vectors to be computed
               --
               ITAU  := 1;
               IWORK := ITAU + M;
               --
               --              Compute A=L*Q
               --              (Workspace: need 2*M, prefer M+M*NB)
               --
               DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
               --
               --              Zero out above L
               --
               DLASET ('U', M - 1, M - 1, ZERO, ZERO, A (1, 2)'Address, LDA);
               IE    := 1;
               ITAUQ := IE + M;
               ITAUP := ITAUQ + M;
               IWORK := ITAUP + M;
               --
               --              Bidiagonalize L in A
               --              (Workspace: need 4*M, prefer 3*M+2*M*NB)
               --
               DGEBRD
                 (M,
                  M,
                  A'Address,
                  LDA,
                  S'Address,
                  WORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (IWORK)'Address,
                  LWORK - IWORK + 1,
                  IERR);
               if WNTUO or WNTUAS then
                  --
                  --                 If left singular vectors desired, generate Q
                  --                 (Workspace: need 4*M, prefer 3*M+M*NB)
                  --
                  DORGBR ('Q', M, M, M, A'Address, LDA, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
               end if;
               IWORK := IE + M;
               NRU   := 0;
               if WNTUO or WNTUAS then
                  NRU := M;
               end if;
               --
               --              Perform bidiagonal QR iteration, computing left singular
               --              vectors of A in A if desired
               --              (Workspace: need BDSPAC)
               --
               DBDSQR
                 ('U',
                  M,
                  0,
                  NRU,
                  0,
                  S'Address,
                  WORK (IE)'Address,
                  DUM'Address,
                  1,
                  A'Address,
                  LDA,
                  DUM'Address,
                  1,
                  WORK (IWORK)'Address,
                  INFO);
               --
               --              If left singular vectors desired in U, copy them there
               --
               if WNTUAS then
                  DLACPY ('F', M, M, A'Address, LDA, U'Address, LDU);
               end if;
            --
            elsif WNTVO and WNTUN then
               --
               --              Path 2t(N much larger than M, JOBU='N', JOBVT='O')
               --              M right singular vectors to be overwritten on A and
               --              no left singular vectors to be computed
               --
               if LWORK >= M * M + max (4 * M, BDSPAC) then
                  --
                  --                 Sufficient workspace for a fast algorithm
                  --
                  IR := 1;
                  if LWORK >= max (WRKBL, LDA * N + M) + LDA * M then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
                     --
                     LDWRKU := LDA;
                     CHUNK  := N;
                     LDWRKR := LDA;
                  elsif LWORK >= max (WRKBL, LDA * N + M) + M * M then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is M by M
                     --
                     LDWRKU := LDA;
                     CHUNK  := N;
                     LDWRKR := M;
                  else
                     --
                     --                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
                     --
                     LDWRKU := M;
                     CHUNK  := (LWORK - M * M - M) / M;
                     LDWRKR := M;
                  end if;
                  ITAU  := IR + LDWRKR * M;
                  IWORK := ITAU + M;
                  --
                  --                 Compute A=L*Q
                  --                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --
                  DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy L to WORK(IR) and zero out above it
                  --
                  DLACPY ('L', M, M, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                  DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IR + LDWRKR)'Address, LDWRKR);
                  --
                  --                 Generate Q in A
                  --                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --
                  DORGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := ITAU;
                  ITAUQ := IE + M;
                  ITAUP := ITAUQ + M;
                  IWORK := ITAUP + M;
                  --
                  --                 Bidiagonalize L in WORK(IR)
                  --                 (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
                  --
                  DGEBRD
                    (M,
                     M,
                     WORK (IR)'Address,
                     LDWRKR,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate right vectors bidiagonalizing L
                  --                 (Workspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
                  --
                  DORGBR
                    ('P',
                     M,
                     M,
                     M,
                     WORK (IR)'Address,
                     LDWRKR,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  IWORK := IE + M;
                  --
                  --                 Perform bidiagonal QR iteration, computing right
                  --                 singular vectors of L in WORK(IR)
                  --                 (Workspace: need M*M+BDSPAC)
                  --
                  DBDSQR
                    ('U',
                     M,
                     M,
                     0,
                     0,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (IR)'Address,
                     LDWRKR,
                     DUM'Address,
                     1,
                     DUM'Address,
                     1,
                     WORK (IWORK)'Address,
                     INFO);
                  IU := IE + M;
                  --
                  --                 Multiply right singular vectors of L in WORK(IR) by Q
                  --                 in A, storing result in WORK(IU) and copying to A
                  --                 (Workspace: need M*M+2*M, prefer M*M+M*N+M)
                  --
                  I := 1 - CHUNK;
                  loop
                     I := I + CHUNK;
                     exit when I > N;
                     BLK := min (N - I + 1, CHUNK);
                     DGEMM
                       ('N',
                        'N',
                        M,
                        BLK,
                        M,
                        ONE,
                        WORK (IR)'Address,
                        LDWRKR,
                        A (1, I)'Address,
                        LDA,
                        ZERO,
                        WORK (IU)'Address,
                        LDWRKU);
                     DLACPY ('F', M, BLK, WORK (IU)'Address, LDWRKU, A (1, I)'Address, LDA);
                  end loop;
               --
               else
                  --
                  --                 Insufficient workspace for a fast algorithm
                  --
                  IE    := 1;
                  ITAUQ := IE + M;
                  ITAUP := ITAUQ + M;
                  IWORK := ITAUP + M;
                  --
                  --                 Bidiagonalize A
                  --                 (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
                  --
                  DGEBRD
                    (M,
                     N,
                     A'Address,
                     LDA,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate right vectors bidiagonalizing A
                  --                 (Workspace: need 4*M, prefer 3*M+M*NB)
                  --
                  DORGBR ('P', M, N, M, A'Address, LDA, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IWORK := IE + M;
                  --
                  --                 Perform bidiagonal QR iteration, computing right
                  --                 singular vectors of A in A
                  --                 (Workspace: need BDSPAC)
                  --
                  DBDSQR
                    ('L',
                     M,
                     N,
                     0,
                     0,
                     S'Address,
                     WORK (IE)'Address,
                     A'Address,
                     LDA,
                     DUM'Address,
                     1,
                     DUM'Address,
                     1,
                     WORK (IWORK)'Address,
                     INFO);
                  --
               end if;
            --
            elsif WNTVO and WNTUAS then
               --
               --              Path 3t(N much larger than M, JOBU='S' or 'A', JOBVT='O')
               --              M right singular vectors to be overwritten on A and
               --              M left singular vectors to be computed in U
               --
               if LWORK >= M * M + max (4 * M, BDSPAC) then
                  --
                  --                 Sufficient workspace for a fast algorithm
                  --
                  IR := 1;
                  if LWORK >= max (WRKBL, LDA * N + M) + LDA * M then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
                     --
                     LDWRKU := LDA;
                     CHUNK  := N;
                     LDWRKR := LDA;
                  elsif LWORK >= max (WRKBL, LDA * N + M) + M * M then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is M by M
                     --
                     LDWRKU := LDA;
                     CHUNK  := N;
                     LDWRKR := M;
                  else
                     --
                     --                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
                     --
                     LDWRKU := M;
                     CHUNK  := (LWORK - M * M - M) / M;
                     LDWRKR := M;
                  end if;
                  ITAU  := IR + LDWRKR * M;
                  IWORK := ITAU + M;
                  --
                  --                 Compute A=L*Q
                  --                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --
                  DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy L to U, zeroing about above it
                  --
                  DLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
                  DLASET ('U', M - 1, M - 1, ZERO, ZERO, U (1, 2)'Address, LDU);
                  --
                  --                 Generate Q in A
                  --                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --
                  DORGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := ITAU;
                  ITAUQ := IE + M;
                  ITAUP := ITAUQ + M;
                  IWORK := ITAUP + M;
                  --
                  --                 Bidiagonalize L in U, copying result to WORK(IR)
                  --                 (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
                  --
                  DGEBRD
                    (M,
                     M,
                     U'Address,
                     LDU,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  DLACPY ('U', M, M, U'Address, LDU, WORK (IR)'Address, LDWRKR);
                  --
                  --                 Generate right vectors bidiagonalizing L in WORK(IR)
                  --                 (Workspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
                  --
                  DORGBR
                    ('P',
                     M,
                     M,
                     M,
                     WORK (IR)'Address,
                     LDWRKR,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate left vectors bidiagonalizing L in U
                  --                 (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
                  --
                  DORGBR ('Q', M, M, M, U'Address, LDU, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IWORK := IE + M;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of L in U, and computing right
                  --                 singular vectors of L in WORK(IR)
                  --                 (Workspace: need M*M+BDSPAC)
                  --
                  DBDSQR
                    ('U',
                     M,
                     M,
                     M,
                     0,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (IR)'Address,
                     LDWRKR,
                     U'Address,
                     LDU,
                     DUM'Address,
                     1,
                     WORK (IWORK)'Address,
                     INFO);
                  IU := IE + M;
                  --
                  --                 Multiply right singular vectors of L in WORK(IR) by Q
                  --                 in A, storing result in WORK(IU) and copying to A
                  --                 (Workspace: need M*M+2*M, prefer M*M+M*N+M)
                  --
                  I := 1 - CHUNK;
                  loop
                     I := I + CHUNK;
                     exit when I > N;
                     BLK := min (N - I + 1, CHUNK);
                     DGEMM
                       ('N',
                        'N',
                        M,
                        BLK,
                        M,
                        ONE,
                        WORK (IR)'Address,
                        LDWRKR,
                        A (1, I)'Address,
                        LDA,
                        ZERO,
                        WORK (IU)'Address,
                        LDWRKU);
                     DLACPY ('F', M, BLK, WORK (IU)'Address, LDWRKU, A (1, I)'Address, LDA);
                  end loop;
               --
               else
                  --
                  --                 Insufficient workspace for a fast algorithm
                  --
                  ITAU  := 1;
                  IWORK := ITAU + M;
                  --
                  --                 Compute A=L*Q
                  --                 (Workspace: need 2*M, prefer M+M*NB)
                  --
                  DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy L to U, zeroing out above it
                  --
                  DLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
                  DLASET ('U', M - 1, M - 1, ZERO, ZERO, U (1, 2)'Address, LDU);
                  --
                  --                 Generate Q in A
                  --                 (Workspace: need 2*M, prefer M+M*NB)
                  --
                  DORGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := ITAU;
                  ITAUQ := IE + M;
                  ITAUP := ITAUQ + M;
                  IWORK := ITAUP + M;
                  --
                  --                 Bidiagonalize L in U
                  --                 (Workspace: need 4*M, prefer 3*M+2*M*NB)
                  --
                  DGEBRD
                    (M,
                     M,
                     U'Address,
                     LDU,
                     S'Address,
                     WORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Multiply right vectors bidiagonalizing L by Q in A
                  --                 (Workspace: need 3*M+N, prefer 3*M+N*NB)
                  --
                  DORMBR
                    ('P',
                     'L',
                     'T',
                     M,
                     N,
                     M,
                     U'Address,
                     LDU,
                     WORK (ITAUP)'Address,
                     A'Address,
                     LDA,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate left vectors bidiagonalizing L in U
                  --                 (Workspace: need 4*M, prefer 3*M+M*NB)
                  --
                  DORGBR ('Q', M, M, M, U'Address, LDU, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IWORK := IE + M;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of A in U and computing right
                  --                 singular vectors of A in A
                  --                 (Workspace: need BDSPAC)
                  --
                  DBDSQR
                    ('U',
                     M,
                     N,
                     M,
                     0,
                     S'Address,
                     WORK (IE)'Address,
                     A'Address,
                     LDA,
                     U'Address,
                     LDU,
                     DUM'Address,
                     1,
                     WORK (IWORK)'Address,
                     INFO);
                  --
               end if;
            --
            elsif WNTVS then
               --
               if WNTUN then
                  --
                  --                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
                  --                 M right singular vectors to be computed in VT and
                  --                 no left singular vectors to be computed
                  --
                  if LWORK >= M * M + max (4 * M, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IR := 1;
                     if LWORK >= WRKBL + LDA * M then
                        --
                        --                       WORK(IR) is LDA by M
                        --
                        LDWRKR := LDA;
                     else
                        --
                        --                       WORK(IR) is M by M
                        --
                        LDWRKR := M;
                     end if;
                     ITAU  := IR + LDWRKR * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q
                     --                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IR), zeroing out above it
                     --
                     DLACPY ('L', M, M, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IR + LDWRKR)'Address, LDWRKR);
                     --
                     --                    Generate Q in A
                     --                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --
                     DORGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IR)
                     --                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right vectors bidiagonalizing L in
                     --                    WORK(IR)
                     --                    (Workspace: need M*M+4*M, prefer M*M+3*M+(M-1)*NB)
                     --
                     DORGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing right
                     --                    singular vectors of L in WORK(IR)
                     --                    (Workspace: need M*M+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        M,
                        0,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (IR)'Address,
                        LDWRKR,
                        DUM'Address,
                        1,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IR) by
                     --                    Q in A, storing result in VT
                     --                    (Workspace: need M*M)
                     --
                     DGEMM ('N', 'N', M, N, M, ONE, WORK (IR)'Address, LDWRKR, A'Address, LDA, ZERO, VT'Address, LDVT);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy result to VT
                     --
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DORGLQ (M, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Zero out above L in A
                     --
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, A (1, 2)'Address, LDA);
                     --
                     --                    Bidiagonalize L in A
                     --                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        A'Address,
                        LDA,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right vectors bidiagonalizing L by Q in VT
                     --                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
                     --
                     DORMBR
                       ('P',
                        'L',
                        'T',
                        M,
                        N,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing right
                     --                    singular vectors of A in VT
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        N,
                        0,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        DUM'Address,
                        1,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTUO then
                  --
                  --                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
                  --                 M right singular vectors to be computed in VT and
                  --                 M left singular vectors to be overwritten on A
                  --
                  if LWORK >= 2 * M * M + max (4 * M, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + 2 * LDA * M then
                        --
                        --                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := LDA;
                     elsif LWORK >= WRKBL + (LDA + M) * M then
                        --
                        --                       WORK(IU) is LDA by M and WORK(IR) is M by M
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := M;
                     else
                        --
                        --                       WORK(IU) is M by M and WORK(IR) is M by M
                        --
                        LDWRKU := M;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := M;
                     end if;
                     ITAU  := IR + LDWRKR * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q
                     --                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IU), zeroing out below it
                     --
                     DLACPY ('L', M, M, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IU + LDWRKU)'Address, LDWRKU);
                     --
                     --                    Generate Q in A
                     --                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
                     --
                     DORGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IU), copying result to
                     --                    WORK(IR)
                     --                    (Workspace: need 2*M*M+4*M,
                     --                                prefer 2*M*M+3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     DLACPY ('L', M, M, WORK (IU)'Address, LDWRKU, WORK (IR)'Address, LDWRKR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IU)
                     --                    (Workspace: need 2*M*M+4*M-1,
                     --                                prefer 2*M*M+3*M+(M-1)*NB)
                     --
                     DORGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IR)
                     --                    (Workspace: need 2*M*M+4*M, prefer 2*M*M+3*M+M*NB)
                     --
                     DORGBR
                       ('Q',
                        M,
                        M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of L in WORK(IR) and computing
                     --                    right singular vectors of L in WORK(IU)
                     --                    (Workspace: need 2*M*M+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        M,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (IR)'Address,
                        LDWRKR,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IU) by
                     --                    Q in A, storing result in VT
                     --                    (Workspace: need M*M)
                     --
                     DGEMM ('N', 'N', M, N, M, ONE, WORK (IU)'Address, LDWRKU, A'Address, LDA, ZERO, VT'Address, LDVT);
                     --
                     --                    Copy left singular vectors of L to A
                     --                    (Workspace: need M*M)
                     --
                     DLACPY ('F', M, M, WORK (IR)'Address, LDWRKR, A'Address, LDA);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DORGLQ (M, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Zero out above L in A
                     --
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, A (1, 2)'Address, LDA);
                     --
                     --                    Bidiagonalize L in A
                     --                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        A'Address,
                        LDA,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right vectors bidiagonalizing L by Q in VT
                     --                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
                     --
                     DORMBR
                       ('P',
                        'L',
                        'T',
                        M,
                        N,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors of L in A
                     --                    (Workspace: need 4*M, prefer 3*M+M*NB)
                     --
                     DORGBR
                       ('Q',
                        M,
                        M,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, compute left
                     --                    singular vectors of A in A and compute right
                     --                    singular vectors of A in VT
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        N,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        A'Address,
                        LDA,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTUAS then
                  --
                  --                 Path 6t(N much larger than M, JOBU='S' or 'A',
                  --                         JOBVT='S')
                  --                 M right singular vectors to be computed in VT and
                  --                 M left singular vectors to be computed in U
                  --
                  if LWORK >= M * M + max (4 * M, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + LDA * M then
                        --
                        --                       WORK(IU) is LDA by N
                        --
                        LDWRKU := LDA;
                     else
                        --
                        --                       WORK(IU) is LDA by M
                        --
                        LDWRKU := M;
                     end if;
                     ITAU  := IU + LDWRKU * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q
                     --                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IU), zeroing out above it
                     --
                     DLACPY ('L', M, M, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IU + LDWRKU)'Address, LDWRKU);
                     --
                     --                    Generate Q in A
                     --                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --
                     DORGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IU), copying result to U
                     --                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     DLACPY ('L', M, M, WORK (IU)'Address, LDWRKU, U'Address, LDU);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IU)
                     --                    (Workspace: need M*M+4*M-1,
                     --                                prefer M*M+3*M+(M-1)*NB)
                     --
                     DORGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in U
                     --                    (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
                     --
                     DORGBR
                       ('Q',
                        M,
                        M,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of L in U and computing right
                     --                    singular vectors of L in WORK(IU)
                     --                    (Workspace: need M*M+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        M,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (IU)'Address,
                        LDWRKU,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IU) by
                     --                    Q in A, storing result in VT
                     --                    (Workspace: need M*M)
                     --
                     DGEMM ('N', 'N', M, N, M, ONE, WORK (IU)'Address, LDWRKU, A'Address, LDA, ZERO, VT'Address, LDVT);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DORGLQ (M, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to U, zeroing out above it
                     --
                     DLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, U (1, 2)'Address, LDU);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in U
                     --                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        U'Address,
                        LDU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right bidiagonalizing vectors in U by Q
                     --                    in VT
                     --                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
                     --
                     DORMBR
                       ('P',
                        'L',
                        'T',
                        M,
                        N,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in U
                     --                    (Workspace: need 4*M, prefer 3*M+M*NB)
                     --
                     DORGBR
                       ('Q',
                        M,
                        M,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in VT
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        N,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
                  --
               end if;
            --
            elsif WNTVA then
               --
               if WNTUN then
                  --
                  --                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
                  --                 N right singular vectors to be computed in VT and
                  --                 no left singular vectors to be computed
                  --
                  if LWORK >= M * M + max (N + M, 4 * M, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IR := 1;
                     if LWORK >= WRKBL + LDA * M then
                        --
                        --                       WORK(IR) is LDA by M
                        --
                        LDWRKR := LDA;
                     else
                        --
                        --                       WORK(IR) is M by M
                        --
                        LDWRKR := M;
                     end if;
                     ITAU  := IR + LDWRKR * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Copy L to WORK(IR), zeroing out above it
                     --
                     DLACPY ('L', M, M, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IR + LDWRKR)'Address, LDWRKR);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need M*M+M+N, prefer M*M+M+N*NB)
                     --
                     DORGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IR)
                     --                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IR)
                     --                    (Workspace: need M*M+4*M-1,
                     --                                prefer M*M+3*M+(M-1)*NB)
                     --
                     DORGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing right
                     --                    singular vectors of L in WORK(IR)
                     --                    (Workspace: need M*M+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        M,
                        0,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (IR)'Address,
                        LDWRKR,
                        DUM'Address,
                        1,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IR) by
                     --                    Q in VT, storing result in A
                     --                    (Workspace: need M*M)
                     --
                     DGEMM ('N', 'N', M, N, M, ONE, WORK (IR)'Address, LDWRKR, VT'Address, LDVT, ZERO, A'Address, LDA);
                     --
                     --                    Copy right singular vectors of A from A to VT
                     --
                     DLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need M+N, prefer M+N*NB)
                     --
                     DORGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Zero out above L in A
                     --
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, A (1, 2)'Address, LDA);
                     --
                     --                    Bidiagonalize L in A
                     --                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        A'Address,
                        LDA,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right bidiagonalizing vectors in A by Q
                     --                    in VT
                     --                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
                     --
                     DORMBR
                       ('P',
                        'L',
                        'T',
                        M,
                        N,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing right
                     --                    singular vectors of A in VT
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        N,
                        0,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        DUM'Address,
                        1,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTUO then
                  --
                  --                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
                  --                 N right singular vectors to be computed in VT and
                  --                 M left singular vectors to be overwritten on A
                  --
                  if LWORK >= 2 * M * M + max (N + M, 4 * M, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + 2 * LDA * M then
                        --
                        --                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := LDA;
                     elsif LWORK >= WRKBL + (LDA + M) * M then
                        --
                        --                       WORK(IU) is LDA by M and WORK(IR) is M by M
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := M;
                     else
                        --
                        --                       WORK(IU) is M by M and WORK(IR) is M by M
                        --
                        LDWRKU := M;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := M;
                     end if;
                     ITAU  := IR + LDWRKR * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need 2*M*M+M+N, prefer 2*M*M+M+N*NB)
                     --
                     DORGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IU), zeroing out above it
                     --
                     DLACPY ('L', M, M, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IU + LDWRKU)'Address, LDWRKU);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IU), copying result to
                     --                    WORK(IR)
                     --                    (Workspace: need 2*M*M+4*M,
                     --                                prefer 2*M*M+3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     DLACPY ('L', M, M, WORK (IU)'Address, LDWRKU, WORK (IR)'Address, LDWRKR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IU)
                     --                    (Workspace: need 2*M*M+4*M-1,
                     --                                prefer 2*M*M+3*M+(M-1)*NB)
                     --
                     DORGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IR)
                     --                    (Workspace: need 2*M*M+4*M, prefer 2*M*M+3*M+M*NB)
                     --
                     DORGBR
                       ('Q',
                        M,
                        M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of L in WORK(IR) and computing
                     --                    right singular vectors of L in WORK(IU)
                     --                    (Workspace: need 2*M*M+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        M,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (IR)'Address,
                        LDWRKR,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IU) by
                     --                    Q in VT, storing result in A
                     --                    (Workspace: need M*M)
                     --
                     DGEMM ('N', 'N', M, N, M, ONE, WORK (IU)'Address, LDWRKU, VT'Address, LDVT, ZERO, A'Address, LDA);
                     --
                     --                    Copy right singular vectors of A from A to VT
                     --
                     DLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Copy left singular vectors of A from WORK(IR) to A
                     --
                     DLACPY ('F', M, M, WORK (IR)'Address, LDWRKR, A'Address, LDA);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need M+N, prefer M+N*NB)
                     --
                     DORGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Zero out above L in A
                     --
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, A (1, 2)'Address, LDA);
                     --
                     --                    Bidiagonalize L in A
                     --                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        A'Address,
                        LDA,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right bidiagonalizing vectors in A by Q
                     --                    in VT
                     --                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
                     --
                     DORMBR
                       ('P',
                        'L',
                        'T',
                        M,
                        N,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in A
                     --                    (Workspace: need 4*M, prefer 3*M+M*NB)
                     --
                     DORGBR
                       ('Q',
                        M,
                        M,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in A and computing right
                     --                    singular vectors of A in VT
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        N,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        A'Address,
                        LDA,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTUAS then
                  --
                  --                 Path 9t(N much larger than M, JOBU='S' or 'A',
                  --                         JOBVT='A')
                  --                 N right singular vectors to be computed in VT and
                  --                 M left singular vectors to be computed in U
                  --
                  if LWORK >= M * M + max (N + M, 4 * M, BDSPAC) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + LDA * M then
                        --
                        --                       WORK(IU) is LDA by M
                        --
                        LDWRKU := LDA;
                     else
                        --
                        --                       WORK(IU) is M by M
                        --
                        LDWRKU := M;
                     end if;
                     ITAU  := IU + LDWRKU * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need M*M+M+N, prefer M*M+M+N*NB)
                     --
                     DORGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IU), zeroing out above it
                     --
                     DLACPY ('L', M, M, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, WORK (IU + LDWRKU)'Address, LDWRKU);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IU), copying result to U
                     --                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     DLACPY ('L', M, M, WORK (IU)'Address, LDWRKU, U'Address, LDU);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IU)
                     --                    (Workspace: need M*M+4*M, prefer M*M+3*M+(M-1)*NB)
                     --
                     DORGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in U
                     --                    (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
                     --
                     DORGBR
                       ('Q',
                        M,
                        M,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of L in U and computing right
                     --                    singular vectors of L in WORK(IU)
                     --                    (Workspace: need M*M+BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        M,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (IU)'Address,
                        LDWRKU,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IU) by
                     --                    Q in VT, storing result in A
                     --                    (Workspace: need M*M)
                     --
                     DGEMM ('N', 'N', M, N, M, ONE, WORK (IU)'Address, LDWRKU, VT'Address, LDVT, ZERO, A'Address, LDA);
                     --
                     --                    Copy right singular vectors of A from A to VT
                     --
                     DLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (Workspace: need 2*M, prefer M+M*NB)
                     --
                     DGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (Workspace: need M+N, prefer M+N*NB)
                     --
                     DORGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to U, zeroing out above it
                     --
                     DLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
                     DLASET ('U', M - 1, M - 1, ZERO, ZERO, U (1, 2)'Address, LDU);
                     IE    := ITAU;
                     ITAUQ := IE + M;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in U
                     --                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
                     --
                     DGEBRD
                       (M,
                        M,
                        U'Address,
                        LDU,
                        S'Address,
                        WORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right bidiagonalizing vectors in U by Q
                     --                    in VT
                     --                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
                     --
                     DORMBR
                       ('P',
                        'L',
                        'T',
                        M,
                        N,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in U
                     --                    (Workspace: need 4*M, prefer 3*M+M*NB)
                     --
                     DORGBR
                       ('Q',
                        M,
                        M,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in VT
                     --                    (Workspace: need BDSPAC)
                     --
                     DBDSQR
                       ('U',
                        M,
                        N,
                        M,
                        0,
                        S'Address,
                        WORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        U'Address,
                        LDU,
                        DUM'Address,
                        1,
                        WORK (IWORK)'Address,
                        INFO);
                     --
                  end if;
                  --
               end if;
               --
            end if;
         --
         else
            --
            --           N .LT. MNTHR
            --
            --           Path 10t(N greater than M, but not much larger)
            --           Reduce to bidiagonal form without LQ decomposition
            --
            IE    := 1;
            ITAUQ := IE + M;
            ITAUP := ITAUQ + M;
            IWORK := ITAUP + M;
            --
            --           Bidiagonalize A
            --           (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
            --
            DGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               WORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (IWORK)'Address,
               LWORK - IWORK + 1,
               IERR);
            if WNTUAS then
               --
               --              If left singular vectors desired in U, copy result to U
               --              and generate left bidiagonalizing vectors in U
               --              (Workspace: need 4*M-1, prefer 3*M+(M-1)*NB)
               --
               DLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
               DORGBR ('Q', M, M, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTVAS then
               --
               --              If right singular vectors desired in VT, copy result to
               --              VT and generate right bidiagonalizing vectors in VT
               --              (Workspace: need 3*M+NRVT, prefer 3*M+NRVT*NB)
               --
               DLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
               if WNTVA then
                  NRVT := N;
               end if;
               if WNTVS then
                  NRVT := M;
               end if;
               DORGBR
                 ('P',
                  NRVT,
                  N,
                  M,
                  VT'Address,
                  LDVT,
                  WORK (ITAUP)'Address,
                  WORK (IWORK)'Address,
                  LWORK - IWORK + 1,
                  IERR);
            end if;
            if WNTUO then
               --
               --              If left singular vectors desired in A, generate left
               --              bidiagonalizing vectors in A
               --              (Workspace: need 4*M-1, prefer 3*M+(M-1)*NB)
               --
               DORGBR ('Q', M, M, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTVO then
               --
               --              If right singular vectors desired in A, generate right
               --              bidiagonalizing vectors in A
               --              (Workspace: need 4*M, prefer 3*M+M*NB)
               --
               DORGBR ('P', M, N, M, A'Address, LDA, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            IWORK := IE + M;
            if WNTUAS or WNTUO then
               NRU := M;
            end if;
            if WNTUN then
               NRU := 0;
            end if;
            if WNTVAS or WNTVO then
               NCVT := N;
            end if;
            if WNTVN then
               NCVT := 0;
            end if;
            if (not WNTUO) and (not WNTVO) then
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in U and computing right singular
               --              vectors in VT
               --              (Workspace: need BDSPAC)
               --
               DBDSQR
                 ('L',
                  M,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  WORK (IE)'Address,
                  VT'Address,
                  LDVT,
                  U'Address,
                  LDU,
                  DUM'Address,
                  1,
                  WORK (IWORK)'Address,
                  INFO);
            elsif (not WNTUO) and WNTVO then
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in U and computing right singular
               --              vectors in A
               --              (Workspace: need BDSPAC)
               --
               DBDSQR
                 ('L',
                  M,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  WORK (IE)'Address,
                  A'Address,
                  LDA,
                  U'Address,
                  LDU,
                  DUM'Address,
                  1,
                  WORK (IWORK)'Address,
                  INFO);
            else
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in A and computing right singular
               --              vectors in VT
               --              (Workspace: need BDSPAC)
               --
               DBDSQR
                 ('L',
                  M,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  WORK (IE)'Address,
                  VT'Address,
                  LDVT,
                  A'Address,
                  LDA,
                  DUM'Address,
                  1,
                  WORK (IWORK)'Address,
                  INFO);
            end if;
            --
         end if;
         --
      end if;
      --
      --     If DBDSQR failed to converge, copy unconverged superdiagonals
      --     to WORK( 2:MINMN )
      --
      if INFO /= 0 then
         if IE > 2 then
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > MINMN - 1;
               WORK (I + 1) := WORK (I + IE - 1);
            end loop;
         end if;
         if IE < 2 then
            I := MINMN - 1 + 1;
            loop
               I := I - 1;
               exit when I < 1;
               WORK (I + 1) := WORK (I + IE - 1);
            end loop;
         end if;
      end if;
      --
      --     Undo scaling if necessary
      --
      if ISCL = 1 then
         if ANRM > BIGNUM then
            DLASCL ('G', 0, 0, BIGNUM, ANRM, MINMN, 1, S'Address, MINMN, IERR);
         end if;
         if INFO /= 0 and ANRM > BIGNUM then
            DLASCL ('G', 0, 0, BIGNUM, ANRM, MINMN - 1, 1, WORK (2)'Address, MINMN, IERR);
         end if;
         if ANRM < SMLNUM then
            DLASCL ('G', 0, 0, SMLNUM, ANRM, MINMN, 1, S'Address, MINMN, IERR);
         end if;
         if INFO /= 0 and ANRM < SMLNUM then
            DLASCL ('G', 0, 0, SMLNUM, ANRM, MINMN - 1, 1, WORK (2)'Address, MINMN, IERR);
         end if;
      end if;
      --
      --     Return optimal workspace in WORK(1)
      --
      WORK (1) := Real (MAXWRK);
      --
      return;
      --
      --     End of DGESVD
      --
   end DGESVD;

   procedure DGETF2
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      IPIV_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      IPIV : Ftn_Integer_Vector (1 .. min (M, N));

      for A'Address use A_adr;
      for IPIV'Address use IPIV_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, IPIV);

      ONE   : constant Real := 1.0e0;
      ZERO  : constant Real := 0.0e0;
      SFMIN : Real;
      I     : Integer;
      J     : Integer;
      JP    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGETF2( M, N, A, LDA, IPIV, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGETF2 computes an LU factorization of a general m-by-n matrix A
   --  using partial pivoting with row interchanges.
   --
   --  The factorization has the form
   --     A = P * L * U
   --  where P is a permutation matrix, L is lower triangular with unit
   --  diagonal elements (lower trapezoidal if m > n), and U is upper
   --  triangular (upper trapezoidal if m < n).
   --
   --  This is the right-looking Level 2 BLAS version of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the m by n matrix to be factored.
   --           On exit, the factors L and U from the factorization
   --           A = P*L*U; the unit diagonal elements of L are not stored.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (min(M,N))
   --           The pivot indices; for 1 <= i <= min(M,N), row i of the
   --           matrix was interchanged with row IPIV(i).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -k, the k-th argument had an illegal value
   --           > 0: if INFO = k, U(k,k) is exactly zero. The factorization
   --                has been completed, but the factor U is exactly
   --                singular, and division by zero will occur if it is used
   --                to solve a system of equations.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH
   --      INTEGER            IDAMAX
   --      EXTERNAL           DLAMCH, IDAMAX
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGER, DSCAL, DSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("DGETF2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     Compute machine safe minimum
      --
      SFMIN := DLAMCH ('S');
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > min (M, N);
         --
         --        Find pivot and test for singularity.
         --
         JP       := J - 1 + IDAMAX (M - J + 1, A (J, J)'Address, 1);
         IPIV (J) := JP;
         if A (JP, J) /= ZERO then
            --
            --           Apply the interchange to columns 1:N.
            --
            if JP /= J then
               DSWAP (N, A (J, 1)'Address, LDA, A (JP, 1)'Address, LDA);
            end if;
            --
            --           Compute elements J+1:M of J-th column.
            --
            if J < M then
               if abs (A (J, J)) >= SFMIN then
                  DSCAL (M - J, ONE / A (J, J), A (J + 1, J)'Address, 1);
               else
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M - J;
                     A (J + I, J) := A (J + I, J) / A (J, J);
                  end loop;
               end if;
            end if;
         --
         elsif INFO = 0 then
            --
            INFO := J;
         end if;
         --
         if J < min (M, N) then
            --
            --           Update trailing submatrix.
            --
            DGER (M - J, N - J, -ONE, A (J + 1, J)'Address, 1, A (J, J + 1)'Address, LDA, A (J + 1, J + 1)'Address, LDA);
         end if;
      end loop;
      return;
      --
      --     End of DGETF2
      --
   end DGETF2;

   procedure DGETRF
     (M    : Integer;
      N    : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer;
      IPIV : in out Ftn_Integer_Vector;
      INFO : in out Integer)
   is
      ONE   : constant Real := 1.0e0;
      I     : Integer;
      IINFO : Integer;
      J     : Integer;
      JB    : Integer;
      NB    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGETRF computes an LU factorization of a general M-by-N matrix A
   --  using partial pivoting with row interchanges.
   --
   --  The factorization has the form
   --     A = P * L * U
   --  where P is a permutation matrix, L is lower triangular with unit
   --  diagonal elements (lower trapezoidal if m > n), and U is upper
   --  triangular (upper trapezoidal if m < n).
   --
   --  This is the right-looking Level 3 BLAS version of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the M-by-N matrix to be factored.
   --           On exit, the factors L and U from the factorization
   --           A = P*L*U; the unit diagonal elements of L are not stored.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (min(M,N))
   --           The pivot indices; for 1 <= i <= min(M,N), row i of the
   --           matrix was interchanged with row IPIV(i).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
   --                 has been completed, but the factor U is exactly
   --                 singular, and division by zero will occur if it is used
   --                 to solve a system of equations.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMM, DGETF2, DLASWP, DTRSM, XERBLA
   --     ..
   --     .. External Functions ..
   --      INTEGER            ILAENV
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("DGETRF", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     Determine the block size for this environment.
      --
      NB := ILAENV (1, "DGETRF", " ", M, N, -1, -1);
      if NB <= 1 or NB >= min (M, N) then
         --
         --        Use unblocked code.
         --
         DGETF2 (M, N, A'Address, LDA, IPIV'Address, INFO);
      else
         --
         --        Use blocked code.
         --
         J := 1 - NB;
         loop
            J := J + NB;
            exit when J > min (M, N);
            JB := min (min (M, N) - J + 1, NB);
            --
            --           Factor diagonal and subdiagonal blocks and test for exact
            --           singularity.
            --
            DGETF2 (M - J + 1, JB, A (J, J)'Address, LDA, IPIV (J)'Address, IINFO);
            --
            --           Adjust INFO and the pivot indices.
            --
            if INFO = 0 and IINFO > 0 then
               INFO := IINFO + J - 1;
            end if;
            I := J - 1;
            loop
               I := I + 1;
               exit when I > min (M, J + JB - 1);
               IPIV (I) := J - 1 + IPIV (I);
            end loop;
            --
            --           Apply interchanges to columns 1:J-1.
            --
            DLASWP (J - 1, A'Address, LDA, J, J + JB - 1, IPIV'Address, 1);
            --
            if J + JB <= N then
               --
               --              Apply interchanges to columns J+JB:N.
               --
               DLASWP (N - J - JB + 1, A (1, J + JB)'Address, LDA, J, J + JB - 1, IPIV'Address, 1);
               --
               --              Compute block row of U.
               --
               DTRSM ('L', 'L', 'N', 'U', JB, N - J - JB + 1, ONE, A (J, J)'Address, LDA, A (J, J + JB)'Address, LDA);
               if J + JB <= M then
                  --
                  --                 Update trailing submatrix.
                  --
                  DGEMM
                    ('N',
                     'N',
                     M - J - JB + 1,
                     N - J - JB + 1,
                     JB,
                     -ONE,
                     A (J + JB, J)'Address,
                     LDA,
                     A (J, J + JB)'Address,
                     LDA,
                     ONE,
                     A (J + JB, J + JB)'Address,
                     LDA);
               end if;
            end if;
         end loop;
      end if;
      return;
      --
      --     End of DGETRF
      --
   end DGETRF;

   procedure DGETRI
     (N     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      IPIV  : in out Ftn_Integer_Vector;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      LQUERY : Boolean;
      I      : Integer;
      IWS    : Integer;
      J      : Integer;
      JB     : Integer;
      JJ     : Integer;
      JP     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NN     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGETRI computes the inverse of a matrix using the LU factorization
   --  computed by DGETRF.
   --
   --  This method inverts U and then computes inv(A) by solving the system
   --  inv(A)*L = inv(U) for inv(A).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the factors L and U from the factorization
   --           A = P*L*U as computed by DGETRF.
   --           On exit, if INFO = 0, the inverse of the original matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           The pivot indices from DGETRF; for 1<=i<=N, row i of the
   --           matrix was interchanged with row IPIV(i).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= max(1,N).
   --           For optimal performance LWORK >= N*NB, where NB is
   --           the optimal blocksize returned by ILAENV.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
   --                 singular and its inverse could not be computed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMM, DGEMV, DSWAP, DTRSM, DTRTRI, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "DGETRI", " ", N, -1, -1, -1);
      LWKOPT   := N * NB;
      WORK (1) := Real (LWKOPT);
      LQUERY   := (LWORK = -1);
      if N < 0 then
         INFO := -1;
      elsif LDA < max (1, N) then
         INFO := -3;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -6;
      end if;
      if INFO /= 0 then
         XERBLA ("DGETRI", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     Form inv(U).  If INFO > 0 from DTRTRI, then U is singular,
      --     and the inverse is not computed.
      --
      DTRTRI ('U', 'N', N, A, LDA, INFO);
      if INFO > 0 then
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := N;
      if NB > 1 and NB < N then
         IWS := max (LDWORK * NB, 1);
         if LWORK < IWS then
            NB    := LWORK / LDWORK;
            NBMIN := max (2, ILAENV (2, "DGETRI", " ", N, -1, -1, -1));
         end if;
      else
         IWS := N;
      end if;
      --
      --     Solve the equation inv(A)*L = inv(U) for inv(A).
      --
      if NB < NBMIN or NB >= N then
         --
         --        Use unblocked code.
         --
         J := N + 1;
         loop
            J := J - 1;
            exit when J < 1;
            --
            --           Copy current column of L to WORK and replace with zeros.
            --
            I := J + 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               WORK (I) := A (I, J);
               A (I, J) := ZERO;
            end loop;
            --
            --           Compute current column of inv(A).
            --
            if J < N then
               DGEMV ('N', N, N - J, -ONE, A (1, J + 1)'Address, LDA, WORK (J + 1)'Address, 1, ONE, A (1, J)'Address, 1);
            end if;
         end loop;
      else
         --
         --        Use blocked code.
         --
         NN := ((N - 1) / NB) * NB + 1;
         J  := NN + 1;
         loop
            J := J - 1;
            exit when J < 1;
            JB := min (NB, N - J + 1);
            --
            --           Copy current block column of L to WORK and replace with
            --           zeros.
            --
            JJ := J - 1;
            loop
               JJ := JJ + 1;
               exit when JJ > J + JB - 1;
               I := JJ + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  WORK (I + (JJ - J) * LDWORK)   := A (I, JJ);
                  A (I, JJ)                      := ZERO;
               end loop;
            end loop;
            --
            --           Compute current block column of inv(A).
            --
            if J + JB <= N then
               DGEMM
                 ('N',
                  'N',
                  N,
                  JB,
                  N - J - JB + 1,
                  -ONE,
                  A (1, J + JB)'Address,
                  LDA,
                  WORK (J + JB)'Address,
                  LDWORK,
                  ONE,
                  A (1, J)'Address,
                  LDA);
            end if;
            DTRSM ('R', 'L', 'N', 'U', N, JB, ONE, WORK (J)'Address, LDWORK, A (1, J)'Address, LDA);
         end loop;
      end if;
      --
      --     Apply column interchanges.
      --
      J := N - 1 + 1;
      loop
         J := J - 1;
         exit when J < 1;
         JP := IPIV (J);
         if JP /= J then
            DSWAP (N, A (1, J)'Address, 1, A (1, JP)'Address, 1);
         end if;
      end loop;
      --
      WORK (1) := Real (IWS);
      return;
      --
      --     End of DGETRI
      --
   end DGETRI;

   procedure DGETRS
     (TRANS : Character;
      N     : Integer;
      NRHS  : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      IPIV  : in out Ftn_Integer_Vector;
      B     : in out Ftn_Real_Matrix;
      LDB   : Integer;
      INFO  : in out Integer)
   is
      ONE    : constant Real := 1.0e0;
      NOTRAN : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          TRANS
   --       INTEGER            INFO, LDA, LDB, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DGETRS solves a system of linear equations
   --     A * X = B  or  A**T * X = B
   --  with a general N-by-N matrix A using the LU factorization computed
   --  by DGETRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           Specifies the form of the system of equations:
   --           = 'N':  A * X = B     (No transpose)
   --           = 'T':  A**T * X = B  (Transpose)
   --           = 'C':  A**T * X = B  (Conjugate transpose = Transpose)
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The factors L and U from the factorization A = P*L*U
   --           as computed by DGETRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           The pivot indices from DGETRF; for 1<=i<=N, row i of the
   --           matrix was interchanged with row IPIV(i).
   --
   --  [in,out] B
   --           B is DOUBLE PRECISION array, dimension (LDB,NRHS)
   --           On entry, the right hand side matrix B.
   --           On exit, the solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASWP, DTRSM, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      NOTRAN := LSAME (TRANS, 'N');
      if not NOTRAN and not LSAME (TRANS, 'T') and not LSAME (TRANS, 'C') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NRHS < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDB < max (1, N) then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("DGETRS", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 or NRHS = 0 then
         return;
      end if;
      --
      if NOTRAN then
         --
         --        Solve A * X = B.
         --
         --        Apply row interchanges to the right hand sides.
         --
         DLASWP (NRHS, B'Address, LDB, 1, N, IPIV'Address, 1);
         --
         --        Solve L*X = B, overwriting B with X.
         --
         DTRSM ('L', 'L', 'N', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --        Solve U*X = B, overwriting B with X.
         --
         DTRSM ('L', 'U', 'N', 'N', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
      else
         --
         --        Solve A**T * X = B.
         --
         --        Solve U**T *X = B, overwriting B with X.
         --
         DTRSM ('L', 'U', 'T', 'N', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --        Solve L**T *X = B, overwriting B with X.
         --
         DTRSM ('L', 'L', 'T', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --        Apply row interchanges to the solution vectors.
         --
         DLASWP (NRHS, B'Address, LDB, 1, N, IPIV'Address, -1);
      end if;
      --
      return;
      --
      --     End of DGETRS
      --
   end DGETRS;

   procedure DHSEQR
     (JOB      : Character;
      COMPZ    : Character;
      N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      H_adr    : Address;
      LDH      : Integer;
      WR_adr   : Address;
      WI_adr   : Address;
      Z_adr    : Address;
      LDZ      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      H    : Ftn_Real_Matrix (1 .. LDH, 1 .. N);
      WR   : Ftn_Real_Vector (1 .. N);
      WI   : Ftn_Real_Vector (1 .. N);
      Z    : Ftn_Real_Matrix (1 .. LDZ, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for H'Address use H_adr;
      for WR'Address use WR_adr;
      for WI'Address use WI_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, WR);
      pragma Import (Ada, WI);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);

      NTINY  : constant Integer := 11;
      NL     : constant Integer := 49;
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      HL     : Ftn_Real_Matrix (1 .. NL, 1 .. NL);
      WORKL  : Ftn_Real_Vector (1 .. NL);
      I      : Integer;
      KBOT   : Integer;
      NMIN   : Integer;
      INITZ  : Boolean;
      LQUERY : Boolean;
      WANTT  : Boolean;
      WANTZ  : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DHSEQR( JOB, COMPZ, N, ILO, IHI, H, LDH, WR, WI, Z,
   --                          LDZ, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, INFO, LDH, LDZ, LWORK, N
   --       CHARACTER          COMPZ, JOB
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   H( LDH, * ), WI( * ), WORK( * ), WR( * ),
   --      $                   Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DHSEQR computes the eigenvalues of a Hessenberg matrix H
   --     and, optionally, the matrices T and Z from the Schur decomposition
   --     H = Z T Z**T, where T is an upper quasi-triangular matrix (the
   --     Schur form), and Z is the orthogonal matrix of Schur vectors.
   --
   --     Optionally Z may be postmultiplied into an input orthogonal
   --     matrix Q so that this routine can give the Schur factorization
   --     of a matrix A which has been reduced to the Hessenberg form H
   --     by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOB
   --           JOB is CHARACTER*1
   --            = 'E':  compute eigenvalues only;
   --            = 'S':  compute eigenvalues and the Schur form T.
   --
   --  [in] COMPZ
   --           COMPZ is CHARACTER*1
   --            = 'N':  no Schur vectors are computed;
   --            = 'I':  Z is initialized to the unit matrix and the matrix Z
   --                    of Schur vectors of H is returned;
   --            = 'V':  Z must contain an orthogonal matrix Q on entry, and
   --                    the product Q*Z is returned.
   --
   --  [in] N
   --           N is INTEGER
   --            The order of the matrix H.  N .GE. 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --            It is assumed that H is already upper triangular in rows
   --            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
   --            set by a previous call to DGEBAL, and then passed to ZGEHRD
   --            when the matrix output by DGEBAL is reduced to Hessenberg
   --            form. Otherwise ILO and IHI should be set to 1 and N
   --            respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
   --            If N = 0, then ILO = 1 and IHI = 0.
   --
   --  [in,out] H
   --           H is DOUBLE PRECISION array, dimension (LDH,N)
   --            On entry, the upper Hessenberg matrix H.
   --            On exit, if INFO = 0 and JOB = 'S', then H contains the
   --            upper quasi-triangular matrix T from the Schur decomposition
   --            (the Schur form); 2-by-2 diagonal blocks (corresponding to
   --            complex conjugate pairs of eigenvalues) are returned in
   --            standard form, with H(i,i) = H(i+1,i+1) and
   --            H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and JOB = 'E', the
   --            contents of H are unspecified on exit.  (The output value of
   --            H when INFO.GT.0 is given under the description of INFO
   --            below.)
   --
   --            Unlike earlier versions of DHSEQR, this subroutine may
   --            explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
   --            or j = IHI+1, IHI+2, ... N.
   --
   --  [in] LDH
   --           LDH is INTEGER
   --            The leading dimension of the array H. LDH .GE. max(1,N).
   --
   --  [out] WR
   --           WR is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] WI
   --           WI is DOUBLE PRECISION array, dimension (N)
   --
   --            The real and imaginary parts, respectively, of the computed
   --            eigenvalues. If two eigenvalues are computed as a complex
   --            conjugate pair, they are stored in consecutive elements of
   --            WR and WI, say the i-th and (i+1)th, with WI(i) .GT. 0 and
   --            WI(i+1) .LT. 0. If JOB = 'S', the eigenvalues are stored in
   --            the same order as on the diagonal of the Schur form returned
   --            in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
   --            diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
   --            WI(i+1) = -WI(i).
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension (LDZ,N)
   --            If COMPZ = 'N', Z is not referenced.
   --            If COMPZ = 'I', on entry Z need not be set and on exit,
   --            if INFO = 0, Z contains the orthogonal matrix Z of the Schur
   --            vectors of H.  If COMPZ = 'V', on entry Z must contain an
   --            N-by-N matrix Q, which is assumed to be equal to the unit
   --            matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
   --            if INFO = 0, Z contains Q*Z.
   --            Normally Q is the orthogonal matrix generated by DORGHR
   --            after the call to DGEHRD which formed the Hessenberg matrix
   --            H. (The output value of Z when INFO.GT.0 is given under
   --            the description of INFO below.)
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --            The leading dimension of the array Z.  if COMPZ = 'I' or
   --            COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (LWORK)
   --            On exit, if INFO = 0, WORK(1) returns an estimate of
   --            the optimal value for LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --            The dimension of the array WORK.  LWORK .GE. max(1,N)
   --            is sufficient and delivers very good and sometimes
   --            optimal performance.  However, LWORK as large as 11*N
   --            may be required for optimal performance.  A workspace
   --            query is recommended to determine the optimal workspace
   --            size.
   --
   --            If LWORK = -1, then DHSEQR does a workspace query.
   --            In this case, DHSEQR checks the input parameters and
   --            estimates the optimal workspace size for the given
   --            values of N, ILO and IHI.  The estimate is returned
   --            in WORK(1).  No error message related to LWORK is
   --            issued by XERBLA.  Neither H nor Z are accessed.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --              =  0:  successful exit
   --            .LT. 0:  if INFO = -i, the i-th argument had an illegal
   --                     value
   --            .GT. 0:  if INFO = i, DHSEQR failed to compute all of
   --                 the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
   --                 and WI contain those eigenvalues which have been
   --                 successfully computed.  (Failures are rare.)
   --
   --                 If INFO .GT. 0 and JOB = 'E', then on exit, the
   --                 remaining unconverged eigenvalues are the eigen-
   --                 values of the upper Hessenberg matrix rows and
   --                 columns ILO through INFO of the final, output
   --                 value of H.
   --
   --                 If INFO .GT. 0 and JOB   = 'S', then on exit
   --
   --            (*)  (initial value of H)*U  = U*(final value of H)
   --
   --                 where U is an orthogonal matrix.  The final
   --                 value of H is upper Hessenberg and quasi-triangular
   --                 in rows and columns INFO+1 through IHI.
   --
   --                 If INFO .GT. 0 and COMPZ = 'V', then on exit
   --
   --                   (final value of Z)  =  (initial value of Z)*U
   --
   --                 where U is the orthogonal matrix in (*) (regard-
   --                 less of the value of JOB.)
   --
   --                 If INFO .GT. 0 and COMPZ = 'I', then on exit
   --                       (final value of Z)  = U
   --                 where U is the orthogonal matrix in (*) (regard-
   --                 less of the value of JOB.)
   --
   --                 If INFO .GT. 0 and COMPZ = 'N', then Z is not
   --                 accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  Further Details:
   --  ================
   --
   --
   --              Default values supplied by
   --              ILAENV(ISPEC,'DHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
   --              It is suggested that these defaults be adjusted in order
   --              to attain best performance in each particular
   --              computational environment.
   --
   --             ISPEC=12: The DLAHQR vs DLAQR0 crossover point.
   --                       Default: 75. (Must be at least 11.)
   --
   --             ISPEC=13: Recommended deflation window size.
   --                       This depends on ILO, IHI and NS.  NS is the
   --                       number of simultaneous shifts returned
   --                       by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
   --                       The default for (IHI-ILO+1).LE.500 is NS.
   --                       The default for (IHI-ILO+1).GT.500 is 3*NS/2.
   --
   --             ISPEC=14: Nibble crossover point. (See IPARMQ for
   --                       details.)  Default: 14% of deflation window
   --                       size.
   --
   --             ISPEC=15: Number of simultaneous shifts in a multishift
   --                       QR iteration.
   --
   --                       If IHI-ILO+1 is ...
   --
   --                       greater than      ...but less    ... the
   --                       or equal to ...      than        default is
   --
   --                            1               30          NS =   2(+)
   --                           30               60          NS =   4(+)
   --                           60              150          NS =  10(+)
   --                          150              590          NS =  **
   --                          590             3000          NS =  64
   --                         3000             6000          NS = 128
   --                         6000             infinity      NS = 256
   --
   --                   (+)  By default some or all matrices of this order
   --                        are passed to the implicit Real shift routine
   --                        DLAHQR and this parameter is ignored.  See
   --                        ISPEC=12 above and comments in IPARMQ for
   --                        details.
   --
   --                  (**)  The asterisks (**) indicate an ad-hoc
   --                        function of N increasing from 10 to 64.
   --
   --             ISPEC=16: Select structured matrix multiply.
   --                       If the number of simultaneous shifts (specified
   --                       by ISPEC=15) is less than 14, then the default
   --                       for ISPEC=16 is 0.  Otherwise the default for
   --                       ISPEC=16 is 2.
   --
   --  References:
   --  ================
   --
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
   --        Performance, SIAM Journal of Matrix Analysis, volume 23, pages
   --        929--947, 2002.
   --  \n
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part II: Aggressive Early Deflation, SIAM Journal
   --        of Matrix Analysis, volume 23, pages 948--973, 2002.
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --
   --     ==== Matrices of order NTINY or smaller must be processed by
   --     .    DLAHQR because of insufficient subdiagonal scratch space.
   --     .    (This is a hard limit.) ====
   --      PARAMETER          ( NTINY = 11 )
   --
   --     ==== NL allocates some local workspace to help small matrices
   --     .    through a rare DLAHQR failure.  NL .GT. NTINY = 11 is
   --     .    required and NL .LE. NMIN = ILAENV(ISPEC=12,...) is recom-
   --     .    mended.  (The default value of NMIN is 75.)  Using NL = 49
   --     .    allows up to six simultaneous shifts and a 16-by-16
   --     .    deflation window.  ====
   --      PARAMETER          ( NL = 49 )
   --      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0 )
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      INTEGER            ILAENV
   --      LOGICAL            LSAME
   --      EXTERNAL           ILAENV, LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLACPY, DLAHQR, DLAQR0, DLASET, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     ==== Decode and check the input parameters. ====
   --
   begin
      WANTT    := LSAME (JOB, 'S');
      INITZ    := LSAME (COMPZ, 'I');
      WANTZ    := INITZ or LSAME (COMPZ, 'V');
      WORK (1) := Real (max (1, N));
      LQUERY   := LWORK = -1;
      --
      INFO := 0;
      if not LSAME (JOB, 'E') and not WANTT then
         INFO := -1;
      elsif not LSAME (COMPZ, 'N') and not WANTZ then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -4;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -5;
      elsif LDH < max (1, N) then
         INFO := -7;
      elsif LDZ < 1 or (WANTZ and LDZ < max (1, N)) then
         INFO := -11;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -13;
      end if;
      --
      if INFO /= 0 then
         --
         --        ==== Quick return in case of invalid argument. ====
         --
         XERBLA ("DHSEQR", -INFO);
         return;
      --
      elsif N = 0 then
         --
         --        ==== Quick return in case N = 0; nothing to do. ====
         --
         return;
      --
      elsif LQUERY then
         --
         --        ==== Quick return in case of a workspace query ====
         --
         DLAQR0 (WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI, ILO, IHI, Z, LDZ, WORK, LWORK, INFO);
         --        ==== Ensure reported workspace size is backward-compatible with
         --        .    previous LAPACK versions. ====
         WORK (1) := max (Real (max (1, N)), WORK (1));
         return;
      --
      else
         --
         --        ==== copy eigenvalues isolated by DGEBAL ====
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > ILO - 1;
            WR (I) := H (I, I);
            WI (I) := ZERO;
         end loop;
         I := IHI + 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            WR (I) := H (I, I);
            WI (I) := ZERO;
         end loop;
         --
         --        ==== Initialize Z, if requested ====
         --
         if INITZ then
            DLASET ('A', N, N, ZERO, ONE, Z'Address, LDZ);
         end if;
         --
         --        ==== Quick return if possible ====
         --
         if ILO = IHI then
            WR (ILO) := H (ILO, ILO);
            WI (ILO) := ZERO;
            return;
         end if;
         --
         --        ==== DLAHQR/DLAQR0 crossover point ====
         --
         NMIN := ILAENV (12, "DHSEQR", JOB & COMPZ, N, ILO, IHI, LWORK);
         NMIN := max (NTINY, NMIN);
         --
         --        ==== DLAQR0 for big matrices; DLAHQR for small ones ====
         --
         if N > NMIN then
            DLAQR0 (WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI, ILO, IHI, Z, LDZ, WORK, LWORK, INFO);
         else
            --
            --           ==== Small matrix ====
            --
            DLAHQR (WANTT, WANTZ, N, ILO, IHI, H'Address, LDH, WR'Address, WI'Address, ILO, IHI, Z'Address, LDZ, INFO);
            --
            if INFO > 0 then
               --
               --              ==== A rare DLAHQR failure!  DLAQR0 sometimes succeeds
               --              .    when DLAHQR fails. ====
               --
               KBOT := INFO;
               --
               if N >= NL then
                  --
                  --                 ==== Larger matrices have enough subdiagonal scratch
                  --                 .    space to call DLAQR0 directly. ====
                  --
                  DLAQR0 (WANTT, WANTZ, N, ILO, KBOT, H, LDH, WR, WI, ILO, IHI, Z, LDZ, WORK, LWORK, INFO);
               --
               else
                  --
                  --                 ==== Tiny matrices don't have enough subdiagonal
                  --                 .    scratch space to benefit from DLAQR0.  Hence,
                  --                 .    tiny matrices must be copied into a larger
                  --                 .    array before calling DLAQR0. ====
                  --
                  DLACPY ('A', N, N, H'Address, LDH, HL'Address, NL);
                  HL (N + 1, N) := ZERO;
                  DLASET ('A', NL, NL - N, ZERO, ZERO, HL (1, N + 1)'Address, NL);
                  DLAQR0 (WANTT, WANTZ, NL, ILO, KBOT, HL, NL, WR, WI, ILO, IHI, Z, LDZ, WORKL, NL, INFO);
                  if WANTT or INFO /= 0 then
                     DLACPY ('A', N, N, HL'Address, NL, H'Address, LDH);
                  end if;
               end if;
            end if;
         end if;
         --
         --        ==== Clear out the trash, if necessary. ====
         --
         if (WANTT or INFO /= 0) and N > 2 then
            DLASET ('L', N - 2, N - 2, ZERO, ZERO, H (3, 1)'Address, LDH);
         end if;
         --
         --        ==== Ensure reported workspace size is backward-compatible with
         --        .    previous LAPACK versions. ====
         --
         WORK (1) := max (Real (max (1, N)), WORK (1));
      end if;
      --
      --     ==== End of DHSEQR ====
      --
   end DHSEQR;

   function DISNAN (DIN : Real) return Boolean is
      DISNAN_Result : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       LOGICAL FUNCTION DISNAN( DIN )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   DIN
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DISNAN returns .TRUE. if its argument is NaN, and .FALSE.
   --  otherwise.  To be replaced by the Fortran 2003 intrinsic in the
   --  future.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] DIN
   --           DIN is DOUBLE PRECISION
   --           Input to test for NaN.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --  .. External Functions ..
   --      EXTERNAL DLAISNAN
   --  ..
   --  .. Executable Statements ..
   begin
      DISNAN_Result := DLAISNAN (DIN, DIN);
      return DISNAN_Result;
   end DISNAN;

   procedure DLABAD (SMALL : in out Real; LARGE : in out Real) is

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLABAD( SMALL, LARGE )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   LARGE, SMALL
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLABAD takes as input the values computed by DLAMCH for underflow and
   --  overflow, and returns the square root of each of these values if the
   --  log of LARGE is sufficiently large.  This subroutine is intended to
   --  identify machines with a large exponent range, such as the Crays, and
   --  redefine the underflow and overflow limits to be the square roots of
   --  the values computed by DLAMCH.  This subroutine is needed because
   --  DLAMCH does not compensate for poor arithmetic in the upper half of
   --  the exponent range, as is found on a Cray.
   --
   --  Arguments:
   --  ==========
   --
   --  [in,out] SMALL
   --           SMALL is DOUBLE PRECISION
   --           On entry, the underflow threshold as computed by DLAMCH.
   --           On exit, if LOG10(LARGE) is sufficiently large, the square
   --           root of SMALL, otherwise unchanged.
   --
   --  [in,out] LARGE
   --           LARGE is DOUBLE PRECISION
   --           On entry, the overflow threshold as computed by DLAMCH.
   --           On exit, if LOG10(LARGE) is sufficiently large, the square
   --           root of LARGE, otherwise unchanged.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Intrinsic Functions ..
   --      INTRINSIC          LOG10, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     If it looks like we're on a Cray, take the square root of
   --     SMALL and LARGE to avoid overflow and underflow problems.
   --
   begin
      if log10 (LARGE) > 2000.0e0 then
         SMALL := Sqrt (SMALL);
         LARGE := Sqrt (LARGE);
      end if;
      --
      return;
      --
      --     End of DLABAD
      --
   end DLABAD;

   procedure DLABRD
     (M        : Integer;
      N        : Integer;
      NB       : Integer;
      A_adr    : Address;
      LDA      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      TAUQ_adr : Address;
      TAUP_adr : Address;
      X_adr    : Address;
      LDX      : Integer;
      Y_adr    : Address;
      LDY      : Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      D    : Ftn_Real_Vector (1 .. NB);
      E    : Ftn_Real_Vector (1 .. NB);
      TAUQ : Ftn_Real_Vector (1 .. NB);
      TAUP : Ftn_Real_Vector (1 .. NB);
      X    : Ftn_Real_Matrix (1 .. LDX, 1 .. NB);
      Y    : Ftn_Real_Matrix (1 .. LDY, 1 .. NB);

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAUQ'Address use TAUQ_adr;
      for TAUP'Address use TAUP_adr;
      for X'Address use X_adr;
      for Y'Address use Y_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAUQ);
      pragma Import (Ada, TAUP);
      pragma Import (Ada, X);
      pragma Import (Ada, Y);

      ZERO : constant Real := 0.0e0;
      ONE  : constant Real := 1.0e0;
      I    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLABRD( M, N, NB, A, LDA, D, E, TAUQ, TAUP, X, LDX, Y,
   --                          LDY )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            LDA, LDX, LDY, M, N, NB
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAUP( * ),
   --      $                   TAUQ( * ), X( LDX, * ), Y( LDY, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLABRD reduces the first NB rows and columns of a real general
   --  m by n matrix A to upper or lower bidiagonal form by an orthogonal
   --  transformation Q**T * A * P, and returns the matrices X and Y which
   --  are needed to apply the transformation to the unreduced part of A.
   --
   --  If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
   --  bidiagonal form.
   --
   --  This is an auxiliary routine called by DGEBRD
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows in the matrix A.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns in the matrix A.
   --
   --  [in] NB
   --           NB is INTEGER
   --           The number of leading rows and columns of A to be reduced.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the m by n general matrix to be reduced.
   --           On exit, the first NB rows and columns of the matrix are
   --           overwritten; the rest of the array is unchanged.
   --           If m >= n, elements on and below the diagonal in the first NB
   --             columns, with the array TAUQ, represent the orthogonal
   --             matrix Q as a product of elementary reflectors; and
   --             elements above the diagonal in the first NB rows, with the
   --             array TAUP, represent the orthogonal matrix P as a product
   --             of elementary reflectors.
   --           If m < n, elements below the diagonal in the first NB
   --             columns, with the array TAUQ, represent the orthogonal
   --             matrix Q as a product of elementary reflectors, and
   --             elements on and above the diagonal in the first NB rows,
   --             with the array TAUP, represent the orthogonal matrix P as
   --             a product of elementary reflectors.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (NB)
   --           The diagonal elements of the first NB rows and columns of
   --           the reduced matrix.  D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (NB)
   --           The off-diagonal elements of the first NB rows and columns of
   --           the reduced matrix.
   --
   --  [out] TAUQ
   --           TAUQ is DOUBLE PRECISION array dimension (NB)
   --           The scalar factors of the elementary reflectors which
   --           represent the orthogonal matrix Q. See Further Details.
   --
   --  [out] TAUP
   --           TAUP is DOUBLE PRECISION array, dimension (NB)
   --           The scalar factors of the elementary reflectors which
   --           represent the orthogonal matrix P. See Further Details.
   --
   --  [out] X
   --           X is DOUBLE PRECISION array, dimension (LDX,NB)
   --           The m-by-nb matrix X required to update the unreduced part
   --           of A.
   --
   --  [in] LDX
   --           LDX is INTEGER
   --           The leading dimension of the array X. LDX >= max(1,M).
   --
   --  [out] Y
   --           Y is DOUBLE PRECISION array, dimension (LDY,NB)
   --           The n-by-nb matrix Y required to update the unreduced part
   --           of A.
   --
   --  [in] LDY
   --           LDY is INTEGER
   --           The leading dimension of the array Y. LDY >= max(1,N).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrices Q and P are represented as products of elementary
   --   reflectors:
   --
   --      Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
   --
   --   where tauq and taup are real scalars, and v and u are real vectors.
   --
   --   If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
   --   A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
   --   A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
   --   A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
   --   A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   The elements of the vectors v and u together form the m-by-nb matrix
   --   V and the nb-by-n matrix U**T which are needed, with X and Y, to apply
   --   the transformation to the unreduced part of the matrix, using a block
   --   update of the form:  A := A - V*Y**T - X*U**T.
   --
   --   The contents of A on exit are illustrated by the following examples
   --   with nb = 2:
   --
   --   m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
   --
   --     (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
   --     (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
   --     (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
   --     (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
   --     (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
   --     (  v1  v2  a   a   a  )
   --
   --   where a denotes an element of the original matrix which is unchanged,
   --   vi denotes an element of the vector defining H(i), and ui an element
   --   of the vector defining G(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMV, DLARFG, DSCAL
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if M <= 0 or N <= 0 then
         return;
      end if;
      --
      if M >= N then
         --
         --        Reduce to upper bidiagonal form
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > NB;
            --
            --           Update A(i:m,i)
            --
            DGEMV ('N', M - I + 1, I - 1, -ONE, A (I, 1)'Address, LDA, Y (I, 1)'Address, LDY, ONE, A (I, I)'Address, 1);
            DGEMV ('N', M - I + 1, I - 1, -ONE, X (I, 1)'Address, LDX, A (1, I)'Address, 1, ONE, A (I, I)'Address, 1);
            --
            --           Generate reflection Q(i) to annihilate A(i+1:m,i)
            --
            DLARFG (M - I + 1, A (I, I), A (min (I + 1, M), I)'Address, 1, TAUQ (I));
            D (I) := A (I, I);
            if I < N then
               A (I, I) := ONE;
               --
               --              Compute Y(i+1:n,i)
               --
               DGEMV
                 ('T',
                  M - I + 1,
                  N - I,
                  ONE,
                  A (I, I + 1)'Address,
                  LDA,
                  A (I, I)'Address,
                  1,
                  ZERO,
                  Y (I + 1, I)'Address,
                  1);
               DGEMV ('T', M - I + 1, I - 1, ONE, A (I, 1)'Address, LDA, A (I, I)'Address, 1, ZERO, Y (1, I)'Address, 1);
               DGEMV
                 ('N',
                  N - I,
                  I - 1,
                  -ONE,
                  Y (I + 1, 1)'Address,
                  LDY,
                  Y (1, I)'Address,
                  1,
                  ONE,
                  Y (I + 1, I)'Address,
                  1);
               DGEMV ('T', M - I + 1, I - 1, ONE, X (I, 1)'Address, LDX, A (I, I)'Address, 1, ZERO, Y (1, I)'Address, 1);
               DGEMV
                 ('T',
                  I - 1,
                  N - I,
                  -ONE,
                  A (1, I + 1)'Address,
                  LDA,
                  Y (1, I)'Address,
                  1,
                  ONE,
                  Y (I + 1, I)'Address,
                  1);
               DSCAL (N - I, TAUQ (I), Y (I + 1, I)'Address, 1);
               --
               --              Update A(i,i+1:n)
               --
               DGEMV
                 ('N',
                  N - I,
                  I,
                  -ONE,
                  Y (I + 1, 1)'Address,
                  LDY,
                  A (I, 1)'Address,
                  LDA,
                  ONE,
                  A (I, I + 1)'Address,
                  LDA);
               DGEMV
                 ('T',
                  I - 1,
                  N - I,
                  -ONE,
                  A (1, I + 1)'Address,
                  LDA,
                  X (I, 1)'Address,
                  LDX,
                  ONE,
                  A (I, I + 1)'Address,
                  LDA);
               --
               --              Generate reflection P(i) to annihilate A(i,i+2:n)
               --
               DLARFG (N - I, A (I, I + 1), A (I, min (I + 2, N))'Address, LDA, TAUP (I));
               E (I)        := A (I, I + 1);
               A (I, I + 1) := ONE;
               --
               --              Compute X(i+1:m,i)
               --
               DGEMV
                 ('N',
                  M - I,
                  N - I,
                  ONE,
                  A (I + 1, I + 1)'Address,
                  LDA,
                  A (I, I + 1)'Address,
                  LDA,
                  ZERO,
                  X (I + 1, I)'Address,
                  1);
               DGEMV ('T', N - I, I, ONE, Y (I + 1, 1)'Address, LDY, A (I, I + 1)'Address, LDA, ZERO, X (1, I)'Address, 1);
               DGEMV ('N', M - I, I, -ONE, A (I + 1, 1)'Address, LDA, X (1, I)'Address, 1, ONE, X (I + 1, I)'Address, 1);
               DGEMV
                 ('N',
                  I - 1,
                  N - I,
                  ONE,
                  A (1, I + 1)'Address,
                  LDA,
                  A (I, I + 1)'Address,
                  LDA,
                  ZERO,
                  X (1, I)'Address,
                  1);
               DGEMV
                 ('N',
                  M - I,
                  I - 1,
                  -ONE,
                  X (I + 1, 1)'Address,
                  LDX,
                  X (1, I)'Address,
                  1,
                  ONE,
                  X (I + 1, I)'Address,
                  1);
               DSCAL (M - I, TAUP (I), X (I + 1, I)'Address, 1);
            end if;
         end loop;
      else
         --
         --        Reduce to lower bidiagonal form
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > NB;
            --
            --           Update A(i,i:n)
            --
            DGEMV ('N', N - I + 1, I - 1, -ONE, Y (I, 1)'Address, LDY, A (I, 1)'Address, LDA, ONE, A (I, I)'Address, LDA);
            DGEMV ('T', I - 1, N - I + 1, -ONE, A (1, I)'Address, LDA, X (I, 1)'Address, LDX, ONE, A (I, I)'Address, LDA);
            --
            --           Generate reflection P(i) to annihilate A(i,i+1:n)
            --
            DLARFG (N - I + 1, A (I, I), A (I, min (I + 1, N))'Address, LDA, TAUP (I));
            D (I) := A (I, I);
            if I < M then
               A (I, I) := ONE;
               --
               --              Compute X(i+1:m,i)
               --
               DGEMV
                 ('N',
                  M - I,
                  N - I + 1,
                  ONE,
                  A (I + 1, I)'Address,
                  LDA,
                  A (I, I)'Address,
                  LDA,
                  ZERO,
                  X (I + 1, I)'Address,
                  1);
               DGEMV ('T', N - I + 1, I - 1, ONE, Y (I, 1)'Address, LDY, A (I, I)'Address, LDA, ZERO, X (1, I)'Address, 1);
               DGEMV
                 ('N',
                  M - I,
                  I - 1,
                  -ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  X (1, I)'Address,
                  1,
                  ONE,
                  X (I + 1, I)'Address,
                  1);
               DGEMV ('N', I - 1, N - I + 1, ONE, A (1, I)'Address, LDA, A (I, I)'Address, LDA, ZERO, X (1, I)'Address, 1);
               DGEMV
                 ('N',
                  M - I,
                  I - 1,
                  -ONE,
                  X (I + 1, 1)'Address,
                  LDX,
                  X (1, I)'Address,
                  1,
                  ONE,
                  X (I + 1, I)'Address,
                  1);
               DSCAL (M - I, TAUP (I), X (I + 1, I)'Address, 1);
               --
               --              Update A(i+1:m,i)
               --
               DGEMV
                 ('N',
                  M - I,
                  I - 1,
                  -ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  Y (I, 1)'Address,
                  LDY,
                  ONE,
                  A (I + 1, I)'Address,
                  1);
               DGEMV ('N', M - I, I, -ONE, X (I + 1, 1)'Address, LDX, A (1, I)'Address, 1, ONE, A (I + 1, I)'Address, 1);
               --
               --              Generate reflection Q(i) to annihilate A(i+2:m,i)
               --
               DLARFG (M - I, A (I + 1, I), A (min (I + 2, M), I)'Address, 1, TAUQ (I));
               E (I)        := A (I + 1, I);
               A (I + 1, I) := ONE;
               --
               --              Compute Y(i+1:n,i)
               --
               DGEMV
                 ('T',
                  M - I,
                  N - I,
                  ONE,
                  A (I + 1, I + 1)'Address,
                  LDA,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  Y (I + 1, I)'Address,
                  1);
               DGEMV
                 ('T',
                  M - I,
                  I - 1,
                  ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  Y (1, I)'Address,
                  1);
               DGEMV
                 ('N',
                  N - I,
                  I - 1,
                  -ONE,
                  Y (I + 1, 1)'Address,
                  LDY,
                  Y (1, I)'Address,
                  1,
                  ONE,
                  Y (I + 1, I)'Address,
                  1);
               DGEMV ('T', M - I, I, ONE, X (I + 1, 1)'Address, LDX, A (I + 1, I)'Address, 1, ZERO, Y (1, I)'Address, 1);
               DGEMV ('T', I, N - I, -ONE, A (1, I + 1)'Address, LDA, Y (1, I)'Address, 1, ONE, Y (I + 1, I)'Address, 1);
               DSCAL (N - I, TAUQ (I), Y (I + 1, I)'Address, 1);
            end if;
         end loop;
      end if;
      return;
      --
      --     End of DLABRD
      --
   end DLABRD;

   procedure DLACPY
     (UPLO  : Character;
      M     : Integer;
      N     : Integer;
      A_adr : Address;
      LDA   : Integer;
      B_adr : Address;
      LDB   : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      B : Ftn_Real_Matrix (1 .. LDB, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);

      I : Integer;
      J : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLACPY( UPLO, M, N, A, LDA, B, LDB )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            LDA, LDB, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLACPY copies all or part of a two-dimensional matrix A to another
   --  matrix B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies the part of the matrix A to be copied to B.
   --           = 'U':      Upper triangular part
   --           = 'L':      Lower triangular part
   --           Otherwise:  All of the matrix A
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The m by n matrix A.  If UPLO = 'U', only the upper triangle
   --           or trapezoid is accessed; if UPLO = 'L', only the lower
   --           triangle or trapezoid is accessed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] B
   --           B is DOUBLE PRECISION array, dimension (LDB,N)
   --           On exit, B = A in the locations specified by UPLO.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if LSAME (UPLO, 'U') then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J, M);
               B (I, J) := A (I, J);
            end loop;
         end loop;
      elsif LSAME (UPLO, 'L') then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := J - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := A (I, J);
            end loop;
         end loop;
      else
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := A (I, J);
            end loop;
         end loop;
      end if;
      return;
      --
      --     End of DLACPY
      --
   end DLACPY;

   procedure DLADIV
     (A : Real;
      B : Real;
      C : Real;
      D : Real;
      P : in out Real;
      Q : in out Real)
   is
      E : Real;
      F : Real;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLADIV( A, B, C, D, P, Q )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   A, B, C, D, P, Q
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLADIV performs complex division in  real arithmetic
   --
   --                        a + i*b
   --             p + i*q = ---------
   --                        c + i*d
   --
   --  The algorithm is due to Robert L. Smith and can be found
   --  in D. Knuth, The art of Computer Programming, Vol.2, p.195
   --
   --  Arguments:
   --  ==========
   --
   --  [in] A
   --           A is DOUBLE PRECISION
   --
   --  [in] B
   --           B is DOUBLE PRECISION
   --
   --  [in] C
   --           C is DOUBLE PRECISION
   --
   --  [in] D
   --           D is DOUBLE PRECISION
   --           The scalars a, b, c, and d in the above expression.
   --
   --  [out] P
   --           P is DOUBLE PRECISION
   --
   --  [out] Q
   --           Q is DOUBLE PRECISION
   --           The scalars p and q in the above expression.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if abs (D) < abs (C) then
         E := D / C;
         F := C + D * E;
         P := (A + B * E) / F;
         Q := (B - A * E) / F;
      else
         E := C / D;
         F := D + C * E;
         P := (B + A * E) / F;
         Q := (-A + B * E) / F;
      end if;
      --
      return;
      --
      --     End of DLADIV
      --
   end DLADIV;

   procedure DLAE2
     (A   : Real;
      B   : Real;
      C   : Real;
      RT1 : in out Real;
      RT2 : in out Real)
   is
      ONE  : constant Real := 1.0e0;
      TWO  : constant Real := 2.0e0;
      ZERO : constant Real := 0.0e0;
      HALF : constant Real := 0.5e0;
      AB   : Real;
      ACMN : Real;
      ACMX : Real;
      ADF  : Real;
      DF   : Real;
      RT   : Real;
      SM   : Real;
      TB   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAE2( A, B, C, RT1, RT2 )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   A, B, C, RT1, RT2
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
   --     [  A   B  ]
   --     [  B   C  ].
   --  On return, RT1 is the eigenvalue of larger absolute value, and RT2
   --  is the eigenvalue of smaller absolute value.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] A
   --           A is DOUBLE PRECISION
   --           The (1,1) element of the 2-by-2 matrix.
   --
   --  [in] B
   --           B is DOUBLE PRECISION
   --           The (1,2) and (2,1) elements of the 2-by-2 matrix.
   --
   --  [in] C
   --           C is DOUBLE PRECISION
   --           The (2,2) element of the 2-by-2 matrix.
   --
   --  [out] RT1
   --           RT1 is DOUBLE PRECISION
   --           The eigenvalue of larger absolute value.
   --
   --  [out] RT2
   --           RT2 is DOUBLE PRECISION
   --           The eigenvalue of smaller absolute value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   RT1 is accurate to a few ulps barring over/underflow.
   --
   --   RT2 may be inaccurate if there is massive cancellation in the
   --   determinant A*C-B*B; higher precision or correctly rounded or
   --   correctly truncated arithmetic would be needed to compute RT2
   --   accurately in all cases.
   --
   --   Overflow is possible only if RT1 is within a factor of 5 of overflow.
   --   Underflow is harmless if the input data is 0 or exceeds
   --      underflow_threshold / macheps.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D0 )
   --      PARAMETER          ( TWO = 2.0D0 )
   --      PARAMETER          ( ZERO = 0.0D0 )
   --      PARAMETER          ( HALF = 0.5D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Compute the eigenvalues
   --
   begin
      SM  := A + C;
      DF  := A - C;
      ADF := abs (DF);
      TB  := B + B;
      AB  := abs (TB);
      if abs (A) > abs (C) then
         ACMX := A;
         ACMN := C;
      else
         ACMX := C;
         ACMN := A;
      end if;
      if ADF > AB then
         RT := ADF * Sqrt (ONE + (AB / ADF) ** 2);
      elsif ADF < AB then
         RT := AB * Sqrt (ONE + (ADF / AB) ** 2);
      else
         --
         --        Includes case AB=ADF=0
         --
         RT := AB * Sqrt (TWO);
      end if;
      if SM < ZERO then
         RT1 := HALF * (SM - RT);
         --
         --        Order of execution important.
         --        To get fully accurate smaller eigenvalue,
         --        next line needs to be executed in higher precision.
         --
         RT2 := (ACMX / RT1) * ACMN - (B / RT1) * B;
      elsif SM > ZERO then
         RT1 := HALF * (SM + RT);
         --
         --        Order of execution important.
         --        To get fully accurate smaller eigenvalue,
         --        next line needs to be executed in higher precision.
         --
         RT2 := (ACMX / RT1) * ACMN - (B / RT1) * B;
      else
         --
         --        Includes case RT1 = RT2 = 0
         --
         RT1 := HALF * RT;
         RT2 := -HALF * RT;
      end if;
      return;
      --
      --     End of DLAE2
      --
   end DLAE2;

   procedure DLAED0
     (ICOMPQ     : Integer;
      QSIZ       : Integer;
      N          : Integer;
      D_adr      : Address;
      E_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      QSTORE_adr : Address;
      LDQS       : Integer;
      WORK_adr   : Address;
      IWORK_adr  : Address;
      INFO       : in out Integer)
   is

      N_Log2_N  : constant Integer := N * (1 + intlog2 (N));
      tmp_work  : constant Integer := max (4 * N + N * N, 1 + 3 * N + 2 * N_Log2_N + 3 * N * N);
      tmp_iwork : constant Integer := max (3 + 5 * N, 6 + 6 * N + 5 * N_Log2_N);

      D      : Ftn_Real_Vector (1 .. N);
      E      : Ftn_Real_Vector (1 .. N - 1);
      Q      : Ftn_Real_Matrix (1 .. LDQ, 1 .. N);
      QSTORE : Ftn_Real_Matrix (1 .. LDQS, 1 .. N);
      WORK   : Ftn_Real_Vector (1 .. tmp_work);
      IWORK  : Ftn_Integer_Vector (1 .. tmp_iwork);

      for D'Address use D_adr;
      for E'Address use E_adr;
      for Q'Address use Q_adr;
      for QSTORE'Address use QSTORE_adr;
      for WORK'Address use WORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, Q);
      pragma Import (Ada, QSTORE);
      pragma Import (Ada, WORK);
      pragma Import (Ada, IWORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      CURLVL : Integer;
      CURPRB : Integer;
      CURR   : Integer;
      I      : Integer;
      IGIVCL : Integer;
      IGIVNM : Integer;
      IGIVPT : Integer;
      INDXQ  : Integer;
      IPERM  : Integer;
      IPRMPT : Integer;
      IQ     : Integer;
      IQPTR  : Integer;
      IWREM  : Integer;
      J      : Integer;
      K      : Integer;
      LGN    : Integer;
      MATSIZ : Integer;
      MSD2   : Integer;
      SMLSIZ : Integer;
      SMM1   : Integer;
      SPM1   : Integer;
      SPM2   : Integer;
      SUBMAT : Integer;
      SUBPBS : Integer;
      TLVLS  : Integer;
      TEMP   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED0( ICOMPQ, QSIZ, N, D, E, Q, LDQ, QSTORE, LDQS,
   --                          WORK, IWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            ICOMPQ, INFO, LDQ, LDQS, N, QSIZ
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   D( * ), E( * ), Q( LDQ, * ), QSTORE( LDQS, * ),
   --      $                   WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAED0 computes all eigenvalues and corresponding eigenvectors of a
   --  symmetric tridiagonal matrix using the divide and conquer method.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ICOMPQ
   --           ICOMPQ is INTEGER
   --           = 0:  Compute eigenvalues only.
   --           = 1:  Compute eigenvectors of original dense symmetric matrix
   --                 also.  On entry, Q contains the orthogonal matrix used
   --                 to reduce the original matrix to tridiagonal form.
   --           = 2:  Compute eigenvalues and eigenvectors of tridiagonal
   --                 matrix.
   --
   --  [in] QSIZ
   --           QSIZ is INTEGER
   --          The dimension of the orthogonal matrix used to reduce
   --          the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry, the main diagonal of the tridiagonal matrix.
   --          On exit, its eigenvalues.
   --
   --  [in] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --          The off-diagonal elements of the tridiagonal matrix.
   --          On exit, E has been destroyed.
   --
   --  [in,out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ, N)
   --          On entry, Q must contain an N-by-N orthogonal matrix.
   --          If ICOMPQ = 0    Q is not referenced.
   --          If ICOMPQ = 1    On entry, Q is a subset of the columns of the
   --                           orthogonal matrix used to reduce the full
   --                           matrix to tridiagonal form corresponding to
   --                           the subset of the full matrix which is being
   --                           decomposed at this time.
   --          If ICOMPQ = 2    On entry, Q will be the identity matrix.
   --                           On exit, Q contains the eigenvectors of the
   --                           tridiagonal matrix.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  If eigenvectors are
   --          desired, then  LDQ >= max(1,N).  In any case,  LDQ >= 1.
   --
   --  [out] QSTORE
   --           QSTORE is DOUBLE PRECISION array, dimension (LDQS, N)
   --          Referenced only when ICOMPQ = 1.  Used to store parts of
   --          the eigenvector matrix when the updating matrix multiplies
   --          take place.
   --
   --  [in] LDQS
   --           LDQS is INTEGER
   --          The leading dimension of the array QSTORE.  If ICOMPQ = 1,
   --          then  LDQS >= max(1,N).  In any case,  LDQS >= 1.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array,
   --          If ICOMPQ = 0 or 1, the dimension of WORK must be at least
   --                      1 + 3*N + 2*N*lg N + 3*N**2
   --                      ( lg( N ) = smallest integer k
   --                                  such that 2^k >= N )
   --          If ICOMPQ = 2, the dimension of WORK must be at least
   --                      4*N + N**2.
   --
   --  [out] IWORK
   --           IWORK is INTEGER array,
   --          If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
   --                         6 + 6*N + 5*N*lg N.
   --                         ( lg( N ) = smallest integer k
   --                                     such that 2^k >= N )
   --          If ICOMPQ = 2, the dimension of IWORK must be at least
   --                         3 + 5*N.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  The algorithm failed to compute an eigenvalue while
   --                 working on the submatrix lying in rows and columns
   --                 INFO/(N+1) through mod(INFO,N+1).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.D0, ONE = 1.D0, TWO = 2.D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DGEMM, DLACPY, DLAED1, DLAED7, DSTEQR, XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, LOG, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if ICOMPQ < 0 or ICOMPQ > 2 then
         INFO := -1;
      elsif (ICOMPQ = 1) and (QSIZ < max (0, N)) then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDQ < max (1, N) then
         INFO := -7;
      elsif LDQS < max (1, N) then
         INFO := -9;
      end if;
      if INFO /= 0 then
         XERBLA ("DLAED0", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      SMLSIZ := ILAENV (9, "DLAED0", " ", 0, 0, 0, 0);
      --
      --     Determine the size and placement of the submatrices, and save in
      --     the leading elements of IWORK.
      --
      IWORK (1) := N;
      SUBPBS    := 1;
      TLVLS     := 0;
      <<L10>> null;
      if IWORK (SUBPBS) > SMLSIZ then
         J := SUBPBS + 1;
         loop
            J := J - 1;
            exit when J < 1;
            IWORK (2 * J)     := (IWORK (J) + 1) / 2;
            IWORK (2 * J - 1) := IWORK (J) / 2;
         end loop;
         TLVLS  := TLVLS + 1;
         SUBPBS := 2 * SUBPBS;
         goto L10;
      end if;
      J := 2 - 1;
      loop
         J := J + 1;
         exit when J > SUBPBS;
         IWORK (J) := IWORK (J) + IWORK (J - 1);
      end loop;
      --
      --     Divide the matrix into SUBPBS submatrices of size at most SMLSIZ+1
      --     using rank-1 modifications (cuts).
      --
      SPM1 := SUBPBS - 1;
      I    := 1 - 1;
      loop
         I := I + 1;
         exit when I > SPM1;
         SUBMAT     := IWORK (I) + 1;
         SMM1       := SUBMAT - 1;
         D (SMM1)   := D (SMM1) - abs (E (SMM1));
         D (SUBMAT) := D (SUBMAT) - abs (E (SMM1));
      end loop;
      --
      INDXQ := 4 * N + 3;
      if ICOMPQ /= 2 then
         --
         --        Set up workspaces for eigenvalues only/accumulate new vectors
         --        routine
         --
         TEMP := Log (Real (N)) / Log (TWO);
         LGN  := int (TEMP);
         if 2 ** LGN < N then
            LGN := LGN + 1;
         end if;
         if 2 ** LGN < N then
            LGN := LGN + 1;
         end if;
         IPRMPT := INDXQ + N + 1;
         IPERM  := IPRMPT + N * LGN;
         IQPTR  := IPERM + N * LGN;
         IGIVPT := IQPTR + N + 2;
         IGIVCL := IGIVPT + N * LGN;
         --
         IGIVNM := 1;
         IQ     := IGIVNM + 2 * N * LGN;
         IWREM  := IQ + N ** 2 + 1;
         --
         --        Initialize pointers
         --
         I := 0 - 1;
         loop
            I := I + 1;
            exit when I > SUBPBS;
            IWORK (IPRMPT + I) := 1;
            IWORK (IGIVPT + I) := 1;
         end loop;
         IWORK (IQPTR) := 1;
      end if;
      --
      --     Solve each submatrix eigenproblem at the bottom of the divide and
      --     conquer tree.
      --
      CURR := 0;
      I    := 0 - 1;
      loop
         I := I + 1;
         exit when I > SPM1;
         if I = 0 then
            SUBMAT := 1;
            MATSIZ := IWORK (1);
         else
            SUBMAT := IWORK (I) + 1;
            MATSIZ := IWORK (I + 1) - IWORK (I);
         end if;
         if ICOMPQ = 2 then
            DSTEQR
              ('I',
               MATSIZ,
               D (SUBMAT)'Address,
               E (SUBMAT)'Address,
               Q (SUBMAT, SUBMAT)'Address,
               LDQ,
               WORK'Address,
               INFO);
            if INFO /= 0 then
               goto L130;
            end if;
         else
            DSTEQR
              ('I',
               MATSIZ,
               D (SUBMAT)'Address,
               E (SUBMAT)'Address,
               WORK (IQ - 1 + IWORK (IQPTR + CURR))'Address,
               MATSIZ,
               WORK'Address,
               INFO);
            if INFO /= 0 then
               goto L130;
            end if;
            if ICOMPQ = 1 then
               DGEMM
                 ('N',
                  'N',
                  QSIZ,
                  MATSIZ,
                  MATSIZ,
                  ONE,
                  Q (1, SUBMAT)'Address,
                  LDQ,
                  WORK (IQ - 1 + IWORK (IQPTR + CURR))'Address,
                  MATSIZ,
                  ZERO,
                  QSTORE (1, SUBMAT)'Address,
                  LDQS);
            end if;
            IWORK (IQPTR + CURR + 1) := IWORK (IQPTR + CURR) + MATSIZ ** 2;
            CURR                     := CURR + 1;
         end if;
         K := 1;
         J := SUBMAT - 1;
         loop
            J := J + 1;
            exit when J > IWORK (I + 1);
            IWORK (INDXQ + J) := K;
            K                 := K + 1;
         end loop;
      end loop;
      --
      --     Successively merge eigensystems of adjacent submatrices
      --     into eigensystem for the corresponding larger matrix.
      --
      --     while ( SUBPBS > 1 )
      --
      CURLVL := 1;
      <<L80>> null;
      if SUBPBS > 1 then
         SPM2 := SUBPBS - 2;
         I    := 0 - 2;
         loop
            I := I + 2;
            exit when I > SPM2;
            if I = 0 then
               SUBMAT := 1;
               MATSIZ := IWORK (2);
               MSD2   := IWORK (1);
               CURPRB := 0;
            else
               SUBMAT := IWORK (I) + 1;
               MATSIZ := IWORK (I + 2) - IWORK (I);
               MSD2   := MATSIZ / 2;
               CURPRB := CURPRB + 1;
            end if;
            --
            --     Merge lower order eigensystems (of size MSD2 and MATSIZ - MSD2)
            --     into an eigensystem of size MATSIZ.
            --     DLAED1 is used only for the full eigensystem of a tridiagonal
            --     matrix.
            --     DLAED7 handles the cases in which eigenvalues only or eigenvalues
            --     and eigenvectors of a full symmetric matrix (which was reduced to
            --     tridiagonal form) are desired.
            --
            if ICOMPQ = 2 then
               DLAED1
                 (MATSIZ,
                  D (SUBMAT)'Address,
                  Q (SUBMAT, SUBMAT)'Address,
                  LDQ,
                  IWORK (INDXQ + SUBMAT)'Address,
                  E (SUBMAT + MSD2 - 1),
                  MSD2,
                  WORK'Address,
                  IWORK (SUBPBS + 1)'Address,
                  INFO);
            else
               DLAED7
                 (ICOMPQ,
                  MATSIZ,
                  QSIZ,
                  TLVLS,
                  CURLVL,
                  CURPRB,
                  D (SUBMAT)'Address,
                  QSTORE (1, SUBMAT)'Address,
                  LDQS,
                  IWORK (INDXQ + SUBMAT)'Address,
                  E (SUBMAT + MSD2 - 1),
                  MSD2,
                  WORK (IQ)'Address,
                  IWORK (IQPTR)'Address,
                  IWORK (IPRMPT)'Address,
                  IWORK (IPERM)'Address,
                  IWORK (IGIVPT)'Address,
                  IWORK (IGIVCL)'Address,
                  WORK (IGIVNM)'Address,
                  WORK (IWREM)'Address,
                  IWORK (SUBPBS + 1)'Address,
                  INFO);
            end if;
            if INFO /= 0 then
               goto L130;
            end if;
            IWORK (I / 2 + 1) := IWORK (I + 2);
            I                 := I + 2;
         end loop;
         SUBPBS := SUBPBS / 2;
         CURLVL := CURLVL + 1;
         goto L80;
      end if;
      --
      --     end while
      --
      --     Re-merge the eigenvalues/vectors which were deflated at the final
      --     merge step.
      --
      if ICOMPQ = 1 then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            J        := IWORK (INDXQ + I);
            WORK (I) := D (J);
            DCOPY (QSIZ, QSTORE (1, J)'Address, 1, Q (1, I)'Address, 1);
         end loop;
         DCOPY (N, WORK'Address, 1, D'Address, 1);
      elsif ICOMPQ = 2 then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            J        := IWORK (INDXQ + I);
            WORK (I) := D (J);
            DCOPY (N, Q (1, J)'Address, 1, WORK (N * I + 1)'Address, 1);
         end loop;
         DCOPY (N, WORK'Address, 1, D'Address, 1);
         DLACPY ('A', N, N, WORK (N + 1)'Address, N, Q'Address, LDQ);
      else
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            J        := IWORK (INDXQ + I);
            WORK (I) := D (J);
         end loop;
         DCOPY (N, WORK'Address, 1, D'Address, 1);
      end if;
      goto L140;
      --
      <<L130>> null;
      INFO := SUBMAT * (N + 1) + SUBMAT + MATSIZ - 1;
      --
      <<L140>> null;
      return;
      --
      --     End of DLAED0
      --
   end DLAED0;

   procedure DLAED1
     (N         : Integer;
      D_adr     : Address;
      Q_adr     : Address;
      LDQ       : Integer;
      INDXQ_adr : Address;
      RHO       : in out Real;
      CUTPNT    : Integer;
      WORK_adr  : Address;
      IWORK_adr : Address;
      INFO      : in out Integer)
   is

      D     : Ftn_Real_Vector (1 .. N);
      Q     : Ftn_Real_Matrix (1 .. LDQ, 1 .. N);
      INDXQ : Ftn_Integer_Vector (1 .. N);
      WORK  : Ftn_Real_Vector (1 .. 4 * N + N * N);
      IWORK : Ftn_Integer_Vector (1 .. 4 * N);

      for D'Address use D_adr;
      for Q'Address use Q_adr;
      for INDXQ'Address use INDXQ_adr;
      for WORK'Address use WORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Q);
      pragma Import (Ada, INDXQ);
      pragma Import (Ada, WORK);
      pragma Import (Ada, IWORK);

      COLTYP : Integer;
      I      : Integer;
      IDLMDA : Integer;
      INDX   : Integer;
      INDXC  : Integer;
      INDXP  : Integer;
      IQ2    : Integer;
      Ftn_IS : Integer;
      IW     : Integer;
      IZ     : Integer;
      K      : Integer;
      N1     : Integer;
      N2     : Integer;
      ZPP1   : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED1( N, D, Q, LDQ, INDXQ, RHO, CUTPNT, WORK, IWORK,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            CUTPNT, INFO, LDQ, N
   --       DOUBLE PRECISION   RHO
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            INDXQ( * ), IWORK( * )
   --       DOUBLE PRECISION   D( * ), Q( LDQ, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAED1 computes the updated eigensystem of a diagonal
   --  matrix after modification by a rank-one symmetric matrix.  This
   --  routine is used only for the eigenproblem which requires all
   --  eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
   --  the case in which eigenvalues only or eigenvalues and eigenvectors
   --  of a full symmetric matrix (which was reduced to tridiagonal form)
   --  are desired.
   --
   --    T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
   --
   --     where Z = Q**T*u, u is a vector of length N with ones in the
   --     CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
   --
   --     The eigenvectors of the original matrix are stored in Q, and the
   --     eigenvalues are in D.  The algorithm consists of three stages:
   --
   --        The first stage consists of deflating the size of the problem
   --        when there are multiple eigenvalues or if there is a zero in
   --        the Z vector.  For each such occurence the dimension of the
   --        secular equation problem is reduced by one.  This stage is
   --        performed by the routine DLAED2.
   --
   --        The second stage consists of calculating the updated
   --        eigenvalues. This is done by finding the roots of the secular
   --        equation via the routine DLAED4 (as called by DLAED3).
   --        This routine also calculates the eigenvectors of the current
   --        problem.
   --
   --        The final stage consists of computing the updated eigenvectors
   --        directly using the updated eigenvalues.  The eigenvectors for
   --        the current problem are multiplied with the eigenvectors from
   --        the overall problem.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry, the eigenvalues of the rank-1-perturbed matrix.
   --          On exit, the eigenvalues of the repaired matrix.
   --
   --  [in,out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ,N)
   --          On entry, the eigenvectors of the rank-1-perturbed matrix.
   --          On exit, the eigenvectors of the repaired tridiagonal matrix.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [in,out] INDXQ
   --           INDXQ is INTEGER array, dimension (N)
   --          On entry, the permutation which separately sorts the two
   --          subproblems in D into ascending order.
   --          On exit, the permutation which will reintegrate the
   --          subproblems back into sorted order,
   --          i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --          The subdiagonal entry used to create the rank-1 modification.
   --
   --  [in] CUTPNT
   --           CUTPNT is INTEGER
   --          The location of the last eigenvalue in the leading sub-matrix.
   --          min(1,N) <= CUTPNT <= N/2.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (4*N + N**2)
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (4*N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, an eigenvalue did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA \n
   --   Modified by Francoise Tisseur, University of Tennessee
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLAED2, DLAED3, DLAMRG, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if N < 0 then
         INFO := -1;
      elsif LDQ < max (1, N) then
         INFO := -4;
      elsif min (1, N / 2) > CUTPNT or (N / 2) < CUTPNT then
         INFO := -7;
      end if;
      if INFO /= 0 then
         XERBLA ("DLAED1", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     The following values are integer pointers which indicate
      --     the portion of the workspace
      --     used by a particular array in DLAED2 and DLAED3.
      --
      IZ     := 1;
      IDLMDA := IZ + N;
      IW     := IDLMDA + N;
      IQ2    := IW + N;
      --
      INDX   := 1;
      INDXC  := INDX + N;
      COLTYP := INDXC + N;
      INDXP  := COLTYP + N;
      --
      --
      --     Form the z-vector which consists of the last row of Q_1 and the
      --     first row of Q_2.
      --
      DCOPY (CUTPNT, Q (CUTPNT, 1)'Address, LDQ, WORK (IZ)'Address, 1);
      ZPP1 := CUTPNT + 1;
      DCOPY (N - CUTPNT, Q (ZPP1, ZPP1)'Address, LDQ, WORK (IZ + CUTPNT)'Address, 1);
      --
      --     Deflate eigenvalues.
      --
      DLAED2
        (K,
         N,
         CUTPNT,
         D'Address,
         Q'Address,
         LDQ,
         INDXQ'Address,
         RHO,
         WORK (IZ)'Address,
         WORK (IDLMDA)'Address,
         WORK (IW)'Address,
         WORK (IQ2)'Address,
         IWORK (INDX)'Address,
         IWORK (INDXC)'Address,
         IWORK (INDXP)'Address,
         IWORK (COLTYP)'Address,
         INFO);
      --
      if INFO /= 0 then
         goto L20;
      end if;
      --
      --     Solve Secular Equation.
      --
      if K /= 0 then
         Ftn_IS := (IWORK (COLTYP) + IWORK (COLTYP + 1)) * CUTPNT +
                   (IWORK (COLTYP + 1) + IWORK (COLTYP + 2)) * (N - CUTPNT) +
                   IQ2;
         DLAED3
           (K,
            N,
            CUTPNT,
            D'Address,
            Q'Address,
            LDQ,
            RHO,
            WORK (IDLMDA)'Address,
            WORK (IQ2)'Address,
            IWORK (INDXC)'Address,
            IWORK (COLTYP)'Address,
            WORK (IW)'Address,
            WORK (Ftn_IS)'Address,
            INFO);
         if INFO /= 0 then
            goto L20;
         end if;
         --
         --     Prepare the INDXQ sorting permutation.
         --
         N1 := K;
         N2 := N - K;
         DLAMRG (N1, N2, D'Address, 1, -1, INDXQ'Address);
      else
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            INDXQ (I) := I;
         end loop;
      end if;
      --
      <<L20>> null;
      return;
      --
      --     End of DLAED1
      --
   end DLAED1;

   procedure DLAED2
     (K          : in out Integer;
      N          : Integer;
      N1         : Integer;
      D_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      INDXQ_adr  : Address;
      RHO        : in out Real;
      Z_adr      : Address;
      DLAMDA_adr : Address;
      W_adr      : Address;
      Q2_adr     : Address;
      INDX_adr   : Address;
      INDXC_adr  : Address;
      INDXP_adr  : Address;
      COLTYP_adr : Address;
      INFO       : in out Integer)
   is

      D      : Ftn_Real_Vector (1 .. N);
      Q      : Ftn_Real_Matrix (1 .. LDQ, 1 .. N);
      INDXQ  : Ftn_Integer_Vector (1 .. N);
      Z      : Ftn_Real_Vector (1 .. N);
      DLAMDA : Ftn_Real_Vector (1 .. N);
      W      : Ftn_Real_Vector (1 .. N);
      Q2     : Ftn_Real_Vector (1 .. N1 * N1 + (N - N1) * (N - N1));
      INDX   : Ftn_Integer_Vector (1 .. N);
      INDXC  : Ftn_Integer_Vector (1 .. N);
      INDXP  : Ftn_Integer_Vector (1 .. N);
      COLTYP : Ftn_Integer_Vector (1 .. N);

      for D'Address use D_adr;
      for Q'Address use Q_adr;
      for INDXQ'Address use INDXQ_adr;
      for Z'Address use Z_adr;
      for DLAMDA'Address use DLAMDA_adr;
      for W'Address use W_adr;
      for Q2'Address use Q2_adr;
      for INDX'Address use INDX_adr;
      for INDXC'Address use INDXC_adr;
      for INDXP'Address use INDXP_adr;
      for COLTYP'Address use COLTYP_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Q);
      pragma Import (Ada, INDXQ);
      pragma Import (Ada, Z);
      pragma Import (Ada, DLAMDA);
      pragma Import (Ada, W);
      pragma Import (Ada, Q2);
      pragma Import (Ada, INDX);
      pragma Import (Ada, INDXC);
      pragma Import (Ada, INDXP);
      pragma Import (Ada, COLTYP);

      MONE  : constant Real := -1.0e0;
      ZERO  : constant Real := 0.0e0;
      ONE   : constant Real := 1.0e0;
      TWO   : constant Real := 2.0e0;
      EIGHT : constant Real := 8.0e0;
      CTOT  : Ftn_Integer_Vector (1 .. 4);
      PSM   : Ftn_Integer_Vector (1 .. 4);
      CT    : Integer;
      I     : Integer;
      IMAX  : Integer;
      IQ1   : Integer;
      IQ2   : Integer;
      J     : Integer;
      JMAX  : Integer;
      JS    : Integer;
      K2    : Integer;
      N1P1  : Integer;
      N2    : Integer;
      NJ    : Integer;
      PJ    : Integer;
      C     : Real;
      EPS   : Real;
      S     : Real;
      T     : Real;
      TAU   : Real;
      TOL   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED2( K, N, N1, D, Q, LDQ, INDXQ, RHO, Z, DLAMDA, W,
   --                          Q2, INDX, INDXC, INDXP, COLTYP, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDQ, N, N1
   --       DOUBLE PRECISION   RHO
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            COLTYP( * ), INDX( * ), INDXC( * ), INDXP( * ),
   --      $                   INDXQ( * )
   --       DOUBLE PRECISION   D( * ), DLAMDA( * ), Q( LDQ, * ), Q2( * ),
   --      $                   W( * ), Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAED2 merges the two sets of eigenvalues together into a single
   --  sorted set.  Then it tries to deflate the size of the problem.
   --  There are two ways in which deflation can occur:  when two or more
   --  eigenvalues are close together or if there is a tiny entry in the
   --  Z vector.  For each such occurrence the order of the related secular
   --  equation problem is reduced by one.
   --
   --  Arguments:
   --  ==========
   --
   --  [out] K
   --           K is INTEGER
   --          The number of non-deflated eigenvalues, and the order of the
   --          related secular equation. 0 <= K <=N.
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in] N1
   --           N1 is INTEGER
   --          The location of the last eigenvalue in the leading sub-matrix.
   --          min(1,N) <= N1 <= N/2.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry, D contains the eigenvalues of the two submatrices to
   --          be combined.
   --          On exit, D contains the trailing (N-K) updated eigenvalues
   --          (those which were deflated) sorted into increasing order.
   --
   --  [in,out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ, N)
   --          On entry, Q contains the eigenvectors of two submatrices in
   --          the two square blocks with corners at (1,1), (N1,N1)
   --          and (N1+1, N1+1), (N,N).
   --          On exit, Q contains the trailing (N-K) updated eigenvectors
   --          (those which were deflated) in its last N-K columns.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [in,out] INDXQ
   --           INDXQ is INTEGER array, dimension (N)
   --          The permutation which separately sorts the two sub-problems
   --          in D into ascending order.  Note that elements in the second
   --          half of this permutation must first have N1 added to their
   --          values. Destroyed on exit.
   --
   --  [in,out] RHO
   --           RHO is DOUBLE PRECISION
   --          On entry, the off-diagonal element associated with the rank-1
   --          cut which originally split the two submatrices which are now
   --          being recombined.
   --          On exit, RHO has been modified to the value required by
   --          DLAED3.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension (N)
   --          On entry, Z contains the updating vector (the last
   --          row of the first sub-eigenvector matrix and the first row of
   --          the second sub-eigenvector matrix).
   --          On exit, the contents of Z have been destroyed by the updating
   --          process.
   --
   --  [out] DLAMDA
   --           DLAMDA is DOUBLE PRECISION array, dimension (N)
   --          A copy of the first K eigenvalues which will be used by
   --          DLAED3 to form the secular equation.
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (N)
   --          The first k values of the final deflation-altered z-vector
   --          which will be passed to DLAED3.
   --
   --  [out] Q2
   --           Q2 is DOUBLE PRECISION array, dimension (N1**2+(N-N1)**2)
   --          A copy of the first K eigenvectors which will be used by
   --          DLAED3 in a matrix multiply (DGEMM) to solve for the new
   --          eigenvectors.
   --
   --  [out] INDX
   --           INDX is INTEGER array, dimension (N)
   --          The permutation used to sort the contents of DLAMDA into
   --          ascending order.
   --
   --  [out] INDXC
   --           INDXC is INTEGER array, dimension (N)
   --          The permutation used to arrange the columns of the deflated
   --          Q matrix into three groups:  the first group contains non-zero
   --          elements only at and above N1, the second contains
   --          non-zero elements only below N1, and the third is dense.
   --
   --  [out] INDXP
   --           INDXP is INTEGER array, dimension (N)
   --          The permutation used to place deflated values of D at the end
   --          of the array.  INDXP(1:K) points to the nondeflated D-values
   --          and INDXP(K+1:N) points to the deflated eigenvalues.
   --
   --  [out] COLTYP
   --           COLTYP is INTEGER array, dimension (N)
   --          During execution, a label which will indicate which of the
   --          following types a column in the Q2 matrix is:
   --          1 : non-zero in the upper half only;
   --          2 : dense;
   --          3 : non-zero in the lower half only;
   --          4 : deflated.
   --          On exit, COLTYP(i) is the number of columns of type i,
   --          for i=1 to 4 only.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA \n
   --   Modified by Francoise Tisseur, University of Tennessee
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( MONE = -1.0D0, ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, EIGHT = 8.0D0 )
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           IDAMAX, DLAMCH, DLAPY2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLACPY, DLAMRG, DROT, DSCAL, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if N < 0 then
         INFO := -2;
      elsif LDQ < max (1, N) then
         INFO := -6;
      elsif min (1, (N / 2)) > N1 or (N / 2) < N1 then
         INFO := -3;
      end if;
      if INFO /= 0 then
         XERBLA ("DLAED2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      N2   := N - N1;
      N1P1 := N1 + 1;
      --
      if RHO < ZERO then
         DSCAL (N2, MONE, Z (N1P1)'Address, 1);
      end if;
      --
      --     Normalize z so that norm(z) = 1.  Since z is the concatenation of
      --     two normalized vectors, norm2(z) = sqrt(2).
      --
      T := ONE / Sqrt (TWO);
      DSCAL (N, T, Z'Address, 1);
      --
      --     RHO = ABS( norm(z)**2 * RHO )
      --
      RHO := abs (TWO * RHO);
      --
      --     Sort the eigenvalues into increasing order
      --
      I := N1P1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         INDXQ (I) := INDXQ (I) + N1;
      end loop;
      --
      --     re-integrate the deflated parts from the last pass
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         DLAMDA (I) := D (INDXQ (I));
      end loop;
      DLAMRG (N1, N2, DLAMDA'Address, 1, 1, INDXC'Address);
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         INDX (I) := INDXQ (INDXC (I));
      end loop;
      --
      --     Calculate the allowable deflation tolerance
      --
      IMAX := IDAMAX (N, Z'Address, 1);
      JMAX := IDAMAX (N, D'Address, 1);
      EPS  := DLAMCH ('E');
      TOL  := EIGHT * EPS * max (abs (D (JMAX)), abs (Z (IMAX)));
      --
      --     If the rank-1 modifier is small enough, no more needs to be done
      --     except to reorganize Q so that its columns correspond with the
      --     elements in D.
      --
      if RHO * abs (Z (IMAX)) <= TOL then
         K   := 0;
         IQ2 := 1;
         J   := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := INDX (J);
            DCOPY (N, Q (1, I)'Address, 1, Q2 (IQ2)'Address, 1);
            DLAMDA (J) := D (I);
            IQ2        := IQ2 + N;
         end loop;
         DLACPY ('A', N, N, Q2'Address, N, Q'Address, LDQ);
         DCOPY (N, DLAMDA'Address, 1, D'Address, 1);
         goto L190;
      end if;
      --
      --     If there are multiple eigenvalues then the problem deflates.  Here
      --     the number of equal eigenvalues are found.  As each equal
      --     eigenvalue is found, an elementary reflector is computed to rotate
      --     the corresponding eigensubspace so that the corresponding
      --     components of Z are zero in this new basis.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N1;
         COLTYP (I) := 1;
      end loop;
      I := N1P1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         COLTYP (I) := 3;
      end loop;
      --
      --
      K  := 0;
      K2 := N + 1;
      J  := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         NJ := INDX (J);
         if RHO * abs (Z (NJ)) <= TOL then
            --
            --           Deflate due to small z component.
            --
            K2          := K2 - 1;
            COLTYP (NJ) := 4;
            INDXP (K2)  := NJ;
            if J = N then
               goto L100;
            end if;
         else
            PJ := NJ;
            goto L80;
         end if;
      end loop;
      <<L80>> null;
      J  := J + 1;
      NJ := INDX (J);
      if J > N then
         goto L100;
      end if;
      if RHO * abs (Z (NJ)) <= TOL then
         --
         --        Deflate due to small z component.
         --
         K2          := K2 - 1;
         COLTYP (NJ) := 4;
         INDXP (K2)  := NJ;
      else
         --
         --        Check if eigenvalues are close enough to allow deflation.
         --
         S := Z (PJ);
         C := Z (NJ);
         --
         --        Find sqrt(a**2+b**2) without overflow or
         --        destructive underflow.
         --
         TAU := DLAPY2 (C, S);
         T   := D (NJ) - D (PJ);
         C   := C / TAU;
         S   := -S / TAU;
         if abs (T * C * S) <= TOL then
            --
            --           Deflation is possible.
            --
            Z (NJ) := TAU;
            Z (PJ) := ZERO;
            if COLTYP (NJ) /= COLTYP (PJ) then
               COLTYP (NJ) := 2;
            end if;
            COLTYP (PJ) := 4;
            DROT (N, Q (1, PJ)'Address, 1, Q (1, NJ)'Address, 1, C, S);
            T      := D (PJ) * C ** 2 + D (NJ) * S ** 2;
            D (NJ) := D (PJ) * S ** 2 + D (NJ) * C ** 2;
            D (PJ) := T;
            K2     := K2 - 1;
            I      := 1;
            <<L90>> null;
            if K2 + I <= N then
               if D (PJ) < D (INDXP (K2 + I)) then
                  INDXP (K2 + I - 1) := INDXP (K2 + I);
                  INDXP (K2 + I)     := PJ;
                  I                  := I + 1;
                  goto L90;
               else
                  INDXP (K2 + I - 1) := PJ;
               end if;
            else
               INDXP (K2 + I - 1) := PJ;
            end if;
            PJ := NJ;
         else
            K          := K + 1;
            DLAMDA (K) := D (PJ);
            W (K)      := Z (PJ);
            INDXP (K)  := PJ;
            PJ         := NJ;
         end if;
      end if;
      goto L80;
      <<L100>> null;
      --
      --     Record the last eigenvalue.
      --
      K          := K + 1;
      DLAMDA (K) := D (PJ);
      W (K)      := Z (PJ);
      INDXP (K)  := PJ;
      --
      --     Count up the total number of the various types of columns, then
      --     form a permutation which positions the four column types into
      --     four uniform groups (although one or more of these groups may be
      --     empty).
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > 4;
         CTOT (J) := 0;
      end loop;
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         CT        := COLTYP (J);
         CTOT (CT) := CTOT (CT) + 1;
      end loop;
      --
      --     PSM(*) = Position in SubMatrix (of types 1 through 4)
      --
      PSM (1) := 1;
      PSM (2) := 1 + CTOT (1);
      PSM (3) := PSM (2) + CTOT (2);
      PSM (4) := PSM (3) + CTOT (3);
      K       := N - CTOT (4);
      --
      --     Fill out the INDXC array so that the permutation which it induces
      --     will place all type-1 columns first, all type-2 columns next,
      --     then all type-3's, and finally all type-4's.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         JS                := INDXP (J);
         CT                := COLTYP (JS);
         INDX (PSM (CT))   := JS;
         INDXC (PSM (CT))  := J;
         PSM (CT)          := PSM (CT) + 1;
      end loop;
      --
      --     Sort the eigenvalues and corresponding eigenvectors into DLAMDA
      --     and Q2 respectively.  The eigenvalues/vectors which were not
      --     deflated go into the first K slots of DLAMDA and Q2 respectively,
      --     while those which were deflated go into the last N - K slots.
      --
      I   := 1;
      IQ1 := 1;
      IQ2 := 1 + (CTOT (1) + CTOT (2)) * N1;
      J   := 1 - 1;
      loop
         J := J + 1;
         exit when J > CTOT (1);
         JS := INDX (I);
         DCOPY (N1, Q (1, JS)'Address, 1, Q2 (IQ1)'Address, 1);
         Z (I) := D (JS);
         I     := I + 1;
         IQ1   := IQ1 + N1;
      end loop;
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > CTOT (2);
         JS := INDX (I);
         DCOPY (N1, Q (1, JS)'Address, 1, Q2 (IQ1)'Address, 1);
         DCOPY (N2, Q (N1 + 1, JS)'Address, 1, Q2 (IQ2)'Address, 1);
         Z (I) := D (JS);
         I     := I + 1;
         IQ1   := IQ1 + N1;
         IQ2   := IQ2 + N2;
      end loop;
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > CTOT (3);
         JS := INDX (I);
         DCOPY (N2, Q (N1 + 1, JS)'Address, 1, Q2 (IQ2)'Address, 1);
         Z (I) := D (JS);
         I     := I + 1;
         IQ2   := IQ2 + N2;
      end loop;
      --
      IQ1 := IQ2;
      J   := 1 - 1;
      loop
         J := J + 1;
         exit when J > CTOT (4);
         JS := INDX (I);
         DCOPY (N, Q (1, JS)'Address, 1, Q2 (IQ2)'Address, 1);
         IQ2   := IQ2 + N;
         Z (I) := D (JS);
         I     := I + 1;
      end loop;
      --
      --     The deflated eigenvalues and their corresponding vectors go back
      --     into the last N - K slots of D and Q respectively.
      --
      if K < N then
         DLACPY ('A', N, CTOT (4), Q2 (IQ1)'Address, N, Q (1, K + 1)'Address, LDQ);
         DCOPY (N - K, Z (K + 1)'Address, 1, D (K + 1)'Address, 1);
      end if;
      --
      --     Copy CTOT into COLTYP for referencing in DLAED3.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > 4;
         COLTYP (J) := CTOT (J);
      end loop;
      --
      <<L190>> null;
      return;
      --
      --     End of DLAED2
      --
   end DLAED2;

   procedure DLAED3
     (K          : Integer;
      N          : Integer;
      N1         : Integer;
      D_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      RHO        : Real;
      DLAMDA_adr : Address;
      Q2_adr     : Address;
      INDX_adr   : Address;
      CTOT_adr   : Address;
      W_adr      : Address;
      S_adr      : Address;
      INFO       : in out Integer)
   is

      D      : Ftn_Real_Vector (1 .. N);
      Q      : Ftn_Real_Matrix (1 .. LDQ, 1 .. N);
      DLAMDA : Ftn_Real_Vector (1 .. K);
      Q2     : Ftn_Real_Vector (1 .. 4 * N + N * N); -- LCB: see documentation below
      INDX   : Ftn_Integer_Vector (1 .. N);
      CTOT   : Ftn_Integer_Vector (1 .. 4);
      W      : Ftn_Real_Vector (1 .. K);
      S      : Ftn_Real_Vector (1 .. (N1 + 1) * K);

      for D'Address use D_adr;
      for Q'Address use Q_adr;
      for DLAMDA'Address use DLAMDA_adr;
      for Q2'Address use Q2_adr;
      for INDX'Address use INDX_adr;
      for CTOT'Address use CTOT_adr;
      for W'Address use W_adr;
      for S'Address use S_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Q);
      pragma Import (Ada, DLAMDA);
      pragma Import (Ada, Q2);
      pragma Import (Ada, INDX);
      pragma Import (Ada, CTOT);
      pragma Import (Ada, W);
      pragma Import (Ada, S);

      ONE  : constant Real := 1.0e0;
      ZERO : constant Real := 0.0e0;
      I    : Integer;
      II   : Integer;
      IQ2  : Integer;
      J    : Integer;
      N12  : Integer;
      N2   : Integer;
      N23  : Integer;
      TEMP : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED3( K, N, N1, D, Q, LDQ, RHO, DLAMDA, Q2, INDX,
   --                          CTOT, W, S, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDQ, N, N1
   --       DOUBLE PRECISION   RHO
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            CTOT( * ), INDX( * )
   --       DOUBLE PRECISION   D( * ), DLAMDA( * ), Q( LDQ, * ), Q2( * ),
   --      $                   S( * ), W( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAED3 finds the roots of the secular equation, as defined by the
   --  values in D, W, and RHO, between 1 and K.  It makes the
   --  appropriate calls to DLAED4 and then updates the eigenvectors by
   --  multiplying the matrix of eigenvectors of the pair of eigensystems
   --  being combined by the matrix of eigenvectors of the K-by-K system
   --  which is solved here.
   --
   --  This code makes very mild assumptions about floating point
   --  arithmetic. It will work on machines with a guard digit in
   --  add/subtract, or on those binary machines without guard digits
   --  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
   --  It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] K
   --           K is INTEGER
   --           The number of terms in the rational function to be solved by
   --           DLAED4.  K >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of rows and columns in the Q matrix.
   --           N >= K (deflation may result in N>K).
   --
   --  [in] N1
   --           N1 is INTEGER
   --           The location of the last eigenvalue in the leading submatrix.
   --           min(1,N) <= N1 <= N/2.
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           D(I) contains the updated eigenvalues for
   --           1 <= I <= K.
   --
   --  [out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ,N)
   --           Initially the first K columns are used as workspace.
   --           On output the columns 1 to K contain
   --           the updated eigenvectors.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --           The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --           The value of the parameter in the rank one update equation.
   --           RHO >= 0 required.
   --
   --  [in,out] DLAMDA
   --           DLAMDA is DOUBLE PRECISION array, dimension (K)
   --           The first K elements of this array contain the old roots
   --           of the deflated updating problem.  These are the poles
   --           of the secular equation. May be changed on output by
   --           having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
   --           Cray-2, or Cray C-90, as described above.
   --
   --  [in] Q2
   --           Q2 is DOUBLE PRECISION array, dimension (LDQ2, N)
   --              LCB: this appears to be wrong. Q2 is only used as a vector
   --              LCB: dlaed3 seems only to be called by dlaed1 and as
   --              LCB: that routine passes WORK to Q2 I will declare
   --              LCB: Q2 here to be the same length as WORK
   --           The first K columns of this matrix contain the non-deflated
   --           eigenvectors for the split problem.
   --
   --  [in] INDX
   --           INDX is INTEGER array, dimension (N)
   --           The permutation used to arrange the columns of the deflated
   --           Q matrix into three groups (see DLAED2).
   --           The rows of the eigenvectors found by DLAED4 must be likewise
   --           permuted before the matrix multiply can take place.
   --
   --  [in] CTOT
   --           CTOT is INTEGER array, dimension (4)
   --           A count of the total number of the various types of columns
   --           in Q, as described in INDX.  The fourth column type is any
   --           column which has been deflated.
   --
   --  [in,out] W
   --           W is DOUBLE PRECISION array, dimension (K)
   --           The first K elements of this array contain the components
   --           of the deflation-adjusted updating vector. Destroyed on
   --           output.
   --
   --  [out] S
   --           S is DOUBLE PRECISION array, dimension (N1 + 1)*K
   --           Will contain the eigenvectors of the repaired matrix which
   --           will be multiplied by the previously accumulated eigenvectors
   --           to update the system.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, an eigenvalue did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA \n
   --   Modified by Francoise Tisseur, University of Tennessee
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D0, ZERO = 0.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMC3, DNRM2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DGEMM, DLACPY, DLAED4, DLASET, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if K < 0 then
         INFO := -1;
      elsif N < K then
         INFO := -2;
      elsif LDQ < max (1, N) then
         INFO := -6;
      end if;
      if INFO /= 0 then
         XERBLA ("DLAED3", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if K = 0 then
         return;
      end if;
      --
      --     Modify values DLAMDA(i) to make sure all DLAMDA(i)-DLAMDA(j) can
      --     be computed with high relative accuracy (barring over/underflow).
      --     This is a problem on machines without a guard digit in
      --     add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
      --     The following code replaces DLAMDA(I) by 2*DLAMDA(I)-DLAMDA(I),
      --     which on any of these machines zeros out the bottommost
      --     bit of DLAMDA(I) if it is 1; this makes the subsequent
      --     subtractions DLAMDA(I)-DLAMDA(J) unproblematic when cancellation
      --     occurs. On binary machines with a guard digit (almost all
      --     machines) it does not change DLAMDA(I) at all. On hexadecimal
      --     and decimal machines with a guard digit, it slightly
      --     changes the bottommost bits of DLAMDA(I). It does not account
      --     for hexadecimal or decimal machines without guard digits
      --     (we know of none). We use a subroutine call to compute
      --     2*DLAMBDA(I) to prevent optimizing compilers from eliminating
      --     this code.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         DLAMDA (I) := DLAMC3 (DLAMDA (I), DLAMDA (I)) - DLAMDA (I);
      end loop;
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > K;
         DLAED4 (K, J, DLAMDA'Address, W'Address, Q (1, J)'Address, RHO, D (J), INFO);
         --
         --        If the zero finder fails, the computation is terminated.
         --
         if INFO /= 0 then
            goto L120;
         end if;
      end loop;
      --
      if K = 1 then
         goto L110;
      end if;
      if K = 2 then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > K;
            W (1)    := Q (1, J);
            W (2)    := Q (2, J);
            II       := INDX (1);
            Q (1, J) := W (II);
            II       := INDX (2);
            Q (2, J) := W (II);
         end loop;
         goto L110;
      end if;
      --
      --     Compute updated W.
      --
      DCOPY (K, W'Address, 1, S'Address, 1);
      --
      --     Initialize W(I) = Q(I,I)
      --
      DCOPY (K, Q'Address, LDQ + 1, W'Address, 1);
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > K;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > J - 1;
            W (I) := W (I) * (Q (I, J) / (DLAMDA (I) - DLAMDA (J)));
         end loop;
         I := J + 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            W (I) := W (I) * (Q (I, J) / (DLAMDA (I) - DLAMDA (J)));
         end loop;
      end loop;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         W (I) := sign (Sqrt (-W (I)), S (I));
      end loop;
      --
      --     Compute eigenvectors of the modified rank-1 modification.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > K;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            S (I) := W (I) / Q (I, J);
         end loop;
         TEMP := DNRM2 (K, S'Address, 1);
         I    := 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            II       := INDX (I);
            Q (I, J) := S (II) / TEMP;
         end loop;
      end loop;
      --
      --     Compute the updated eigenvectors.
      --
      <<L110>> null;
      --
      N2  := N - N1;
      N12 := CTOT (1) + CTOT (2);
      N23 := CTOT (2) + CTOT (3);
      --
      DLACPY ('A', N23, K, Q (CTOT (1) + 1, 1)'Address, LDQ, S'Address, N23);
      IQ2 := N1 * N12 + 1;
      if N23 /= 0 
         then DGEMM ('N', 'N', N2, K, N23, ONE, Q2 (IQ2)'Address, N2, S'Address, N23, ZERO, Q (N1 + 1, 1)'Address, LDQ);
         else DLASET ('A', N2, K, ZERO, ZERO, Q (N1 + 1, 1)'Address, LDQ);
      end if;
      --
      DLACPY ('A', N12, K, Q'Address, LDQ, S'Address, N12);
      if N12 /= 0 
         then DGEMM ('N', 'N', N1, K, N12, ONE, Q2'Address, N1, S'Address, N12, ZERO, Q'Address, LDQ);
         else DLASET ('A', N1, K, ZERO, ZERO, Q (1, 1)'Address, LDQ);
      end if;
      --
      --
      <<L120>> null;
      return;
      --
      --     End of DLAED3
      --
   end DLAED3;

   procedure DLAED4
     (N             : Integer;
      I             : Integer;
      D_adr         : Address;
      Z_adr         : Address;
      Ftn_DELTA_adr : Address;
      RHO           : Real;
      DLAM          : in out Real;
      INFO          : in out Integer)
   is

      D         : Ftn_Real_Vector (1 .. N);
      Z         : Ftn_Real_Vector (1 .. N);
      Ftn_DELTA : Ftn_Real_Vector (1 .. N);

      for D'Address use D_adr;
      for Z'Address use Z_adr;
      for Ftn_DELTA'Address use Ftn_DELTA_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Z);
      pragma Import (Ada, Ftn_DELTA);

      MAXIT  : constant Integer := 30;
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      TWO    : constant Real    := 2.0e0;
      THREE  : constant Real    := 3.0e0;
      FOUR   : constant Real    := 4.0e0;
      EIGHT  : constant Real    := 8.0e0;
      TEN    : constant Real    := 10.0;
      ORGATI : Boolean;
      SWTCH  : Boolean;
      SWTCH3 : Boolean;
      II     : Integer;
      IIM1   : Integer;
      IIP1   : Integer;
      IP1    : Integer;
      ITER   : Integer;
      J      : Integer;
      NITER  : Integer;
      A      : Real;
      B      : Real;
      C      : Real;
      DEL    : Real;
      DLTLB  : Real;
      DLTUB  : Real;
      DPHI   : Real;
      DPSI   : Real;
      DW     : Real;
      EPS    : Real;
      ERRETM : Real;
      ETA    : Real;
      MIDPT  : Real;
      PHI    : Real;
      PREW   : Real;
      PSI    : Real;
      RHOINV : Real;
      TAU    : Real;
      TEMP   : Real;
      TEMP1  : Real;
      W      : Real;
      ZZ     : Ftn_Real_Vector (1 .. 3);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED4( N, I, D, Z, DELTA, RHO, DLAM, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            I, INFO, N
   --       DOUBLE PRECISION   DLAM, RHO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), DELTA( * ), Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  This subroutine computes the I-th updated eigenvalue of a symmetric
   --  rank-one modification to a diagonal matrix whose elements are
   --  given in the array d, and that
   --
   --             D(i) < D(j)  for  i < j
   --
   --  and that RHO > 0.  This is arranged by the calling routine, and is
   --  no loss in generality.  The rank-one modified system is thus
   --
   --             diag( D )  +  RHO * Z * Z_transpose.
   --
   --  where we assume the Euclidean norm of Z is 1.
   --
   --  The method consists of approximating the rational functions in the
   --  secular equation by simpler interpolating rational functions.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --          The length of all arrays.
   --
   --  [in] I
   --           I is INTEGER
   --          The index of the eigenvalue to be computed.  1 <= I <= N.
   --
   --  [in] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          The original eigenvalues.  It is assumed that they are in
   --          order, D(I) < D(J)  for I < J.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension (N)
   --          The components of the updating vector.
   --
   --  [out] DELTA
   --           DELTA is DOUBLE PRECISION array, dimension (N)
   --          If N .GT. 2, DELTA contains (D(j) - lambda_I) in its  j-th
   --          component.  If N = 1, then DELTA(1) = 1. If N = 2, see DLAED5
   --          for detail. The vector DELTA contains the information necessary
   --          to construct the eigenvectors by DLAED3 and DLAED9.
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --          The scalar in the symmetric updating formula.
   --
   --  [out] DLAM
   --           DLAM is DOUBLE PRECISION
   --          The computed lambda_I, the I-th updated eigenvalue.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --          = 0:  successful exit
   --          > 0:  if INFO = 1, the updating process failed.
   --
   --  Internal Parameters:
   --  =========================
   --
   --   LOGICAL variable ORGATI (origin-at-i?) is used for distinguishing
   --   whether D(i) or D(i+1) is treated as the origin.
   --
   --             ORGATI = .true.    origin at i
   --             ORGATI = .false.   origin at i+1
   --
   --    LOGICAL variable SWTCH3 (switch-for-3-poles?) is for noting
   --    if we are working with THREE poles!
   --
   --    MAXIT is the maximum number of iterations allowed for each
   --    eigenvalue.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ren-Cang Li, Computer Science Division, University of California
   --      at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( MAXIT = 30 )
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, THREE = 3.0D0, FOUR = 4.0D0, EIGHT = 8.0D0, TEN =
   --10.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLAED5, DLAED6
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Since this routine is called in an inner loop, we do no argument
   --     checking.
   --
   --     Quick return for N=1 and 2.
   --
   begin
      INFO := 0;
      if N = 1 then
         --
         --         Presumably, I=1 upon entry
         --
         DLAM          := D (1) + RHO * Z (1) * Z (1);
         Ftn_DELTA (1) := ONE;
         return;
      end if;
      if N = 2 then
         DLAED5 (I, D'Address, Z'Address, Ftn_DELTA'Address, RHO, DLAM);
         return;
      end if;
      --
      --     Compute machine epsilon
      --
      EPS    := DLAMCH ('E');
      RHOINV := ONE / RHO;
      --
      --     The case I = N
      --
      if I = N then
         --
         --        Initialize some basic variables
         --
         II    := N - 1;
         NITER := 1;
         --
         --        Calculate initial guess
         --
         MIDPT := RHO / TWO;
         --
         --        If ||Z||_2 is not one, then TEMP should be set to
         --        RHO * ||Z||_2^2 / TWO
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            Ftn_DELTA (J) := (D (J) - D (I)) - MIDPT;
         end loop;
         --
         PSI := ZERO;
         J   := 1 - 1;
         loop
            J := J + 1;
            exit when J > N - 2;
            PSI := PSI + Z (J) * Z (J) / Ftn_DELTA (J);
         end loop;
         --
         C := RHOINV + PSI;
         W := C + Z (II) * Z (II) / Ftn_DELTA (II) + Z (N) * Z (N) / Ftn_DELTA (N);
         --
         if W <= ZERO then
            TEMP := Z (N - 1) * Z (N - 1) / (D (N) - D (N - 1) + RHO) + Z (N) * Z (N) / RHO;
            if C <= TEMP then
               TAU := RHO;
            else
               DEL := D (N) - D (N - 1);
               A   := -C * DEL + Z (N - 1) * Z (N - 1) + Z (N) * Z (N);
               B   := Z (N) * Z (N) * DEL;
               if A < ZERO 
                  then TAU := TWO * B / (Sqrt (A * A + FOUR * B * C) - A);
                  else TAU := (A + Sqrt (A * A + FOUR * B * C)) / (TWO * C);
               end if;
            end if;
            --
            --           It can be proved that
            --               D(N)+RHO/2 <= LAMBDA(N) < D(N)+TAU <= D(N)+RHO
            --
            DLTLB := MIDPT;
            DLTUB := RHO;
         else
            DEL := D (N) - D (N - 1);
            A   := -C * DEL + Z (N - 1) * Z (N - 1) + Z (N) * Z (N);
            B   := Z (N) * Z (N) * DEL;
            if A < ZERO 
               then TAU := TWO * B / (Sqrt (A * A + FOUR * B * C) - A);
               else TAU := (A + Sqrt (A * A + FOUR * B * C)) / (TWO * C);
            end if;
            --
            --           It can be proved that
            --               D(N) < D(N)+TAU < LAMBDA(N) < D(N)+RHO/2
            --
            DLTLB := ZERO;
            DLTUB := MIDPT;
         end if;
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            Ftn_DELTA (J) := (D (J) - D (I)) - TAU;
         end loop;
         --
         --        Evaluate PSI and the derivative DPSI
         --
         DPSI   := ZERO;
         PSI    := ZERO;
         ERRETM := ZERO;
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > II;
            TEMP   := Z (J) / Ftn_DELTA (J);
            PSI    := PSI + Z (J) * TEMP;
            DPSI   := DPSI + TEMP * TEMP;
            ERRETM := ERRETM + PSI;
         end loop;
         ERRETM := abs (ERRETM);
         --
         --        Evaluate PHI and the derivative DPHI
         --
         TEMP   := Z (N) / Ftn_DELTA (N);
         PHI    := Z (N) * TEMP;
         DPHI   := TEMP * TEMP;
         ERRETM := EIGHT * (-PHI - PSI) + ERRETM - PHI + RHOINV + abs (TAU) * (DPSI + DPHI);
         --
         W := RHOINV + PHI + PSI;
         --
         --        Test for convergence
         --
         if abs (W) <= EPS * ERRETM then
            DLAM := D (I) + TAU;
            goto L250;
         end if;
         --
         if W <= ZERO 
            then DLTLB := max (DLTLB, TAU);
            else DLTUB := min (DLTUB, TAU);
         end if;
         --
         --        Calculate the new step
         --
         NITER := NITER + 1;
         C     := W - Ftn_DELTA (N - 1) * DPSI - Ftn_DELTA (N) * DPHI;
         A     := (Ftn_DELTA (N - 1) + Ftn_DELTA (N)) * W - Ftn_DELTA (N - 1) * Ftn_DELTA (N) * (DPSI + DPHI);
         B     := Ftn_DELTA (N - 1) * Ftn_DELTA (N) * W;
         if C < ZERO then
            C := abs (C);
         end if;
         if C = ZERO then
            --          ETA = B/A
            --           ETA = RHO - TAU
            ETA := DLTUB - TAU;
         elsif A >= ZERO then
            ETA := (A + Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
         else
            ETA := TWO * B / (A - Sqrt (abs (A * A - FOUR * B * C)));
         end if;
         --
         --        Note, eta should be positive if w is negative, and
         --        eta should be negative otherwise. However,
         --        if for some reason caused by roundoff, eta*w > 0,
         --        we simply use one Newton step instead. This way
         --        will guarantee eta*w < 0.
         --
         if W * ETA > ZERO then
            ETA := -W / (DPSI + DPHI);
         end if;
         TEMP := TAU + ETA;
         if TEMP > DLTUB or TEMP < DLTLB then
            if W < ZERO 
               then ETA := (DLTUB - TAU) / TWO;
               else ETA := (DLTLB - TAU) / TWO;
            end if;
         end if;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            Ftn_DELTA (J) := Ftn_DELTA (J) - ETA;
         end loop;
         --
         TAU := TAU + ETA;
         --
         --        Evaluate PSI and the derivative DPSI
         --
         DPSI   := ZERO;
         PSI    := ZERO;
         ERRETM := ZERO;
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > II;
            TEMP   := Z (J) / Ftn_DELTA (J);
            PSI    := PSI + Z (J) * TEMP;
            DPSI   := DPSI + TEMP * TEMP;
            ERRETM := ERRETM + PSI;
         end loop;
         ERRETM := abs (ERRETM);
         --
         --        Evaluate PHI and the derivative DPHI
         --
         TEMP   := Z (N) / Ftn_DELTA (N);
         PHI    := Z (N) * TEMP;
         DPHI   := TEMP * TEMP;
         ERRETM := EIGHT * (-PHI - PSI) + ERRETM - PHI + RHOINV + abs (TAU) * (DPSI + DPHI);
         --
         W := RHOINV + PHI + PSI;
         --
         --        Main loop to update the values of the array   DELTA
         --
         ITER := NITER + 1;
         --
         NITER := ITER - 1;
         loop
            NITER := NITER + 1;
            exit when NITER > MAXIT;
            --
            --           Test for convergence
            --
            if abs (W) <= EPS * ERRETM then
               DLAM := D (I) + TAU;
               goto L250;
            end if;
            --
            if W <= ZERO 
               then DLTLB := max (DLTLB, TAU);
               else DLTUB := min (DLTUB, TAU);
            end if;
            --
            --           Calculate the new step
            --
            C := W - Ftn_DELTA (N - 1) * DPSI - Ftn_DELTA (N) * DPHI;
            A := (Ftn_DELTA (N - 1) + Ftn_DELTA (N)) * W - Ftn_DELTA (N - 1) * Ftn_DELTA (N) * (DPSI + DPHI);
            B := Ftn_DELTA (N - 1) * Ftn_DELTA (N) * W;
            if A >= ZERO 
               then ETA := (A + Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
               else ETA := TWO * B / (A - Sqrt (abs (A * A - FOUR * B * C)));
            end if;
            --
            --           Note, eta should be positive if w is negative, and
            --           eta should be negative otherwise. However,
            --           if for some reason caused by roundoff, eta*w > 0,
            --           we simply use one Newton step instead. This way
            --           will guarantee eta*w < 0.
            --
            if W * ETA > ZERO then
               ETA := -W / (DPSI + DPHI);
            end if;
            TEMP := TAU + ETA;
            if TEMP > DLTUB or TEMP < DLTLB then
               if W < ZERO 
                  then ETA := (DLTUB - TAU) / TWO;
                  else ETA := (DLTLB - TAU) / TWO;
               end if;
            end if;
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               Ftn_DELTA (J) := Ftn_DELTA (J) - ETA;
            end loop;
            --
            TAU := TAU + ETA;
            --
            --           Evaluate PSI and the derivative DPSI
            --
            DPSI   := ZERO;
            PSI    := ZERO;
            ERRETM := ZERO;
            J      := 1 - 1;
            loop
               J := J + 1;
               exit when J > II;
               TEMP   := Z (J) / Ftn_DELTA (J);
               PSI    := PSI + Z (J) * TEMP;
               DPSI   := DPSI + TEMP * TEMP;
               ERRETM := ERRETM + PSI;
            end loop;
            ERRETM := abs (ERRETM);
            --
            --           Evaluate PHI and the derivative DPHI
            --
            TEMP   := Z (N) / Ftn_DELTA (N);
            PHI    := Z (N) * TEMP;
            DPHI   := TEMP * TEMP;
            ERRETM := EIGHT * (-PHI - PSI) + ERRETM - PHI + RHOINV + abs (TAU) * (DPSI + DPHI);
            --
            W := RHOINV + PHI + PSI;
         end loop;
         --
         --        Return with INFO = 1, NITER = MAXIT and not converged
         --
         INFO := 1;
         DLAM := D (I) + TAU;
         goto L250;
      --
      --        End for the case I = N
      --
      else
         --
         --        The case for I < N
         --
         NITER := 1;
         IP1   := I + 1;
         --
         --        Calculate initial guess
         --
         DEL   := D (IP1) - D (I);
         MIDPT := DEL / TWO;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            Ftn_DELTA (J) := (D (J) - D (I)) - MIDPT;
         end loop;
         --
         PSI := ZERO;
         J   := 1 - 1;
         loop
            J := J + 1;
            exit when J > I - 1;
            PSI := PSI + Z (J) * Z (J) / Ftn_DELTA (J);
         end loop;
         --
         PHI := ZERO;
         J   := N + 1;
         loop
            J := J - 1;
            exit when J < I + 2;
            PHI := PHI + Z (J) * Z (J) / Ftn_DELTA (J);
         end loop;
         C := RHOINV + PSI + PHI;
         W := C + Z (I) * Z (I) / Ftn_DELTA (I) + Z (IP1) * Z (IP1) / Ftn_DELTA (IP1);
         --
         if W > ZERO then
            --
            --           d(i)< the ith eigenvalue < (d(i)+d(i+1))/2
            --
            --           We choose d(i) as origin.
            --
            ORGATI := True;
            A      := C * DEL + Z (I) * Z (I) + Z (IP1) * Z (IP1);
            B      := Z (I) * Z (I) * DEL;
            if A > ZERO 
               then TAU := TWO * B / (A + Sqrt (abs (A * A - FOUR * B * C)));
               else TAU := (A - Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
            end if;
            DLTLB := ZERO;
            DLTUB := MIDPT;
         else
            --
            --           (d(i)+d(i+1))/2 <= the ith eigenvalue < d(i+1)
            --
            --           We choose d(i+1) as origin.
            --
            ORGATI := False;
            A      := C * DEL - Z (I) * Z (I) - Z (IP1) * Z (IP1);
            B      := Z (IP1) * Z (IP1) * DEL;
            if A < ZERO 
               then TAU := TWO * B / (A - Sqrt (abs (A * A + FOUR * B * C)));
               else TAU := -(A + Sqrt (abs (A * A + FOUR * B * C))) / (TWO * C);
            end if;
            DLTLB := -MIDPT;
            DLTUB := ZERO;
         end if;
         --
         if ORGATI then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               Ftn_DELTA (J) := (D (J) - D (I)) - TAU;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               Ftn_DELTA (J) := (D (J) - D (IP1)) - TAU;
            end loop;
         end if;
         if ORGATI 
            then II := I;
            else II := I + 1;
         end if;
         IIM1 := II - 1;
         IIP1 := II + 1;
         --
         --        Evaluate PSI and the derivative DPSI
         --
         DPSI   := ZERO;
         PSI    := ZERO;
         ERRETM := ZERO;
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > IIM1;
            TEMP   := Z (J) / Ftn_DELTA (J);
            PSI    := PSI + Z (J) * TEMP;
            DPSI   := DPSI + TEMP * TEMP;
            ERRETM := ERRETM + PSI;
         end loop;
         ERRETM := abs (ERRETM);
         --
         --        Evaluate PHI and the derivative DPHI
         --
         DPHI := ZERO;
         PHI  := ZERO;
         J    := N + 1;
         loop
            J := J - 1;
            exit when J < IIP1;
            TEMP   := Z (J) / Ftn_DELTA (J);
            PHI    := PHI + Z (J) * TEMP;
            DPHI   := DPHI + TEMP * TEMP;
            ERRETM := ERRETM + PHI;
         end loop;
         --
         W := RHOINV + PHI + PSI;
         --
         --        W is the value of the secular function with
         --        its ii-th element removed.
         --
         SWTCH3 := False;
         if ORGATI then
            if W < ZERO then
               SWTCH3 := True;
            end if;
         else
            if W > ZERO then
               SWTCH3 := True;
            end if;
         end if;
         if II = 1 or II = N then
            SWTCH3 := False;
         end if;
         --
         TEMP   := Z (II) / Ftn_DELTA (II);
         DW     := DPSI + DPHI + TEMP * TEMP;
         TEMP   := Z (II) * TEMP;
         W      := W + TEMP;
         ERRETM := EIGHT * (PHI - PSI) + ERRETM + TWO * RHOINV + THREE * abs (TEMP) + abs (TAU) * DW;
         --
         --        Test for convergence
         --
         if abs (W) <= EPS * ERRETM then
            if ORGATI 
               then DLAM := D (I) + TAU;
               else DLAM := D (IP1) + TAU;
            end if;
            goto L250;
         end if;
         --
         if W <= ZERO 
            then DLTLB := max (DLTLB, TAU);
            else DLTUB := min (DLTUB, TAU);
         end if;
         --
         --        Calculate the new step
         --
         NITER := NITER + 1;
         if not SWTCH3 then
            if ORGATI 
               then C := W - Ftn_DELTA (IP1) * DW - (D (I) - D (IP1)) * (Z (I) / Ftn_DELTA (I)) ** 2;
               else C := W - Ftn_DELTA (I) * DW - (D (IP1) - D (I)) * (Z (IP1) / Ftn_DELTA (IP1)) ** 2;
            end if;
            A := (Ftn_DELTA (I) + Ftn_DELTA (IP1)) * W - Ftn_DELTA (I) * Ftn_DELTA (IP1) * DW;
            B := Ftn_DELTA (I) * Ftn_DELTA (IP1) * W;
            if C = ZERO then
               if A = ZERO then
                  if ORGATI 
                     then A := Z (I) * Z (I) + Ftn_DELTA (IP1) * Ftn_DELTA (IP1) * (DPSI + DPHI);
                     else A := Z (IP1) * Z (IP1) + Ftn_DELTA (I) * Ftn_DELTA (I) * (DPSI + DPHI);
                  end if;
               end if;
               ETA := B / A;
            elsif A <= ZERO then
               ETA := (A - Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
            else
               ETA := TWO * B / (A + Sqrt (abs (A * A - FOUR * B * C)));
            end if;
         else
            --
            --           Interpolation using THREE most relevant poles
            --
            TEMP := RHOINV + PSI + PHI;
            if ORGATI then
               TEMP1  := Z (IIM1) / Ftn_DELTA (IIM1);
               TEMP1  := TEMP1 * TEMP1;
               C      := TEMP - Ftn_DELTA (IIP1) * (DPSI + DPHI) - (D (IIM1) - D (IIP1)) * TEMP1;
               ZZ (1) := Z (IIM1) * Z (IIM1);
               ZZ (3) := Ftn_DELTA (IIP1) * Ftn_DELTA (IIP1) * ((DPSI - TEMP1) + DPHI);
            else
               TEMP1  := Z (IIP1) / Ftn_DELTA (IIP1);
               TEMP1  := TEMP1 * TEMP1;
               C      := TEMP - Ftn_DELTA (IIM1) * (DPSI + DPHI) - (D (IIP1) - D (IIM1)) * TEMP1;
               ZZ (1) := Ftn_DELTA (IIM1) * Ftn_DELTA (IIM1) * (DPSI + (DPHI - TEMP1));
               ZZ (3) := Z (IIP1) * Z (IIP1);
            end if;
            ZZ (2) := Z (II) * Z (II);
            DLAED6 (NITER, ORGATI, C, Ftn_DELTA (IIM1)'Address, ZZ'Address, W, ETA, INFO);
            if INFO /= 0 then
               goto L250;
            end if;
         end if;
         --
         --        Note, eta should be positive if w is negative, and
         --        eta should be negative otherwise. However,
         --        if for some reason caused by roundoff, eta*w > 0,
         --        we simply use one Newton step instead. This way
         --        will guarantee eta*w < 0.
         --
         if W * ETA >= ZERO then
            ETA := -W / DW;
         end if;
         TEMP := TAU + ETA;
         if TEMP > DLTUB or TEMP < DLTLB then
            if W < ZERO 
               then ETA := (DLTUB - TAU) / TWO;
               else ETA := (DLTLB - TAU) / TWO;
            end if;
         end if;
         --
         PREW := W;
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            Ftn_DELTA (J) := Ftn_DELTA (J) - ETA;
         end loop;
         --
         --        Evaluate PSI and the derivative DPSI
         --
         DPSI   := ZERO;
         PSI    := ZERO;
         ERRETM := ZERO;
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > IIM1;
            TEMP   := Z (J) / Ftn_DELTA (J);
            PSI    := PSI + Z (J) * TEMP;
            DPSI   := DPSI + TEMP * TEMP;
            ERRETM := ERRETM + PSI;
         end loop;
         ERRETM := abs (ERRETM);
         --
         --        Evaluate PHI and the derivative DPHI
         --
         DPHI := ZERO;
         PHI  := ZERO;
         J    := N + 1;
         loop
            J := J - 1;
            exit when J < IIP1;
            TEMP   := Z (J) / Ftn_DELTA (J);
            PHI    := PHI + Z (J) * TEMP;
            DPHI   := DPHI + TEMP * TEMP;
            ERRETM := ERRETM + PHI;
         end loop;
         --
         TEMP   := Z (II) / Ftn_DELTA (II);
         DW     := DPSI + DPHI + TEMP * TEMP;
         TEMP   := Z (II) * TEMP;
         W      := RHOINV + PHI + PSI + TEMP;
         ERRETM := EIGHT * (PHI - PSI) + ERRETM + TWO * RHOINV + THREE * abs (TEMP) + abs (TAU + ETA) * DW;
         --
         SWTCH := False;
         if ORGATI then
            if -W > abs (PREW) / TEN then
               SWTCH := True;
            end if;
         else
            if W > abs (PREW) / TEN then
               SWTCH := True;
            end if;
         end if;
         --
         TAU := TAU + ETA;
         --
         --        Main loop to update the values of the array   DELTA
         --
         ITER := NITER + 1;
         --
         NITER := ITER - 1;
         loop
            NITER := NITER + 1;
            exit when NITER > MAXIT;
            --
            --           Test for convergence
            --
            if abs (W) <= EPS * ERRETM then
               if ORGATI 
                  then DLAM := D (I) + TAU;
                  else DLAM := D (IP1) + TAU;
               end if;
               goto L250;
            end if;
            --
            if W <= ZERO 
               then DLTLB := max (DLTLB, TAU);
               else DLTUB := min (DLTUB, TAU);
            end if;
            --
            --           Calculate the new step
            --
            if not SWTCH3 then
               if not SWTCH then
                  if ORGATI 
                     then C := W - Ftn_DELTA (IP1) * DW - (D (I) - D (IP1)) * (Z (I) / Ftn_DELTA (I)) ** 2;
                     else C := W - Ftn_DELTA (I) * DW - (D (IP1) - D (I)) * (Z (IP1) / Ftn_DELTA (IP1)) ** 2;
                  end if;
               else
                  TEMP := Z (II) / Ftn_DELTA (II);
                  if ORGATI 
                     then DPSI := DPSI + TEMP * TEMP;
                     else DPHI := DPHI + TEMP * TEMP;
                  end if;
                  C := W - Ftn_DELTA (I) * DPSI - Ftn_DELTA (IP1) * DPHI;
               end if;
               A := (Ftn_DELTA (I) + Ftn_DELTA (IP1)) * W - Ftn_DELTA (I) * Ftn_DELTA (IP1) * DW;
               B := Ftn_DELTA (I) * Ftn_DELTA (IP1) * W;
               if C = ZERO then
                  if A = ZERO then
                     if not SWTCH then
                        if ORGATI 
                           then A := Z (I) * Z (I) + Ftn_DELTA (IP1) * Ftn_DELTA (IP1) * (DPSI + DPHI);
                           else A := Z (IP1) * Z (IP1) + Ftn_DELTA (I) * Ftn_DELTA (I) * (DPSI + DPHI);
                        end if;
                     else
                        A := Ftn_DELTA (I) * Ftn_DELTA (I) * DPSI + Ftn_DELTA (IP1) * Ftn_DELTA (IP1) * DPHI;
                     end if;
                  end if;
                  ETA := B / A;
               elsif A <= ZERO then
                  ETA := (A - Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
               else
                  ETA := TWO * B / (A + Sqrt (abs (A * A - FOUR * B * C)));
               end if;
            else
               --
               --              Interpolation using THREE most relevant poles
               --
               TEMP := RHOINV + PSI + PHI;
               if SWTCH then
                  C      := TEMP - Ftn_DELTA (IIM1) * DPSI - Ftn_DELTA (IIP1) * DPHI;
                  ZZ (1) := Ftn_DELTA (IIM1) * Ftn_DELTA (IIM1) * DPSI;
                  ZZ (3) := Ftn_DELTA (IIP1) * Ftn_DELTA (IIP1) * DPHI;
               else
                  if ORGATI then
                     TEMP1  := Z (IIM1) / Ftn_DELTA (IIM1);
                     TEMP1  := TEMP1 * TEMP1;
                     C      := TEMP - Ftn_DELTA (IIP1) * (DPSI + DPHI) - (D (IIM1) - D (IIP1)) * TEMP1;
                     ZZ (1) := Z (IIM1) * Z (IIM1);
                     ZZ (3) := Ftn_DELTA (IIP1) * Ftn_DELTA (IIP1) * ((DPSI - TEMP1) + DPHI);
                  else
                     TEMP1  := Z (IIP1) / Ftn_DELTA (IIP1);
                     TEMP1  := TEMP1 * TEMP1;
                     C      := TEMP - Ftn_DELTA (IIM1) * (DPSI + DPHI) - (D (IIP1) - D (IIM1)) * TEMP1;
                     ZZ (1) := Ftn_DELTA (IIM1) * Ftn_DELTA (IIM1) * (DPSI + (DPHI - TEMP1));
                     ZZ (3) := Z (IIP1) * Z (IIP1);
                  end if;
               end if;
               DLAED6 (NITER, ORGATI, C, Ftn_DELTA (IIM1)'Address, ZZ'Address, W, ETA, INFO);
               if INFO /= 0 then
                  goto L250;
               end if;
            end if;
            --
            --           Note, eta should be positive if w is negative, and
            --           eta should be negative otherwise. However,
            --           if for some reason caused by roundoff, eta*w > 0,
            --           we simply use one Newton step instead. This way
            --           will guarantee eta*w < 0.
            --
            if W * ETA >= ZERO then
               ETA := -W / DW;
            end if;
            TEMP := TAU + ETA;
            if TEMP > DLTUB or TEMP < DLTLB then
               if W < ZERO 
                  then ETA := (DLTUB - TAU) / TWO;
                  else ETA := (DLTLB - TAU) / TWO;
               end if;
            end if;
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               Ftn_DELTA (J) := Ftn_DELTA (J) - ETA;
            end loop;
            --
            TAU  := TAU + ETA;
            PREW := W;
            --
            --           Evaluate PSI and the derivative DPSI
            --
            DPSI   := ZERO;
            PSI    := ZERO;
            ERRETM := ZERO;
            J      := 1 - 1;
            loop
               J := J + 1;
               exit when J > IIM1;
               TEMP   := Z (J) / Ftn_DELTA (J);
               PSI    := PSI + Z (J) * TEMP;
               DPSI   := DPSI + TEMP * TEMP;
               ERRETM := ERRETM + PSI;
            end loop;
            ERRETM := abs (ERRETM);
            --
            --           Evaluate PHI and the derivative DPHI
            --
            DPHI := ZERO;
            PHI  := ZERO;
            J    := N + 1;
            loop
               J := J - 1;
               exit when J < IIP1;
               TEMP   := Z (J) / Ftn_DELTA (J);
               PHI    := PHI + Z (J) * TEMP;
               DPHI   := DPHI + TEMP * TEMP;
               ERRETM := ERRETM + PHI;
            end loop;
            --
            TEMP   := Z (II) / Ftn_DELTA (II);
            DW     := DPSI + DPHI + TEMP * TEMP;
            TEMP   := Z (II) * TEMP;
            W      := RHOINV + PHI + PSI + TEMP;
            ERRETM := EIGHT * (PHI - PSI) + ERRETM + TWO * RHOINV + THREE * abs (TEMP) + abs (TAU) * DW;
            if W * PREW > ZERO and abs (W) > abs (PREW) / TEN then
               SWTCH := not SWTCH;
            end if;
            --
         end loop;
         --
         --        Return with INFO = 1, NITER = MAXIT and not converged
         --
         INFO := 1;
         if ORGATI 
            then DLAM := D (I) + TAU;
            else DLAM := D (IP1) + TAU;
         end if;
         --
      end if;
      --
      <<L250>> null;
      --
      return;
      --
      --     End of DLAED4
      --
   end DLAED4;

   procedure DLAED5
     (I             : Integer;
      D_adr         : Address;
      Z_adr         : Address;
      Ftn_DELTA_adr : Address;
      RHO           : Real;
      DLAM          : in out Real)
   is

      D         : Ftn_Real_Vector (1 .. 2);
      Z         : Ftn_Real_Vector (1 .. 2);
      Ftn_DELTA : Ftn_Real_Vector (1 .. 2);

      for D'Address use D_adr;
      for Z'Address use Z_adr;
      for Ftn_DELTA'Address use Ftn_DELTA_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Z);
      pragma Import (Ada, Ftn_DELTA);

      ZERO : constant Real := 0.0e0;
      ONE  : constant Real := 1.0e0;
      TWO  : constant Real := 2.0e0;
      FOUR : constant Real := 4.0e0;
      B    : Real;
      C    : Real;
      DEL  : Real;
      TAU  : Real;
      TEMP : Real;
      W    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED5( I, D, Z, DELTA, RHO, DLAM )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            I
   --       DOUBLE PRECISION   DLAM, RHO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( 2 ), DELTA( 2 ), Z( 2 )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  This subroutine computes the I-th eigenvalue of a symmetric rank-one
   --  modification of a 2-by-2 diagonal matrix
   --
   --             diag( D )  +  RHO * Z * transpose(Z) .
   --
   --  The diagonal elements in the array D are assumed to satisfy
   --
   --             D(i) < D(j)  for  i < j .
   --
   --  We also assume RHO > 0 and that the Euclidean norm of the vector
   --  Z is one.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] I
   --           I is INTEGER
   --          The index of the eigenvalue to be computed.  I = 1 or I = 2.
   --
   --  [in] D
   --           D is DOUBLE PRECISION array, dimension (2)
   --          The original eigenvalues.  We assume D(1) < D(2).
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension (2)
   --          The components of the updating vector.
   --
   --  [out] DELTA
   --           DELTA is DOUBLE PRECISION array, dimension (2)
   --          The vector DELTA contains the information necessary
   --          to construct the eigenvectors.
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --          The scalar in the symmetric updating formula.
   --
   --  [out] DLAM
   --           DLAM is DOUBLE PRECISION
   --          The computed lambda_I, the I-th updated eigenvalue.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ren-Cang Li, Computer Science Division, University of California
   --      at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, FOUR = 4.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      DEL := D (2) - D (1);
      if I = 1 then
         W := ONE + TWO * RHO * (Z (2) * Z (2) - Z (1) * Z (1)) / DEL;
         if W > ZERO then
            B := DEL + RHO * (Z (1) * Z (1) + Z (2) * Z (2));
            C := RHO * Z (1) * Z (1) * DEL;
            --
            --           B > ZERO, always
            --
            TAU           := TWO * C / (B + Sqrt (abs (B * B - FOUR * C)));
            DLAM          := D (1) + TAU;
            Ftn_DELTA (1) := -Z (1) / TAU;
            Ftn_DELTA (2) := Z (2) / (DEL - TAU);
         else
            B := -DEL + RHO * (Z (1) * Z (1) + Z (2) * Z (2));
            C := RHO * Z (2) * Z (2) * DEL;
            if B > ZERO 
               then TAU := -TWO * C / (B + Sqrt (B * B + FOUR * C));
               else TAU := (B - Sqrt (B * B + FOUR * C)) / TWO;
            end if;
            DLAM          := D (2) + TAU;
            Ftn_DELTA (1) := -Z (1) / (DEL + TAU);
            Ftn_DELTA (2) := -Z (2) / TAU;
         end if;
         TEMP          := Sqrt (Ftn_DELTA (1) * Ftn_DELTA (1) + Ftn_DELTA (2) * Ftn_DELTA (2));
         Ftn_DELTA (1) := Ftn_DELTA (1) / TEMP;
         Ftn_DELTA (2) := Ftn_DELTA (2) / TEMP;
      else
         --
         --     Now I=2
         --
         B := -DEL + RHO * (Z (1) * Z (1) + Z (2) * Z (2));
         C := RHO * Z (2) * Z (2) * DEL;
         if B > ZERO 
            then TAU := (B + Sqrt (B * B + FOUR * C)) / TWO;
            else TAU := TWO * C / (-B + Sqrt (B * B + FOUR * C));
         end if;
         DLAM          := D (2) + TAU;
         Ftn_DELTA (1) := -Z (1) / (DEL + TAU);
         Ftn_DELTA (2) := -Z (2) / TAU;
         TEMP          := Sqrt (Ftn_DELTA (1) * Ftn_DELTA (1) + Ftn_DELTA (2) * Ftn_DELTA (2));
         Ftn_DELTA (1) := Ftn_DELTA (1) / TEMP;
         Ftn_DELTA (2) := Ftn_DELTA (2) / TEMP;
      end if;
      return;
      --
      --     End OF DLAED5
      --
   end DLAED5;

   procedure DLAED6
     (KNITER : Integer;
      ORGATI : Boolean;
      RHO    : Real;
      D_adr  : Address;
      Z_adr  : Address;
      FINIT  : Real;
      TAU    : in out Real;
      INFO   : in out Integer)
   is

      D : Ftn_Real_Vector (1 .. 3);
      Z : Ftn_Real_Vector (1 .. 3);

      for D'Address use D_adr;
      for Z'Address use Z_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Z);

      MAXIT  : constant Integer := 40;
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      TWO    : constant Real    := 2.0e0;
      THREE  : constant Real    := 3.0e0;
      FOUR   : constant Real    := 4.0e0;
      EIGHT  : constant Real    := 8.0e0;
      DSCALE : Ftn_Real_Vector (1 .. 3);
      ZSCALE : Ftn_Real_Vector (1 .. 3);
      SCALE  : Boolean;
      I      : Integer;
      ITER   : Integer;
      NITER  : Integer;
      A      : Real;
      B      : Real;
      BASE   : Real;
      C      : Real;
      DDF    : Real;
      DF     : Real;
      EPS    : Real;
      ERRETM : Real;
      ETA    : Real;
      F      : Real;
      FC     : Real;
      SCLFAC : Real;
      SCLINV : Real;
      SMALL1 : Real;
      SMALL2 : Real;
      SMINV1 : Real;
      SMINV2 : Real;
      TEMP   : Real;
      TEMP1  : Real;
      TEMP2  : Real;
      TEMP3  : Real;
      TEMP4  : Real;
      LBD    : Real;
      UBD    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED6( KNITER, ORGATI, RHO, D, Z, FINIT, TAU, INFO )
   --
   --       .. Scalar Arguments ..
   --       LOGICAL            ORGATI
   --       INTEGER            INFO, KNITER
   --       DOUBLE PRECISION   FINIT, RHO, TAU
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( 3 ), Z( 3 )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAED6 computes the positive or negative root (closest to the origin)
   --  of
   --                   z(1)        z(2)        z(3)
   --  f(x) =   rho + --------- + ---------- + ---------
   --                  d(1)-x      d(2)-x      d(3)-x
   --
   --  It is assumed that
   --
   --        if ORGATI = .true. the root is between d(2) and d(3);
   --        otherwise it is between d(1) and d(2)
   --
   --  This routine will be called by DLAED4 when necessary. In most cases,
   --  the root sought is the smallest in magnitude, though it might not be
   --  in some extremely rare situations.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] KNITER
   --           KNITER is INTEGER
   --                Refer to DLAED4 for its significance.
   --
   --  [in] ORGATI
   --           ORGATI is LOGICAL
   --                If ORGATI is true, the needed root is between d(2) and
   --                d(3); otherwise it is between d(1) and d(2).  See
   --                DLAED4 for further details.
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --                Refer to the equation f(x) above.
   --
   --  [in] D
   --           D is DOUBLE PRECISION array, dimension (3)
   --                D satisfies d(1) < d(2) < d(3).
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension (3)
   --                Each of the elements in z must be positive.
   --
   --  [in] FINIT
   --           FINIT is DOUBLE PRECISION
   --                The value of f at 0. It is more accurate than the one
   --                evaluated inside this routine (if someone wants to do
   --                so).
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION
   --                The root of the equation f(x).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --                = 0: successful exit
   --                > 0: if INFO = 1, failure to converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   10/02/03: This version has a few statements commented out for thread
   --   safety (machine parameters are computed on each entry). SJH.
   --
   --   05/10/06: Modified from a new version of Ren-Cang Li, use
   --      Gragg-Thornton-Warner cubic convergent scheme for better stability.
   --
   --  Contributors:
   --  ==================
   --
   --      Ren-Cang Li, Computer Science Division, University of California
   --      at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( MAXIT = 40 )
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, THREE = 3.0D0, FOUR = 4.0D0, EIGHT = 8.0D0 )
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, INT, LOG, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO := 0;
      --
      if ORGATI then
         LBD := D (2);
         UBD := D (3);
      else
         LBD := D (1);
         UBD := D (2);
      end if;
      if FINIT < ZERO 
         then LBD := ZERO;
         else UBD := ZERO;
      end if;
      --
      NITER := 1;
      TAU   := ZERO;
      if KNITER = 2 then
         if ORGATI then
            TEMP := (D (3) - D (2)) / TWO;
            C    := RHO + Z (1) / ((D (1) - D (2)) - TEMP);
            A    := C * (D (2) + D (3)) + Z (2) + Z (3);
            B    := C * D (2) * D (3) + Z (2) * D (3) + Z (3) * D (2);
         else
            TEMP := (D (1) - D (2)) / TWO;
            C    := RHO + Z (3) / ((D (3) - D (2)) - TEMP);
            A    := C * (D (1) + D (2)) + Z (1) + Z (2);
            B    := C * D (1) * D (2) + Z (1) * D (2) + Z (2) * D (1);
         end if;
         TEMP := max (abs (A), abs (B), abs (C));
         A    := A / TEMP;
         B    := B / TEMP;
         C    := C / TEMP;
         if C = ZERO then
            TAU := B / A;
         elsif A <= ZERO then
            TAU := (A - Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
         else
            TAU := TWO * B / (A + Sqrt (abs (A * A - FOUR * B * C)));
         end if;
         if TAU < LBD or TAU > UBD then
            TAU := (LBD + UBD) / TWO;
         end if;
         if D (1) = TAU or D (2) = TAU or D (3) = TAU then
            TAU := ZERO;
         else
            TEMP := FINIT +
                    TAU * Z (1) / (D (1) * (D (1) - TAU)) +
                    TAU * Z (2) / (D (2) * (D (2) - TAU)) +
                    TAU * Z (3) / (D (3) * (D (3) - TAU));
            if TEMP <= ZERO 
               then LBD := TAU;
               else UBD := TAU;
            end if;
            if abs (FINIT) <= abs (TEMP) then
               TAU := ZERO;
            end if;
         end if;
      end if;
      --
      --     get machine parameters for possible scaling to avoid overflow
      --
      --     modified by Sven: parameters SMALL1, SMINV1, SMALL2,
      --     SMINV2, EPS are not SAVEd anymore between one call to the
      --     others but recomputed at each call
      --
      EPS    := DLAMCH ('E');
      BASE   := DLAMCH ('B');
      SMALL1 := BASE ** (int (Log (DLAMCH ('S')) / Log (BASE) / THREE));
      SMINV1 := ONE / SMALL1;
      SMALL2 := SMALL1 * SMALL1;
      SMINV2 := SMINV1 * SMINV1;
      --
      --     Determine if scaling of inputs necessary to avoid overflow
      --     when computing 1/TEMP**3
      --
      if ORGATI 
         then TEMP := min (abs (D (2) - TAU), abs (D (3) - TAU));
         else TEMP := min (abs (D (1) - TAU), abs (D (2) - TAU));
      end if;
      SCALE := False;
      if TEMP <= SMALL1 then
         SCALE := True;
         if TEMP <= SMALL2 then
            --
            --        Scale up by power of radix nearest 1/SAFMIN**(2/3)
            --
            SCLFAC := SMINV2;
            SCLINV := SMALL2;
         else
            --
            --        Scale up by power of radix nearest 1/SAFMIN**(1/3)
            --
            SCLFAC := SMINV1;
            SCLINV := SMALL1;
         end if;
         --
         --        Scaling up safe because D, Z, TAU scaled elsewhere to be O(1)
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > 3;
            DSCALE (I) := D (I) * SCLFAC;
            ZSCALE (I) := Z (I) * SCLFAC;
         end loop;
         TAU := TAU * SCLFAC;
         LBD := LBD * SCLFAC;
         UBD := UBD * SCLFAC;
      else
         --
         --        Copy D and Z to DSCALE and ZSCALE
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > 3;
            DSCALE (I) := D (I);
            ZSCALE (I) := Z (I);
         end loop;
      end if;
      --
      FC  := ZERO;
      DF  := ZERO;
      DDF := ZERO;
      I   := 1 - 1;
      loop
         I := I + 1;
         exit when I > 3;
         TEMP  := ONE / (DSCALE (I) - TAU);
         TEMP1 := ZSCALE (I) * TEMP;
         TEMP2 := TEMP1 * TEMP;
         TEMP3 := TEMP2 * TEMP;
         FC    := FC + TEMP1 / DSCALE (I);
         DF    := DF + TEMP2;
         DDF   := DDF + TEMP3;
      end loop;
      F := FINIT + TAU * FC;
      --
      if abs (F) <= ZERO then
         goto L60;
      end if;
      if F <= ZERO 
         then LBD := TAU;
         else UBD := TAU;
      end if;
      --
      --        Iteration begins -- Use Gragg-Thornton-Warner cubic convergent
      --                            scheme
      --
      --     It is not hard to see that
      --
      --           (1) Iterations will go up monotonically
      --               if FINIT < 0;
      --
      --           (2) Iterations will go down monotonically
      --               if FINIT > 0.
      --
      ITER := NITER + 1;
      --
      NITER := ITER - 1;
      loop
         NITER := NITER + 1;
         exit when NITER > MAXIT;
         --
         if ORGATI then
            TEMP1 := DSCALE (2) - TAU;
            TEMP2 := DSCALE (3) - TAU;
         else
            TEMP1 := DSCALE (1) - TAU;
            TEMP2 := DSCALE (2) - TAU;
         end if;
         A    := (TEMP1 + TEMP2) * F - TEMP1 * TEMP2 * DF;
         B    := TEMP1 * TEMP2 * F;
         C    := F - (TEMP1 + TEMP2) * DF + TEMP1 * TEMP2 * DDF;
         TEMP := max (abs (A), abs (B), abs (C));
         A    := A / TEMP;
         B    := B / TEMP;
         C    := C / TEMP;
         if C = ZERO then
            ETA := B / A;
         elsif A <= ZERO then
            ETA := (A - Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
         else
            ETA := TWO * B / (A + Sqrt (abs (A * A - FOUR * B * C)));
         end if;
         if F * ETA >= ZERO then
            ETA := -F / DF;
         end if;
         --
         TAU := TAU + ETA;
         if TAU < LBD or TAU > UBD then
            TAU := (LBD + UBD) / TWO;
         end if;
         --
         FC     := ZERO;
         ERRETM := ZERO;
         DF     := ZERO;
         DDF    := ZERO;
         I      := 1 - 1;
         loop
            I := I + 1;
            exit when I > 3;
            if (DSCALE (I) - TAU) /= ZERO then
               TEMP   := ONE / (DSCALE (I) - TAU);
               TEMP1  := ZSCALE (I) * TEMP;
               TEMP2  := TEMP1 * TEMP;
               TEMP3  := TEMP2 * TEMP;
               TEMP4  := TEMP1 / DSCALE (I);
               FC     := FC + TEMP4;
               ERRETM := ERRETM + abs (TEMP4);
               DF     := DF + TEMP2;
               DDF    := DDF + TEMP3;
            else
               goto L60;
            end if;
         end loop;
         F      := FINIT + TAU * FC;
         ERRETM := EIGHT * (abs (FINIT) + abs (TAU) * ERRETM) + abs (TAU) * DF;
         if abs (F) <= EPS * ERRETM then
            goto L60;
         end if;
         if F <= ZERO 
            then LBD := TAU;
            else UBD := TAU;
         end if;
      end loop;
      INFO := 1;
      <<L60>> null;
      --
      --     Undo scaling
      --
      if SCALE then
         TAU := TAU * SCLINV;
      end if;
      return;
      --
      --     End of DLAED6
      --
   end DLAED6;

   procedure DLAED7
     (ICOMPQ     : Integer;
      N          : Integer;
      QSIZ       : Integer;
      TLVLS      : Integer;
      CURLVL     : Integer;
      CURPBM     : Integer;
      D_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      INDXQ_adr  : Address;
      RHO        : in out Real;
      CUTPNT     : Integer;
      QSTORE_adr : Address;
      QPTR_adr   : Address;
      PRMPTR_adr : Address;
      PERM_adr   : Address;
      GIVPTR_adr : Address;
      GIVCOL_adr : Address;
      GIVNUM_adr : Address;
      WORK_adr   : Address;
      IWORK_adr  : Address;
      INFO       : in out Integer)
   is

      N_Log2_N : constant Integer := N * (1 + intlog2 (N));

      D      : Ftn_Real_Vector (1 .. N);
      Q      : Ftn_Real_Matrix (1 .. LDQ, 1 .. N);
      INDXQ  : Ftn_Integer_Vector (1 .. N);
      QSTORE : Ftn_Real_Vector (1 .. N * N + 1);
      QPTR   : Ftn_Integer_Vector (1 .. N + 2);
      PRMPTR : Ftn_Integer_Vector (1 .. N_Log2_N);
      PERM   : Ftn_Integer_Vector (1 .. N_Log2_N);
      GIVPTR : Ftn_Integer_Vector (1 .. N_Log2_N);
      GIVCOL : Ftn_Integer_Matrix (1 .. 2, 1 .. N_Log2_N);
      GIVNUM : Ftn_Real_Matrix (1 .. 2, 1 .. N_Log2_N);
      WORK   : Ftn_Real_Vector (1 .. 3 * N + 2 * QSIZ * N);
      IWORK  : Ftn_Integer_Vector (1 .. 4 * N);

      for D'Address use D_adr;
      for Q'Address use Q_adr;
      for INDXQ'Address use INDXQ_adr;
      for QSTORE'Address use QSTORE_adr;
      for QPTR'Address use QPTR_adr;
      for PRMPTR'Address use PRMPTR_adr;
      for PERM'Address use PERM_adr;
      for GIVPTR'Address use GIVPTR_adr;
      for GIVCOL'Address use GIVCOL_adr;
      for GIVNUM'Address use GIVNUM_adr;
      for WORK'Address use WORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Q);
      pragma Import (Ada, INDXQ);
      pragma Import (Ada, QSTORE);
      pragma Import (Ada, QPTR);
      pragma Import (Ada, PRMPTR);
      pragma Import (Ada, PERM);
      pragma Import (Ada, GIVPTR);
      pragma Import (Ada, GIVCOL);
      pragma Import (Ada, GIVNUM);
      pragma Import (Ada, WORK);
      pragma Import (Ada, IWORK);

      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
      COLTYP : Integer;
      CURR   : Integer;
      I      : Integer;
      IDLMDA : Integer;
      INDX   : Integer;
      INDXC  : Integer;
      INDXP  : Integer;
      IQ2    : Integer;
      Ftn_IS : Integer;
      IW     : Integer;
      IZ     : Integer;
      K      : Integer;
      LDQ2   : Integer;
      N1     : Integer;
      N2     : Integer;
      PTR    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED7( ICOMPQ, N, QSIZ, TLVLS, CURLVL, CURPBM, D, Q,
   --                          LDQ, INDXQ, RHO, CUTPNT, QSTORE, QPTR, PRMPTR,
   --                          PERM, GIVPTR, GIVCOL, GIVNUM, WORK, IWORK,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            CURLVL, CURPBM, CUTPNT, ICOMPQ, INFO, LDQ, N,
   --      $                   QSIZ, TLVLS
   --       DOUBLE PRECISION   RHO
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            GIVCOL( 2, * ), GIVPTR( * ), INDXQ( * ),
   --      $                   IWORK( * ), PERM( * ), PRMPTR( * ), QPTR( * )
   --       DOUBLE PRECISION   D( * ), GIVNUM( 2, * ), Q( LDQ, * ),
   --      $                   QSTORE( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAED7 computes the updated eigensystem of a diagonal
   --  matrix after modification by a rank-one symmetric matrix. This
   --  routine is used only for the eigenproblem which requires all
   --  eigenvalues and optionally eigenvectors of a dense symmetric matrix
   --  that has been reduced to tridiagonal form.  DLAED1 handles
   --  the case in which all eigenvalues and eigenvectors of a symmetric
   --  tridiagonal matrix are desired.
   --
   --    T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
   --
   --     where Z = Q**Tu, u is a vector of length N with ones in the
   --     CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
   --
   --     The eigenvectors of the original matrix are stored in Q, and the
   --     eigenvalues are in D.  The algorithm consists of three stages:
   --
   --        The first stage consists of deflating the size of the problem
   --        when there are multiple eigenvalues or if there is a zero in
   --        the Z vector.  For each such occurence the dimension of the
   --        secular equation problem is reduced by one.  This stage is
   --        performed by the routine DLAED8.
   --
   --        The second stage consists of calculating the updated
   --        eigenvalues. This is done by finding the roots of the secular
   --        equation via the routine DLAED4 (as called by DLAED9).
   --        This routine also calculates the eigenvectors of the current
   --        problem.
   --
   --        The final stage consists of computing the updated eigenvectors
   --        directly using the updated eigenvalues.  The eigenvectors for
   --        the current problem are multiplied with the eigenvectors from
   --        the overall problem.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ICOMPQ
   --           ICOMPQ is INTEGER
   --           = 0:  Compute eigenvalues only.
   --           = 1:  Compute eigenvectors of original dense symmetric matrix
   --                 also.  On entry, Q contains the orthogonal matrix used
   --                 to reduce the original matrix to tridiagonal form.
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in] QSIZ
   --           QSIZ is INTEGER
   --          The dimension of the orthogonal matrix used to reduce
   --          the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
   --
   --  [in] TLVLS
   --           TLVLS is INTEGER
   --          The total number of merging levels in the overall divide and
   --          conquer tree.
   --
   --  [in] CURLVL
   --           CURLVL is INTEGER
   --          The current level in the overall merge routine,
   --          0 <= CURLVL <= TLVLS.
   --
   --  [in] CURPBM
   --           CURPBM is INTEGER
   --          The current problem in the current level in the overall
   --          merge routine (counting from upper left to lower right).
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry, the eigenvalues of the rank-1-perturbed matrix.
   --          On exit, the eigenvalues of the repaired matrix.
   --
   --  [in,out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ, N)
   --          On entry, the eigenvectors of the rank-1-perturbed matrix.
   --          On exit, the eigenvectors of the repaired tridiagonal matrix.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [out] INDXQ
   --           INDXQ is INTEGER array, dimension (N)
   --          The permutation which will reintegrate the subproblem just
   --          solved back into sorted order, i.e., D( INDXQ( I = 1, N ) )
   --          will be in ascending order.
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --          The subdiagonal element used to create the rank-1
   --          modification.
   --
   --  [in] CUTPNT
   --           CUTPNT is INTEGER
   --          Contains the location of the last eigenvalue in the leading
   --          sub-matrix.  min(1,N) <= CUTPNT <= N.
   --
   --  [in,out] QSTORE
   --           QSTORE is DOUBLE PRECISION array, dimension (N**2+1)
   --          Stores eigenvectors of submatrices encountered during
   --          divide and conquer, packed together. QPTR points to
   --          beginning of the submatrices.
   --
   --  [in,out] QPTR
   --           QPTR is INTEGER array, dimension (N+2)
   --          List of indices pointing to beginning of submatrices stored
   --          in QSTORE. The submatrices are numbered starting at the
   --          bottom left of the divide and conquer tree, from left to
   --          right and bottom to top.
   --
   --  [in] PRMPTR
   --           PRMPTR is INTEGER array, dimension (N lg N)
   --          Contains a list of pointers which indicate where in PERM a
   --          level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
   --          indicates the size of the permutation and also the size of
   --          the full, non-deflated problem.
   --
   --  [in] PERM
   --           PERM is INTEGER array, dimension (N lg N)
   --          Contains the permutations (from deflation and sorting) to be
   --          applied to each eigenblock.
   --
   --  [in] GIVPTR
   --           GIVPTR is INTEGER array, dimension (N lg N)
   --          Contains a list of pointers which indicate where in GIVCOL a
   --          level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
   --          indicates the number of Givens rotations.
   --
   --  [in] GIVCOL
   --           GIVCOL is INTEGER array, dimension (2, N lg N)
   --          Each pair of numbers indicates a pair of columns to take place
   --          in a Givens rotation.
   --
   --  [in] GIVNUM
   --           GIVNUM is DOUBLE PRECISION array, dimension (2, N lg N)
   --          Each number indicates the S value to be used in the
   --          corresponding Givens rotation.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (3*N+2*QSIZ*N)
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (4*N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, an eigenvalue did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D0, ZERO = 0.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMM, DLAED8, DLAED9, DLAEDA, DLAMRG, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if ICOMPQ < 0 or ICOMPQ > 1 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif ICOMPQ = 1 and QSIZ < N then
         INFO := -4;
      elsif LDQ < max (1, N) then
         INFO := -9;
      elsif min (1, N) > CUTPNT or N < CUTPNT then
         INFO := -12;
      end if;
      if INFO /= 0 then
         XERBLA ("DLAED7", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     The following values are for bookkeeping purposes only.  They are
      --     integer pointers which indicate the portion of the workspace
      --     used by a particular array in DLAED8 and DLAED9.
      --
      if ICOMPQ = 1 
         then LDQ2 := QSIZ;
         else LDQ2 := N;
      end if;
      --
      IZ     := 1;
      IDLMDA := IZ + N;
      IW     := IDLMDA + N;
      IQ2    := IW + N;
      Ftn_IS := IQ2 + N * LDQ2;
      --
      INDX   := 1;
      INDXC  := INDX + N;
      COLTYP := INDXC + N;
      INDXP  := COLTYP + N;
      --
      --     Form the z-vector which consists of the last row of Q_1 and the
      --     first row of Q_2.
      --
      PTR := 1 + 2 ** TLVLS;
      I   := 1 - 1;
      loop
         I := I + 1;
         exit when I > CURLVL - 1;
         PTR := PTR + 2 ** (TLVLS - I);
      end loop;
      CURR := PTR + CURPBM;
      DLAEDA
        (N,
         TLVLS,
         CURLVL,
         CURPBM,
         PRMPTR'Address,
         PERM'Address,
         GIVPTR'Address,
         GIVCOL'Address,
         GIVNUM'Address,
         QSTORE'Address,
         QPTR'Address,
         WORK (IZ)'Address,
         WORK (IZ + N)'Address,
         INFO);
      --
      --     When solving the final problem, we no longer need the stored data,
      --     so we will overwrite the data from this level onto the previously
      --     used storage space.
      --
      if CURLVL = TLVLS then
         QPTR (CURR)   := 1;
         PRMPTR (CURR) := 1;
         GIVPTR (CURR) := 1;
      end if;
      --
      --     Sort and Deflate eigenvalues.
      --
      DLAED8
        (ICOMPQ,
         K,
         N,
         QSIZ,
         D'Address,
         Q'Address,
         LDQ,
         INDXQ'Address,
         RHO,
         CUTPNT,
         WORK (IZ)'Address,
         WORK (IDLMDA)'Address,
         WORK (IQ2)'Address,
         LDQ2,
         WORK (IW)'Address,
         PERM (PRMPTR (CURR))'Address,
         GIVPTR (CURR + 1),
         GIVCOL (1, GIVPTR (CURR))'Address,
         GIVNUM (1, GIVPTR (CURR))'Address,
         IWORK (INDXP)'Address,
         IWORK (INDX)'Address,
         INFO);
      PRMPTR (CURR + 1) := PRMPTR (CURR) + N;
      GIVPTR (CURR + 1) := GIVPTR (CURR + 1) + GIVPTR (CURR);
      --
      --     Solve Secular Equation.
      --
      if K /= 0 then
         DLAED9
           (K,
            1,
            K,
            N,
            D'Address,
            WORK (Ftn_IS)'Address,
            K,
            RHO,
            WORK (IDLMDA)'Address,
            WORK (IW)'Address,
            QSTORE (QPTR (CURR))'Address,
            K,
            INFO);
         if INFO /= 0 then
            goto L30;
         end if;
         if ICOMPQ = 1 then
            DGEMM
              ('N',
               'N',
               QSIZ,
               K,
               K,
               ONE,
               WORK (IQ2)'Address,
               LDQ2,
               QSTORE (QPTR (CURR))'Address,
               K,
               ZERO,
               Q'Address,
               LDQ);
         end if;
         QPTR (CURR + 1) := QPTR (CURR) + K ** 2;
         --
         --     Prepare the INDXQ sorting permutation.
         --
         N1 := K;
         N2 := N - K;
         DLAMRG (N1, N2, D'Address, 1, -1, INDXQ'Address);
      else
         QPTR (CURR + 1) := QPTR (CURR);
         I               := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            INDXQ (I) := I;
         end loop;
      end if;
      --
      <<L30>> null;
      return;
      --
      --     End of DLAED7
      --
   end DLAED7;

   procedure DLAED8
     (ICOMPQ     : Integer;
      K          : in out Integer;
      N          : Integer;
      QSIZ       : Integer;
      D_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      INDXQ_adr  : Address;
      RHO        : in out Real;
      CUTPNT     : Integer;
      Z_adr      : Address;
      DLAMDA_adr : Address;
      Q2_adr     : Address;
      LDQ2       : Integer;
      W_adr      : Address;
      PERM_adr   : Address;
      GIVPTR     : in out Integer;
      GIVCOL_adr : Address;
      GIVNUM_adr : Address;
      INDXP_adr  : Address;
      INDX_adr   : Address;
      INFO       : in out Integer)
   is

      D      : Ftn_Real_Vector (1 .. N);
      Q      : Ftn_Real_Matrix (1 .. LDQ, 1 .. N);
      INDXQ  : Ftn_Integer_Vector (1 .. N);
      Z      : Ftn_Real_Vector (1 .. N);
      DLAMDA : Ftn_Real_Vector (1 .. N);
      Q2     : Ftn_Real_Matrix (1 .. LDQ2, 1 .. N);
      W      : Ftn_Real_Vector (1 .. N);
      PERM   : Ftn_Integer_Vector (1 .. N);
      GIVCOL : Ftn_Integer_Matrix (1 .. 2, 1 .. N);
      GIVNUM : Ftn_Real_Matrix (1 .. 2, 1 .. N);
      INDXP  : Ftn_Integer_Vector (1 .. N);
      INDX   : Ftn_Integer_Vector (1 .. N);

      for D'Address use D_adr;
      for Q'Address use Q_adr;
      for INDXQ'Address use INDXQ_adr;
      for Z'Address use Z_adr;
      for DLAMDA'Address use DLAMDA_adr;
      for Q2'Address use Q2_adr;
      for W'Address use W_adr;
      for PERM'Address use PERM_adr;
      for GIVCOL'Address use GIVCOL_adr;
      for GIVNUM'Address use GIVNUM_adr;
      for INDXP'Address use INDXP_adr;
      for INDX'Address use INDX_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Q);
      pragma Import (Ada, INDXQ);
      pragma Import (Ada, Z);
      pragma Import (Ada, DLAMDA);
      pragma Import (Ada, Q2);
      pragma Import (Ada, W);
      pragma Import (Ada, PERM);
      pragma Import (Ada, GIVCOL);
      pragma Import (Ada, GIVNUM);
      pragma Import (Ada, INDXP);
      pragma Import (Ada, INDX);

      MONE  : constant Real := -1.0e0;
      ZERO  : constant Real := 0.0e0;
      ONE   : constant Real := 1.0e0;
      TWO   : constant Real := 2.0e0;
      EIGHT : constant Real := 8.0e0;
      I     : Integer;
      IMAX  : Integer;
      J     : Integer;
      JLAM  : Integer;
      JMAX  : Integer;
      JP    : Integer;
      K2    : Integer;
      N1    : Integer;
      N1P1  : Integer;
      N2    : Integer;
      C     : Real;
      EPS   : Real;
      S     : Real;
      T     : Real;
      TAU   : Real;
      TOL   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED8( ICOMPQ, K, N, QSIZ, D, Q, LDQ, INDXQ, RHO,
   --                          CUTPNT, Z, DLAMDA, Q2, LDQ2, W, PERM, GIVPTR,
   --                          GIVCOL, GIVNUM, INDXP, INDX, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            CUTPNT, GIVPTR, ICOMPQ, INFO, K, LDQ, LDQ2, N,
   --      $                   QSIZ
   --       DOUBLE PRECISION   RHO
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            GIVCOL( 2, * ), INDX( * ), INDXP( * ),
   --      $                   INDXQ( * ), PERM( * )
   --       DOUBLE PRECISION   D( * ), DLAMDA( * ), GIVNUM( 2, * ),
   --      $                   Q( LDQ, * ), Q2( LDQ2, * ), W( * ), Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAED8 merges the two sets of eigenvalues together into a single
   --  sorted set.  Then it tries to deflate the size of the problem.
   --  There are two ways in which deflation can occur:  when two or more
   --  eigenvalues are close together or if there is a tiny element in the
   --  Z vector.  For each such occurrence the order of the related secular
   --  equation problem is reduced by one.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ICOMPQ
   --           ICOMPQ is INTEGER
   --           = 0:  Compute eigenvalues only.
   --           = 1:  Compute eigenvectors of original dense symmetric matrix
   --                 also.  On entry, Q contains the orthogonal matrix used
   --                 to reduce the original matrix to tridiagonal form.
   --
   --  [out] K
   --           K is INTEGER
   --          The number of non-deflated eigenvalues, and the order of the
   --          related secular equation.
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in] QSIZ
   --           QSIZ is INTEGER
   --          The dimension of the orthogonal matrix used to reduce
   --          the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry, the eigenvalues of the two submatrices to be
   --          combined.  On exit, the trailing (N-K) updated eigenvalues
   --          (those which were deflated) sorted into increasing order.
   --
   --  [in,out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ,N)
   --          If ICOMPQ = 0, Q is not referenced.  Otherwise,
   --          on entry, Q contains the eigenvectors of the partially solved
   --          system which has been previously updated in matrix
   --          multiplies with other partially solved eigensystems.
   --          On exit, Q contains the trailing (N-K) updated eigenvectors
   --          (those which were deflated) in its last N-K columns.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [in] INDXQ
   --           INDXQ is INTEGER array, dimension (N)
   --          The permutation which separately sorts the two sub-problems
   --          in D into ascending order.  Note that elements in the second
   --          half of this permutation must first have CUTPNT added to
   --          their values in order to be accurate.
   --
   --  [in,out] RHO
   --           RHO is DOUBLE PRECISION
   --          On entry, the off-diagonal element associated with the rank-1
   --          cut which originally split the two submatrices which are now
   --          being recombined.
   --          On exit, RHO has been modified to the value required by
   --          DLAED3.
   --
   --  [in] CUTPNT
   --           CUTPNT is INTEGER
   --          The location of the last eigenvalue in the leading
   --          sub-matrix.  min(1,N) <= CUTPNT <= N.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension (N)
   --          On entry, Z contains the updating vector (the last row of
   --          the first sub-eigenvector matrix and the first row of the
   --          second sub-eigenvector matrix).
   --          On exit, the contents of Z are destroyed by the updating
   --          process.
   --
   --  [out] DLAMDA
   --           DLAMDA is DOUBLE PRECISION array, dimension (N)
   --          A copy of the first K eigenvalues which will be used by
   --          DLAED3 to form the secular equation.
   --
   --  [out] Q2
   --           Q2 is DOUBLE PRECISION array, dimension (LDQ2,N)
   --          If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
   --          a copy of the first K eigenvectors which will be used by
   --          DLAED7 in a matrix multiply (DGEMM) to update the new
   --          eigenvectors.
   --
   --  [in] LDQ2
   --           LDQ2 is INTEGER
   --          The leading dimension of the array Q2.  LDQ2 >= max(1,N).
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (N)
   --          The first k values of the final deflation-altered z-vector and
   --          will be passed to DLAED3.
   --
   --  [out] PERM
   --           PERM is INTEGER array, dimension (N)
   --          The permutations (from deflation and sorting) to be applied
   --          to each eigenblock.
   --
   --  [out] GIVPTR
   --           GIVPTR is INTEGER
   --          The number of Givens rotations which took place in this
   --          subproblem.
   --
   --  [out] GIVCOL
   --           GIVCOL is INTEGER array, dimension (2, N)
   --          Each pair of numbers indicates a pair of columns to take place
   --          in a Givens rotation.
   --
   --  [out] GIVNUM
   --           GIVNUM is DOUBLE PRECISION array, dimension (2, N)
   --          Each number indicates the S value to be used in the
   --          corresponding Givens rotation.
   --
   --  [out] INDXP
   --           INDXP is INTEGER array, dimension (N)
   --          The permutation used to place deflated values of D at the end
   --          of the array.  INDXP(1:K) points to the nondeflated D-values
   --          and INDXP(K+1:N) points to the deflated eigenvalues.
   --
   --  [out] INDX
   --           INDX is INTEGER array, dimension (N)
   --          The permutation used to sort the contents of D into ascending
   --          order.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( MONE = -1.0D0, ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, EIGHT = 8.0D0 )
   --     ..
   --     .. Local Scalars ..
   --
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           IDAMAX, DLAMCH, DLAPY2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLACPY, DLAMRG, DROT, DSCAL, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if ICOMPQ < 0 or ICOMPQ > 1 then
         INFO := -1;
      elsif N < 0 then
         INFO := -3;
      elsif ICOMPQ = 1 and QSIZ < N then
         INFO := -4;
      elsif LDQ < max (1, N) then
         INFO := -7;
      elsif CUTPNT < min (1, N) or CUTPNT > N then
         INFO := -10;
      elsif LDQ2 < max (1, N) then
         INFO := -14;
      end if;
      if INFO /= 0 then
         XERBLA ("DLAED8", -INFO);
         return;
      end if;
      --
      --     Need to initialize GIVPTR to O here in case of quick exit
      --     to prevent an unspecified code behavior (usually sigfault)
      --     when IWORK array on entry to *stedc is not zeroed
      --     (or at least some IWORK entries which used in *laed7 for GIVPTR).
      --
      GIVPTR := 0;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      N1   := CUTPNT;
      N2   := N - N1;
      N1P1 := N1 + 1;
      --
      if RHO < ZERO then
         DSCAL (N2, MONE, Z (N1P1)'Address, 1);
      end if;
      --
      --     Normalize z so that norm(z) = 1
      --
      T := ONE / Sqrt (TWO);
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         INDX (J) := J;
      end loop;
      DSCAL (N, T, Z'Address, 1);
      RHO := abs (TWO * RHO);
      --
      --     Sort the eigenvalues into increasing order
      --
      I := CUTPNT + 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         INDXQ (I) := INDXQ (I) + CUTPNT;
      end loop;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         DLAMDA (I) := D (INDXQ (I));
         W (I)      := Z (INDXQ (I));
      end loop;
      I := 1;
      J := CUTPNT + 1;
      DLAMRG (N1, N2, DLAMDA'Address, 1, 1, INDX'Address);
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         D (I) := DLAMDA (INDX (I));
         Z (I) := W (INDX (I));
      end loop;
      --
      --     Calculate the allowable deflation tolerence
      --
      IMAX := IDAMAX (N, Z'Address, 1);
      JMAX := IDAMAX (N, D'Address, 1);
      EPS  := DLAMCH ('E');
      TOL  := EIGHT * EPS * abs (D (JMAX));
      --
      --     If the rank-1 modifier is small enough, no more needs to be done
      --     except to reorganize Q so that its columns correspond with the
      --     elements in D.
      --
      if RHO * abs (Z (IMAX)) <= TOL then
         K := 0;
         if ICOMPQ = 0 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               PERM (J) := INDXQ (INDX (J));
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               PERM (J) := INDXQ (INDX (J));
               DCOPY (QSIZ, Q (1, PERM (J))'Address, 1, Q2 (1, J)'Address, 1);
            end loop;
            DLACPY ('A', QSIZ, N, Q2 (1, 1)'Address, LDQ2, Q (1, 1)'Address, LDQ);
         end if;
         return;
      end if;
      --
      --     If there are multiple eigenvalues then the problem deflates.  Here
      --     the number of equal eigenvalues are found.  As each equal
      --     eigenvalue is found, an elementary reflector is computed to rotate
      --     the corresponding eigensubspace so that the corresponding
      --     components of Z are zero in this new basis.
      --
      K  := 0;
      K2 := N + 1;
      J  := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         if RHO * abs (Z (J)) <= TOL then
            --
            --           Deflate due to small z component.
            --
            K2         := K2 - 1;
            INDXP (K2) := J;
            if J = N then
               goto L110;
            end if;
         else
            JLAM := J;
            goto L80;
         end if;
      end loop;
      <<L80>> null;
      J := J + 1;
      if J > N then
         goto L100;
      end if;
      if RHO * abs (Z (J)) <= TOL then
         --
         --        Deflate due to small z component.
         --
         K2         := K2 - 1;
         INDXP (K2) := J;
      else
         --
         --        Check if eigenvalues are close enough to allow deflation.
         --
         S := Z (JLAM);
         C := Z (J);
         --
         --        Find sqrt(a**2+b**2) without overflow or
         --        destructive underflow.
         --
         TAU := DLAPY2 (C, S);
         T   := D (J) - D (JLAM);
         C   := C / TAU;
         S   := -S / TAU;
         if abs (T * C * S) <= TOL then
            --
            --           Deflation is possible.
            --
            Z (J)    := TAU;
            Z (JLAM) := ZERO;
            --
            --           Record the appropriate Givens rotation
            --
            GIVPTR             := GIVPTR + 1;
            GIVCOL (1, GIVPTR) := INDXQ (INDX (JLAM));
            GIVCOL (2, GIVPTR) := INDXQ (INDX (J));
            GIVNUM (1, GIVPTR) := C;
            GIVNUM (2, GIVPTR) := S;
            if ICOMPQ = 1 then
               DROT (QSIZ, Q (1, INDXQ (INDX (JLAM)))'Address, 1, Q (1, INDXQ (INDX (J)))'Address, 1, C, S);
            end if;
            T        := D (JLAM) * C * C + D (J) * S * S;
            D (J)    := D (JLAM) * S * S + D (J) * C * C;
            D (JLAM) := T;
            K2       := K2 - 1;
            I        := 1;
            <<L90>> null;
            if K2 + I <= N then
               if D (JLAM) < D (INDXP (K2 + I)) then
                  INDXP (K2 + I - 1) := INDXP (K2 + I);
                  INDXP (K2 + I)     := JLAM;
                  I                  := I + 1;
                  goto L90;
               else
                  INDXP (K2 + I - 1) := JLAM;
               end if;
            else
               INDXP (K2 + I - 1) := JLAM;
            end if;
            JLAM := J;
         else
            K          := K + 1;
            W (K)      := Z (JLAM);
            DLAMDA (K) := D (JLAM);
            INDXP (K)  := JLAM;
            JLAM       := J;
         end if;
      end if;
      goto L80;
      <<L100>> null;
      --
      --     Record the last eigenvalue.
      --
      K          := K + 1;
      W (K)      := Z (JLAM);
      DLAMDA (K) := D (JLAM);
      INDXP (K)  := JLAM;
      --
      <<L110>> null;
      --
      --     Sort the eigenvalues and corresponding eigenvectors into DLAMDA
      --     and Q2 respectively.  The eigenvalues/vectors which were not
      --     deflated go into the first K slots of DLAMDA and Q2 respectively,
      --     while those which were deflated go into the last N - K slots.
      --
      if ICOMPQ = 0 then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            JP         := INDXP (J);
            DLAMDA (J) := D (JP);
            PERM (J)   := INDXQ (INDX (JP));
         end loop;
      else
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            JP         := INDXP (J);
            DLAMDA (J) := D (JP);
            PERM (J)   := INDXQ (INDX (JP));
            DCOPY (QSIZ, Q (1, PERM (J))'Address, 1, Q2 (1, J)'Address, 1);
         end loop;
      end if;
      --
      --     The deflated eigenvalues and their corresponding vectors go back
      --     into the last N - K slots of D and Q respectively.
      --
      if K < N then
         if ICOMPQ = 0 then
            DCOPY (N - K, DLAMDA (K + 1)'Address, 1, D (K + 1)'Address, 1);
         else
            DCOPY (N - K, DLAMDA (K + 1)'Address, 1, D (K + 1)'Address, 1);
            DLACPY ('A', QSIZ, N - K, Q2 (1, K + 1)'Address, LDQ2, Q (1, K + 1)'Address, LDQ);
         end if;
      end if;
      --
      return;
      --
      --     End of DLAED8
      --
   end DLAED8;

   procedure DLAED9
     (K          : Integer;
      KSTART     : Integer;
      KSTOP      : Integer;
      N          : Integer;
      D_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      RHO        : Real;
      DLAMDA_adr : Address;
      W_adr      : Address;
      S_adr      : Address;
      LDS        : Integer;
      INFO       : in out Integer)
   is

      D      : Ftn_Real_Vector (1 .. N);
      Q      : Ftn_Real_Matrix (1 .. LDQ, 1 .. N);
      DLAMDA : Ftn_Real_Vector (1 .. K);
      W      : Ftn_Real_Vector (1 .. K);
      S      : Ftn_Real_Matrix (1 .. LDS, 1 .. K);

      for D'Address use D_adr;
      for Q'Address use Q_adr;
      for DLAMDA'Address use DLAMDA_adr;
      for W'Address use W_adr;
      for S'Address use S_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Q);
      pragma Import (Ada, DLAMDA);
      pragma Import (Ada, W);
      pragma Import (Ada, S);

      I    : Integer;
      J    : Integer;
      TEMP : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAED9( K, KSTART, KSTOP, N, D, Q, LDQ, RHO, DLAMDA, W,
   --                          S, LDS, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, KSTART, KSTOP, LDQ, LDS, N
   --       DOUBLE PRECISION   RHO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), DLAMDA( * ), Q( LDQ, * ), S( LDS, * ),
   --      $                   W( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAED9 finds the roots of the secular equation, as defined by the
   --  values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
   --  appropriate calls to DLAED4 and then stores the new matrix of
   --  eigenvectors for use in calculating the next level of Z vectors.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] K
   --           K is INTEGER
   --           The number of terms in the rational function to be solved by
   --           DLAED4.  K >= 0.
   --
   --  [in] KSTART
   --           KSTART is INTEGER
   --
   --  [in] KSTOP
   --           KSTOP is INTEGER
   --           The updated eigenvalues Lambda(I), KSTART <= I <= KSTOP
   --           are to be computed.  1 <= KSTART <= KSTOP <= K.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of rows and columns in the Q matrix.
   --           N >= K (delation may result in N > K).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           D(I) contains the updated eigenvalues
   --           for KSTART <= I <= KSTOP.
   --
   --  [out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ,N)
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --           The leading dimension of the array Q.  LDQ >= max( 1, N ).
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --           The value of the parameter in the rank one update equation.
   --           RHO >= 0 required.
   --
   --  [in] DLAMDA
   --           DLAMDA is DOUBLE PRECISION array, dimension (K)
   --           The first K elements of this array contain the old roots
   --           of the deflated updating problem.  These are the poles
   --           of the secular equation.
   --
   --  [in] W
   --           W is DOUBLE PRECISION array, dimension (K)
   --           The first K elements of this array contain the components
   --           of the deflation-adjusted updating vector.
   --
   --  [out] S
   --           S is DOUBLE PRECISION array, dimension (LDS, K)
   --           Will contain the eigenvectors of the repaired matrix which
   --           will be stored for subsequent Z vector calculation and
   --           multiplied by the previously accumulated eigenvectors
   --           to update the system.
   --
   --  [in] LDS
   --           LDS is INTEGER
   --           The leading dimension of S.  LDS >= max( 1, K ).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, an eigenvalue did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMC3, DNRM2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLAED4, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if K < 0 then
         INFO := -1;
      elsif KSTART < 1 or KSTART > max (1, K) then
         INFO := -2;
      elsif max (1, KSTOP) < KSTART or KSTOP > max (1, K) then
         INFO := -3;
      elsif N < K then
         INFO := -4;
      elsif LDQ < max (1, K) then
         INFO := -7;
      elsif LDS < max (1, K) then
         INFO := -12;
      end if;
      if INFO /= 0 then
         XERBLA ("DLAED9", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if K = 0 then
         return;
      end if;
      --
      --     Modify values DLAMDA(i) to make sure all DLAMDA(i)-DLAMDA(j) can
      --     be computed with high relative accuracy (barring over/underflow).
      --     This is a problem on machines without a guard digit in
      --     add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
      --     The following code replaces DLAMDA(I) by 2*DLAMDA(I)-DLAMDA(I),
      --     which on any of these machines zeros out the bottommost
      --     bit of DLAMDA(I) if it is 1; this makes the subsequent
      --     subtractions DLAMDA(I)-DLAMDA(J) unproblematic when cancellation
      --     occurs. On binary machines with a guard digit (almost all
      --     machines) it does not change DLAMDA(I) at all. On hexadecimal
      --     and decimal machines with a guard digit, it slightly
      --     changes the bottommost bits of DLAMDA(I). It does not account
      --     for hexadecimal or decimal machines without guard digits
      --     (we know of none). We use a subroutine call to compute
      --     2*DLAMBDA(I) to prevent optimizing compilers from eliminating
      --     this code.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         DLAMDA (I) := DLAMC3 (DLAMDA (I), DLAMDA (I)) - DLAMDA (I);
      end loop;
      --
      J := KSTART - 1;
      loop
         J := J + 1;
         exit when J > KSTOP;
         DLAED4 (K, J, DLAMDA'Address, W'Address, Q (1, J)'Address, RHO, D (J), INFO);
         --
         --        If the zero finder fails, the computation is terminated.
         --
         if INFO /= 0 then
            goto L120;
         end if;
      end loop;
      --
      if K = 1 or K = 2 then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > K;
               S (J, I) := Q (J, I);
            end loop;
         end loop;
         goto L120;
      end if;
      --
      --     Compute updated W.
      --
      DCOPY (K, W'Address, 1, S'Address, 1);
      --
      --     Initialize W(I) = Q(I,I)
      --
      DCOPY (K, Q'Address, LDQ + 1, W'Address, 1);
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > K;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > J - 1;
            W (I) := W (I) * (Q (I, J) / (DLAMDA (I) - DLAMDA (J)));
         end loop;
         I := J + 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            W (I) := W (I) * (Q (I, J) / (DLAMDA (I) - DLAMDA (J)));
         end loop;
      end loop;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         W (I) := sign (Sqrt (-W (I)), S (I, 1));
      end loop;
      --
      --     Compute eigenvectors of the modified rank-1 modification.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > K;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            Q (I, J) := W (I) / Q (I, J);
         end loop;
         TEMP := DNRM2 (K, Q (1, J)'Address, 1);
         I    := 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            S (I, J) := Q (I, J) / TEMP;
         end loop;
      end loop;
      --
      <<L120>> null;
      return;
      --
      --     End of DLAED9
      --
   end DLAED9;

   procedure DLAEDA
     (N          : Integer;
      TLVLS      : Integer;
      CURLVL     : Integer;
      CURPBM     : Integer;
      PRMPTR_adr : Address;
      PERM_adr   : Address;
      GIVPTR_adr : Address;
      GIVCOL_adr : Address;
      GIVNUM_adr : Address;
      Q_adr      : Address;
      QPTR_adr   : Address;
      Z_adr      : Address;
      ZTEMP_adr  : Address;
      INFO       : in out Integer)
   is

      N_Log2_N : constant Integer := N * (1 + intlog2 (N));

      PRMPTR : Ftn_Integer_Vector (1 .. N_Log2_N);
      PERM   : Ftn_Integer_Vector (1 .. N_Log2_N);
      GIVPTR : Ftn_Integer_Vector (1 .. N_Log2_N);
      GIVCOL : Ftn_Integer_Matrix (1 .. 2, 1 .. N_Log2_N);
      GIVNUM : Ftn_Real_Matrix (1 .. 2, 1 .. N_Log2_N);
      Q      : Ftn_Real_Vector (1 .. N * N);
      QPTR   : Ftn_Integer_Vector (1 .. N + 2);
      Z      : Ftn_Real_Vector (1 .. N);
      ZTEMP  : Ftn_Real_Vector (1 .. N);

      for PRMPTR'Address use PRMPTR_adr;
      for PERM'Address use PERM_adr;
      for GIVPTR'Address use GIVPTR_adr;
      for GIVCOL'Address use GIVCOL_adr;
      for GIVNUM'Address use GIVNUM_adr;
      for Q'Address use Q_adr;
      for QPTR'Address use QPTR_adr;
      for Z'Address use Z_adr;
      for ZTEMP'Address use ZTEMP_adr;

      pragma Import (Ada, PRMPTR);
      pragma Import (Ada, PERM);
      pragma Import (Ada, GIVPTR);
      pragma Import (Ada, GIVCOL);
      pragma Import (Ada, GIVNUM);
      pragma Import (Ada, Q);
      pragma Import (Ada, QPTR);
      pragma Import (Ada, Z);
      pragma Import (Ada, ZTEMP);

      ZERO  : constant Real := 0.0e0;
      HALF  : constant Real := 0.5e0;
      ONE   : constant Real := 1.0e0;
      BSIZ1 : Integer;
      BSIZ2 : Integer;
      CURR  : Integer;
      I     : Integer;
      K     : Integer;
      MID   : Integer;
      PSIZ1 : Integer;
      PSIZ2 : Integer;
      PTR   : Integer;
      ZPTR1 : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAEDA( N, TLVLS, CURLVL, CURPBM, PRMPTR, PERM, GIVPTR,
   --                          GIVCOL, GIVNUM, Q, QPTR, Z, ZTEMP, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            CURLVL, CURPBM, INFO, N, TLVLS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            GIVCOL( 2, * ), GIVPTR( * ), PERM( * ),
   --      $                   PRMPTR( * ), QPTR( * )
   --       DOUBLE PRECISION   GIVNUM( 2, * ), Q( * ), Z( * ), ZTEMP( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAEDA computes the Z vector corresponding to the merge step in the
   --  CURLVLth step of the merge process with TLVLS steps for the CURPBMth
   --  problem.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in] TLVLS
   --           TLVLS is INTEGER
   --          The total number of merging levels in the overall divide and
   --          conquer tree.
   --
   --  [in] CURLVL
   --           CURLVL is INTEGER
   --          The current level in the overall merge routine,
   --          0 <= curlvl <= tlvls.
   --
   --  [in] CURPBM
   --           CURPBM is INTEGER
   --          The current problem in the current level in the overall
   --          merge routine (counting from upper left to lower right).
   --
   --  [in] PRMPTR
   --           PRMPTR is INTEGER array, dimension (N lg N)
   --          Contains a list of pointers which indicate where in PERM a
   --          level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
   --          indicates the size of the permutation and incidentally the
   --          size of the full, non-deflated problem.
   --
   --  [in] PERM
   --           PERM is INTEGER array, dimension (N lg N)
   --          Contains the permutations (from deflation and sorting) to be
   --          applied to each eigenblock.
   --
   --  [in] GIVPTR
   --           GIVPTR is INTEGER array, dimension (N lg N)
   --          Contains a list of pointers which indicate where in GIVCOL a
   --          level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
   --          indicates the number of Givens rotations.
   --
   --  [in] GIVCOL
   --           GIVCOL is INTEGER array, dimension (2, N lg N)
   --          Each pair of numbers indicates a pair of columns to take place
   --          in a Givens rotation.
   --
   --  [in] GIVNUM
   --           GIVNUM is DOUBLE PRECISION array, dimension (2, N lg N)
   --          Each number indicates the S value to be used in the
   --          corresponding Givens rotation.
   --
   --  [in] Q
   --           Q is DOUBLE PRECISION array, dimension (N**2)
   --          Contains the square eigenblocks from previous levels, the
   --          starting positions for blocks are given by QPTR.
   --
   --  [in] QPTR
   --           QPTR is INTEGER array, dimension (N+2)
   --          Contains a list of pointers which indicate where in Q an
   --          eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
   --          the size of the block.
   --
   --  [out] Z
   --           Z is DOUBLE PRECISION array, dimension (N)
   --          On output this vector contains the updating vector (the last
   --          row of the first sub-eigenvector matrix and the first row of
   --          the second sub-eigenvector matrix).
   --
   --  [out] ZTEMP
   --           ZTEMP is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, HALF = 0.5D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DGEMV, DROT, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, INT, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if N < 0 then
         INFO := -1;
      end if;
      if INFO /= 0 then
         XERBLA ("DLAEDA", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     Determine location of first number in second half.
      --
      MID := N / 2 + 1;
      --
      --     Gather last/first rows of appropriate eigenblocks into center of Z
      --
      PTR := 1;
      --
      --     Determine location of lowest level subproblem in the full storage
      --     scheme
      --
      CURR := PTR + CURPBM * 2 ** CURLVL + 2 ** (CURLVL - 1) - 1;
      --
      --     Determine size of these matrices.  We add HALF to the value of
      --     the SQRT in case the machine underestimates one of these square
      --     roots.
      --
      BSIZ1 := int (HALF + Sqrt (Real (QPTR (CURR + 1) - QPTR (CURR))));
      BSIZ2 := int (HALF + Sqrt (Real (QPTR (CURR + 2) - QPTR (CURR + 1))));
      K     := 1 - 1;
      loop
         K := K + 1;
         exit when K > MID - BSIZ1 - 1;
         Z (K) := ZERO;
      end loop;
      DCOPY (BSIZ1, Q (QPTR (CURR) + BSIZ1 - 1)'Address, BSIZ1, Z (MID - BSIZ1)'Address, 1);
      DCOPY (BSIZ2, Q (QPTR (CURR + 1))'Address, BSIZ2, Z (MID)'Address, 1);
      K := MID + BSIZ2 - 1;
      loop
         K := K + 1;
         exit when K > N;
         Z (K) := ZERO;
      end loop;
      --
      --     Loop through remaining levels 1 -> CURLVL applying the Givens
      --     rotations and permutation and then multiplying the center matrices
      --     against the current Z.
      --
      PTR := 2 ** TLVLS + 1;
      K   := 1 - 1;
      loop
         K := K + 1;
         exit when K > CURLVL - 1;
         CURR  := PTR + CURPBM * 2 ** (CURLVL - K) + 2 ** (CURLVL - K - 1) - 1;
         PSIZ1 := PRMPTR (CURR + 1) - PRMPTR (CURR);
         PSIZ2 := PRMPTR (CURR + 2) - PRMPTR (CURR + 1);
         ZPTR1 := MID - PSIZ1;
         --
         --       Apply Givens at CURR and CURR+1
         --
         I := GIVPTR (CURR) - 1;
         loop
            I := I + 1;
            exit when I > GIVPTR (CURR + 1) - 1;
            DROT
              (1,
               Z (ZPTR1 + GIVCOL (1, I) - 1)'Address,
               1,
               Z (ZPTR1 + GIVCOL (2, I) - 1)'Address,
               1,
               GIVNUM (1, I),
               GIVNUM (2, I));
         end loop;
         I := GIVPTR (CURR + 1) - 1;
         loop
            I := I + 1;
            exit when I > GIVPTR (CURR + 2) - 1;
            DROT
              (1,
               Z (MID - 1 + GIVCOL (1, I))'Address,
               1,
               Z (MID - 1 + GIVCOL (2, I))'Address,
               1,
               GIVNUM (1, I),
               GIVNUM (2, I));
         end loop;
         PSIZ1 := PRMPTR (CURR + 1) - PRMPTR (CURR);
         PSIZ2 := PRMPTR (CURR + 2) - PRMPTR (CURR + 1);
         I     := 0 - 1;
         loop
            I := I + 1;
            exit when I > PSIZ1 - 1;
            ZTEMP (I + 1) := Z (ZPTR1 + PERM (PRMPTR (CURR) + I) - 1);
         end loop;
         I := 0 - 1;
         loop
            I := I + 1;
            exit when I > PSIZ2 - 1;
            ZTEMP (PSIZ1 + I + 1) := Z (MID + PERM (PRMPTR (CURR + 1) + I) - 1);
         end loop;
         --
         --        Multiply Blocks at CURR and CURR+1
         --
         --        Determine size of these matrices.  We add HALF to the value of
         --        the SQRT in case the machine underestimates one of these
         --        square roots.
         --
         BSIZ1 := int (HALF + Sqrt (Real (QPTR (CURR + 1) - QPTR (CURR))));
         BSIZ2 := int (HALF + Sqrt (Real (QPTR (CURR + 2) - QPTR (CURR + 1))));
         if BSIZ1 > 0 then
            DGEMV
              ('T',
               BSIZ1,
               BSIZ1,
               ONE,
               Q (QPTR (CURR))'Address,
               BSIZ1,
               ZTEMP (1)'Address,
               1,
               ZERO,
               Z (ZPTR1)'Address,
               1);
         end if;
         DCOPY (PSIZ1 - BSIZ1, ZTEMP (BSIZ1 + 1)'Address, 1, Z (ZPTR1 + BSIZ1)'Address, 1);
         if BSIZ2 > 0 then
            DGEMV
              ('T',
               BSIZ2,
               BSIZ2,
               ONE,
               Q (QPTR (CURR + 1))'Address,
               BSIZ2,
               ZTEMP (PSIZ1 + 1)'Address,
               1,
               ZERO,
               Z (MID)'Address,
               1);
         end if;
         DCOPY (PSIZ2 - BSIZ2, ZTEMP (PSIZ1 + BSIZ2 + 1)'Address, 1, Z (MID + BSIZ2)'Address, 1);
         --
         PTR := PTR + 2 ** (TLVLS - K);
      end loop;
      --
      return;
      --
      --     End of DLAEDA
      --
   end DLAEDA;

   procedure DLAEV2
     (A   : Real;
      B   : Real;
      C   : Real;
      RT1 : in out Real;
      RT2 : in out Real;
      CS1 : in out Real;
      SN1 : in out Real)
   is
      ONE  : constant Real := 1.0e0;
      TWO  : constant Real := 2.0e0;
      ZERO : constant Real := 0.0e0;
      HALF : constant Real := 0.5e0;
      SGN1 : Integer;
      SGN2 : Integer;
      AB   : Real;
      ACMN : Real;
      ACMX : Real;
      ACS  : Real;
      ADF  : Real;
      CS   : Real;
      CT   : Real;
      DF   : Real;
      RT   : Real;
      SM   : Real;
      TB   : Real;
      TN   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAEV2( A, B, C, RT1, RT2, CS1, SN1 )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   A, B, C, CS1, RT1, RT2, SN1
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
   --     [  A   B  ]
   --     [  B   C  ].
   --  On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
   --  eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
   --  eigenvector for RT1, giving the decomposition
   --
   --     [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
   --     [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
   --
   --  Arguments:
   --  ==========
   --
   --  [in] A
   --           A is DOUBLE PRECISION
   --           The (1,1) element of the 2-by-2 matrix.
   --
   --  [in] B
   --           B is DOUBLE PRECISION
   --           The (1,2) element and the conjugate of the (2,1) element of
   --           the 2-by-2 matrix.
   --
   --  [in] C
   --           C is DOUBLE PRECISION
   --           The (2,2) element of the 2-by-2 matrix.
   --
   --  [out] RT1
   --           RT1 is DOUBLE PRECISION
   --           The eigenvalue of larger absolute value.
   --
   --  [out] RT2
   --           RT2 is DOUBLE PRECISION
   --           The eigenvalue of smaller absolute value.
   --
   --  [out] CS1
   --           CS1 is DOUBLE PRECISION
   --
   --  [out] SN1
   --           SN1 is DOUBLE PRECISION
   --           The vector (CS1, SN1) is a unit right eigenvector for RT1.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   RT1 is accurate to a few ulps barring over/underflow.
   --
   --   RT2 may be inaccurate if there is massive cancellation in the
   --   determinant A*C-B*B; higher precision or correctly rounded or
   --   correctly truncated arithmetic would be needed to compute RT2
   --   accurately in all cases.
   --
   --   CS1 and SN1 are accurate to a few ulps barring over/underflow.
   --
   --   Overflow is possible only if RT1 is within a factor of 5 of overflow.
   --   Underflow is harmless if the input data is 0 or exceeds
   --      underflow_threshold / macheps.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D0 )
   --      PARAMETER          ( TWO = 2.0D0 )
   --      PARAMETER          ( ZERO = 0.0D0 )
   --      PARAMETER          ( HALF = 0.5D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Compute the eigenvalues
   --
   begin
      SM  := A + C;
      DF  := A - C;
      ADF := abs (DF);
      TB  := B + B;
      AB  := abs (TB);
      if abs (A) > abs (C) then
         ACMX := A;
         ACMN := C;
      else
         ACMX := C;
         ACMN := A;
      end if;
      if ADF > AB then
         RT := ADF * Sqrt (ONE + (AB / ADF) ** 2);
      elsif ADF < AB then
         RT := AB * Sqrt (ONE + (ADF / AB) ** 2);
      else
         --
         --        Includes case AB=ADF=0
         --
         RT := AB * Sqrt (TWO);
      end if;
      if SM < ZERO then
         RT1  := HALF * (SM - RT);
         SGN1 := -1;
         --
         --        Order of execution important.
         --        To get fully accurate smaller eigenvalue,
         --        next line needs to be executed in higher precision.
         --
         RT2 := (ACMX / RT1) * ACMN - (B / RT1) * B;
      elsif SM > ZERO then
         RT1  := HALF * (SM + RT);
         SGN1 := 1;
         --
         --        Order of execution important.
         --        To get fully accurate smaller eigenvalue,
         --        next line needs to be executed in higher precision.
         --
         RT2 := (ACMX / RT1) * ACMN - (B / RT1) * B;
      else
         --
         --        Includes case RT1 = RT2 = 0
         --
         RT1  := HALF * RT;
         RT2  := -HALF * RT;
         SGN1 := 1;
      end if;
      --
      --     Compute the eigenvector
      --
      if DF >= ZERO then
         CS   := DF + RT;
         SGN2 := 1;
      else
         CS   := DF - RT;
         SGN2 := -1;
      end if;
      ACS := abs (CS);
      if ACS > AB then
         CT  := -TB / CS;
         SN1 := ONE / Sqrt (ONE + CT * CT);
         CS1 := CT * SN1;
      else
         if AB = ZERO then
            CS1 := ONE;
            SN1 := ZERO;
         else
            TN  := -CS / TB;
            CS1 := ONE / Sqrt (ONE + TN * TN);
            SN1 := TN * CS1;
         end if;
      end if;
      if SGN1 = SGN2 then
         TN  := CS1;
         CS1 := -SN1;
         SN1 := TN;
      end if;
      return;
      --
      --     End of DLAEV2
      --
   end DLAEV2;

   procedure DLAEXC
     (WANTQ : Boolean;
      N     : Integer;
      T     : in out Ftn_Real_Matrix;
      LDT   : Integer;
      Q     : in out Ftn_Real_Matrix;
      LDQ   : Integer;
      J1    : Integer;
      N1    : Integer;
      N2    : Integer;
      WORK  : in out Ftn_Real_Vector;
      INFO  : in out Integer)
   is
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      TEN    : constant Real    := 10.0e0;
      LDD    : constant Integer := 4;
      LDX    : constant Integer := 2;
      IERR   : Integer;
      J2     : Integer;
      J3     : Integer;
      J4     : Integer;
      K      : Integer;
      ND     : Integer;
      CS     : Real;
      DNORM  : Real;
      EPS    : Real;
      SCALE  : Real;
      SMLNUM : Real;
      SN     : Real;
      T11    : Real;
      T22    : Real;
      T33    : Real;
      TAU    : Real;
      TAU1   : Real;
      TAU2   : Real;
      TEMP   : Real;
      THRESH : Real;
      WI1    : Real;
      WI2    : Real;
      WR1    : Real;
      WR2    : Real;
      XNORM  : Real;
      D      : Ftn_Real_Matrix (1 .. LDD, 1 .. 4);
      U      : Ftn_Real_Vector (1 .. 3);
      U1     : Ftn_Real_Vector (1 .. 3);
      U2     : Ftn_Real_Vector (1 .. 3);
      X      : Ftn_Real_Matrix (1 .. LDX, 1 .. 2);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAEXC( WANTQ, N, T, LDT, Q, LDQ, J1, N1, N2, WORK,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       LOGICAL            WANTQ
   --       INTEGER            INFO, J1, LDQ, LDT, N, N1, N2
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   Q( LDQ, * ), T( LDT, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
   --  an upper quasi-triangular matrix T by an orthogonal similarity
   --  transformation.
   --
   --  T must be in Schur canonical form, that is, block upper triangular
   --  with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
   --  has its diagonal elemnts equal and its off-diagonal elements of
   --  opposite sign.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTQ
   --           WANTQ is LOGICAL
   --           = .TRUE. : accumulate the transformation in the matrix Q;
   --           = .FALSE.: do not accumulate the transformation.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix T. N >= 0.
   --
   --  [in,out] T
   --           T is DOUBLE PRECISION array, dimension (LDT,N)
   --           On entry, the upper quasi-triangular matrix T, in Schur
   --           canonical form.
   --           On exit, the updated matrix T, again in Schur canonical form.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= max(1,N).
   --
   --  [in,out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ,N)
   --           On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
   --           On exit, if WANTQ is .TRUE., the updated matrix Q.
   --           If WANTQ is .FALSE., Q is not referenced.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --           The leading dimension of the array Q.
   --           LDQ >= 1; and if WANTQ is .TRUE., LDQ >= N.
   --
   --  [in] J1
   --           J1 is INTEGER
   --           The index of the first row of the first block T11.
   --
   --  [in] N1
   --           N1 is INTEGER
   --           The order of the first block T11. N1 = 0, 1 or 2.
   --
   --  [in] N2
   --           N2 is INTEGER
   --           The order of the second block T22. N2 = 0, 1 or 2.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           = 1: the transformed matrix T would be too far from Schur
   --                form; the blocks are not swapped and T and Q are
   --                unchanged.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( TEN = 1.0D+1 )
   --      PARAMETER          ( LDD = 4, LDX = 2 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH, DLANGE
   --      EXTERNAL           DLAMCH, DLANGE
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLACPY, DLANV2, DLARFG, DLARFX, DLARTG, DLASY2, DROT
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO := 0;
      --
      --     Quick return if possible
      --
      if N = 0 or N1 = 0 or N2 = 0 then
         return;
      end if;
      if J1 + N1 > N then
         return;
      end if;
      --
      J2 := J1 + 1;
      J3 := J1 + 2;
      J4 := J1 + 3;
      --
      if N1 = 1 and N2 = 1 then
         --
         --        Swap two 1-by-1 blocks.
         --
         T11 := T (J1, J1);
         T22 := T (J2, J2);
         --
         --        Determine the transformation to perform the interchange.
         --
         DLARTG (T (J1, J2), T22 - T11, CS, SN, TEMP);
         --
         --        Apply transformation to the matrix T.
         --
         if J3 <= N then
            DROT (N - J1 - 1, T (J1, J3)'Address, LDT, T (J2, J3)'Address, LDT, CS, SN);
         end if;
         DROT (J1 - 1, T (1, J1)'Address, 1, T (1, J2)'Address, 1, CS, SN);
         --
         T (J1, J1) := T22;
         T (J2, J2) := T11;
         --
         if WANTQ then
            --
            --           Accumulate transformation in the matrix Q.
            --
            DROT (N, Q (1, J1)'Address, 1, Q (1, J2)'Address, 1, CS, SN);
         end if;
      --
      else
         --
         --        Swapping involves at least one 2-by-2 block.
         --
         --        Copy the diagonal block of order N1+N2 to the local array D
         --        and compute its norm.
         --
         ND := N1 + N2;
         DLACPY ('F', ND, ND, T (J1, J1)'Address, LDT, D'Address, LDD);
         DNORM := DLANGE ('M', ND, ND, D, LDD, WORK);
         --
         --        Compute machine-dependent threshold for test for accepting
         --        swap.
         --
         EPS    := DLAMCH ('P');
         SMLNUM := DLAMCH ('S') / EPS;
         THRESH := max (TEN * EPS * DNORM, SMLNUM);
         --
         --        Solve T11*X - X*T22 = scale*T12 for X.
         --
         DLASY2
           (False,
            False,
            -1,
            N1,
            N2,
            D'Address,
            LDD,
            D (N1 + 1, N1 + 1)'Address,
            LDD,
            D (1, N1 + 1)'Address,
            LDD,
            SCALE,
            X'Address,
            LDX,
            XNORM,
            IERR);
         --
         --        Swap the adjacent diagonal blocks.
         --
         K := N1 + N1 + N2 - 3;
         --         GO TO ( 10, 20, 30 )K
         if K = 1 then
            goto L10;
         elsif K = 2 then
            goto L20;
         elsif K = 3 then
            goto L30;
         end if;
         --
         <<L10>> null;
         --
         --        N1 = 1, N2 = 2: generate elementary reflector H so that:
         --
         --        ( scale, X11, X12 ) H = ( 0, 0, * )
         --
         U (1) := SCALE;
         U (2) := X (1, 1);
         U (3) := X (1, 2);
         DLARFG (3, U (3), U'Address, 1, TAU);
         U (3) := ONE;
         T11   := T (J1, J1);
         --
         --        Perform swap provisionally on diagonal block in D.
         --
         DLARFX ('L', 3, 3, U'Address, TAU, D'Address, LDD, WORK'Address);
         DLARFX ('R', 3, 3, U'Address, TAU, D'Address, LDD, WORK'Address);
         --
         --        Test whether to reject swap.
         --
         if max (abs (D (3, 1)), abs (D (3, 2)), abs (D (3, 3) - T11)) > THRESH then
            goto L50;
         end if;
         --
         --        Accept swap: apply transformation to the entire matrix T.
         --
         DLARFX ('L', 3, N - J1 + 1, U'Address, TAU, T (J1, J1)'Address, LDT, WORK'Address);
         DLARFX ('R', J2, 3, U'Address, TAU, T (1, J1)'Address, LDT, WORK'Address);
         --
         T (J3, J1) := ZERO;
         T (J3, J2) := ZERO;
         T (J3, J3) := T11;
         --
         if WANTQ then
            --
            --           Accumulate transformation in the matrix Q.
            --
            DLARFX ('R', N, 3, U'Address, TAU, Q (1, J1)'Address, LDQ, WORK'Address);
         end if;
         goto L40;
         --
         <<L20>> null;
         --
         --        N1 = 2, N2 = 1: generate elementary reflector H so that:
         --
         --        H (  -X11 ) = ( * )
         --          (  -X21 ) = ( 0 )
         --          ( scale ) = ( 0 )
         --
         U (1) := -X (1, 1);
         U (2) := -X (2, 1);
         U (3) := SCALE;
         DLARFG (3, U (1), U (2)'Address, 1, TAU);
         U (1) := ONE;
         T33   := T (J3, J3);
         --
         --        Perform swap provisionally on diagonal block in D.
         --
         DLARFX ('L', 3, 3, U'Address, TAU, D'Address, LDD, WORK'Address);
         DLARFX ('R', 3, 3, U'Address, TAU, D'Address, LDD, WORK'Address);
         --
         --        Test whether to reject swap.
         --
         if max (abs (D (2, 1)), abs (D (3, 1)), abs (D (1, 1) - T33)) > THRESH then
            goto L50;
         end if;
         --
         --        Accept swap: apply transformation to the entire matrix T.
         --
         DLARFX ('R', J3, 3, U'Address, TAU, T (1, J1)'Address, LDT, WORK'Address);
         DLARFX ('L', 3, N - J1, U'Address, TAU, T (J1, J2)'Address, LDT, WORK'Address);
         --
         T (J1, J1) := T33;
         T (J2, J1) := ZERO;
         T (J3, J1) := ZERO;
         --
         if WANTQ then
            --
            --           Accumulate transformation in the matrix Q.
            --
            DLARFX ('R', N, 3, U'Address, TAU, Q (1, J1)'Address, LDQ, WORK'Address);
         end if;
         goto L40;
         --
         <<L30>> null;
         --
         --        N1 = 2, N2 = 2: generate elementary reflectors H(1) and H(2) so
         --        that:
         --
         --        H(2) H(1) (  -X11  -X12 ) = (  *  * )
         --                  (  -X21  -X22 )   (  0  * )
         --                  ( scale    0  )   (  0  0 )
         --                  (    0  scale )   (  0  0 )
         --
         U1 (1) := -X (1, 1);
         U1 (2) := -X (2, 1);
         U1 (3) := SCALE;
         DLARFG (3, U1 (1), U1 (2)'Address, 1, TAU1);
         U1 (1) := ONE;
         --
         TEMP   := -TAU1 * (X (1, 2) + U1 (2) * X (2, 2));
         U2 (1) := -TEMP * U1 (2) - X (2, 2);
         U2 (2) := -TEMP * U1 (3);
         U2 (3) := SCALE;
         DLARFG (3, U2 (1), U2 (2)'Address, 1, TAU2);
         U2 (1) := ONE;
         --
         --        Perform swap provisionally on diagonal block in D.
         --
         DLARFX ('L', 3, 4, U1'Address, TAU1, D'Address, LDD, WORK'Address);
         DLARFX ('R', 4, 3, U1'Address, TAU1, D'Address, LDD, WORK'Address);
         DLARFX ('L', 3, 4, U2'Address, TAU2, D (2, 1)'Address, LDD, WORK'Address);
         DLARFX ('R', 4, 3, U2'Address, TAU2, D (1, 2)'Address, LDD, WORK'Address);
         --
         --        Test whether to reject swap.
         --
         if max (abs (D (3, 1)), abs (D (3, 2)), abs (D (4, 1)), abs (D (4, 2))) > THRESH then
            goto L50;
         end if;
         --
         --        Accept swap: apply transformation to the entire matrix T.
         --
         DLARFX ('L', 3, N - J1 + 1, U1'Address, TAU1, T (J1, J1)'Address, LDT, WORK'Address);
         DLARFX ('R', J4, 3, U1'Address, TAU1, T (1, J1)'Address, LDT, WORK'Address);
         DLARFX ('L', 3, N - J1 + 1, U2'Address, TAU2, T (J2, J1)'Address, LDT, WORK'Address);
         DLARFX ('R', J4, 3, U2'Address, TAU2, T (1, J2)'Address, LDT, WORK'Address);
         --
         T (J3, J1) := ZERO;
         T (J3, J2) := ZERO;
         T (J4, J1) := ZERO;
         T (J4, J2) := ZERO;
         --
         if WANTQ then
            --
            --           Accumulate transformation in the matrix Q.
            --
            DLARFX ('R', N, 3, U1'Address, TAU1, Q (1, J1)'Address, LDQ, WORK'Address);
            DLARFX ('R', N, 3, U2'Address, TAU2, Q (1, J2)'Address, LDQ, WORK'Address);
         end if;
         --
         <<L40>> null;
         --
         if N2 = 2 then
            --
            --           Standardize new 2-by-2 block T11
            --
            DLANV2 (T (J1, J1), T (J1, J2), T (J2, J1), T (J2, J2), WR1, WI1, WR2, WI2, CS, SN);
            DROT (N - J1 - 1, T (J1, J1 + 2)'Address, LDT, T (J2, J1 + 2)'Address, LDT, CS, SN);
            DROT (J1 - 1, T (1, J1)'Address, 1, T (1, J2)'Address, 1, CS, SN);
            if WANTQ then
               DROT (N, Q (1, J1)'Address, 1, Q (1, J2)'Address, 1, CS, SN);
            end if;
         end if;
         --
         if N1 = 2 then
            --
            --           Standardize new 2-by-2 block T22
            --
            J3 := J1 + N2;
            J4 := J3 + 1;
            DLANV2 (T (J3, J3), T (J3, J4), T (J4, J3), T (J4, J4), WR1, WI1, WR2, WI2, CS, SN);
            if J3 + 2 <= N then
               DROT (N - J3 - 1, T (J3, J3 + 2)'Address, LDT, T (J4, J3 + 2)'Address, LDT, CS, SN);
            end if;
            DROT (J3 - 1, T (1, J3)'Address, 1, T (1, J4)'Address, 1, CS, SN);
            if WANTQ then
               DROT (N, Q (1, J3)'Address, 1, Q (1, J4)'Address, 1, CS, SN);
            end if;
         end if;
         --
      end if;
      return;
      --
      --     Exit with INFO = 1 if swap was rejected.
      --
      <<L50>> null;
      INFO := 1;
      return;
      --
      --     End of DLAEXC
      --
   end DLAEXC;

   procedure DLAHQR
     (WANTT  : Boolean;
      WANTZ  : Boolean;
      N      : Integer;
      ILO    : Integer;
      IHI    : Integer;
      H_adr  : Address;
      LDH    : Integer;
      WR_adr : Address;
      WI_adr : Address;
      ILOZ   : Integer;
      IHIZ   : Integer;
      Z_adr  : Address;
      LDZ    : Integer;
      INFO   : in out Integer)
   is

      H  : Ftn_Real_Matrix (1 .. LDH, 1 .. N);
      WR : Ftn_Real_Vector (1 .. N);
      WI : Ftn_Real_Vector (1 .. N);
      Z  : Ftn_Real_Matrix (1 .. LDZ, 1 .. N);

      for H'Address use H_adr;
      for WR'Address use WR_adr;
      for WI'Address use WI_adr;
      for Z'Address use Z_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, WR);
      pragma Import (Ada, WI);
      pragma Import (Ada, Z);

      ITMAX  : constant Integer := 30;
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      TWO    : constant Real    := 2.0e0;
      DAT1   : constant Real    := 0.75e0;
      DAT2   : constant Real    := -0.4375e0;
      AA     : Real;
      AB     : Real;
      BA     : Real;
      BB     : Real;
      CS     : Real;
      DET    : Real;
      H11    : Real;
      H12    : Real;
      H21    : Real;
      H21S   : Real;
      H22    : Real;
      RT1I   : Real;
      RT1R   : Real;
      RT2I   : Real;
      RT2R   : Real;
      RTDISC : Real;
      S      : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SMLNUM : Real;
      SN     : Real;
      SUM    : Real;
      T1     : Real;
      T2     : Real;
      T3     : Real;
      TR     : Real;
      TST    : Real;
      ULP    : Real;
      V2     : Real;
      V3     : Real;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      ITS    : Integer;
      J      : Integer;
      K      : Integer;
      L      : Integer;
      M      : Integer;
      NH     : Integer;
      NR     : Integer;
      NZ     : Integer;
      V      : Ftn_Real_Vector (1 .. 3);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAHQR( WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI,
   --                          ILOZ, IHIZ, Z, LDZ, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, N
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   H( LDH, * ), WI( * ), WR( * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DLAHQR is an auxiliary routine called by DHSEQR to update the
   --     eigenvalues and Schur decomposition already computed by DHSEQR, by
   --     dealing with the Hessenberg submatrix in rows and columns ILO to
   --     IHI.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           = .TRUE. : the full Schur form T is required;
   --           = .FALSE.: only eigenvalues are required.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           = .TRUE. : the matrix of Schur vectors Z is required;
   --           = .FALSE.: Schur vectors are not required.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix H.  N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --           It is assumed that H is already upper quasi-triangular in
   --           rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
   --           ILO = 1). DLAHQR works primarily with the Hessenberg
   --           submatrix in rows and columns ILO to IHI, but applies
   --           transformations to all of H if WANTT is .TRUE..
   --           1 <= ILO <= max(1,IHI); IHI <= N.
   --
   --  [in,out] H
   --           H is DOUBLE PRECISION array, dimension (LDH,N)
   --           On entry, the upper Hessenberg matrix H.
   --           On exit, if INFO is zero and if WANTT is .TRUE., H is upper
   --           quasi-triangular in rows and columns ILO:IHI, with any
   --           2-by-2 diagonal blocks in standard form. If INFO is zero
   --           and WANTT is .FALSE., the contents of H are unspecified on
   --           exit.  The output state of H if INFO is nonzero is given
   --           below under the description of INFO.
   --
   --  [in] LDH
   --           LDH is INTEGER
   --           The leading dimension of the array H. LDH >= max(1,N).
   --
   --  [out] WR
   --           WR is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] WI
   --           WI is DOUBLE PRECISION array, dimension (N)
   --           The real and imaginary parts, respectively, of the computed
   --           eigenvalues ILO to IHI are stored in the corresponding
   --           elements of WR and WI. If two eigenvalues are computed as a
   --           complex conjugate pair, they are stored in consecutive
   --           elements of WR and WI, say the i-th and (i+1)th, with
   --           WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the
   --           eigenvalues are stored in the same order as on the diagonal
   --           of the Schur form returned in H, with WR(i) = H(i,i), and, if
   --           H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
   --           WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --           Specify the rows of Z to which transformations must be
   --           applied if WANTZ is .TRUE..
   --           1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension (LDZ,N)
   --           If WANTZ is .TRUE., on entry Z must contain the current
   --           matrix Z of transformations accumulated by DHSEQR, and on
   --           exit Z has been updated; transformations are applied only to
   --           the submatrix Z(ILOZ:IHIZ,ILO:IHI).
   --           If WANTZ is .FALSE., Z is not referenced.
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --           The leading dimension of the array Z. LDZ >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --            =   0: successful exit
   --           .GT. 0: If INFO = i, DLAHQR failed to compute all the
   --                   eigenvalues ILO to IHI in a total of 30 iterations
   --                   per eigenvalue; elements i+1:ihi of WR and WI
   --                   contain those eigenvalues which have been
   --                   successfully computed.
   --
   --                   If INFO .GT. 0 and WANTT is .FALSE., then on exit,
   --                   the remaining unconverged eigenvalues are the
   --                   eigenvalues of the upper Hessenberg matrix rows
   --                   and columns ILO thorugh INFO of the final, output
   --                   value of H.
   --
   --                   If INFO .GT. 0 and WANTT is .TRUE., then on exit
   --           (*)       (initial value of H)*U  = U*(final value of H)
   --                   where U is an orthognal matrix.    The final
   --                   value of H is upper Hessenberg and triangular in
   --                   rows and columns INFO+1 through IHI.
   --
   --                   If INFO .GT. 0 and WANTZ is .TRUE., then on exit
   --                       (final value of Z)  = (initial value of Z)*U
   --                   where U is the orthogonal matrix in (*)
   --                   (regardless of the value of WANTT.)
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --      02-96 Based on modifications by
   --      David Day, Sandia National Laboratory, USA
   --
   --      12-04 Further modifications by
   --      Ralph Byers, University of Kansas, USA
   --      This is a modified version of DLAHQR from LAPACK version 3.0.
   --      It is (1) more robust against overflow and underflow and
   --      (2) adopts the more conservative Ahues & Tisseur stopping
   --      criterion (LAWN 122, 1997).
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =========================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ITMAX = 30 )
   --      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0, TWO = 2.0d0 )
   --      PARAMETER          ( DAT1 = 3.0d0 / 4.0d0, DAT2 = -0.4375d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLABAD, DLANV2, DLARFG, DROT
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO := 0;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      if ILO = IHI then
         WR (ILO) := H (ILO, ILO);
         WI (ILO) := ZERO;
         return;
      end if;
      --
      --     ==== clear out the trash ====
      J := ILO - 1;
      loop
         J := J + 1;
         exit when J > IHI - 3;
         H (J + 2, J) := ZERO;
         H (J + 3, J) := ZERO;
      end loop;
      if ILO <= IHI - 2 then
         H (IHI, IHI - 2) := ZERO;
      end if;
      --
      NH := IHI - ILO + 1;
      NZ := IHIZ - ILOZ + 1;
      --
      --     Set machine-dependent constants for the stopping criterion.
      --
      SAFMIN := DLAMCH ('S');
      SAFMAX := ONE / SAFMIN;
      DLABAD (SAFMIN, SAFMAX);
      ULP    := DLAMCH ('P');
      SMLNUM := SAFMIN * (Real (NH) / ULP);
      --
      --     I1 and I2 are the indices of the first row and last column of H
      --     to which transformations must be applied. If eigenvalues only are
      --     being computed, I1 and I2 are set inside the main loop.
      --
      if WANTT then
         I1 := 1;
         I2 := N;
      end if;
      --
      --     The main loop begins here. I is the loop index and decreases from
      --     IHI to ILO in steps of 1 or 2. Each iteration of the loop works
      --     with the active submatrix in rows and columns L to I.
      --     Eigenvalues I+1 to IHI have already converged. Either L = ILO or
      --     H(L,L-1) is negligible so that the matrix splits.
      --
      I := IHI;
      <<L20>> null;
      L := ILO;
      if I < ILO then
         goto L160;
      end if;
      --
      --     Perform QR iterations on rows and columns ILO to I until a
      --     submatrix of order 1 or 2 splits off at the bottom because a
      --     subdiagonal element has become negligible.
      --
      ITS := 0 - 1;
      loop
         ITS := ITS + 1;
         exit when ITS > ITMAX;
         --
         --        Look for a single small subdiagonal element.
         --
         K := I + 1;
         loop
            K := K - 1;
            exit when K < L + 1;
            if abs (H (K, K - 1)) <= SMLNUM then
               goto L40;
            end if;
            TST := abs (H (K - 1, K - 1)) + abs (H (K, K));
            if TST = ZERO then
               if K - 2 >= ILO then
                  TST := TST + abs (H (K - 1, K - 2));
               end if;
               if K + 1 <= IHI then
                  TST := TST + abs (H (K + 1, K));
               end if;
            end if;
            --           ==== The following is a conservative small subdiagonal
            --           .    deflation  criterion due to Ahues & Tisseur (LAWN 122,
            --           .    1997). It has better mathematical foundation and
            --           .    improves accuracy in some cases.  ====
            if abs (H (K, K - 1)) <= ULP * TST then
               AB := max (abs (H (K, K - 1)), abs (H (K - 1, K)));
               BA := min (abs (H (K, K - 1)), abs (H (K - 1, K)));
               AA := max (abs (H (K, K)), abs (H (K - 1, K - 1) - H (K, K)));
               BB := min (abs (H (K, K)), abs (H (K - 1, K - 1) - H (K, K)));
               S  := AA + AB;
               if BA * (AB / S) <= max (SMLNUM, ULP * (BB * (AA / S))) then
                  goto L40;
               end if;
            end if;
         end loop;
         <<L40>> null;
         L := K;
         if L > ILO then
            --
            --           H(L,L-1) is negligible
            --
            H (L, L - 1) := ZERO;
         end if;
         --
         --        Exit from loop if a submatrix of order 1 or 2 has split off.
         --
         if L >= I - 1 then
            goto L150;
         end if;
         --
         --        Now the active submatrix is in rows and columns L to I. If
         --        eigenvalues only are being computed, only the active submatrix
         --        need be transformed.
         --
         if not WANTT then
            I1 := L;
            I2 := I;
         end if;
         --
         if ITS = 10 then
            --
            --           Exceptional shift.
            --
            S   := abs (H (L + 1, L)) + abs (H (L + 2, L + 1));
            H11 := DAT1 * S + H (L, L);
            H12 := DAT2 * S;
            H21 := S;
            H22 := H11;
         elsif ITS = 20 then
            --
            --           Exceptional shift.
            --
            S   := abs (H (I, I - 1)) + abs (H (I - 1, I - 2));
            H11 := DAT1 * S + H (I, I);
            H12 := DAT2 * S;
            H21 := S;
            H22 := H11;
         else
            --
            --           Prepare to use Francis' Real shift
            --           (i.e. 2nd degree generalized Rayleigh quotient)
            --
            H11 := H (I - 1, I - 1);
            H21 := H (I, I - 1);
            H12 := H (I - 1, I);
            H22 := H (I, I);
         end if;
         S := abs (H11) + abs (H12) + abs (H21) + abs (H22);
         if S = ZERO then
            RT1R := ZERO;
            RT1I := ZERO;
            RT2R := ZERO;
            RT2I := ZERO;
         else
            H11    := H11 / S;
            H21    := H21 / S;
            H12    := H12 / S;
            H22    := H22 / S;
            TR     := (H11 + H22) / TWO;
            DET    := (H11 - TR) * (H22 - TR) - H12 * H21;
            RTDISC := Sqrt (abs (DET));
            if DET >= ZERO then
               --
               --              ==== complex conjugate shifts ====
               --
               RT1R := TR * S;
               RT2R := RT1R;
               RT1I := RTDISC * S;
               RT2I := -RT1I;
            else
               --
               --              ==== real shifts (use only one of them)  ====
               --
               RT1R := TR + RTDISC;
               RT2R := TR - RTDISC;
               if abs (RT1R - H22) <= abs (RT2R - H22) then
                  RT1R := RT1R * S;
                  RT2R := RT1R;
               else
                  RT2R := RT2R * S;
                  RT1R := RT2R;
               end if;
               RT1I := ZERO;
               RT2I := ZERO;
            end if;
         end if;
         --
         --        Look for two consecutive small subdiagonal elements.
         --
         M := I - 2 + 1;
         loop
            M := M - 1;
            exit when M < L;
            --           Determine the effect of starting the Real-shift QR
            --           iteration at row M, and see if this would make H(M,M-1)
            --           negligible.  (The following uses scaling to avoid
            --           overflows and most underflows.)
            --
            H21S  := H (M + 1, M);
            S     := abs (H (M, M) - RT2R) + abs (RT2I) + abs (H21S);
            H21S  := H (M + 1, M) / S;
            V (1) := H21S * H (M, M + 1) + (H (M, M) - RT1R) * ((H (M, M) - RT2R) / S) - RT1I * (RT2I / S);
            V (2) := H21S * (H (M, M) + H (M + 1, M + 1) - RT1R - RT2R);
            V (3) := H21S * H (M + 2, M + 1);
            S     := abs (V (1)) + abs (V (2)) + abs (V (3));
            V (1) := V (1) / S;
            V (2) := V (2) / S;
            V (3) := V (3) / S;
            if M = L then
               goto L60;
            end if;
            if abs (H (M, M - 1)) * (abs (V (2)) + abs (V (3))) <=
               ULP * abs (V (1)) * (abs (H (M - 1, M - 1)) + abs (H (M, M)) + abs (H (M + 1, M + 1)))
            then
               goto L60;
            end if;
         end loop;
         <<L60>> null;
         --
         --        Real-shift QR step
         --
         K := M - 1;
         loop
            K := K + 1;
            exit when K > I - 1;
            --
            --           The first iteration of this loop determines a reflection G
            --           from the vector V and applies it from left and right to H,
            --           thus creating a nonzero bulge below the subdiagonal.
            --
            --           Each subsequent iteration determines a reflection G to
            --           restore the Hessenberg form in the (K-1)th column, and thus
            --           chases the bulge one step toward the bottom of the active
            --           submatrix. NR is the order of G.
            --
            NR := min (3, I - K + 1);
            if K > M then
               DCOPY (NR, H (K, K - 1)'Address, 1, V'Address, 1);
            end if;
            DLARFG (NR, V (1), V (2)'Address, 1, T1);
            if K > M then
               H (K, K - 1)     := V (1);
               H (K + 1, K - 1) := ZERO;
               if K < I - 1 then
                  H (K + 2, K - 1) := ZERO;
               end if;
            elsif M > L then
               --               ==== Use the following instead of
               --               .    H( K, K-1 ) = -H( K, K-1 ) to
               --               .    avoid a bug when v(2) and v(3)
               --               .    underflow. ====
               H (K, K - 1) := H (K, K - 1) * (ONE - T1);
            end if;
            V2 := V (2);
            T2 := T1 * V2;
            if NR = 3 then
               V3 := V (3);
               T3 := T1 * V3;
               --
               --              Apply G from the left to transform the rows of the matrix
               --              in columns K to I2.
               --
               J := K - 1;
               loop
                  J := J + 1;
                  exit when J > I2;
                  SUM          := H (K, J) + V2 * H (K + 1, J) + V3 * H (K + 2, J);
                  H (K, J)     := H (K, J) - SUM * T1;
                  H (K + 1, J) := H (K + 1, J) - SUM * T2;
                  H (K + 2, J) := H (K + 2, J) - SUM * T3;
               end loop;
               --
               --              Apply G from the right to transform the columns of the
               --              matrix in rows I1 to min(K+3,I).
               --
               J := I1 - 1;
               loop
                  J := J + 1;
                  exit when J > min (K + 3, I);
                  SUM          := H (J, K) + V2 * H (J, K + 1) + V3 * H (J, K + 2);
                  H (J, K)     := H (J, K) - SUM * T1;
                  H (J, K + 1) := H (J, K + 1) - SUM * T2;
                  H (J, K + 2) := H (J, K + 2) - SUM * T3;
               end loop;
               --
               if WANTZ then
                  --
                  --                 Accumulate transformations in the matrix Z
                  --
                  J := ILOZ - 1;
                  loop
                     J := J + 1;
                     exit when J > IHIZ;
                     SUM          := Z (J, K) + V2 * Z (J, K + 1) + V3 * Z (J, K + 2);
                     Z (J, K)     := Z (J, K) - SUM * T1;
                     Z (J, K + 1) := Z (J, K + 1) - SUM * T2;
                     Z (J, K + 2) := Z (J, K + 2) - SUM * T3;
                  end loop;
               end if;
            elsif NR = 2 then
               --
               --              Apply G from the left to transform the rows of the matrix
               --              in columns K to I2.
               --
               J := K - 1;
               loop
                  J := J + 1;
                  exit when J > I2;
                  SUM          := H (K, J) + V2 * H (K + 1, J);
                  H (K, J)     := H (K, J) - SUM * T1;
                  H (K + 1, J) := H (K + 1, J) - SUM * T2;
               end loop;
               --
               --              Apply G from the right to transform the columns of the
               --              matrix in rows I1 to min(K+3,I).
               --
               J := I1 - 1;
               loop
                  J := J + 1;
                  exit when J > I;
                  SUM          := H (J, K) + V2 * H (J, K + 1);
                  H (J, K)     := H (J, K) - SUM * T1;
                  H (J, K + 1) := H (J, K + 1) - SUM * T2;
               end loop;
               --
               if WANTZ then
                  --
                  --                 Accumulate transformations in the matrix Z
                  --
                  J := ILOZ - 1;
                  loop
                     J := J + 1;
                     exit when J > IHIZ;
                     SUM          := Z (J, K) + V2 * Z (J, K + 1);
                     Z (J, K)     := Z (J, K) - SUM * T1;
                     Z (J, K + 1) := Z (J, K + 1) - SUM * T2;
                  end loop;
               end if;
            end if;
         end loop;
         --
      end loop;
      --
      --     Failure to converge in remaining number of iterations
      --
      INFO := I;
      return;
      --
      <<L150>> null;
      --
      if L = I then
         --
         --        H(I,I-1) is negligible: one eigenvalue has converged.
         --
         WR (I) := H (I, I);
         WI (I) := ZERO;
      elsif L = I - 1 then
         --
         --        H(I-1,I-2) is negligible: a pair of eigenvalues have converged.
         --
         --        Transform the 2-by-2 submatrix to standard Schur form,
         --        and compute and store the eigenvalues.
         --
         DLANV2 (H (I - 1, I - 1), H (I - 1, I), H (I, I - 1), H (I, I), WR (I - 1), WI (I - 1), WR (I), WI (I), CS, SN);
         --
         if WANTT then
            --
            --           Apply the transformation to the rest of H.
            --
            if I2 > I then
               DROT (I2 - I, H (I - 1, I + 1)'Address, LDH, H (I, I + 1)'Address, LDH, CS, SN);
            end if;
            DROT (I - I1 - 1, H (I1, I - 1)'Address, 1, H (I1, I)'Address, 1, CS, SN);
         end if;
         if WANTZ then
            --
            --           Apply the transformation to Z.
            --
            DROT (NZ, Z (ILOZ, I - 1)'Address, 1, Z (ILOZ, I)'Address, 1, CS, SN);
         end if;
      end if;
      --
      --     return to start of the main loop with new value of I.
      --
      I := L - 1;
      goto L20;
      --
      <<L160>> null;
      return;
      --
      --     End of DLAHQR
      --
   end DLAHQR;

   procedure DLAHR2
     (N       : Integer;
      K       : Integer;
      NB      : Integer;
      A_adr   : Address;
      LDA     : Integer;
      TAU_adr : Address;
      T_adr   : Address;
      LDT     : Integer;
      Y_adr   : Address;
      LDY     : Integer)
   is

      A   : Ftn_Real_Matrix (1 .. LDA, 1 .. N - K + 1);
      TAU : Ftn_Real_Vector (1 .. NB);
      T   : Ftn_Real_Matrix (1 .. LDT, 1 .. NB);
      Y   : Ftn_Real_Matrix (1 .. LDY, 1 .. NB);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for T'Address use T_adr;
      for Y'Address use Y_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, T);
      pragma Import (Ada, Y);

      ZERO : constant Real := 0.0e0;
      ONE  : constant Real := 1.0e0;
      I    : Integer;
      EI   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAHR2( N, K, NB, A, LDA, TAU, T, LDT, Y, LDY )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            K, LDA, LDT, LDY, N, NB
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION  A( LDA, * ), T( LDT, NB ), TAU( NB ),
   --      $                   Y( LDY, NB )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
   --  matrix A so that elements below the k-th subdiagonal are zero. The
   --  reduction is performed by an orthogonal similarity transformation
   --  Q**T * A * Q. The routine returns the matrices V and T which determine
   --  Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
   --
   --  This is an auxiliary routine called by DGEHRD.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.
   --
   --  [in] K
   --           K is INTEGER
   --           The offset for the reduction. Elements below the k-th
   --           subdiagonal in the first NB columns are reduced to zero.
   --           K < N.
   --
   --  [in] NB
   --           NB is INTEGER
   --           The number of columns to be reduced.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N-K+1)
   --           On entry, the n-by-(n-k+1) general matrix A.
   --           On exit, the elements on and above the k-th subdiagonal in
   --           the first NB columns are overwritten with the corresponding
   --           elements of the reduced matrix; the elements below the k-th
   --           subdiagonal, with the array TAU, represent the matrix Q as a
   --           product of elementary reflectors. The other columns of A are
   --           unchanged. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (NB)
   --           The scalar factors of the elementary reflectors. See Further
   --           Details.
   --
   --  [out] T
   --           T is DOUBLE PRECISION array, dimension (LDT,NB)
   --           The upper triangular matrix T.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T.  LDT >= NB.
   --
   --  [out] Y
   --           Y is DOUBLE PRECISION array, dimension (LDY,NB)
   --           The n-by-nb matrix Y.
   --
   --  [in] LDY
   --           LDY is INTEGER
   --           The leading dimension of the array Y. LDY >= N.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of nb elementary reflectors
   --
   --      Q = H(1) H(2) . . . H(nb).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
   --   A(i+k+1:n,i), and tau in TAU(i).
   --
   --   The elements of the vectors v together form the (n-k+1)-by-nb matrix
   --   V which is needed, with T and Y, to apply the transformation to the
   --   unreduced part of the matrix, using an update of the form:
   --   A := (I - V*T*V**T) * (A - Y*V**T).
   --
   --   The contents of A on exit are illustrated by the following example
   --   with n = 7, k = 3 and nb = 2:
   --
   --      ( a   a   a   a   a )
   --      ( a   a   a   a   a )
   --      ( a   a   a   a   a )
   --      ( h   h   a   a   a )
   --      ( v1  h   a   a   a )
   --      ( v1  v2  a   a   a )
   --      ( v1  v2  a   a   a )
   --
   --   where a denotes an element of the original matrix A, h denotes a
   --   modified element of the upper Hessenberg matrix H, and vi denotes an
   --   element of the vector defining H(i).
   --
   --   This subroutine is a slight modification of LAPACK-3.0's DLAHRD
   --   incorporating improvements proposed by Quintana-Orti and Van de
   --   Gejin. Note that the entries of A(1:K,2:NB) differ from those
   --   returned by the original LAPACK-3.0's DLAHRD routine. (This
   --   subroutine is not backward compatible with LAPACK-3.0's DLAHRD.)
   --
   --  References:
   --  ================
   --
   --   Gregorio Quintana-Orti and Robert van de Geijn, "Improving the
   --   performance of reduction to Hessenberg form," ACM Transactions on
   --   Mathematical Software, 32(2):180-194, June 2006.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0,
   --     $                     ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DAXPY, DCOPY, DGEMM, DGEMV, DLACPY,
   --     $                   DLARFG, DSCAL, DTRMM, DTRMV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if N <= 1 then
         return;
      end if;
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > NB;
         if I > 1 then
            --
            --           Update A(K+1:N,I)
            --
            --           Update I-th column of A - Y * V**T
            --
            DGEMV
              ('N',
               N - K,
               I - 1,
               -ONE,
               Y (K + 1, 1)'Address,
               LDY,
               A (K + I - 1, 1)'Address,
               LDA,
               ONE,
               A (K + 1, I)'Address,
               1);
            --
            --           Apply I - V * T**T * V**T to this column (call it b) from the
            --           left, using the last column of T as workspace
            --
            --           Let  V = ( V1 )   and   b = ( b1 )   (first I-1 rows)
            --                    ( V2 )             ( b2 )
            --
            --           where V1 is unit lower triangular
            --
            --           w := V1**T * b1
            --
            DCOPY (I - 1, A (K + 1, I)'Address, 1, T (1, NB)'Address, 1);
            DTRMV ('L', 'T', 'U', I - 1, A (K + 1, 1)'Address, LDA, T (1, NB)'Address, 1);
            --
            --           w := w + V2**T * b2
            --
            DGEMV
              ('T',
               N - K - I + 1,
               I - 1,
               ONE,
               A (K + I, 1)'Address,
               LDA,
               A (K + I, I)'Address,
               1,
               ONE,
               T (1, NB)'Address,
               1);
            --
            --           w := T**T * w
            --
            DTRMV ('U', 'T', 'N', I - 1, T'Address, LDT, T (1, NB)'Address, 1);
            --
            --           b2 := b2 - V2*w
            --
            DGEMV
              ('N',
               N - K - I + 1,
               I - 1,
               -ONE,
               A (K + I, 1)'Address,
               LDA,
               T (1, NB)'Address,
               1,
               ONE,
               A (K + I, I)'Address,
               1);
            --
            --           b1 := b1 - V1*w
            --
            DTRMV ('L', 'N', 'U', I - 1, A (K + 1, 1)'Address, LDA, T (1, NB)'Address, 1);
            DAXPY (I - 1, -ONE, T (1, NB)'Address, 1, A (K + 1, I)'Address, 1);
            --
            A (K + I - 1, I - 1) := EI;
         end if;
         --
         --        Generate the elementary reflector H(I) to annihilate
         --        A(K+I+1:N,I)
         --
         DLARFG (N - K - I + 1, A (K + I, I), A (min (K + I + 1, N), I)'Address, 1, TAU (I));
         EI           := A (K + I, I);
         A (K + I, I) := ONE;
         --
         --        Compute  Y(K+1:N,I)
         --
         DGEMV
           ('N',
            N - K,
            N - K - I + 1,
            ONE,
            A (K + 1, I + 1)'Address,
            LDA,
            A (K + I, I)'Address,
            1,
            ZERO,
            Y (K + 1, I)'Address,
            1);
         DGEMV
           ('T',
            N - K - I + 1,
            I - 1,
            ONE,
            A (K + I, 1)'Address,
            LDA,
            A (K + I, I)'Address,
            1,
            ZERO,
            T (1, I)'Address,
            1);
         DGEMV ('N', N - K, I - 1, -ONE, Y (K + 1, 1)'Address, LDY, T (1, I)'Address, 1, ONE, Y (K + 1, I)'Address, 1);
         DSCAL (N - K, TAU (I), Y (K + 1, I)'Address, 1);
         --
         --        Compute T(1:I,I)
         --
         DSCAL (I - 1, -TAU (I), T (1, I)'Address, 1);
         DTRMV ('U', 'N', 'N', I - 1, T'Address, LDT, T (1, I)'Address, 1);
         T (I, I) := TAU (I);
         --
      end loop;
      A (K + NB, NB) := EI;
      --
      --     Compute Y(1:K,1:NB)
      --
      DLACPY ('A', K, NB, A (1, 2)'Address, LDA, Y'Address, LDY);
      DTRMM ('R', 'L', 'N', 'U', K, NB, ONE, A (K + 1, 1)'Address, LDA, Y'Address, LDY);
      if N > K + NB then
         DGEMM
           ('N',
            'N',
            K,
            NB,
            N - K - NB,
            ONE,
            A (1, 2 + NB)'Address,
            LDA,
            A (K + 1 + NB, 1)'Address,
            LDA,
            ONE,
            Y'Address,
            LDY);
      end if;
      DTRMM ('R', 'U', 'N', 'N', K, NB, ONE, T'Address, LDT, Y'Address, LDY);
      --
      return;
      --
      --     End of DLAHR2
      --
   end DLAHR2;

   function DLAISNAN (DIN1 : Real; DIN2 : Real) return Boolean is
      DLAISNAN_Result : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       LOGICAL FUNCTION DLAISNAN( DIN1, DIN2 )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   DIN1, DIN2
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  This routine is not for general use.  It exists solely to avoid
   --  over-optimization in DISNAN.
   --
   --  DLAISNAN checks for NaNs by comparing its two arguments for
   --  inequality.  NaN is the only floating-point value where NaN != NaN
   --  returns .TRUE.  To check for NaNs, pass the same variable as both
   --  arguments.
   --
   --  A compiler must assume that the two arguments are
   --  not the same variable, and the test will not be optimized away.
   --  Interprocedural or whole-program optimization may delete this
   --  test.  The ISNAN functions will be replaced by the correct
   --  Fortran 03 intrinsic once the intrinsic is widely available.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] DIN1
   --           DIN1 is DOUBLE PRECISION
   --
   --  [in] DIN2
   --           DIN2 is DOUBLE PRECISION
   --           Two numbers to compare for inequality.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --  .. Executable Statements ..
   begin
      DLAISNAN_Result := (DIN1 /= DIN2);
      return DLAISNAN_Result;
   end DLAISNAN;

   procedure DLALN2
     (LTRANS : Boolean;
      NA     : Integer;
      NW     : Integer;
      SMIN   : Real;
      CA     : Real;
      A_adr  : Address;
      LDA    : Integer;
      D1     : Real;
      D2     : Real;
      B_adr  : Address;
      LDB    : Integer;
      WR     : Real;
      WI     : Real;
      X_adr  : Address;
      LDX    : Integer;
      SCALE  : in out Real;
      XNORM  : in out Real;
      INFO   : in out Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. NA);
      B : Ftn_Real_Matrix (1 .. LDB, 1 .. NW);
      X : Ftn_Real_Matrix (1 .. LDX, 1 .. NW);

      for A'Address use A_adr;
      for B'Address use B_adr;
      for X'Address use X_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);
      pragma Import (Ada, X);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      ICMAX  : Integer;
      J      : Integer;
      BBND   : Real;
      BI1    : Real;
      BI2    : Real;
      BIGNUM : Real;
      BNORM  : Real;
      BR1    : Real;
      BR2    : Real;
      CI21   : Real;
      CI22   : Real;
      CMAX   : Real;
      CNORM  : Real;
      CR21   : Real;
      CR22   : Real;
      CSI    : Real;
      CSR    : Real;
      LI21   : Real;
      LR21   : Real;
      SMINI  : Real;
      SMLNUM : Real;
      TEMP   : Real;
      U22ABS : Real;
      UI11   : Real;
      UI11R  : Real;
      UI12   : Real;
      UI12S  : Real;
      UI22   : Real;
      UR11   : Real;
      UR11R  : Real;
      UR12   : Real;
      UR12S  : Real;
      UR22   : Real;
      XI1    : Real;
      XI2    : Real;
      XR1    : Real;
      XR2    : Real;

      -- Fortran data statements -------------------
      RSWAP  : Ftn_Boolean_Vector (1 .. 4) := (False, True, False, True);
      ZSWAP  : Ftn_Boolean_Vector (1 .. 4) := (False, False, True, True);
      IPIVOT : Ftn_Integer_Matrix (1 .. 4, 1 .. 4) := ((1, 2, 3, 4), (2, 1, 4, 3), (3, 4, 1, 2), (4, 3, 2, 1));
      ----------------------------------------------

      CIV : Ftn_Real_Vector (1 .. 4);
      CRV : Ftn_Real_Vector (1 .. 4);
      CI  : Ftn_Real_Matrix (1 .. 2, 1 .. 2);
      CR  : Ftn_Real_Matrix (1 .. 2, 1 .. 2);

      -- Fortran equivalence statements ------------
      for CI'Address use CIV'Address;
      for CR'Address use CRV'Address;
   ----------------------------------------------

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLALN2( LTRANS, NA, NW, SMIN, CA, A, LDA, D1, D2, B,
   --                          LDB, WR, WI, X, LDX, SCALE, XNORM, INFO )
   --
   --       .. Scalar Arguments ..
   --       LOGICAL            LTRANS
   --       INTEGER            INFO, LDA, LDB, LDX, NA, NW
   --       DOUBLE PRECISION   CA, D1, D2, SCALE, SMIN, WI, WR, XNORM
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), X( LDX, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLALN2 solves a system of the form  (ca A - w D ) X = s B
   --  or (ca A**T - w D) X = s B   with possible scaling ("s") and
   --  perturbation of A.  (A**T means A-transpose.)
   --
   --  A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
   --  real diagonal matrix, w is a real or complex value, and X and B are
   --  NA x 1 matrices -- real if w is real, complex if w is complex.  NA
   --  may be 1 or 2.
   --
   --  If w is complex, X and B are represented as NA x 2 matrices,
   --  the first column of each being the real part and the second
   --  being the imaginary part.
   --
   --  "s" is a scaling factor (.LE. 1), computed by DLALN2, which is
   --  so chosen that X can be computed without overflow.  X is further
   --  scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
   --  than overflow.
   --
   --  If both singular values of (ca A - w D) are less than SMIN,
   --  SMIN*identity will be used instead of (ca A - w D).  If only one
   --  singular value is less than SMIN, one element of (ca A - w D) will be
   --  perturbed enough to make the smallest singular value roughly SMIN.
   --  If both singular values are at least SMIN, (ca A - w D) will not be
   --  perturbed.  In any case, the perturbation will be at most some small
   --  multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
   --  are computed by infinity-norm approximations, and thus will only be
   --  correct to a factor of 2 or so.
   --
   --  Note: all input quantities are assumed to be smaller than overflow
   --  by a reasonable factor.  (See BIGNUM.)
   --
   --  Arguments:
   --  ==========
   --
   --  [in] LTRANS
   --           LTRANS is LOGICAL
   --           =.TRUE.:  A-transpose will be used.
   --           =.FALSE.: A will be used (not transposed.)
   --
   --  [in] NA
   --           NA is INTEGER
   --           The size of the matrix A.  It may (only) be 1 or 2.
   --
   --  [in] NW
   --           NW is INTEGER
   --           1 if "w" is real, 2 if "w" is complex.  It may only be 1
   --           or 2.
   --
   --  [in] SMIN
   --           SMIN is DOUBLE PRECISION
   --           The desired lower bound on the singular values of A.  This
   --           should be a safe distance away from underflow or overflow,
   --           say, between (underflow/machine precision) and  (machine
   --           precision * overflow ).  (See BIGNUM and ULP.)
   --
   --  [in] CA
   --           CA is DOUBLE PRECISION
   --           The coefficient c, which A is multiplied by.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,NA)
   --           The NA x NA matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of A.  It must be at least NA.
   --
   --  [in] D1
   --           D1 is DOUBLE PRECISION
   --           The 1,1 element in the diagonal matrix D.
   --
   --  [in] D2
   --           D2 is DOUBLE PRECISION
   --           The 2,2 element in the diagonal matrix D.  Not used if NW=1.
   --
   --  [in] B
   --           B is DOUBLE PRECISION array, dimension (LDB,NW)
   --           The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
   --           complex), column 1 contains the real part of B and column 2
   --           contains the imaginary part.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of B.  It must be at least NA.
   --
   --  [in] WR
   --           WR is DOUBLE PRECISION
   --           The real part of the scalar "w".
   --
   --  [in] WI
   --           WI is DOUBLE PRECISION
   --           The imaginary part of the scalar "w".  Not used if NW=1.
   --
   --  [out] X
   --           X is DOUBLE PRECISION array, dimension (LDX,NW)
   --           The NA x NW matrix X (unknowns), as computed by DLALN2.
   --           If NW=2 ("w" is complex), on exit, column 1 will contain
   --           the real part of X and column 2 will contain the imaginary
   --           part.
   --
   --  [in] LDX
   --           LDX is INTEGER
   --           The leading dimension of X.  It must be at least NA.
   --
   --  [out] SCALE
   --           SCALE is DOUBLE PRECISION
   --           The scale factor that B must be multiplied by to insure
   --           that overflow does not occur when computing X.  Thus,
   --           (ca A - w D) X  will be SCALE*B, not B (ignoring
   --           perturbations of A.)  It will be at most 1.
   --
   --  [out] XNORM
   --           XNORM is DOUBLE PRECISION
   --           The infinity-norm of X, when X is regarded as an NA x NW
   --           real matrix.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           An error flag.  It will be set to zero if no error occurs,
   --           a negative number if an argument is in error, or a positive
   --           number if  ca A - w D  had to be perturbed.
   --           The possible values are:
   --           = 0: No error occurred, and (ca A - w D) did not have to be
   --                  perturbed.
   --           = 1: (ca A - w D) had to be perturbed to make its smallest
   --                (or only) singular value greater than SMIN.
   --           NOTE: In the interests of speed, this routine does not
   --                 check the inputs for errors.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --      PARAMETER          ( TWO = 2.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLADIV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX
   --     ..
   --     .. Equivalences ..
   --     ..
   --     .. Data statements ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Compute BIGNUM
   --
   begin
      SMLNUM := TWO * DLAMCH ('S');
      BIGNUM := ONE / SMLNUM;
      SMINI  := max (SMIN, SMLNUM);
      --
      --     Don't check for input errors
      --
      INFO := 0;
      --
      --     Standard Initializations
      --
      SCALE := ONE;
      --
      if NA = 1 then
         --
         --        1 x 1  (i.e., scalar) system   C X = B
         --
         if NW = 1 then
            --
            --           Real 1x1 system.
            --
            --           C = ca A - w D
            --
            CSR   := CA * A (1, 1) - WR * D1;
            CNORM := abs (CSR);
            --
            --           If | C | < SMINI, use C = SMINI
            --
            if CNORM < SMINI then
               CSR   := SMINI;
               CNORM := SMINI;
               INFO  := 1;
            end if;
            --
            --           Check scaling for  X = B / C
            --
            BNORM := abs (B (1, 1));
            if CNORM < ONE and BNORM > ONE then
               if BNORM > BIGNUM * CNORM then
                  SCALE := ONE / BNORM;
               end if;
            end if;
            --
            --           Compute X
            --
            X (1, 1) := (B (1, 1) * SCALE) / CSR;
            XNORM    := abs (X (1, 1));
         else
            --
            --           Complex 1x1 system (w is complex)
            --
            --           C = ca A - w D
            --
            CSR   := CA * A (1, 1) - WR * D1;
            CSI   := -WI * D1;
            CNORM := abs (CSR) + abs (CSI);
            --
            --           If | C | < SMINI, use C = SMINI
            --
            if CNORM < SMINI then
               CSR   := SMINI;
               CSI   := ZERO;
               CNORM := SMINI;
               INFO  := 1;
            end if;
            --
            --           Check scaling for  X = B / C
            --
            BNORM := abs (B (1, 1)) + abs (B (1, 2));
            if CNORM < ONE and BNORM > ONE then
               if BNORM > BIGNUM * CNORM then
                  SCALE := ONE / BNORM;
               end if;
            end if;
            --
            --           Compute X
            --
            DLADIV (SCALE * B (1, 1), SCALE * B (1, 2), CSR, CSI, X (1, 1), X (1, 2));
            XNORM := abs (X (1, 1)) + abs (X (1, 2));
         end if;
      --
      else
         --
         --        2x2 System
         --
         --        Compute the real part of  C = ca A - w D  (or  ca A**T - w D )
         --
         CR (1, 1) := CA * A (1, 1) - WR * D1;
         CR (2, 2) := CA * A (2, 2) - WR * D2;
         if LTRANS then
            CR (1, 2) := CA * A (2, 1);
            CR (2, 1) := CA * A (1, 2);
         else
            CR (2, 1) := CA * A (2, 1);
            CR (1, 2) := CA * A (1, 2);
         end if;
         --
         if NW = 1 then
            --
            --           Real 2x2 system  (w is real)
            --
            --           Find the largest element in C
            --
            CMAX  := ZERO;
            ICMAX := 0;
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > 4;
               if abs (CRV (J)) > CMAX then
                  CMAX  := abs (CRV (J));
                  ICMAX := J;
               end if;
            end loop;
            --
            --           If norm(C) < SMINI, use SMINI*identity.
            --
            if CMAX < SMINI then
               BNORM := max (abs (B (1, 1)), abs (B (2, 1)));
               if SMINI < ONE and BNORM > ONE then
                  if BNORM > BIGNUM * SMINI then
                     SCALE := ONE / BNORM;
                  end if;
               end if;
               TEMP     := SCALE / SMINI;
               X (1, 1) := TEMP * B (1, 1);
               X (2, 1) := TEMP * B (2, 1);
               XNORM    := TEMP * BNORM;
               INFO     := 1;
               return;
            end if;
            --
            --           Gaussian elimination with complete pivoting.
            --
            UR11  := CRV (ICMAX);
            CR21  := CRV (IPIVOT (2, ICMAX));
            UR12  := CRV (IPIVOT (3, ICMAX));
            CR22  := CRV (IPIVOT (4, ICMAX));
            UR11R := ONE / UR11;
            LR21  := UR11R * CR21;
            UR22  := CR22 - UR12 * LR21;
            --
            --           If smaller pivot < SMINI, use SMINI
            --
            if abs (UR22) < SMINI then
               UR22 := SMINI;
               INFO := 1;
            end if;
            if RSWAP (ICMAX) then
               BR1 := B (2, 1);
               BR2 := B (1, 1);
            else
               BR1 := B (1, 1);
               BR2 := B (2, 1);
            end if;
            BR2  := BR2 - LR21 * BR1;
            BBND := max (abs (BR1 * (UR22 * UR11R)), abs (BR2));
            if BBND > ONE and abs (UR22) < ONE then
               if BBND >= BIGNUM * abs (UR22) then
                  SCALE := ONE / BBND;
               end if;
            end if;
            --
            XR2 := (BR2 * SCALE) / UR22;
            XR1 := (SCALE * BR1) * UR11R - XR2 * (UR11R * UR12);
            if ZSWAP (ICMAX) then
               X (1, 1) := XR2;
               X (2, 1) := XR1;
            else
               X (1, 1) := XR1;
               X (2, 1) := XR2;
            end if;
            XNORM := max (abs (XR1), abs (XR2));
            --
            --           Further scaling if  norm(A) norm(X) > overflow
            --
            if XNORM > ONE and CMAX > ONE then
               if XNORM > BIGNUM / CMAX then
                  TEMP     := CMAX / BIGNUM;
                  X (1, 1) := TEMP * X (1, 1);
                  X (2, 1) := TEMP * X (2, 1);
                  XNORM    := TEMP * XNORM;
                  SCALE    := TEMP * SCALE;
               end if;
            end if;
         else
            --
            --           Complex 2x2 system  (w is complex)
            --
            --           Find the largest element in C
            --
            CI (1, 1) := -WI * D1;
            CI (2, 1) := ZERO;
            CI (1, 2) := ZERO;
            CI (2, 2) := -WI * D2;
            CMAX      := ZERO;
            ICMAX     := 0;
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > 4;
               if abs (CRV (J)) + abs (CIV (J)) > CMAX then
                  CMAX  := abs (CRV (J)) + abs (CIV (J));
                  ICMAX := J;
               end if;
            end loop;
            --
            --           If norm(C) < SMINI, use SMINI*identity.
            --
            if CMAX < SMINI then
               BNORM := max (abs (B (1, 1)) + abs (B (1, 2)), abs (B (2, 1)) + abs (B (2, 2)));
               if SMINI < ONE and BNORM > ONE then
                  if BNORM > BIGNUM * SMINI then
                     SCALE := ONE / BNORM;
                  end if;
               end if;
               TEMP     := SCALE / SMINI;
               X (1, 1) := TEMP * B (1, 1);
               X (2, 1) := TEMP * B (2, 1);
               X (1, 2) := TEMP * B (1, 2);
               X (2, 2) := TEMP * B (2, 2);
               XNORM    := TEMP * BNORM;
               INFO     := 1;
               return;
            end if;
            --
            --           Gaussian elimination with complete pivoting.
            --
            UR11 := CRV (ICMAX);
            UI11 := CIV (ICMAX);
            CR21 := CRV (IPIVOT (2, ICMAX));
            CI21 := CIV (IPIVOT (2, ICMAX));
            UR12 := CRV (IPIVOT (3, ICMAX));
            UI12 := CIV (IPIVOT (3, ICMAX));
            CR22 := CRV (IPIVOT (4, ICMAX));
            CI22 := CIV (IPIVOT (4, ICMAX));
            if ICMAX = 1 or ICMAX = 4 then
               --
               --              Code when off-diagonals of pivoted C are real
               --
               if abs (UR11) > abs (UI11) then
                  TEMP  := UI11 / UR11;
                  UR11R := ONE / (UR11 * (ONE + TEMP ** 2));
                  UI11R := -TEMP * UR11R;
               else
                  TEMP  := UR11 / UI11;
                  UI11R := -ONE / (UI11 * (ONE + TEMP ** 2));
                  UR11R := -TEMP * UI11R;
               end if;
               LR21  := CR21 * UR11R;
               LI21  := CR21 * UI11R;
               UR12S := UR12 * UR11R;
               UI12S := UR12 * UI11R;
               UR22  := CR22 - UR12 * LR21;
               UI22  := CI22 - UR12 * LI21;
            else
               --
               --              Code when diagonals of pivoted C are real
               --
               UR11R := ONE / UR11;
               UI11R := ZERO;
               LR21  := CR21 * UR11R;
               LI21  := CI21 * UR11R;
               UR12S := UR12 * UR11R;
               UI12S := UI12 * UR11R;
               UR22  := CR22 - UR12 * LR21 + UI12 * LI21;
               UI22  := -UR12 * LI21 - UI12 * LR21;
            end if;
            U22ABS := abs (UR22) + abs (UI22);
            --
            --           If smaller pivot < SMINI, use SMINI
            --
            if U22ABS < SMINI then
               UR22 := SMINI;
               UI22 := ZERO;
               INFO := 1;
            end if;
            if RSWAP (ICMAX) then
               BR2 := B (1, 1);
               BR1 := B (2, 1);
               BI2 := B (1, 2);
               BI1 := B (2, 2);
            else
               BR1 := B (1, 1);
               BR2 := B (2, 1);
               BI1 := B (1, 2);
               BI2 := B (2, 2);
            end if;
            BR2  := BR2 - LR21 * BR1 + LI21 * BI1;
            BI2  := BI2 - LI21 * BR1 - LR21 * BI1;
            BBND := max ((abs (BR1) + abs (BI1)) * (U22ABS * (abs (UR11R) + abs (UI11R))), abs (BR2) + abs (BI2));
            if BBND > ONE and U22ABS < ONE then
               if BBND >= BIGNUM * U22ABS then
                  SCALE := ONE / BBND;
                  BR1   := SCALE * BR1;
                  BI1   := SCALE * BI1;
                  BR2   := SCALE * BR2;
                  BI2   := SCALE * BI2;
               end if;
            end if;
            --
            DLADIV (BR2, BI2, UR22, UI22, XR2, XI2);
            XR1 := UR11R * BR1 - UI11R * BI1 - UR12S * XR2 + UI12S * XI2;
            XI1 := UI11R * BR1 + UR11R * BI1 - UI12S * XR2 - UR12S * XI2;
            if ZSWAP (ICMAX) then
               X (1, 1) := XR2;
               X (2, 1) := XR1;
               X (1, 2) := XI2;
               X (2, 2) := XI1;
            else
               X (1, 1) := XR1;
               X (2, 1) := XR2;
               X (1, 2) := XI1;
               X (2, 2) := XI2;
            end if;
            XNORM := max (abs (XR1) + abs (XI1), abs (XR2) + abs (XI2));
            --
            --           Further scaling if  norm(A) norm(X) > overflow
            --
            if XNORM > ONE and CMAX > ONE then
               if XNORM > BIGNUM / CMAX then
                  TEMP     := CMAX / BIGNUM;
                  X (1, 1) := TEMP * X (1, 1);
                  X (2, 1) := TEMP * X (2, 1);
                  X (1, 2) := TEMP * X (1, 2);
                  X (2, 2) := TEMP * X (2, 2);
                  XNORM    := TEMP * XNORM;
                  SCALE    := TEMP * SCALE;
               end if;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of DLALN2
      --
   end DLALN2;

   function DLAMC3 (A : Real; B : Real) return Real is
      DLAMC3_Result : Real;
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAMC3  is intended to force  A  and  B  to be stored prior to doing
   --  the addition of  A  and  B,  for use in situations where optimizers
   --  might hold one of these in a register.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] A
   --           A is a DOUBLE PRECISION
   --
   --  [in] B
   --           B is a DOUBLE PRECISION
   --           The values A and B.
   --
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
   --     November 2010
   --
   --     .. Scalar Arguments ..
   --     ..
   -- =====================================================================
   --
   --     .. Executable Statements ..
   --
   begin
      DLAMC3_Result := A + B;
      --
      return DLAMC3_Result;
      --
      --     End of DLAMC3
      --
   end DLAMC3;

   function DLAMCH (CMACH : Character) return Real is
      ONE           : constant Real := 1.0e0;
      ZERO          : constant Real := 0.0e0;
      RND           : Real;
      EPS           : Real;
      SFMIN         : Real;
      SMALL         : Real;
      RMACH         : Real;
      DLAMCH_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --      DOUBLE PRECISION FUNCTION DLAMCH( CMACH )
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAMCH determines Real precision machine parameters.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] CMACH
   --           Specifies the value to be returned by DLAMCH:
   --           = 'E' or 'e',   DLAMCH := eps
   --           = 'S' or 's',   DLAMCH := sfmin
   --           = 'B' or 'b',   DLAMCH := base
   --           = 'P' or 'p',   DLAMCH := eps*base
   --           = 'N' or 'n',   DLAMCH := t
   --           = 'R' or 'r',   DLAMCH := rnd
   --           = 'M' or 'm',   DLAMCH := emin
   --           = 'U' or 'u',   DLAMCH := rmin
   --           = 'L' or 'l',   DLAMCH := emax
   --           = 'O' or 'o',   DLAMCH := rmax
   --           where
   --           eps   = relative machine precision
   --           sfmin = safe minimum, such that 1/sfmin does not overflow
   --           base  = base of the machine
   --           prec  = eps*base
   --           t     = number of (base) digits in the mantissa
   --           rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
   --           emin  = minimum exponent before (gradual) underflow
   --           rmin  = underflow threshold - base**(emin-1)
   --           emax  = largest exponent before overflow
   --           rmax  = overflow threshold  - (base**emax)*(1-eps)
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DIGITS, EPSILON, HUGE, MAXEXPONENT, MINEXPONENT, RADIX, TINY
   --     ..
   --     .. Executable Statements ..
   --
   --
   --     Assume rounding, not chopping. Always.
   --
   begin
      RND := ONE;
      --
      if ONE = RND 
         then EPS := epsilon (ZERO) * 0.5;
         else EPS := epsilon (ZERO);
      end if;
      --
      if LSAME (CMACH, 'E') then
         RMACH := EPS;
      elsif LSAME (CMACH, 'S') then
         SFMIN := tiny (ZERO);
         SMALL := ONE / huge (ZERO);
         if SMALL >= SFMIN then
            --
            --           Use SMALL plus a bit, to avoid the possibility of rounding
            --           causing overflow when computing  1/sfmin.
            --
            SFMIN := SMALL * (ONE + EPS);
         end if;
         RMACH := SFMIN;
      elsif LSAME (CMACH, 'B') then
         RMACH := Real (radix (ZERO));
      elsif LSAME (CMACH, 'P') then
         RMACH := EPS * Real (radix (ZERO));
      elsif LSAME (CMACH, 'N') then
         RMACH := Real (the_digits (ZERO));
      elsif LSAME (CMACH, 'R') then
         RMACH := RND;
      elsif LSAME (CMACH, 'M') then
         RMACH := Real (minexponent (ZERO));
      elsif LSAME (CMACH, 'U') then
         RMACH := tiny (ZERO);
      elsif LSAME (CMACH, 'L') then
         RMACH := Real (maxexponent (ZERO));
      elsif LSAME (CMACH, 'O') then
         RMACH := huge (ZERO);
      else
         RMACH := ZERO;
      end if;
      --
      DLAMCH_Result := RMACH;
      return DLAMCH_Result;
      --
      --     End of DLAMCH
      --
   end DLAMCH;

   procedure DLAMRG
     (N1        : Integer;
      N2        : Integer;
      A_adr     : Address;
      DTRD1     : Integer;
      DTRD2     : Integer;
      INDEX_adr : Address)
   is

      A     : Ftn_Real_Vector (1 .. N1 + N2);
      INDEX : Ftn_Integer_Vector (1 .. N1 + N2);

      for A'Address use A_adr;
      for INDEX'Address use INDEX_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, INDEX);

      I    : Integer;
      IND1 : Integer;
      IND2 : Integer;
      N1SV : Integer;
      N2SV : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAMRG( N1, N2, A, DTRD1, DTRD2, INDEX)
   --
   --       .. Scalar Arguments ..
   --       INTEGER            DTRD1, DTRD2, N1, N2
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            INDEX( * )
   --       DOUBLE PRECISION   A( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAMRG will create a permutation list which will merge the elements
   --  of A (which is composed of two independently sorted sets) into a
   --  single set which is sorted in ascending order.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N1
   --           N1 is INTEGER
   --
   --  [in] N2
   --           N2 is INTEGER
   --          These arguements contain the respective lengths of the two
   --          sorted lists to be merged.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (N1+N2)
   --          The first N1 elements of A contain a list of numbers which
   --          are sorted in either ascending or descending order.  Likewise
   --          for the final N2 elements.
   --
   --  [in] DTRD1
   --           DTRD1 is INTEGER
   --
   --  [in] DTRD2
   --           DTRD2 is INTEGER
   --          These are the strides to be taken through the array A.
   --          Allowable strides are 1 and -1.  They indicate whether a
   --          subset of A is sorted in ascending (DTRDx = 1) or descending
   --          (DTRDx = -1) order.
   --
   --  [out] INDEX
   --           INDEX is INTEGER array, dimension (N1+N2)
   --          On exit this array will contain a permutation such that
   --          if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
   --          sorted in ascending order.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   begin
      N1SV := N1;
      N2SV := N2;
      if DTRD1 > 0 
         then IND1 := 1;
         else IND1 := N1;
      end if;
      if DTRD2 > 0 
         then IND2 := 1 + N1;
         else IND2 := N1 + N2;
      end if;
      I := 1;
      --     while ( (N1SV > 0) & (N2SV > 0) )
      <<L10>> null;
      if N1SV > 0 and N2SV > 0 then
         if A (IND1) <= A (IND2) then
            INDEX (I) := IND1;
            I         := I + 1;
            IND1      := IND1 + DTRD1;
            N1SV      := N1SV - 1;
         else
            INDEX (I) := IND2;
            I         := I + 1;
            IND2      := IND2 + DTRD2;
            N2SV      := N2SV - 1;
         end if;
         goto L10;
      end if;
      --     end while
      if N1SV = 0 then
         N1SV := 1 - 1;
         loop
            N1SV := N1SV + 1;
            exit when N1SV > N2SV;
            INDEX (I) := IND2;
            I         := I + 1;
            IND2      := IND2 + DTRD2;
         end loop;
      else
         --     N2SV .EQ. 0
         N2SV := 1 - 1;
         loop
            N2SV := N2SV + 1;
            exit when N2SV > N1SV;
            INDEX (I) := IND1;
            I         := I + 1;
            IND1      := IND1 + DTRD1;
         end loop;
      end if;
      --
      return;
      --
      --     End of DLAMRG
      --
   end DLAMRG;

   function DLANGE
     (NORM : Character;
      M    : Integer;
      N    : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer;
      WORK : in out Ftn_Real_Vector)
      return Real
   is
      ONE           : constant Real := 1.0e0;
      ZERO          : constant Real := 0.0e0;
      I             : Integer;
      J             : Integer;
      SCALE         : Real;
      SUM           : Real;
      VALUE         : Real;
      DLANGE_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION DLANGE( NORM, M, N, A, LDA, WORK )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          NORM
   --       INTEGER            LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLANGE  returns the value of the one norm,  or the Frobenius norm, or
   --  the  infinity norm,  or the  element of  largest absolute value  of a
   --  real matrix A.
   --
   --  \return DLANGE
   --
   --     DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm' )
   --
   --              ( norm1(A),         NORM = '1', 'O' or 'o' )
   --
   --              ( normI(A),         NORM = 'I' or 'i' )
   --
   --              ( normF(A),         NORM = 'F', 'f', 'E' or 'e')
   --
   --  where  norm1  denotes the  one norm of a matrix (maximum column sum),
   --  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
   --  normF  denotes the  Frobenius norm of a matrix (square root of sum of
   --  squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] NORM
   --           NORM is CHARACTER*1
   --           Specifies the value to be returned in DLANGE as described
   --           above.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.  When M = 0,
   --           DLANGE is set to zero.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.  When N = 0,
   --           DLANGE is set to zero.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The m by n matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(M,1).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
   --           where LWORK >= M when NORM = 'I'; otherwise, WORK is not
   --           referenced.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASSQ
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if min (M, N) = 0 then
         VALUE := ZERO;
      elsif LSAME (NORM, 'M') then
         --
         --        Find max(abs(A(i,j))).
         --
         VALUE := ZERO;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               VALUE := max (VALUE, abs (A (I, J)));
            end loop;
         end loop;
      elsif (LSAME (NORM, 'O')) or (NORM = '1') then
         --
         --        Find norm1(A).
         --
         VALUE := ZERO;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM := ZERO;
            I   := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               SUM := SUM + abs (A (I, J));
            end loop;
            VALUE := max (VALUE, SUM);
         end loop;
      elsif LSAME (NORM, 'I') then
         --
         --        Find normI(A).
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            WORK (I) := ZERO;
         end loop;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               WORK (I) := WORK (I) + abs (A (I, J));
            end loop;
         end loop;
         VALUE := ZERO;
         I     := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            VALUE := max (VALUE, WORK (I));
         end loop;
      elsif (LSAME (NORM, 'F')) or (LSAME (NORM, 'E')) then
         --
         --        Find normF(A).
         --
         SCALE := ZERO;
         SUM   := ONE;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            DLASSQ (M, A (1, J)'Address, 1, SCALE, SUM);
         end loop;
         VALUE := SCALE * Sqrt (SUM);
      end if;
      --
      DLANGE_Result := VALUE;
      return DLANGE_Result;
      --
      --     End of DLANGE
      --
   end DLANGE;

   function DLANST
     (NORM  : Character;
      N     : Integer;
      D_adr : Address;
      E_adr : Address)
      return  Real
   is
      D : Ftn_Real_Vector (1 .. N);
      E : Ftn_Real_Vector (1 .. N - 1);

      for D'Address use D_adr;
      for E'Address use E_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);

      ONE           : constant Real := 1.0e0;
      ZERO          : constant Real := 0.0e0;
      I             : Integer;
      ANORM         : Real;
      SCALE         : Real;
      SUM           : Real;
      DLANST_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION DLANST( NORM, N, D, E)
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          NORM
   --       INTEGER            N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLANST  returns the value of the one norm,  or the Frobenius norm, or
   --  the  infinity norm,  or the  element of  largest absolute value  of a
   --  real symmetric tridiagonal matrix A.
   --
   --  \return DLANST
   --
   --     DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm')
   --
   --              ( norm1(A),         NORM = '1', 'O' or 'o')
   --
   --              ( normI(A),         NORM = 'I' or 'i')
   --
   --              ( normF(A),         NORM = 'F', 'f', 'E' or 'e')
   --
   --  where  norm1  denotes the  one norm of a matrix (maximum column sum),
   --  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
   --  normF  denotes the  Frobenius norm of a matrix (square root of sum of
   --  squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] NORM
   --           NORM is CHARACTER*1
   --           Specifies the value to be returned in DLANST as described
   --           above.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.  When N = 0, DLANST is
   --           set to zero.
   --
   --  [in] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           The diagonal elements of A.
   --
   --  [in] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           The (n-1) sub-diagonal or super-diagonal elements of A.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASSQ
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N <= 0 then
         ANORM := ZERO;
      elsif LSAME (NORM, 'M') then
         --
         --        Find max(abs(A(i,j))).
         --
         ANORM := abs (D (N));
         I     := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            ANORM := max (ANORM, abs (D (I)));
            ANORM := max (ANORM, abs (E (I)));
         end loop;
      elsif LSAME (NORM, 'O') or NORM = '1' or LSAME (NORM, 'I') then
         --
         --        Find norm1(A).
         --
         if N = 1 then
            ANORM := abs (D (1));
         else
            ANORM := max (abs (D (1)) + abs (E (1)), abs (E (N - 1)) + abs (D (N)));
            I     := 2 - 1;
            loop
               I := I + 1;
               exit when I > N - 1;
               ANORM := max (ANORM, abs (D (I)) + abs (E (I)) + abs (E (I - 1)));
            end loop;
         end if;
      elsif (LSAME (NORM, 'F')) or (LSAME (NORM, 'E')) then
         --
         --        Find normF(A).
         --
         SCALE := ZERO;
         SUM   := ONE;
         if N > 1 then
            DLASSQ (N - 1, E'Address, 1, SCALE, SUM);
            SUM := 2.0e0 * SUM;
         end if;
         DLASSQ (N, D'Address, 1, SCALE, SUM);
         ANORM := SCALE * Sqrt (SUM);
      end if;
      --
      DLANST_Result := ANORM;
      return DLANST_Result;
      --
      --     End of DLANST
      --
   end DLANST;

   function DLANSY
     (NORM : Character;
      UPLO : Character;
      N    : Integer;
      A    : Ftn_Real_Matrix;
      LDA  : Integer;
      WORK : in out Ftn_Real_Vector)
      return Real
   is
      ONE           : constant Real := 1.0e0;
      ZERO          : constant Real := 0.0e0;
      I             : Integer;
      J             : Integer;
      ABSA          : Real;
      SCALE         : Real;
      SUM           : Real;
      VALUE         : Real;
      DLANSY_Result : Real;

   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASSQ
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N = 0 then
         VALUE := ZERO;
      elsif LSAME (NORM, 'M') then
         --
         --        Find max(abs(A(i,j))).
         --
         VALUE := ZERO;
         if LSAME (UPLO, 'U') then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J;
                  VALUE := max (VALUE, abs (A (I, J)));
               end loop;
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := J - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  VALUE := max (VALUE, abs (A (I, J)));
               end loop;
            end loop;
         end if;
      elsif (LSAME (NORM, 'I')) or (LSAME (NORM, 'O')) or (NORM = '1') then
         --
         --        Find normI(A) ( = norm1(A), since A is symmetric).
         --
         VALUE := ZERO;
         if LSAME (UPLO, 'U') then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               SUM := ZERO;
               I   := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J - 1;
                  ABSA     := abs (A (I, J));
                  SUM      := SUM + ABSA;
                  WORK (I) := WORK (I) + ABSA;
               end loop;
               WORK (J) := SUM + abs (A (J, J));
            end loop;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               VALUE := max (VALUE, WORK (I));
            end loop;
         else
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               WORK (I) := ZERO;
            end loop;
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               SUM := WORK (J) + abs (A (J, J));
               I   := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  ABSA     := abs (A (I, J));
                  SUM      := SUM + ABSA;
                  WORK (I) := WORK (I) + ABSA;
               end loop;
               VALUE := max (VALUE, SUM);
            end loop;
         end if;
      elsif (LSAME (NORM, 'F')) or (LSAME (NORM, 'E')) then
         --
         --        Find normF(A).
         --
         SCALE := ZERO;
         SUM   := ONE;
         if LSAME (UPLO, 'U') then
            J := 2 - 1;
            loop
               J := J + 1;
               exit when J > N;
               DLASSQ (J - 1, A (1, J)'Address, 1, SCALE, SUM);
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N - 1;
               DLASSQ (N - J, A (J + 1, J)'Address, 1, SCALE, SUM);
            end loop;
         end if;
         SUM := 2.0 * SUM;
         DLASSQ (N, A'Address, LDA + 1, SCALE, SUM);
         VALUE := SCALE * Sqrt (SUM);
      end if;
      --
      DLANSY_Result := VALUE;
      return DLANSY_Result;
      --
      --     End of DLANSY
      --
   end DLANSY;

   procedure DLANV2
     (A    : in out Real;
      B    : in out Real;
      C    : in out Real;
      D    : in out Real;
      RT1R : in out Real;
      RT1I : in out Real;
      RT2R : in out Real;
      RT2I : in out Real;
      CS   : in out Real;
      SN   : in out Real)
   is
      ZERO   : constant Real := 0.0e0;
      HALF   : constant Real := 0.5e0;
      ONE    : constant Real := 1.0e0;
      MULTPL : constant Real := 4.0e0;
      AA     : Real;
      BB     : Real;
      BCMAX  : Real;
      BCMIS  : Real;
      CC     : Real;
      CS1    : Real;
      DD     : Real;
      EPS    : Real;
      P      : Real;
      SAB    : Real;
      SAC    : Real;
      SCALE  : Real;
      SIGMA  : Real;
      SN1    : Real;
      TAU    : Real;
      TEMP   : Real;
      Z      : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLANV2( A, B, C, D, RT1R, RT1I, RT2R, RT2I, CS, SN )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   A, B, C, CS, D, RT1I, RT1R, RT2I, RT2R, SN
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
   --  matrix in standard form:
   --
   --       [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
   --       [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
   --
   --  where either
   --  (1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
   --  (2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
   --  conjugate eigenvalues.
   --
   --  Arguments:
   --  ==========
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION
   --
   --  [in,out] B
   --           B is DOUBLE PRECISION
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION
   --           On entry, the elements of the input matrix.
   --           On exit, they are overwritten by the elements of the
   --           standardised Schur form.
   --
   --  [out] RT1R
   --           RT1R is DOUBLE PRECISION
   --
   --  [out] RT1I
   --           RT1I is DOUBLE PRECISION
   --
   --  [out] RT2R
   --           RT2R is DOUBLE PRECISION
   --
   --  [out] RT2I
   --           RT2I is DOUBLE PRECISION
   --           The real and imaginary parts of the eigenvalues. If the
   --           eigenvalues are a complex conjugate pair, RT1I > 0.
   --
   --  [out] CS
   --           CS is DOUBLE PRECISION
   --
   --  [out] SN
   --           SN is DOUBLE PRECISION
   --           Parameters of the rotation matrix.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Modified by V. Sima, Research Institute for Informatics, Bucharest,
   --   Romania, to reduce the risk of cancellation errors,
   --   when computing real eigenvalues, and to ensure, if possible, that
   --   abs(RT1R) >= abs(RT2R).
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, HALF = 0.5D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( MULTPL = 4.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH, DLAPY2
   --      EXTERNAL           DLAMCH, DLAPY2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      EPS := DLAMCH ('P');
      if C = ZERO then
         CS := ONE;
         SN := ZERO;
         goto L10;
      --
      elsif B = ZERO then
         --
         --        Swap rows and columns
         --
         CS   := ZERO;
         SN   := ONE;
         TEMP := D;
         D    := A;
         A    := TEMP;
         B    := -C;
         C    := ZERO;
         goto L10;
      elsif (A - D) = ZERO and sign (ONE, B) /= sign (ONE, C) then
         CS := ONE;
         SN := ZERO;
         goto L10;
      else
         --
         TEMP  := A - D;
         P     := HALF * TEMP;
         BCMAX := max (abs (B), abs (C));
         BCMIS := min (abs (B), abs (C)) * sign (ONE, B) * sign (ONE, C);
         SCALE := max (abs (P), BCMAX);
         Z     := (P / SCALE) * P + (BCMAX / SCALE) * BCMIS;
         --
         --        If Z is of the order of the machine accuracy, postpone the
         --        decision on the nature of eigenvalues
         --
         if Z >= MULTPL * EPS then
            --
            --           Real eigenvalues. Compute A and D.
            --
            Z := P + sign (Sqrt (SCALE) * Sqrt (Z), P);
            A := D + Z;
            D := D - (BCMAX / Z) * BCMIS;
            --
            --           Compute B and the rotation matrix
            --
            TAU := DLAPY2 (C, Z);
            CS  := Z / TAU;
            SN  := C / TAU;
            B   := B - C;
            C   := ZERO;
         else
            --
            --           Complex eigenvalues, or real (almost) equal eigenvalues.
            --           Make diagonal elements equal.
            --
            SIGMA := B + C;
            TAU   := DLAPY2 (SIGMA, TEMP);
            CS    := Sqrt (HALF * (ONE + abs (SIGMA) / TAU));
            SN    := -(P / (TAU * CS)) * sign (ONE, SIGMA);
            --
            --           Compute [ AA  BB ] = [ A  B ] [ CS -SN ]
            --                   [ CC  DD ]   [ C  D ] [ SN  CS ]
            --
            AA := A * CS + B * SN;
            BB := -A * SN + B * CS;
            CC := C * CS + D * SN;
            DD := -C * SN + D * CS;
            --
            --           Compute [ A  B ] = [ CS  SN ] [ AA  BB ]
            --                   [ C  D ]   [-SN  CS ] [ CC  DD ]
            --
            A := AA * CS + CC * SN;
            B := BB * CS + DD * SN;
            C := -AA * SN + CC * CS;
            D := -BB * SN + DD * CS;
            --
            TEMP := HALF * (A + D);
            A    := TEMP;
            D    := TEMP;
            --
            if C /= ZERO then
               if B /= ZERO then
                  if sign (ONE, B) = sign (ONE, C) then
                     --
                     --                    Real eigenvalues: reduce to upper triangular form
                     --
                     SAB  := Sqrt (abs (B));
                     SAC  := Sqrt (abs (C));
                     P    := sign (SAB * SAC, C);
                     TAU  := ONE / Sqrt (abs (B + C));
                     A    := TEMP + P;
                     D    := TEMP - P;
                     B    := B - C;
                     C    := ZERO;
                     CS1  := SAB * TAU;
                     SN1  := SAC * TAU;
                     TEMP := CS * CS1 - SN * SN1;
                     SN   := CS * SN1 + SN * CS1;
                     CS   := TEMP;
                  end if;
               else
                  B    := -C;
                  C    := ZERO;
                  TEMP := CS;
                  CS   := -SN;
                  SN   := TEMP;
               end if;
            end if;
         end if;
         --
      end if;
      --
      <<L10>> null;
      --
      --     Store eigenvalues in (RT1R,RT1I) and (RT2R,RT2I).
      --
      RT1R := A;
      RT2R := D;
      if C = ZERO then
         RT1I := ZERO;
         RT2I := ZERO;
      else
         RT1I := Sqrt (abs (B)) * Sqrt (abs (C));
         RT2I := -RT1I;
      end if;
      return;
      --
      --     End of DLANV2
      --
   end DLANV2;

   function DLAPY2 (X : Real; Y : Real) return Real is
      ZERO          : constant Real := 0.0e0;
      ONE           : constant Real := 1.0e0;
      W             : Real;
      XABS          : Real;
      YABS          : Real;
      Z             : Real;
      DLAPY2_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION DLAPY2( X, Y )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   X, Y
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
   --  overflow.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] X
   --           X is DOUBLE PRECISION
   --
   --  [in] Y
   --           Y is DOUBLE PRECISION
   --           X and Y specify the values x and y.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --      PARAMETER          ( ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      XABS := abs (X);
      YABS := abs (Y);
      W    := max (XABS, YABS);
      Z    := min (XABS, YABS);
      if Z = ZERO 
         then DLAPY2_Result := W;
         else DLAPY2_Result := W * Sqrt (ONE + (Z / W) ** 2);
      end if;
      return DLAPY2_Result;
      --
      --     End of DLAPY2
      --
   end DLAPY2;

   function DLAPY3
     (X    : Real;
      Y    : Real;
      Z    : Real)
      return Real
   is
      ZERO          : constant Real := 0.0e0;
      W             : Real;
      XABS          : Real;
      YABS          : Real;
      ZABS          : Real;
      DLAPY3_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION DLAPY3( X, Y, Z )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   X, Y, Z
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
   --  unnecessary overflow.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] X
   --           X is DOUBLE PRECISION
   --
   --  [in] Y
   --           Y is DOUBLE PRECISION
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION
   --           X, Y and Z specify the values x, y and z.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      XABS := abs (X);
      YABS := abs (Y);
      ZABS := abs (Z);
      W    := max (XABS, YABS, ZABS);
      if W = ZERO then
         --     W can be zero for max(0,nan,0)
         --     adding all three entries together will make sure
         --     NaN will not disappear.
         DLAPY3_Result := XABS + YABS + ZABS;
      else
         DLAPY3_Result := W * Sqrt ((XABS / W) ** 2 + (YABS / W) ** 2 + (ZABS / W) ** 2);
      end if;
      return DLAPY3_Result;
      --
      --     End of DLAPY3
      --
   end DLAPY3;

   procedure DLAQR0
     (WANTT : Boolean;
      WANTZ : Boolean;
      N     : Integer;
      ILO   : Integer;
      IHI   : Integer;
      H     : in out Ftn_Real_Matrix;
      LDH   : Integer;
      WR    : in out Ftn_Real_Vector;
      WI    : in out Ftn_Real_Vector;
      ILOZ  : Integer;
      IHIZ  : Integer;
      Z     : in out Ftn_Real_Matrix;
      LDZ   : Integer;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      NTINY  : constant Integer := 11;
      KEXNW  : constant Integer := 5;
      KEXSH  : constant Integer := 6;
      WILK1  : constant Real    := 0.75e0;
      WILK2  : constant Real    := -0.4375e0;
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      AA     : Real;
      BB     : Real;
      CC     : Real;
      CS     : Real;
      DD     : Real;
      SN     : Real;
      SS     : Real;
      SWAP   : Real;
      I      : Integer;
      INF    : Integer;
      IT     : Integer;
      ITMAX  : Integer;
      K      : Integer;
      KACC22 : Integer;
      KBOT   : Integer;
      KDU    : Integer;
      KS     : Integer;
      KT     : Integer;
      KTOP   : Integer;
      KU     : Integer;
      KV     : Integer;
      KWH    : Integer;
      KWTOP  : Integer;
      KWV    : Integer;
      LD     : Integer;
      LS     : Integer;
      LWKOPT : Integer;
      NDEC   : Integer;
      NDFL   : Integer;
      NH     : Integer;
      NHO    : Integer;
      NIBBLE : Integer;
      NMIN   : Integer;
      NS     : Integer;
      NSMAX  : Integer;
      NSR    : Integer;
      NVE    : Integer;
      NW     : Integer;
      NWMAX  : Integer;
      NWR    : Integer;
      NWUPBD : Integer;
      SORTED : Boolean;
      JBCMPZ : String (1 .. 2);
      ZDUM   : Ftn_Real_Matrix (1 .. 1, 1 .. 1);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAQR0( WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI,
   --                          ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, LWORK, N
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   H( LDH, * ), WI( * ), WORK( * ), WR( * ),
   --      $                   Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DLAQR0 computes the eigenvalues of a Hessenberg matrix H
   --     and, optionally, the matrices T and Z from the Schur decomposition
   --     H = Z T Z**T, where T is an upper quasi-triangular matrix (the
   --     Schur form), and Z is the orthogonal matrix of Schur vectors.
   --
   --     Optionally Z may be postmultiplied into an input orthogonal
   --     matrix Q so that this routine can give the Schur factorization
   --     of a matrix A which has been reduced to the Hessenberg form H
   --     by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           = .TRUE. : the full Schur form T is required;
   --           = .FALSE.: only eigenvalues are required.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           = .TRUE. : the matrix of Schur vectors Z is required;
   --           = .FALSE.: Schur vectors are not required.
   --
   --  [in] N
   --           N is INTEGER
   --            The order of the matrix H.  N .GE. 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --            It is assumed that H is already upper triangular in rows
   --            and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
   --            H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
   --            previous call to DGEBAL, and then passed to DGEHRD when the
   --            matrix output by DGEBAL is reduced to Hessenberg form.
   --            Otherwise, ILO and IHI should be set to 1 and N,
   --            respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
   --            If N = 0, then ILO = 1 and IHI = 0.
   --
   --  [in,out] H
   --           H is DOUBLE PRECISION array, dimension (LDH,N)
   --            On entry, the upper Hessenberg matrix H.
   --            On exit, if INFO = 0 and WANTT is .TRUE., then H contains
   --            the upper quasi-triangular matrix T from the Schur
   --            decomposition (the Schur form); 2-by-2 diagonal blocks
   --            (corresponding to complex conjugate pairs of eigenvalues)
   --            are returned in standard form, with H(i,i) = H(i+1,i+1)
   --            and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
   --            .FALSE., then the contents of H are unspecified on exit.
   --            (The output value of H when INFO.GT.0 is given under the
   --            description of INFO below.)
   --
   --            This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
   --            j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
   --
   --  [in] LDH
   --           LDH is INTEGER
   --            The leading dimension of the array H. LDH .GE. max(1,N).
   --
   --  [out] WR
   --           WR is DOUBLE PRECISION array, dimension (IHI)
   --
   --  [out] WI
   --           WI is DOUBLE PRECISION array, dimension (IHI)
   --            The real and imaginary parts, respectively, of the computed
   --            eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
   --            and WI(ILO:IHI). If two eigenvalues are computed as a
   --            complex conjugate pair, they are stored in consecutive
   --            elements of WR and WI, say the i-th and (i+1)th, with
   --            WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
   --            the eigenvalues are stored in the same order as on the
   --            diagonal of the Schur form returned in H, with
   --            WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
   --            block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
   --            WI(i+1) = -WI(i).
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --            Specify the rows of Z to which transformations must be
   --            applied if WANTZ is .TRUE..
   --            1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension (LDZ,IHI)
   --            If WANTZ is .FALSE., then Z is not referenced.
   --            If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
   --            replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
   --            orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
   --            (The output value of Z when INFO.GT.0 is given under
   --            the description of INFO below.)
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --            The leading dimension of the array Z.  if WANTZ is .TRUE.
   --            then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension LWORK
   --            On exit, if LWORK = -1, WORK(1) returns an estimate of
   --            the optimal value for LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --            The dimension of the array WORK.  LWORK .GE. max(1,N)
   --            is sufficient, but LWORK typically as large as 6*N may
   --            be required for optimal performance.  A workspace query
   --            to determine the optimal workspace size is recommended.
   --
   --            If LWORK = -1, then DLAQR0 does a workspace query.
   --            In this case, DLAQR0 checks the input parameters and
   --            estimates the optimal workspace size for the given
   --            values of N, ILO and IHI.  The estimate is returned
   --            in WORK(1).  No error message related to LWORK is
   --            issued by XERBLA.  Neither H nor Z are accessed.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --              =  0:  successful exit
   --            .GT. 0:  if INFO = i, DLAQR0 failed to compute all of
   --                 the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
   --                 and WI contain those eigenvalues which have been
   --                 successfully computed.  (Failures are rare.)
   --
   --                 If INFO .GT. 0 and WANT is .FALSE., then on exit,
   --                 the remaining unconverged eigenvalues are the eigen-
   --                 values of the upper Hessenberg matrix rows and
   --                 columns ILO through INFO of the final, output
   --                 value of H.
   --
   --                 If INFO .GT. 0 and WANTT is .TRUE., then on exit
   --
   --            (*)  (initial value of H)*U  = U*(final value of H)
   --
   --                 where U is an orthogonal matrix.  The final
   --                 value of H is upper Hessenberg and quasi-triangular
   --                 in rows and columns INFO+1 through IHI.
   --
   --                 If INFO .GT. 0 and WANTZ is .TRUE., then on exit
   --
   --                   final value of Z(ILO:IHI,ILOZ:IHIZ)
   --                    =  initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
   --
   --                 where U is the orthogonal matrix in (*) (regard-
   --                 less of the value of WANTT.)
   --
   --                 If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
   --                 accessed.
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  References:
   --  ================
   --
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
   --        Performance, SIAM Journal of Matrix Analysis, volume 23, pages
   --        929--947, 2002.
   --  \n
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part II: Aggressive Early Deflation, SIAM Journal
   --        of Matrix Analysis, volume 23, pages 948--973, 2002.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --
   --     .. Parameters ..
   --
   --     ==== Matrices of order NTINY or smaller must be processed by
   --     .    DLAHQR because of insufficient subdiagonal scratch space.
   --     .    (This is a hard limit.) ====
   --      PARAMETER          ( NTINY = 11 )
   --
   --     ==== Exceptional deflation windows:  try to cure rare
   --     .    slow convergence by varying the size of the
   --     .    deflation window after KEXNW iterations. ====
   --      PARAMETER          ( KEXNW = 5 )
   --
   --     ==== Exceptional shifts: try to cure rare slow convergence
   --     .    with ad-hoc exceptional shifts every KEXSH iterations.
   --     .    ====
   --      PARAMETER          ( KEXSH = 6 )
   --
   --     ==== The constants WILK1 and WILK2 are used to form the
   --     .    exceptional shifts. ====
   --      PARAMETER          ( WILK1 = 0.75d0, WILK2 = -0.4375d0 )
   --      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      INTEGER            ILAENV
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLACPY, DLAHQR, DLANV2, DLAQR3, DLAQR4, DLAQR5
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, MAX, MIN, MOD
   --     ..
   --     .. Executable Statements ..
   begin
      INFO := 0;
      --
      --     ==== Quick return for N = 0: nothing to do. ====
      --
      if N = 0 then
         WORK (1) := ONE;
         return;
      end if;
      --
      if N <= NTINY then
         --
         --        ==== Tiny matrices must use DLAHQR. ====
         --
         LWKOPT := 1;
         if LWORK /= -1 then
            DLAHQR (WANTT, WANTZ, N, ILO, IHI, H'Address, LDH, WR'Address, WI'Address, ILOZ, IHIZ, Z'Address, LDZ, INFO);
         end if;
      else
         --
         --        ==== Use small bulge multi-shift QR with aggressive early
         --        .    deflation on larger-than-tiny matrices. ====
         --
         --        ==== Hope for the best. ====
         --
         INFO := 0;
         --
         --        ==== Set up job flags for ILAENV. ====
         --
         if WANTT 
            then JBCMPZ (1) := 'S';
            else JBCMPZ (1) := 'E';
         end if;
         if WANTZ 
            then JBCMPZ (2) := 'V';
            else JBCMPZ (2) := 'N';
         end if;
         --
         --        ==== NWR = recommended deflation window size.  At this
         --        .    point,  N .GT. NTINY = 11, so there is enough
         --        .    subdiagonal workspace for NWR.GE.2 as required.
         --        .    (In fact, there is enough subdiagonal space for
         --        .    NWR.GE.3.) ====
         --
         NWR := ILAENV (13, "DLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         NWR := max (2, NWR);
         NWR := min (IHI - ILO + 1, (N - 1) / 3, NWR);
         --
         --        ==== NSR = recommended number of simultaneous shifts.
         --        .    At this point N .GT. NTINY = 11, so there is at
         --        .    enough subdiagonal workspace for NSR to be even
         --        .    and greater than or equal to two as required. ====
         --
         NSR := ILAENV (15, "DLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         NSR := min (NSR, (N + 6) / 9, IHI - ILO);
         NSR := max (2, NSR - "mod" (NSR, 2));
         --
         --        ==== Estimate optimal workspace ====
         --
         --        ==== Workspace query call to DLAQR3 ====
         --
         DLAQR3
           (WANTT,
            WANTZ,
            N,
            ILO,
            IHI,
            NWR + 1,
            H'Address,
            LDH,
            ILOZ,
            IHIZ,
            Z'Address,
            LDZ,
            LS,
            LD,
            WR'Address,
            WI'Address,
            H'Address,
            LDH,
            N,
            H'Address,
            LDH,
            N,
            H'Address,
            LDH,
            WORK'Address,
            -1);
         --
         --        ==== Optimal workspace = MAX(DLAQR5, DLAQR3) ====
         --
         LWKOPT := max (3 * NSR / 2, int (WORK (1)));
         --
         --        ==== Quick return in case of workspace query. ====
         --
         if LWORK = -1 then
            WORK (1) := Real (LWKOPT);
            return;
         end if;
         --
         --        ==== DLAHQR/DLAQR0 crossover point ====
         --
         NMIN := ILAENV (12, "DLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         NMIN := max (NTINY, NMIN);
         --
         --        ==== Nibble crossover point ====
         --
         NIBBLE := ILAENV (14, "DLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         NIBBLE := max (0, NIBBLE);
         --
         --        ==== Accumulate reflections during ttswp?  Use block
         --        .    2-by-2 structure during matrix-matrix multiply? ====
         --
         KACC22 := ILAENV (16, "DLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         KACC22 := max (0, KACC22);
         KACC22 := min (2, KACC22);
         --
         --        ==== NWMAX = the largest possible deflation window for
         --        .    which there is sufficient workspace. ====
         --
         NWMAX := min ((N - 1) / 3, LWORK / 2);
         NW    := NWMAX;
         --
         --        ==== NSMAX = the Largest number of simultaneous shifts
         --        .    for which there is sufficient workspace. ====
         --
         NSMAX := min ((N + 6) / 9, 2 * LWORK / 3);
         NSMAX := NSMAX - "mod" (NSMAX, 2);
         --
         --        ==== NDFL: an iteration count restarted at deflation. ====
         --
         NDFL := 1;
         --
         --        ==== ITMAX = iteration limit ====
         --
         ITMAX := max (30, 2 * KEXSH) * max (10, (IHI - ILO + 1));
         --
         --        ==== Last row and column in the active block ====
         --
         KBOT := IHI;
         --
         --        ==== Main Loop ====
         --
         IT := 1 - 1;
         loop
            IT := IT + 1;
            exit when IT > ITMAX;
            --
            --           ==== Done when KBOT falls below ILO ====
            --
            if KBOT < ILO then
               goto L90;
            end if;
            --
            --           ==== Locate active block ====
            --
            K := KBOT + 1;
            loop
               K := K - 1;
               exit when K < ILO + 1;
               if H (K, K - 1) = ZERO then
                  goto L20;
               end if;
            end loop;
            K := ILO;
            <<L20>> null;
            KTOP := K;
            --
            --           ==== Select deflation window size:
            --           .    Typical Case:
            --           .      If possible and advisable, nibble the entire
            --           .      active block.  If not, use size MIN(NWR,NWMAX)
            --           .      or MIN(NWR+1,NWMAX) depending upon which has
            --           .      the smaller corresponding subdiagonal entry
            --           .      (a heuristic).
            --           .
            --           .    Exceptional Case:
            --           .      If there have been no deflations in KEXNW or
            --           .      more iterations, then vary the deflation window
            --           .      size.   At first, because, larger windows are,
            --           .      in general, more powerful than smaller ones,
            --           .      rapidly increase the window to the maximum possible.
            --           .      Then, gradually reduce the window size. ====
            --
            NH     := KBOT - KTOP + 1;
            NWUPBD := min (NH, NWMAX);
            if NDFL < KEXNW 
               then NW := min (NWUPBD, NWR);
               else NW := min (NWUPBD, 2 * NW);
            end if;
            if NW < NWMAX then
               if NW >= NH - 1 then
                  NW := NH;
               else
                  KWTOP := KBOT - NW + 1;
                  if abs (H (KWTOP, KWTOP - 1)) > abs (H (KWTOP - 1, KWTOP - 2)) then
                     NW := NW + 1;
                  end if;
               end if;
            end if;
            if NDFL < KEXNW then
               NDEC := -1;
            elsif NDEC >= 0 or NW >= NWUPBD then
               NDEC := NDEC + 1;
               if NW - NDEC < 2 then
                  NDEC := 0;
               end if;
               NW := NW - NDEC;
            end if;
            --
            --           ==== Aggressive early deflation:
            --           .    split workspace under the subdiagonal into
            --           .      - an nw-by-nw work array V in the lower
            --           .        left-hand-corner,
            --           .      - an NW-by-at-least-NW-but-more-is-better
            --           .        (NW-by-NHO) horizontal work array along
            --           .        the bottom edge,
            --           .      - an at-least-NW-but-more-is-better (NHV-by-NW)
            --           .        vertical work array along the left-hand-edge.
            --           .        ====
            --
            KV  := N - NW + 1;
            KT  := NW + 1;
            NHO := (N - NW - 1) - KT + 1;
            KWV := NW + 2;
            NVE := (N - NW) - KWV + 1;
            --
            --           ==== Aggressive early deflation ====
            --
            DLAQR3
              (WANTT,
               WANTZ,
               N,
               KTOP,
               KBOT,
               NW,
               H'Address,
               LDH,
               ILOZ,
               IHIZ,
               Z'Address,
               LDZ,
               LS,
               LD,
               WR'Address,
               WI'Address,
               H (KV, 1)'Address,
               LDH,
               NHO,
               H (KV, KT)'Address,
               LDH,
               NVE,
               H (KWV, 1)'Address,
               LDH,
               WORK'Address,
               LWORK);
            --
            --           ==== Adjust KBOT accounting for new deflations. ====
            --
            KBOT := KBOT - LD;
            --
            --           ==== KS points to the shifts. ====
            --
            KS := KBOT - LS + 1;
            --
            --           ==== Skip an expensive QR sweep if there is a (partly
            --           .    heuristic) reason to expect that many eigenvalues
            --           .    will deflate without it.  Here, the QR sweep is
            --           .    skipped if many eigenvalues have just been deflated
            --           .    or if the remaining active block is small.
            --
            if (LD = 0) or ((100 * LD <= NW * NIBBLE) and (KBOT - KTOP + 1 > min (NMIN, NWMAX))) then
               --
               --              ==== NS = nominal number of simultaneous shifts.
               --              .    This may be lowered (slightly) if DLAQR3
               --              .    did not provide that many shifts. ====
               --
               NS := min (NSMAX, NSR, max (2, KBOT - KTOP));
               NS := NS - "mod" (NS, 2);
               --
               --              ==== If there have been no deflations
               --              .    in a multiple of KEXSH iterations,
               --              .    then try exceptional shifts.
               --              .    Otherwise use shifts provided by
               --              .    DLAQR3 above or from the eigenvalues
               --              .    of a trailing principal submatrix. ====
               --
               if "mod" (NDFL, KEXSH) = 0 then
                  KS := KBOT - NS + 1;
                  I  := KBOT + 2;
                  loop
                     I := I - 2;
                     exit when I < max (KS + 1, KTOP + 2);
                     SS := abs (H (I, I - 1)) + abs (H (I - 1, I - 2));
                     AA := WILK1 * SS + H (I, I);
                     BB := SS;
                     CC := WILK2 * SS;
                     DD := AA;
                     DLANV2 (AA, BB, CC, DD, WR (I - 1), WI (I - 1), WR (I), WI (I), CS, SN);
                  end loop;
                  if KS = KTOP then
                     WR (KS + 1) := H (KS + 1, KS + 1);
                     WI (KS + 1) := ZERO;
                     WR (KS)     := WR (KS + 1);
                     WI (KS)     := WI (KS + 1);
                  end if;
               else
                  --
                  --                 ==== Got NS/2 or fewer shifts? Use DLAQR4 or
                  --                 .    DLAHQR on a trailing principal submatrix to
                  --                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                  --                 .    there is enough space below the subdiagonal
                  --                 .    to fit an NS-by-NS scratch array.) ====
                  --
                  if KBOT - KS + 1 <= NS / 2 then
                     KS := KBOT - NS + 1;
                     KT := N - NS + 1;
                     DLACPY ('A', NS, NS, H (KS, KS)'Address, LDH, H (KT, 1)'Address, LDH);
                     if NS > NMIN then
                        DLAQR4
                          (False,
                           False,
                           NS,
                           1,
                           NS,
                           H (KT, 1)'Address,
                           LDH,
                           WR (KS)'Address,
                           WI (KS)'Address,
                           1,
                           1,
                           ZDUM'Address,
                           1,
                           WORK'Address,
                           LWORK,
                           INF);
                     else
                        DLAHQR
                          (False,
                           False,
                           NS,
                           1,
                           NS,
                           H (KT, 1)'Address,
                           LDH,
                           WR (KS)'Address,
                           WI (KS)'Address,
                           1,
                           1,
                           ZDUM'Address,
                           1,
                           INF);
                     end if;
                     KS := KS + INF;
                     --
                     --                    ==== In case of a rare QR failure use
                     --                    .    eigenvalues of the trailing 2-by-2
                     --                    .    principal submatrix.  ====
                     --
                     if KS >= KBOT then
                        AA := H (KBOT - 1, KBOT - 1);
                        CC := H (KBOT, KBOT - 1);
                        BB := H (KBOT - 1, KBOT);
                        DD := H (KBOT, KBOT);
                        DLANV2 (AA, BB, CC, DD, WR (KBOT - 1), WI (KBOT - 1), WR (KBOT), WI (KBOT), CS, SN);
                        KS := KBOT - 1;
                     end if;
                  end if;
                  --
                  if KBOT - KS + 1 > NS then
                     --
                     --                    ==== Sort the shifts (Helps a little)
                     --                    .    double sort keeps complex conjugate
                     --                    .    pairs together. ====
                     --
                     SORTED := False;
                     K      := KBOT + 1;
                     loop
                        K := K - 1;
                        exit when K < KS + 1;
                        if SORTED then
                           goto L60;
                        end if;
                        SORTED := True;
                        I      := KS - 1;
                        loop
                           I := I + 1;
                           exit when I > K - 1;
                           if abs (WR (I)) + abs (WI (I)) < abs (WR (I + 1)) + abs (WI (I + 1)) then
                              SORTED := False;
                              --
                              SWAP       := WR (I);
                              WR (I)     := WR (I + 1);
                              WR (I + 1) := SWAP;
                              --
                              SWAP       := WI (I);
                              WI (I)     := WI (I + 1);
                              WI (I + 1) := SWAP;
                           end if;
                        end loop;
                     end loop;
                     <<L60>> null;
                  end if;
                  --
                  --                 ==== Shuffle shifts into pairs of real shifts
                  --                 .    and pairs of complex conjugate shifts
                  --                 .    assuming complex conjugate shifts are
                  --                 .    already adjacent to one another. (Yes,
                  --                 .    they are.)  ====
                  --
                  I := KBOT + 2;
                  loop
                     I := I - 2;
                     exit when I < KS + 2;
                     if WI (I) /= -WI (I - 1) then
                        --
                        SWAP       := WR (I);
                        WR (I)     := WR (I - 1);
                        WR (I - 1) := WR (I - 2);
                        WR (I - 2) := SWAP;
                        --
                        SWAP       := WI (I);
                        WI (I)     := WI (I - 1);
                        WI (I - 1) := WI (I - 2);
                        WI (I - 2) := SWAP;
                     end if;
                  end loop;
               end if;
               --
               --              ==== If there are only two shifts and both are
               --              .    real, then use only one.  ====
               --
               if KBOT - KS + 1 = 2 then
                  if WI (KBOT) = ZERO then
                     if abs (WR (KBOT) - H (KBOT, KBOT)) < abs (WR (KBOT - 1) - H (KBOT, KBOT)) 
                        then WR (KBOT - 1) := WR (KBOT);
                        else WR (KBOT) := WR (KBOT - 1);
                     end if;
                  end if;
               end if;
               --
               --              ==== Use up to NS of the the smallest magnatiude
               --              .    shifts.  If there aren't NS shifts available,
               --              .    then use them all, possibly dropping one to
               --              .    make the number of shifts even. ====
               --
               NS := min (NS, KBOT - KS + 1);
               NS := NS - "mod" (NS, 2);
               KS := KBOT - NS + 1;
               --
               --              ==== Small-bulge multi-shift QR sweep:
               --              .    split workspace under the subdiagonal into
               --              .    - a KDU-by-KDU work array U in the lower
               --              .      left-hand-corner,
               --              .    - a KDU-by-at-least-KDU-but-more-is-better
               --              .      (KDU-by-NHo) horizontal work array WH along
               --              .      the bottom edge,
               --              .    - and an at-least-KDU-but-more-is-better-by-KDU
               --              .      (NVE-by-KDU) vertical work WV arrow along
               --              .      the left-hand-edge. ====
               --
               KDU := 3 * NS - 3;
               KU  := N - KDU + 1;
               KWH := KDU + 1;
               NHO := (N - KDU + 1 - 4) - (KDU + 1) + 1;
               KWV := KDU + 4;
               NVE := N - KDU - KWV + 1;
               --
               --              ==== Small-bulge multi-shift QR sweep ====
               --
               DLAQR5
                 (WANTT,
                  WANTZ,
                  KACC22,
                  N,
                  KTOP,
                  KBOT,
                  NS,
                  WR (KS)'Address,
                  WI (KS)'Address,
                  H'Address,
                  LDH,
                  ILOZ,
                  IHIZ,
                  Z'Address,
                  LDZ,
                  WORK'Address,
                  3,
                  H (KU, 1)'Address,
                  LDH,
                  NVE,
                  H (KWV, 1)'Address,
                  LDH,
                  NHO,
                  H (KU, KWH)'Address,
                  LDH);
            end if;
            --
            --           ==== Note progress (or the lack of it). ====
            --
            if LD > 0 
               then NDFL := 1;
               else NDFL := NDFL + 1;
            end if;
            --
            --           ==== End of main loop ====
         end loop;
         --
         --        ==== Iteration limit exceeded.  Set INFO to show where
         --        .    the problem occurred and exit. ====
         --
         INFO := KBOT;
         <<L90>> null;
      end if;
      --
      --     ==== Return the optimal value of LWORK. ====
      --
      WORK (1) := Real (LWKOPT);
      --
      --     ==== End of DLAQR0 ====
      --
   end DLAQR0;

   procedure DLAQR1
     (N     : Integer;
      H_adr : Address;
      LDH   : Integer;
      SR1   : Real;
      SI1   : Real;
      SR2   : Real;
      SI2   : Real;
      V_adr : Address)
   is

      H : Ftn_Real_Matrix (1 .. LDH, 1 .. N);
      V : Ftn_Real_Vector (1 .. N);

      for H'Address use H_adr;
      for V'Address use V_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, V);

      ZERO : constant Real := 0.0e0;
      H21S : Real;
      H31S : Real;
      S    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAQR1( N, H, LDH, SR1, SI1, SR2, SI2, V)
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   SI1, SI2, SR1, SR2
   --       INTEGER            LDH, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   H( LDH, * ), V( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --       Given a 2-by-2 or 3-by-3 matrix H, DLAQR1 sets v to a
   --       scalar multiple of the first column of the product
   --
   --       (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
   --
   --       scaling to avoid overflows and most underflows. It
   --       is assumed that either
   --
   --               (1) sr1 = sr2 and si1 = -si2
   --           or
   --               (2) si1 = si2 = 0.
   --
   --       This is useful for starting Real implicit shift bulges
   --       in the QR algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is integer
   --               Order of the matrix H. N must be either 2 or 3.
   --
   --  [in] H
   --           H is DOUBLE PRECISION array of dimension (LDH,N)
   --               The 2-by-2 or 3-by-3 matrix H in (*).
   --
   --  [in] LDH
   --           LDH is integer
   --               The leading dimension of H as declared in
   --               the calling procedure.  LDH.GE.N
   --
   --  [in] SR1
   --           SR1 is DOUBLE PRECISION
   --
   --  [in] SI1
   --           SI1 is DOUBLE PRECISION
   --
   --  [in] SR2
   --           SR2 is DOUBLE PRECISION
   --
   --  [in] SI2
   --           SI2 is DOUBLE PRECISION
   --               The shifts in (*).
   --
   --  [out] V
   --           V is DOUBLE PRECISION array of dimension N
   --               A scalar multiple of the first column of the
   --               matrix K in (*).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS
   --     ..
   --     .. Executable Statements ..
   begin
      if N = 2 then
         S := abs (H (1, 1) - SR2) + abs (SI2) + abs (H (2, 1));
         if S = ZERO then
            V (1) := ZERO;
            V (2) := ZERO;
         else
            H21S  := H (2, 1) / S;
            V (1) := H21S * H (1, 2) + (H (1, 1) - SR1) * ((H (1, 1) - SR2) / S) - SI1 * (SI2 / S);
            V (2) := H21S * (H (1, 1) + H (2, 2) - SR1 - SR2);
         end if;
      else
         S := abs (H (1, 1) - SR2) + abs (SI2) + abs (H (2, 1)) + abs (H (3, 1));
         if S = ZERO then
            V (1) := ZERO;
            V (2) := ZERO;
            V (3) := ZERO;
         else
            H21S  := H (2, 1) / S;
            H31S  := H (3, 1) / S;
            V (1) := (H (1, 1) - SR1) * ((H (1, 1) - SR2) / S) -
                     SI1 * (SI2 / S) +
                     H (1, 2) * H21S +
                     H (1, 3) * H31S;
            V (2) := H21S * (H (1, 1) + H (2, 2) - SR1 - SR2) + H (2, 3) * H31S;
            V (3) := H31S * (H (1, 1) + H (3, 3) - SR1 - SR2) + H21S * H (3, 2);
         end if;
      end if;
   end DLAQR1;

   procedure DLAQR2
     (WANTT    : Boolean;
      WANTZ    : Boolean;
      N        : Integer;
      KTOP     : Integer;
      KBOT     : Integer;
      NW       : Integer;
      H_adr    : Address;
      LDH      : Integer;
      ILOZ     : Integer;
      IHIZ     : Integer;
      Z_adr    : Address;
      LDZ      : Integer;
      NS       : in out Integer;
      ND       : in out Integer;
      SR_adr   : Address;
      SI_adr   : Address;
      V_adr    : Address;
      LDV      : Integer;
      NH       : Integer;
      T_adr    : Address;
      LDT      : Integer;
      NV       : Integer;
      WV_adr   : Address;
      LDWV     : Integer;
      WORK_adr : Address;
      LWORK    : Integer)
   is

      H    : Ftn_Real_Matrix (1 .. LDH, 1 .. N);
      Z    : Ftn_Real_Matrix (1 .. LDZ, 1 .. N);
      SR   : Ftn_Real_Vector (1 .. KBOT);
      SI   : Ftn_Real_Vector (1 .. KBOT);
      V    : Ftn_Real_Matrix (1 .. LDV, 1 .. NW);
      T    : Ftn_Real_Matrix (1 .. LDT, 1 .. NW);
      WV   : Ftn_Real_Matrix (1 .. LDWV, 1 .. NW);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for H'Address use H_adr;
      for Z'Address use Z_adr;
      for SR'Address use SR_adr;
      for SI'Address use SI_adr;
      for V'Address use V_adr;
      for T'Address use T_adr;
      for WV'Address use WV_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, Z);
      pragma Import (Ada, SR);
      pragma Import (Ada, SI);
      pragma Import (Ada, V);
      pragma Import (Ada, T);
      pragma Import (Ada, WV);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      AA     : Real;
      BB     : Real;
      BETA   : Real;
      CC     : Real;
      CS     : Real;
      DD     : Real;
      EVI    : Real;
      EVK    : Real;
      FOO    : Real;
      S      : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SMLNUM : Real;
      SN     : Real;
      TAU    : Real;
      ULP    : Real;
      I      : Integer;
      IFST   : Integer;
      ILST   : Integer;
      INFO   : Integer;
      INFQR  : Integer;
      J      : Integer;
      JW     : Integer;
      K      : Integer;
      KCOL   : Integer;
      KEND   : Integer;
      KLN    : Integer;
      KROW   : Integer;
      KWTOP  : Integer;
      LTOP   : Integer;
      LWK1   : Integer;
      LWK2   : Integer;
      LWKOPT : Integer;
      BULGE  : Boolean;
      SORTED : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAQR2( WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ,
   --                          IHIZ, Z, LDZ, NS, ND, SR, SI, V, LDV, NH, T,
   --                          LDT, NV, WV, LDWV, WORK, LWORK )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHIZ, ILOZ, KBOT, KTOP, LDH, LDT, LDV, LDWV,
   --      $                   LDZ, LWORK, N, ND, NH, NS, NV, NW
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   H( LDH, * ), SI( * ), SR( * ), T( LDT, * ),
   --      $                   V( LDV, * ), WORK( * ), WV( LDWV, * ),
   --      $                   Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DLAQR2 is identical to DLAQR3 except that it avoids
   --     recursion by calling DLAHQR instead of DLAQR4.
   --
   --     Aggressive early deflation:
   --
   --     This subroutine accepts as input an upper Hessenberg matrix
   --     H and performs an orthogonal similarity transformation
   --     designed to detect and deflate fully converged eigenvalues from
   --     a trailing principal submatrix.  On output H has been over-
   --     written by a new Hessenberg matrix that is a perturbation of
   --     an orthogonal similarity transformation of H.  It is to be
   --     hoped that the final version of H has many zero subdiagonal
   --     entries.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           If .TRUE., then the Hessenberg matrix H is fully updated
   --           so that the quasi-triangular Schur factor may be
   --           computed (in cooperation with the calling subroutine).
   --           If .FALSE., then only enough of H is updated to preserve
   --           the eigenvalues.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           If .TRUE., then the orthogonal matrix Z is updated so
   --           so that the orthogonal Schur factor may be computed
   --           (in cooperation with the calling subroutine).
   --           If .FALSE., then Z is not referenced.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix H and (if WANTZ is .TRUE.) the
   --           order of the orthogonal matrix Z.
   --
   --  [in] KTOP
   --           KTOP is INTEGER
   --           It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
   --           KBOT and KTOP together determine an isolated block
   --           along the diagonal of the Hessenberg matrix.
   --
   --  [in] KBOT
   --           KBOT is INTEGER
   --           It is assumed without a check that either
   --           KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
   --           determine an isolated block along the diagonal of the
   --           Hessenberg matrix.
   --
   --  [in] NW
   --           NW is INTEGER
   --           Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
   --
   --  [in,out] H
   --           H is DOUBLE PRECISION array, dimension (LDH,N)
   --           On input the initial N-by-N section of H stores the
   --           Hessenberg matrix undergoing aggressive early deflation.
   --           On output H has been transformed by an orthogonal
   --           similarity transformation, perturbed, and the returned
   --           to Hessenberg form that (it is to be hoped) has some
   --           zero subdiagonal entries.
   --
   --  [in] LDH
   --           LDH is integer
   --           Leading dimension of H just as declared in the calling
   --           subroutine.  N .LE. LDH
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --           Specify the rows of Z to which transformations must be
   --           applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension (LDZ,N)
   --           IF WANTZ is .TRUE., then on output, the orthogonal
   --           similarity transformation mentioned above has been
   --           accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
   --           If WANTZ is .FALSE., then Z is unreferenced.
   --
   --  [in] LDZ
   --           LDZ is integer
   --           The leading dimension of Z just as declared in the
   --           calling subroutine.  1 .LE. LDZ.
   --
   --  [out] NS
   --           NS is integer
   --           The number of unconverged (ie approximate) eigenvalues
   --           returned in SR and SI that may be used as shifts by the
   --           calling subroutine.
   --
   --  [out] ND
   --           ND is integer
   --           The number of converged eigenvalues uncovered by this
   --           subroutine.
   --
   --  [out] SR
   --           SR is DOUBLE PRECISION array, dimension (KBOT)
   --
   --  [out] SI
   --           SI is DOUBLE PRECISION array, dimension (KBOT)
   --           On output, the real and imaginary parts of approximate
   --           eigenvalues that may be used for shifts are stored in
   --           SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
   --           SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
   --           The real and imaginary parts of converged eigenvalues
   --           are stored in SR(KBOT-ND+1) through SR(KBOT) and
   --           SI(KBOT-ND+1) through SI(KBOT), respectively.
   --
   --  [out] V
   --           V is DOUBLE PRECISION array, dimension (LDV,NW)
   --           An NW-by-NW work array.
   --
   --  [in] LDV
   --           LDV is integer scalar
   --           The leading dimension of V just as declared in the
   --           calling subroutine.  NW .LE. LDV
   --
   --  [in] NH
   --           NH is integer scalar
   --           The number of columns of T.  NH.GE.NW.
   --
   --  [out] T
   --           T is DOUBLE PRECISION array, dimension (LDT,NW)
   --
   --  [in] LDT
   --           LDT is integer
   --           The leading dimension of T just as declared in the
   --           calling subroutine.  NW .LE. LDT
   --
   --  [in] NV
   --           NV is integer
   --           The number of rows of work array WV available for
   --           workspace.  NV.GE.NW.
   --
   --  [out] WV
   --           WV is DOUBLE PRECISION array, dimension (LDWV,NW)
   --
   --  [in] LDWV
   --           LDWV is integer
   --           The leading dimension of W just as declared in the
   --           calling subroutine.  NW .LE. LDV
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (LWORK)
   --           On exit, WORK(1) is set to an estimate of the optimal value
   --           of LWORK for the given values of N, NW, KTOP and KBOT.
   --
   --  [in] LWORK
   --           LWORK is integer
   --           The dimension of the work array WORK.  LWORK = 2*NW
   --           suffices, but greater efficiency may result from larger
   --           values of LWORK.
   --
   --           If LWORK = -1, then a workspace query is assumed; DLAQR2
   --           only estimates the optimal workspace size for the given
   --           values of N, NW, KTOP and KBOT.  The estimate is returned
   --           in WORK(1).  No error message related to LWORK is issued
   --           by XERBLA.  Neither H nor Z are accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DGEHRD, DGEMM, DLABAD, DLACPY, DLAHQR, DLANV2, DLARF, DLARFG, DLASET, DORMHR, DTREXC
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     ==== Estimate optimal workspace. ====
   --
   begin
      JW := min (NW, KBOT - KTOP + 1);
      if JW <= 2 then
         LWKOPT := 1;
      else
         --
         --        ==== Workspace query call to DGEHRD ====
         --
         DGEHRD (JW, 1, JW - 1, T'Address, LDT, WORK'Address, WORK'Address, -1, INFO);
         LWK1 := int (WORK (1));
         --
         --        ==== Workspace query call to DORMHR ====
         --
         DORMHR ('R', 'N', JW, JW, 1, JW - 1, T'Address, LDT, WORK'Address, V'Address, LDV, WORK'Address, -1, INFO);
         LWK2 := int (WORK (1));
         --
         --        ==== Optimal workspace ====
         --
         LWKOPT := JW + max (LWK1, LWK2);
      end if;
      --
      --     ==== Quick return in case of workspace query. ====
      --
      if LWORK = -1 then
         WORK (1) := Real (LWKOPT);
         return;
      end if;
      --
      --     ==== Nothing to do ...
      --     ... for an empty active block ... ====
      NS       := 0;
      ND       := 0;
      WORK (1) := ONE;
      if KTOP > KBOT then
         return;
      end if;
      --     ... nor for an empty deflation window. ====
      if NW < 1 then
         return;
      end if;
      --
      --     ==== Machine constants ====
      --
      SAFMIN := DLAMCH ('S');
      SAFMAX := ONE / SAFMIN;
      DLABAD (SAFMIN, SAFMAX);
      ULP    := DLAMCH ('P');
      SMLNUM := SAFMIN * (Real (N) / ULP);
      --
      --     ==== Setup deflation window ====
      --
      JW    := min (NW, KBOT - KTOP + 1);
      KWTOP := KBOT - JW + 1;
      if KWTOP = KTOP 
         then S := ZERO;
         else S := H (KWTOP, KWTOP - 1);
      end if;
      --
      if KBOT = KWTOP then
         --
         --        ==== 1-by-1 deflation window: not much to do ====
         --
         SR (KWTOP) := H (KWTOP, KWTOP);
         SI (KWTOP) := ZERO;
         NS         := 1;
         ND         := 0;
         if abs (S) <= max (SMLNUM, ULP * abs (H (KWTOP, KWTOP))) then
            NS := 0;
            ND := 1;
            if KWTOP > KTOP then
               H (KWTOP, KWTOP - 1) := ZERO;
            end if;
         end if;
         WORK (1) := ONE;
         return;
      end if;
      --
      --     ==== Convert to spike-triangular form.  (In case of a
      --     .    rare QR failure, this routine continues to do
      --     .    aggressive early deflation using that part of
      --     .    the deflation window that converged using INFQR
      --     .    here and there to keep track.) ====
      --
      DLACPY ('U', JW, JW, H (KWTOP, KWTOP)'Address, LDH, T'Address, LDT);
      DCOPY (JW - 1, H (KWTOP + 1, KWTOP)'Address, LDH + 1, T (2, 1)'Address, LDT + 1);
      --
      DLASET ('A', JW, JW, ZERO, ONE, V'Address, LDV);
      DLAHQR (True, True, JW, 1, JW, T'Address, LDT, SR (KWTOP)'Address, SI (KWTOP)'Address, 1, JW, V'Address, LDV, INFQR);
      --
      --     ==== DTREXC needs a clean margin near the diagonal ====
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > JW - 3;
         T (J + 2, J) := ZERO;
         T (J + 3, J) := ZERO;
      end loop;
      if JW > 2 then
         T (JW, JW - 2) := ZERO;
      end if;
      --
      --     ==== Deflation detection loop ====
      --
      NS   := JW;
      ILST := INFQR + 1;
      <<L20>> null;
      if ILST <= NS then
         if NS = 1 
            then BULGE := False;
            else BULGE := T (NS, NS - 1) /= ZERO;
         end if;
         --
         --        ==== Small spike tip test for deflation ====
         --
         if not BULGE then
            --
            --           ==== Real eigenvalue ====
            --
            FOO := abs (T (NS, NS));
            if FOO = ZERO then
               FOO := abs (S);
            end if;
            if abs (S * V (1, NS)) <= max (SMLNUM, ULP * FOO) then
               --
               --              ==== Deflatable ====
               --
               NS := NS - 1;
            else
               --
               --              ==== Undeflatable.   Move it up out of the way.
               --              .    (DTREXC can not fail in this case.) ====
               --
               IFST := NS;
               DTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, WORK, INFO);
               ILST := ILST + 1;
            end if;
         else
            --
            --           ==== Complex conjugate pair ====
            --
            FOO := abs (T (NS, NS)) + Sqrt (abs (T (NS, NS - 1))) * Sqrt (abs (T (NS - 1, NS)));
            if FOO = ZERO then
               FOO := abs (S);
            end if;
            if max (abs (S * V (1, NS)), abs (S * V (1, NS - 1))) <= max (SMLNUM, ULP * FOO) then
               --
               --              ==== Deflatable ====
               --
               NS := NS - 2;
            else
               --
               --              ==== Undeflatable. Move them up out of the way.
               --              .    Fortunately, DTREXC does the right thing with
               --              .    ILST in case of a rare exchange failure. ====
               --
               IFST := NS;
               DTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, WORK, INFO);
               ILST := ILST + 2;
            end if;
         end if;
         --
         --        ==== End deflation detection loop ====
         --
         goto L20;
      end if;
      --
      --        ==== Return to Hessenberg form ====
      --
      if NS = 0 then
         S := ZERO;
      end if;
      --
      if NS < JW then
         --
         --        ==== sorting diagonal blocks of T improves accuracy for
         --        .    graded matrices.  double sort deals well with
         --        .    exchange failures. ====
         --
         SORTED := False;
         I      := NS + 1;
         <<L30>> null;
         if SORTED then
            goto L50;
         end if;
         SORTED := True;
         --
         KEND := I - 1;
         I    := INFQR + 1;
         if I = NS then
            K := I + 1;
         elsif T (I + 1, I) = ZERO then
            K := I + 1;
         else
            K := I + 2;
         end if;
         <<L40>> null;
         if K <= KEND then
            if K = I + 1 
               then EVI := abs (T (I, I));
               else EVI := abs (T (I, I)) + Sqrt (abs (T (I + 1, I))) * Sqrt (abs (T (I, I + 1)));
            end if;
            --
            if K = KEND then
               EVK := abs (T (K, K));
            elsif T (K + 1, K) = ZERO then
               EVK := abs (T (K, K));
            else
               EVK := abs (T (K, K)) + Sqrt (abs (T (K + 1, K))) * Sqrt (abs (T (K, K + 1)));
            end if;
            --
            if EVI >= EVK then
               I := K;
            else
               SORTED := False;
               IFST   := I;
               ILST   := K;
               DTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, WORK, INFO);
               if INFO = 0 
                  then I := ILST;
                  else I := K;
               end if;
            end if;
            if I = KEND then
               K := I + 1;
            elsif T (I + 1, I) = ZERO then
               K := I + 1;
            else
               K := I + 2;
            end if;
            goto L40;
         end if;
         goto L30;
         <<L50>> null;
      end if;
      --
      --     ==== Restore shift/eigenvalue array from T ====
      --
      I := JW;
      <<L60>> null;
      if I >= INFQR + 1 then
         if I = INFQR + 1 then
            SR (KWTOP + I - 1) := T (I, I);
            SI (KWTOP + I - 1) := ZERO;
            I                  := I - 1;
         elsif T (I, I - 1) = ZERO then
            SR (KWTOP + I - 1) := T (I, I);
            SI (KWTOP + I - 1) := ZERO;
            I                  := I - 1;
         else
            AA := T (I - 1, I - 1);
            CC := T (I, I - 1);
            BB := T (I - 1, I);
            DD := T (I, I);
            DLANV2 (AA, BB, CC, DD, SR (KWTOP + I - 2), SI (KWTOP + I - 2), SR (KWTOP + I - 1), SI (KWTOP + I - 1), CS, SN);
            I := I - 2;
         end if;
         goto L60;
      end if;
      --
      if NS < JW or S = ZERO then
         if NS > 1 and S /= ZERO then
            --
            --           ==== Reflect spike back into lower triangle ====
            --
            DCOPY (NS, V'Address, LDV, WORK'Address, 1);
            BETA := WORK (1);
            DLARFG (NS, BETA, WORK (2)'Address, 1, TAU);
            WORK (1) := ONE;
            --
            DLASET ('L', JW - 2, JW - 2, ZERO, ZERO, T (3, 1)'Address, LDT);
            --
            DLARF ('L', NS, JW, WORK'Address, 1, TAU, T'Address, LDT, WORK (JW + 1)'Address);
            DLARF ('R', NS, NS, WORK'Address, 1, TAU, T'Address, LDT, WORK (JW + 1)'Address);
            DLARF ('R', JW, NS, WORK'Address, 1, TAU, V'Address, LDV, WORK (JW + 1)'Address);
            --
            DGEHRD (JW, 1, NS, T'Address, LDT, WORK'Address, WORK (JW + 1)'Address, LWORK - JW, INFO);
         end if;
         --
         --        ==== Copy updated reduced window into place ====
         --
         if KWTOP > 1 then
            H (KWTOP, KWTOP - 1) := S * V (1, 1);
         end if;
         DLACPY ('U', JW, JW, T'Address, LDT, H (KWTOP, KWTOP)'Address, LDH);
         DCOPY (JW - 1, T (2, 1)'Address, LDT + 1, H (KWTOP + 1, KWTOP)'Address, LDH + 1);
         --
         --        ==== Accumulate orthogonal matrix in order update
         --        .    H and Z, if requested.  ====
         --
         if NS > 1 and S /= ZERO then
            DORMHR
              ('R',
               'N',
               JW,
               NS,
               1,
               NS,
               T'Address,
               LDT,
               WORK'Address,
               V'Address,
               LDV,
               WORK (JW + 1)'Address,
               LWORK - JW,
               INFO);
         end if;
         --
         --        ==== Update vertical slab in H ====
         --
         if WANTT 
            then LTOP := 1;
            else LTOP := KTOP;
         end if;
         KROW := LTOP - NV;
         loop
            KROW := KROW + NV;
            exit when KROW > KWTOP - 1;
            KLN := min (NV, KWTOP - KROW);
            DGEMM ('N', 'N', KLN, JW, JW, ONE, H (KROW, KWTOP)'Address, LDH, V'Address, LDV, ZERO, WV'Address, LDWV);
            DLACPY ('A', KLN, JW, WV'Address, LDWV, H (KROW, KWTOP)'Address, LDH);
         end loop;
         --
         --        ==== Update horizontal slab in H ====
         --
         if WANTT then
            KCOL := KBOT + 1 - NH;
            loop
               KCOL := KCOL + NH;
               exit when KCOL > N;
               KLN := min (NH, N - KCOL + 1);
               DGEMM ('C', 'N', JW, KLN, JW, ONE, V'Address, LDV, H (KWTOP, KCOL)'Address, LDH, ZERO, T'Address, LDT);
               DLACPY ('A', JW, KLN, T'Address, LDT, H (KWTOP, KCOL)'Address, LDH);
            end loop;
         end if;
         --
         --        ==== Update vertical slab in Z ====
         --
         if WANTZ then
            KROW := ILOZ - NV;
            loop
               KROW := KROW + NV;
               exit when KROW > IHIZ;
               KLN := min (NV, IHIZ - KROW + 1);
               DGEMM ('N', 'N', KLN, JW, JW, ONE, Z (KROW, KWTOP)'Address, LDZ, V'Address, LDV, ZERO, WV'Address, LDWV);
               DLACPY ('A', KLN, JW, WV'Address, LDWV, Z (KROW, KWTOP)'Address, LDZ);
            end loop;
         end if;
      end if;
      --
      --     ==== Return the number of deflations ... ====
      --
      ND := JW - NS;
      --
      --     ==== ... and the number of shifts. (Subtracting
      --     .    INFQR from the spike length takes care
      --     .    of the case of a rare QR failure while
      --     .    calculating eigenvalues of the deflation
      --     .    window.)  ====
      --
      NS := NS - INFQR;
      --
      --      ==== Return optimal workspace. ====
      --
      WORK (1) := Real (LWKOPT);
      --
      --     ==== End of DLAQR2 ====
      --
   end DLAQR2;

   procedure DLAQR3
     (WANTT    : Boolean;
      WANTZ    : Boolean;
      N        : Integer;
      KTOP     : Integer;
      KBOT     : Integer;
      NW       : Integer;
      H_adr    : Address;
      LDH      : Integer;
      ILOZ     : Integer;
      IHIZ     : Integer;
      Z_adr    : Address;
      LDZ      : Integer;
      NS       : in out Integer;
      ND       : in out Integer;
      SR_adr   : Address;
      SI_adr   : Address;
      V_adr    : Address;
      LDV      : Integer;
      NH       : Integer;
      T_adr    : Address;
      LDT      : Integer;
      NV       : Integer;
      WV_adr   : Address;
      LDWV     : Integer;
      WORK_adr : Address;
      LWORK    : Integer)
   is

      H    : Ftn_Real_Matrix (1 .. LDH, 1 .. N);
      Z    : Ftn_Real_Matrix (1 .. LDZ, 1 .. N);
      SR   : Ftn_Real_Vector (1 .. KBOT);
      SI   : Ftn_Real_Vector (1 .. KBOT);
      V    : Ftn_Real_Matrix (1 .. LDV, 1 .. NW);
      T    : Ftn_Real_Matrix (1 .. LDT, 1 .. NW);
      WV   : Ftn_Real_Matrix (1 .. LDWV, 1 .. NW);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for H'Address use H_adr;
      for Z'Address use Z_adr;
      for SR'Address use SR_adr;
      for SI'Address use SI_adr;
      for V'Address use V_adr;
      for T'Address use T_adr;
      for WV'Address use WV_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, Z);
      pragma Import (Ada, SR);
      pragma Import (Ada, SI);
      pragma Import (Ada, V);
      pragma Import (Ada, T);
      pragma Import (Ada, WV);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      AA     : Real;
      BB     : Real;
      BETA   : Real;
      CC     : Real;
      CS     : Real;
      DD     : Real;
      EVI    : Real;
      EVK    : Real;
      FOO    : Real;
      S      : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SMLNUM : Real;
      SN     : Real;
      TAU    : Real;
      ULP    : Real;
      I      : Integer;
      IFST   : Integer;
      ILST   : Integer;
      INFO   : Integer;
      INFQR  : Integer;
      J      : Integer;
      JW     : Integer;
      K      : Integer;
      KCOL   : Integer;
      KEND   : Integer;
      KLN    : Integer;
      KROW   : Integer;
      KWTOP  : Integer;
      LTOP   : Integer;
      LWK1   : Integer;
      LWK2   : Integer;
      LWK3   : Integer;
      LWKOPT : Integer;
      NMIN   : Integer;
      BULGE  : Boolean;
      SORTED : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAQR3( WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ,
   --                          IHIZ, Z, LDZ, NS, ND, SR, SI, V, LDV, NH, T,
   --                          LDT, NV, WV, LDWV, WORK, LWORK )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHIZ, ILOZ, KBOT, KTOP, LDH, LDT, LDV, LDWV,
   --      $                   LDZ, LWORK, N, ND, NH, NS, NV, NW
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   H( LDH, * ), SI( * ), SR( * ), T( LDT, * ),
   --      $                   V( LDV, * ), WORK( * ), WV( LDWV, * ),
   --      $                   Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     Aggressive early deflation:
   --
   --     DLAQR3 accepts as input an upper Hessenberg matrix
   --     H and performs an orthogonal similarity transformation
   --     designed to detect and deflate fully converged eigenvalues from
   --     a trailing principal submatrix.  On output H has been over-
   --     written by a new Hessenberg matrix that is a perturbation of
   --     an orthogonal similarity transformation of H.  It is to be
   --     hoped that the final version of H has many zero subdiagonal
   --     entries.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           If .TRUE., then the Hessenberg matrix H is fully updated
   --           so that the quasi-triangular Schur factor may be
   --           computed (in cooperation with the calling subroutine).
   --           If .FALSE., then only enough of H is updated to preserve
   --           the eigenvalues.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           If .TRUE., then the orthogonal matrix Z is updated so
   --           so that the orthogonal Schur factor may be computed
   --           (in cooperation with the calling subroutine).
   --           If .FALSE., then Z is not referenced.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix H and (if WANTZ is .TRUE.) the
   --           order of the orthogonal matrix Z.
   --
   --  [in] KTOP
   --           KTOP is INTEGER
   --           It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
   --           KBOT and KTOP together determine an isolated block
   --           along the diagonal of the Hessenberg matrix.
   --
   --  [in] KBOT
   --           KBOT is INTEGER
   --           It is assumed without a check that either
   --           KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
   --           determine an isolated block along the diagonal of the
   --           Hessenberg matrix.
   --
   --  [in] NW
   --           NW is INTEGER
   --           Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
   --
   --  [in,out] H
   --           H is DOUBLE PRECISION array, dimension (LDH,N)
   --           On input the initial N-by-N section of H stores the
   --           Hessenberg matrix undergoing aggressive early deflation.
   --           On output H has been transformed by an orthogonal
   --           similarity transformation, perturbed, and the returned
   --           to Hessenberg form that (it is to be hoped) has some
   --           zero subdiagonal entries.
   --
   --  [in] LDH
   --           LDH is integer
   --           Leading dimension of H just as declared in the calling
   --           subroutine.  N .LE. LDH
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --           Specify the rows of Z to which transformations must be
   --           applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension (LDZ,N)
   --           IF WANTZ is .TRUE., then on output, the orthogonal
   --           similarity transformation mentioned above has been
   --           accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
   --           If WANTZ is .FALSE., then Z is unreferenced.
   --
   --  [in] LDZ
   --           LDZ is integer
   --           The leading dimension of Z just as declared in the
   --           calling subroutine.  1 .LE. LDZ.
   --
   --  [out] NS
   --           NS is integer
   --           The number of unconverged (ie approximate) eigenvalues
   --           returned in SR and SI that may be used as shifts by the
   --           calling subroutine.
   --
   --  [out] ND
   --           ND is integer
   --           The number of converged eigenvalues uncovered by this
   --           subroutine.
   --
   --  [out] SR
   --           SR is DOUBLE PRECISION array, dimension (KBOT)
   --
   --  [out] SI
   --           SI is DOUBLE PRECISION array, dimension (KBOT)
   --           On output, the real and imaginary parts of approximate
   --           eigenvalues that may be used for shifts are stored in
   --           SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
   --           SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
   --           The real and imaginary parts of converged eigenvalues
   --           are stored in SR(KBOT-ND+1) through SR(KBOT) and
   --           SI(KBOT-ND+1) through SI(KBOT), respectively.
   --
   --  [out] V
   --           V is DOUBLE PRECISION array, dimension (LDV,NW)
   --           An NW-by-NW work array.
   --
   --  [in] LDV
   --           LDV is integer scalar
   --           The leading dimension of V just as declared in the
   --           calling subroutine.  NW .LE. LDV
   --
   --  [in] NH
   --           NH is integer scalar
   --           The number of columns of T.  NH.GE.NW.
   --
   --  [out] T
   --           T is DOUBLE PRECISION array, dimension (LDT,NW)
   --
   --  [in] LDT
   --           LDT is integer
   --           The leading dimension of T just as declared in the
   --           calling subroutine.  NW .LE. LDT
   --
   --  [in] NV
   --           NV is integer
   --           The number of rows of work array WV available for
   --           workspace.  NV.GE.NW.
   --
   --  [out] WV
   --           WV is DOUBLE PRECISION array, dimension (LDWV,NW)
   --
   --  [in] LDWV
   --           LDWV is integer
   --           The leading dimension of W just as declared in the
   --           calling subroutine.  NW .LE. LDV
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (LWORK)
   --           On exit, WORK(1) is set to an estimate of the optimal value
   --           of LWORK for the given values of N, NW, KTOP and KBOT.
   --
   --  [in] LWORK
   --           LWORK is integer
   --           The dimension of the work array WORK.  LWORK = 2*NW
   --           suffices, but greater efficiency may result from larger
   --           values of LWORK.
   --
   --           If LWORK = -1, then a workspace query is assumed; DLAQR3
   --           only estimates the optimal workspace size for the given
   --           values of N, NW, KTOP and KBOT.  The estimate is returned
   --           in WORK(1).  No error message related to LWORK is issued
   --           by XERBLA.  Neither H nor Z are accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH
   --      INTEGER            ILAENV
   --      EXTERNAL           DLAMCH, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DGEHRD, DGEMM, DLABAD, DLACPY, DLAHQR,
   --     $                   DLANV2, DLAQR4, DLARF, DLARFG, DLASET, DORMHR,
   --     $                   DTREXC
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     ==== Estimate optimal workspace. ====
   --
   begin
      JW := min (NW, KBOT - KTOP + 1);
      if JW <= 2 then
         LWKOPT := 1;
      else
         --
         --        ==== Workspace query call to DGEHRD ====
         --
         DGEHRD (JW, 1, JW - 1, T'Address, LDT, WORK'Address, WORK'Address, -1, INFO);
         LWK1 := int (WORK (1));
         --
         --        ==== Workspace query call to DORMHR ====
         --
         DORMHR ('R', 'N', JW, JW, 1, JW - 1, T'Address, LDT, WORK'Address, V'Address, LDV, WORK'Address, -1, INFO);
         LWK2 := int (WORK (1));
         --
         --        ==== Workspace query call to DLAQR4 ====
         --
         DLAQR4
           (True,
            True,
            JW,
            1,
            JW,
            T'Address,
            LDT,
            SR'Address,
            SI'Address,
            1,
            JW,
            V'Address,
            LDV,
            WORK'Address,
            -1,
            INFQR);
         LWK3 := int (WORK (1));
         --
         --        ==== Optimal workspace ====
         --
         LWKOPT := max (JW + max (LWK1, LWK2), LWK3);
      end if;
      --
      --     ==== Quick return in case of workspace query. ====
      --
      if LWORK = -1 then
         WORK (1) := Real (LWKOPT);
         return;
      end if;
      --
      --     ==== Nothing to do ...
      --     ... for an empty active block ... ====
      NS       := 0;
      ND       := 0;
      WORK (1) := ONE;
      if KTOP > KBOT then
         return;
      end if;
      --     ... nor for an empty deflation window. ====
      if NW < 1 then
         return;
      end if;
      --
      --     ==== Machine constants ====
      --
      SAFMIN := DLAMCH ('S');
      SAFMAX := ONE / SAFMIN;
      DLABAD (SAFMIN, SAFMAX);
      ULP    := DLAMCH ('P');
      SMLNUM := SAFMIN * (Real (N) / ULP);
      --
      --     ==== Setup deflation window ====
      --
      JW    := min (NW, KBOT - KTOP + 1);
      KWTOP := KBOT - JW + 1;
      if KWTOP = KTOP 
         then S := ZERO;
         else S := H (KWTOP, KWTOP - 1);
      end if;
      --
      if KBOT = KWTOP then
         --
         --        ==== 1-by-1 deflation window: not much to do ====
         --
         SR (KWTOP) := H (KWTOP, KWTOP);
         SI (KWTOP) := ZERO;
         NS         := 1;
         ND         := 0;
         if abs (S) <= max (SMLNUM, ULP * abs (H (KWTOP, KWTOP))) then
            NS := 0;
            ND := 1;
            if KWTOP > KTOP then
               H (KWTOP, KWTOP - 1) := ZERO;
            end if;
         end if;
         WORK (1) := ONE;
         return;
      end if;
      --
      --     ==== Convert to spike-triangular form.  (In case of a
      --     .    rare QR failure, this routine continues to do
      --     .    aggressive early deflation using that part of
      --     .    the deflation window that converged using INFQR
      --     .    here and there to keep track.) ====
      --
      DLACPY ('U', JW, JW, H (KWTOP, KWTOP)'Address, LDH, T'Address, LDT);
      DCOPY (JW - 1, H (KWTOP + 1, KWTOP)'Address, LDH + 1, T (2, 1)'Address, LDT + 1);
      --
      DLASET ('A', JW, JW, ZERO, ONE, V'Address, LDV);
      NMIN := ILAENV (12, "DLAQR3", "SV", JW, 1, JW, LWORK);
      if JW > NMIN then
         DLAQR4
           (True,
            True,
            JW,
            1,
            JW,
            T'Address,
            LDT,
            SR (KWTOP)'Address,
            SI (KWTOP)'Address,
            1,
            JW,
            V'Address,
            LDV,
            WORK'Address,
            LWORK,
            INFQR);
      else
         DLAHQR
           (True,
            True,
            JW,
            1,
            JW,
            T'Address,
            LDT,
            SR (KWTOP)'Address,
            SI (KWTOP)'Address,
            1,
            JW,
            V'Address,
            LDV,
            INFQR);
      end if;
      --
      --     ==== DTREXC needs a clean margin near the diagonal ====
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > JW - 3;
         T (J + 2, J) := ZERO;
         T (J + 3, J) := ZERO;
      end loop;
      if JW > 2 then
         T (JW, JW - 2) := ZERO;
      end if;
      --
      --     ==== Deflation detection loop ====
      --
      NS   := JW;
      ILST := INFQR + 1;
      <<L20>> null;
      if ILST <= NS then
         if NS = 1 
            then BULGE := False;
            else BULGE := T (NS, NS - 1) /= ZERO;
         end if;
         --
         --        ==== Small spike tip test for deflation ====
         --
         if not BULGE then
            --
            --           ==== Real eigenvalue ====
            --
            FOO := abs (T (NS, NS));
            if FOO = ZERO then
               FOO := abs (S);
            end if;
            if abs (S * V (1, NS)) <= max (SMLNUM, ULP * FOO) then
               --
               --              ==== Deflatable ====
               --
               NS := NS - 1;
            else
               --
               --              ==== Undeflatable.   Move it up out of the way.
               --              .    (DTREXC can not fail in this case.) ====
               --
               IFST := NS;
               DTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, WORK, INFO);
               ILST := ILST + 1;
            end if;
         else
            --
            --           ==== Complex conjugate pair ====
            --
            FOO := abs (T (NS, NS)) + Sqrt (abs (T (NS, NS - 1))) * Sqrt (abs (T (NS - 1, NS)));
            if FOO = ZERO then
               FOO := abs (S);
            end if;
            if max (abs (S * V (1, NS)), abs (S * V (1, NS - 1))) <= max (SMLNUM, ULP * FOO) then
               --
               --              ==== Deflatable ====
               --
               NS := NS - 2;
            else
               --
               --              ==== Undeflatable. Move them up out of the way.
               --              .    Fortunately, DTREXC does the right thing with
               --              .    ILST in case of a rare exchange failure. ====
               --
               IFST := NS;
               DTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, WORK, INFO);
               ILST := ILST + 2;
            end if;
         end if;
         --
         --        ==== End deflation detection loop ====
         --
         goto L20;
      end if;
      --
      --        ==== Return to Hessenberg form ====
      --
      if NS = 0 then
         S := ZERO;
      end if;
      --
      if NS < JW then
         --
         --        ==== sorting diagonal blocks of T improves accuracy for
         --        .    graded matrices.  double sort deals well with
         --        .    exchange failures. ====
         --
         SORTED := False;
         I      := NS + 1;
         <<L30>> null;
         if SORTED then
            goto L50;
         end if;
         SORTED := True;
         --
         KEND := I - 1;
         I    := INFQR + 1;
         if I = NS then
            K := I + 1;
         elsif T (I + 1, I) = ZERO then
            K := I + 1;
         else
            K := I + 2;
         end if;
         <<L40>> null;
         if K <= KEND then
            if K = I + 1 
               then EVI := abs (T (I, I));
               else EVI := abs (T (I, I)) + Sqrt (abs (T (I + 1, I))) * Sqrt (abs (T (I, I + 1)));
            end if;
            --
            if K = KEND then
               EVK := abs (T (K, K));
            elsif T (K + 1, K) = ZERO then
               EVK := abs (T (K, K));
            else
               EVK := abs (T (K, K)) + Sqrt (abs (T (K + 1, K))) * Sqrt (abs (T (K, K + 1)));
            end if;
            --
            if EVI >= EVK then
               I := K;
            else
               SORTED := False;
               IFST   := I;
               ILST   := K;
               DTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, WORK, INFO);
               if INFO = 0 
                  then I := ILST;
                  else I := K;
               end if;
            end if;
            if I = KEND then
               K := I + 1;
            elsif T (I + 1, I) = ZERO then
               K := I + 1;
            else
               K := I + 2;
            end if;
            goto L40;
         end if;
         goto L30;
         <<L50>> null;
      end if;
      --
      --     ==== Restore shift/eigenvalue array from T ====
      --
      I := JW;
      <<L60>> null;
      if I >= INFQR + 1 then
         if I = INFQR + 1 then
            SR (KWTOP + I - 1) := T (I, I);
            SI (KWTOP + I - 1) := ZERO;
            I                  := I - 1;
         elsif T (I, I - 1) = ZERO then
            SR (KWTOP + I - 1) := T (I, I);
            SI (KWTOP + I - 1) := ZERO;
            I                  := I - 1;
         else
            AA := T (I - 1, I - 1);
            CC := T (I, I - 1);
            BB := T (I - 1, I);
            DD := T (I, I);
            DLANV2 (AA, BB, CC, DD, SR (KWTOP + I - 2), SI (KWTOP + I - 2), SR (KWTOP + I - 1), SI (KWTOP + I - 1), CS, SN);
            I := I - 2;
         end if;
         goto L60;
      end if;
      --
      if NS < JW or S = ZERO then
         if NS > 1 and S /= ZERO then
            --
            --           ==== Reflect spike back into lower triangle ====
            --
            DCOPY (NS, V'Address, LDV, WORK'Address, 1);
            BETA := WORK (1);
            DLARFG (NS, BETA, WORK (2)'Address, 1, TAU);
            WORK (1) := ONE;
            --
            DLASET ('L', JW - 2, JW - 2, ZERO, ZERO, T (3, 1)'Address, LDT);
            --
            DLARF ('L', NS, JW, WORK'Address, 1, TAU, T'Address, LDT, WORK (JW + 1)'Address);
            DLARF ('R', NS, NS, WORK'Address, 1, TAU, T'Address, LDT, WORK (JW + 1)'Address);
            DLARF ('R', JW, NS, WORK'Address, 1, TAU, V'Address, LDV, WORK (JW + 1)'Address);
            --
            DGEHRD (JW, 1, NS, T'Address, LDT, WORK'Address, WORK (JW + 1)'Address, LWORK - JW, INFO);
         end if;
         --
         --        ==== Copy updated reduced window into place ====
         --
         if KWTOP > 1 then
            H (KWTOP, KWTOP - 1) := S * V (1, 1);
         end if;
         DLACPY ('U', JW, JW, T'Address, LDT, H (KWTOP, KWTOP)'Address, LDH);
         DCOPY (JW - 1, T (2, 1)'Address, LDT + 1, H (KWTOP + 1, KWTOP)'Address, LDH + 1);
         --
         --        ==== Accumulate orthogonal matrix in order update
         --        .    H and Z, if requested.  ====
         --
         if NS > 1 and S /= ZERO then
            DORMHR
              ('R',
               'N',
               JW,
               NS,
               1,
               NS,
               T'Address,
               LDT,
               WORK'Address,
               V'Address,
               LDV,
               WORK (JW + 1)'Address,
               LWORK - JW,
               INFO);
         end if;
         --
         --        ==== Update vertical slab in H ====
         --
         if WANTT 
            then LTOP := 1;
            else LTOP := KTOP;
         end if;
         KROW := LTOP - NV;
         loop
            KROW := KROW + NV;
            exit when KROW > KWTOP - 1;
            KLN := min (NV, KWTOP - KROW);
            DGEMM ('N', 'N', KLN, JW, JW, ONE, H (KROW, KWTOP)'Address, LDH, V'Address, LDV, ZERO, WV'Address, LDWV);
            DLACPY ('A', KLN, JW, WV'Address, LDWV, H (KROW, KWTOP)'Address, LDH);
         end loop;
         --
         --        ==== Update horizontal slab in H ====
         --
         if WANTT then
            KCOL := KBOT + 1 - NH;
            loop
               KCOL := KCOL + NH;
               exit when KCOL > N;
               KLN := min (NH, N - KCOL + 1);
               DGEMM ('C', 'N', JW, KLN, JW, ONE, V'Address, LDV, H (KWTOP, KCOL)'Address, LDH, ZERO, T'Address, LDT);
               DLACPY ('A', JW, KLN, T'Address, LDT, H (KWTOP, KCOL)'Address, LDH);
            end loop;
         end if;
         --
         --        ==== Update vertical slab in Z ====
         --
         if WANTZ then
            KROW := ILOZ - NV;
            loop
               KROW := KROW + NV;
               exit when KROW > IHIZ;
               KLN := min (NV, IHIZ - KROW + 1);
               DGEMM ('N', 'N', KLN, JW, JW, ONE, Z (KROW, KWTOP)'Address, LDZ, V'Address, LDV, ZERO, WV'Address, LDWV);
               DLACPY ('A', KLN, JW, WV'Address, LDWV, Z (KROW, KWTOP)'Address, LDZ);
            end loop;
         end if;
      end if;
      --
      --     ==== Return the number of deflations ... ====
      --
      ND := JW - NS;
      --
      --     ==== ... and the number of shifts. (Subtracting
      --     .    INFQR from the spike length takes care
      --     .    of the case of a rare QR failure while
      --     .    calculating eigenvalues of the deflation
      --     .    window.)  ====
      --
      NS := NS - INFQR;
      --
      --      ==== Return optimal workspace. ====
      --
      WORK (1) := Real (LWKOPT);
      --
      --     ==== End of DLAQR3 ====
      --
   end DLAQR3;

   procedure DLAQR4
     (WANTT    : Boolean;
      WANTZ    : Boolean;
      N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      H_adr    : Address;
      LDH      : Integer;
      WR_adr   : Address;
      WI_adr   : Address;
      ILOZ     : Integer;
      IHIZ     : Integer;
      Z_adr    : Address;
      LDZ      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      H    : Ftn_Real_Matrix (1 .. LDH, 1 .. N);
      WR   : Ftn_Real_Vector (1 .. IHI);
      WI   : Ftn_Real_Vector (1 .. IHI);
      Z    : Ftn_Real_Matrix (1 .. LDZ, 1 .. IHI);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for H'Address use H_adr;
      for WR'Address use WR_adr;
      for WI'Address use WI_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, WR);
      pragma Import (Ada, WI);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);

      NTINY  : constant Integer := 11;
      KEXNW  : constant Integer := 5;
      KEXSH  : constant Integer := 6;
      WILK1  : constant Real    := 0.75e0;
      WILK2  : constant Real    := -0.4375e0;
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      AA     : Real;
      BB     : Real;
      CC     : Real;
      CS     : Real;
      DD     : Real;
      SN     : Real;
      SS     : Real;
      SWAP   : Real;
      I      : Integer;
      INF    : Integer;
      IT     : Integer;
      ITMAX  : Integer;
      K      : Integer;
      KACC22 : Integer;
      KBOT   : Integer;
      KDU    : Integer;
      KS     : Integer;
      KT     : Integer;
      KTOP   : Integer;
      KU     : Integer;
      KV     : Integer;
      KWH    : Integer;
      KWTOP  : Integer;
      KWV    : Integer;
      LD     : Integer;
      LS     : Integer;
      LWKOPT : Integer;
      NDEC   : Integer;
      NDFL   : Integer;
      NH     : Integer;
      NHO    : Integer;
      NIBBLE : Integer;
      NMIN   : Integer;
      NS     : Integer;
      NSMAX  : Integer;
      NSR    : Integer;
      NVE    : Integer;
      NW     : Integer;
      NWMAX  : Integer;
      NWR    : Integer;
      NWUPBD : Integer;
      SORTED : Boolean;
      JBCMPZ : String (1 .. 2);
      ZDUM   : Ftn_Real_Matrix (1 .. 1, 1 .. 1);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAQR4( WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI,
   --                          ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, LWORK, N
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   H( LDH, * ), WI( * ), WORK( * ), WR( * ),
   --      $                   Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DLAQR4 implements one level of recursion for DLAQR0.
   --     It is a complete implementation of the small bulge multi-shift
   --     QR algorithm.  It may be called by DLAQR0 and, for large enough
   --     deflation window size, it may be called by DLAQR3.  This
   --     subroutine is identical to DLAQR0 except that it calls DLAQR2
   --     instead of DLAQR3.
   --
   --     DLAQR4 computes the eigenvalues of a Hessenberg matrix H
   --     and, optionally, the matrices T and Z from the Schur decomposition
   --     H = Z T Z**T, where T is an upper quasi-triangular matrix (the
   --     Schur form), and Z is the orthogonal matrix of Schur vectors.
   --
   --     Optionally Z may be postmultiplied into an input orthogonal
   --     matrix Q so that this routine can give the Schur factorization
   --     of a matrix A which has been reduced to the Hessenberg form H
   --     by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           = .TRUE. : the full Schur form T is required;
   --           = .FALSE.: only eigenvalues are required.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           = .TRUE. : the matrix of Schur vectors Z is required;
   --           = .FALSE.: Schur vectors are not required.
   --
   --  [in] N
   --           N is INTEGER
   --            The order of the matrix H.  N .GE. 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --            It is assumed that H is already upper triangular in rows
   --            and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
   --            H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
   --            previous call to DGEBAL, and then passed to DGEHRD when the
   --            matrix output by DGEBAL is reduced to Hessenberg form.
   --            Otherwise, ILO and IHI should be set to 1 and N,
   --            respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
   --            If N = 0, then ILO = 1 and IHI = 0.
   --
   --  [in,out] H
   --           H is DOUBLE PRECISION array, dimension (LDH,N)
   --            On entry, the upper Hessenberg matrix H.
   --            On exit, if INFO = 0 and WANTT is .TRUE., then H contains
   --            the upper quasi-triangular matrix T from the Schur
   --            decomposition (the Schur form); 2-by-2 diagonal blocks
   --            (corresponding to complex conjugate pairs of eigenvalues)
   --            are returned in standard form, with H(i,i) = H(i+1,i+1)
   --            and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
   --            .FALSE., then the contents of H are unspecified on exit.
   --            (The output value of H when INFO.GT.0 is given under the
   --            description of INFO below.)
   --
   --            This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
   --            j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
   --
   --  [in] LDH
   --           LDH is INTEGER
   --            The leading dimension of the array H. LDH .GE. max(1,N).
   --
   --  [out] WR
   --           WR is DOUBLE PRECISION array, dimension (IHI)
   --
   --  [out] WI
   --           WI is DOUBLE PRECISION array, dimension (IHI)
   --            The real and imaginary parts, respectively, of the computed
   --            eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
   --            and WI(ILO:IHI). If two eigenvalues are computed as a
   --            complex conjugate pair, they are stored in consecutive
   --            elements of WR and WI, say the i-th and (i+1)th, with
   --            WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
   --            the eigenvalues are stored in the same order as on the
   --            diagonal of the Schur form returned in H, with
   --            WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
   --            block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
   --            WI(i+1) = -WI(i).
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --            Specify the rows of Z to which transformations must be
   --            applied if WANTZ is .TRUE..
   --            1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension (LDZ,IHI)
   --            If WANTZ is .FALSE., then Z is not referenced.
   --            If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
   --            replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
   --            orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
   --            (The output value of Z when INFO.GT.0 is given under
   --            the description of INFO below.)
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --            The leading dimension of the array Z.  if WANTZ is .TRUE.
   --            then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension LWORK
   --            On exit, if LWORK = -1, WORK(1) returns an estimate of
   --            the optimal value for LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --            The dimension of the array WORK.  LWORK .GE. max(1,N)
   --            is sufficient, but LWORK typically as large as 6*N may
   --            be required for optimal performance.  A workspace query
   --            to determine the optimal workspace size is recommended.
   --
   --            If LWORK = -1, then DLAQR4 does a workspace query.
   --            In this case, DLAQR4 checks the input parameters and
   --            estimates the optimal workspace size for the given
   --            values of N, ILO and IHI.  The estimate is returned
   --            in WORK(1).  No error message related to LWORK is
   --            issued by XERBLA.  Neither H nor Z are accessed.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --              =  0:  successful exit
   --            .GT. 0:  if INFO = i, DLAQR4 failed to compute all of
   --                 the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
   --                 and WI contain those eigenvalues which have been
   --                 successfully computed.  (Failures are rare.)
   --
   --                 If INFO .GT. 0 and WANT is .FALSE., then on exit,
   --                 the remaining unconverged eigenvalues are the eigen-
   --                 values of the upper Hessenberg matrix rows and
   --                 columns ILO through INFO of the final, output
   --                 value of H.
   --
   --                 If INFO .GT. 0 and WANTT is .TRUE., then on exit
   --
   --            (*)  (initial value of H)*U  = U*(final value of H)
   --
   --                 where U is a orthogonal matrix.  The final
   --                 value of  H is upper Hessenberg and triangular in
   --                 rows and columns INFO+1 through IHI.
   --
   --                 If INFO .GT. 0 and WANTZ is .TRUE., then on exit
   --
   --                   final value of Z(ILO:IHI,ILOZ:IHIZ)
   --                    =  initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
   --
   --                 where U is the orthogonal matrix in (*) (regard-
   --                 less of the value of WANTT.)
   --
   --                 If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
   --                 accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  References:
   --  ================
   --
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
   --        Performance, SIAM Journal of Matrix Analysis, volume 23, pages
   --        929--947, 2002.
   --  \n
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part II: Aggressive Early Deflation, SIAM Journal
   --        of Matrix Analysis, volume 23, pages 948--973, 2002.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --     .. Parameters ..
   --
   --     ==== Matrices of order NTINY or smaller must be processed by
   --     .    DLAHQR because of insufficient subdiagonal scratch space.
   --     .    (This is a hard limit.) ====
   --      PARAMETER          ( NTINY = 11 )
   --
   --     ==== Exceptional deflation windows:  try to cure rare
   --     .    slow convergence by varying the size of the
   --     .    deflation window after KEXNW iterations. ====
   --      PARAMETER          ( KEXNW = 5 )
   --
   --     ==== Exceptional shifts: try to cure rare slow convergence
   --     .    with ad-hoc exceptional shifts every KEXSH iterations.
   --     .    ====
   --      PARAMETER          ( KEXSH = 6 )
   --
   --     ==== The constants WILK1 and WILK2 are used to form the
   --     .    exceptional shifts. ====
   --      PARAMETER          ( WILK1 = 0.75d0, WILK2 = -0.4375d0 )
   --      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      INTEGER            ILAENV
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLACPY, DLAHQR, DLANV2, DLAQR2, DLAQR5
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, MAX, MIN, MOD
   --     ..
   --     .. Executable Statements ..
   begin
      INFO := 0;
      --
      --     ==== Quick return for N = 0: nothing to do. ====
      --
      if N = 0 then
         WORK (1) := ONE;
         return;
      end if;
      --
      if N <= NTINY then
         --
         --        ==== Tiny matrices must use DLAHQR. ====
         --
         LWKOPT := 1;
         if LWORK /= -1 then
            DLAHQR (WANTT, WANTZ, N, ILO, IHI, H'Address, LDH, WR'Address, WI'Address, ILOZ, IHIZ, Z'Address, LDZ, INFO);
         end if;
      else
         --
         --        ==== Use small bulge multi-shift QR with aggressive early
         --        .    deflation on larger-than-tiny matrices. ====
         --
         --        ==== Hope for the best. ====
         --
         INFO := 0;
         --
         --        ==== Set up job flags for ILAENV. ====
         --
         if WANTT 
            then JBCMPZ (1) := 'S';
            else JBCMPZ (1) := 'E';
         end if;
         if WANTZ 
            then JBCMPZ (2) := 'V';
            else JBCMPZ (2) := 'N';
         end if;
         --
         --        ==== NWR = recommended deflation window size.  At this
         --        .    point,  N .GT. NTINY = 11, so there is enough
         --        .    subdiagonal workspace for NWR.GE.2 as required.
         --        .    (In fact, there is enough subdiagonal space for
         --        .    NWR.GE.3.) ====
         --
         NWR := ILAENV (13, "DLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         NWR := max (2, NWR);
         NWR := min (IHI - ILO + 1, (N - 1) / 3, NWR);
         --
         --        ==== NSR = recommended number of simultaneous shifts.
         --        .    At this point N .GT. NTINY = 11, so there is at
         --        .    enough subdiagonal workspace for NSR to be even
         --        .    and greater than or equal to two as required. ====
         --
         NSR := ILAENV (15, "DLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         NSR := min (NSR, (N + 6) / 9, IHI - ILO);
         NSR := max (2, NSR - "mod" (NSR, 2));
         --
         --        ==== Estimate optimal workspace ====
         --
         --        ==== Workspace query call to DLAQR2 ====
         --
         DLAQR2
           (WANTT,
            WANTZ,
            N,
            ILO,
            IHI,
            NWR + 1,
            H'Address,
            LDH,
            ILOZ,
            IHIZ,
            Z'Address,
            LDZ,
            LS,
            LD,
            WR'Address,
            WI'Address,
            H'Address,
            LDH,
            N,
            H'Address,
            LDH,
            N,
            H'Address,
            LDH,
            WORK'Address,
            -1);
         --
         --        ==== Optimal workspace = MAX(DLAQR5, DLAQR2) ====
         --
         LWKOPT := max (3 * NSR / 2, int (WORK (1)));
         --
         --        ==== Quick return in case of workspace query. ====
         --
         if LWORK = -1 then
            WORK (1) := Real (LWKOPT);
            return;
         end if;
         --
         --        ==== DLAHQR/DLAQR0 crossover point ====
         --
         NMIN := ILAENV (12, "DLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         NMIN := max (NTINY, NMIN);
         --
         --        ==== Nibble crossover point ====
         --
         NIBBLE := ILAENV (14, "DLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         NIBBLE := max (0, NIBBLE);
         --
         --        ==== Accumulate reflections during ttswp?  Use block
         --        .    2-by-2 structure during matrix-matrix multiply? ====
         --
         KACC22 := ILAENV (16, "DLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         KACC22 := max (0, KACC22);
         KACC22 := min (2, KACC22);
         --
         --        ==== NWMAX = the largest possible deflation window for
         --        .    which there is sufficient workspace. ====
         --
         NWMAX := min ((N - 1) / 3, LWORK / 2);
         NW    := NWMAX;
         --
         --        ==== NSMAX = the Largest number of simultaneous shifts
         --        .    for which there is sufficient workspace. ====
         --
         NSMAX := min ((N + 6) / 9, 2 * LWORK / 3);
         NSMAX := NSMAX - "mod" (NSMAX, 2);
         --
         --        ==== NDFL: an iteration count restarted at deflation. ====
         --
         NDFL := 1;
         --
         --        ==== ITMAX = iteration limit ====
         --
         ITMAX := max (30, 2 * KEXSH) * max (10, (IHI - ILO + 1));
         --
         --        ==== Last row and column in the active block ====
         --
         KBOT := IHI;
         --
         --        ==== Main Loop ====
         --
         IT := 1 - 1;
         loop
            IT := IT + 1;
            exit when IT > ITMAX;
            --
            --           ==== Done when KBOT falls below ILO ====
            --
            if KBOT < ILO then
               goto L90;
            end if;
            --
            --           ==== Locate active block ====
            --
            K := KBOT + 1;
            loop
               K := K - 1;
               exit when K < ILO + 1;
               if H (K, K - 1) = ZERO then
                  goto L20;
               end if;
            end loop;
            K := ILO;
            <<L20>> null;
            KTOP := K;
            --
            --           ==== Select deflation window size:
            --           .    Typical Case:
            --           .      If possible and advisable, nibble the entire
            --           .      active block.  If not, use size MIN(NWR,NWMAX)
            --           .      or MIN(NWR+1,NWMAX) depending upon which has
            --           .      the smaller corresponding subdiagonal entry
            --           .      (a heuristic).
            --           .
            --           .    Exceptional Case:
            --           .      If there have been no deflations in KEXNW or
            --           .      more iterations, then vary the deflation window
            --           .      size.   At first, because, larger windows are,
            --           .      in general, more powerful than smaller ones,
            --           .      rapidly increase the window to the maximum possible.
            --           .      Then, gradually reduce the window size. ====
            --
            NH     := KBOT - KTOP + 1;
            NWUPBD := min (NH, NWMAX);
            if NDFL < KEXNW 
               then NW := min (NWUPBD, NWR);
               else NW := min (NWUPBD, 2 * NW);
            end if;
            if NW < NWMAX then
               if NW >= NH - 1 then
                  NW := NH;
               else
                  KWTOP := KBOT - NW + 1;
                  if abs (H (KWTOP, KWTOP - 1)) > abs (H (KWTOP - 1, KWTOP - 2)) then
                     NW := NW + 1;
                  end if;
               end if;
            end if;
            if NDFL < KEXNW then
               NDEC := -1;
            elsif NDEC >= 0 or NW >= NWUPBD then
               NDEC := NDEC + 1;
               if NW - NDEC < 2 then
                  NDEC := 0;
               end if;
               NW := NW - NDEC;
            end if;
            --
            --           ==== Aggressive early deflation:
            --           .    split workspace under the subdiagonal into
            --           .      - an nw-by-nw work array V in the lower
            --           .        left-hand-corner,
            --           .      - an NW-by-at-least-NW-but-more-is-better
            --           .        (NW-by-NHO) horizontal work array along
            --           .        the bottom edge,
            --           .      - an at-least-NW-but-more-is-better (NHV-by-NW)
            --           .        vertical work array along the left-hand-edge.
            --           .        ====
            --
            KV  := N - NW + 1;
            KT  := NW + 1;
            NHO := (N - NW - 1) - KT + 1;
            KWV := NW + 2;
            NVE := (N - NW) - KWV + 1;
            --
            --           ==== Aggressive early deflation ====
            --
            DLAQR2
              (WANTT,
               WANTZ,
               N,
               KTOP,
               KBOT,
               NW,
               H'Address,
               LDH,
               ILOZ,
               IHIZ,
               Z'Address,
               LDZ,
               LS,
               LD,
               WR'Address,
               WI'Address,
               H (KV, 1)'Address,
               LDH,
               NHO,
               H (KV, KT)'Address,
               LDH,
               NVE,
               H (KWV, 1)'Address,
               LDH,
               WORK'Address,
               LWORK);
            --
            --           ==== Adjust KBOT accounting for new deflations. ====
            --
            KBOT := KBOT - LD;
            --
            --           ==== KS points to the shifts. ====
            --
            KS := KBOT - LS + 1;
            --
            --           ==== Skip an expensive QR sweep if there is a (partly
            --           .    heuristic) reason to expect that many eigenvalues
            --           .    will deflate without it.  Here, the QR sweep is
            --           .    skipped if many eigenvalues have just been deflated
            --           .    or if the remaining active block is small.
            --
            if (LD = 0) or ((100 * LD <= NW * NIBBLE) and (KBOT - KTOP + 1 > min (NMIN, NWMAX))) then
               --
               --              ==== NS = nominal number of simultaneous shifts.
               --              .    This may be lowered (slightly) if DLAQR2
               --              .    did not provide that many shifts. ====
               --
               NS := min (NSMAX, NSR, max (2, KBOT - KTOP));
               NS := NS - "mod" (NS, 2);
               --
               --              ==== If there have been no deflations
               --              .    in a multiple of KEXSH iterations,
               --              .    then try exceptional shifts.
               --              .    Otherwise use shifts provided by
               --              .    DLAQR2 above or from the eigenvalues
               --              .    of a trailing principal submatrix. ====
               --
               if "mod" (NDFL, KEXSH) = 0 then
                  KS := KBOT - NS + 1;
                  I  := KBOT + 2;
                  loop
                     I := I - 2;
                     exit when I < max (KS + 1, KTOP + 2);
                     SS := abs (H (I, I - 1)) + abs (H (I - 1, I - 2));
                     AA := WILK1 * SS + H (I, I);
                     BB := SS;
                     CC := WILK2 * SS;
                     DD := AA;
                     DLANV2 (AA, BB, CC, DD, WR (I - 1), WI (I - 1), WR (I), WI (I), CS, SN);
                  end loop;
                  if KS = KTOP then
                     WR (KS + 1) := H (KS + 1, KS + 1);
                     WI (KS + 1) := ZERO;
                     WR (KS)     := WR (KS + 1);
                     WI (KS)     := WI (KS + 1);
                  end if;
               else
                  --
                  --                 ==== Got NS/2 or fewer shifts? Use DLAHQR
                  --                 .    on a trailing principal submatrix to
                  --                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                  --                 .    there is enough space below the subdiagonal
                  --                 .    to fit an NS-by-NS scratch array.) ====
                  --
                  if KBOT - KS + 1 <= NS / 2 then
                     KS := KBOT - NS + 1;
                     KT := N - NS + 1;
                     DLACPY ('A', NS, NS, H (KS, KS)'Address, LDH, H (KT, 1)'Address, LDH);
                     DLAHQR
                       (False,
                        False,
                        NS,
                        1,
                        NS,
                        H (KT, 1)'Address,
                        LDH,
                        WR (KS)'Address,
                        WI (KS)'Address,
                        1,
                        1,
                        ZDUM'Address,
                        1,
                        INF);
                     KS := KS + INF;
                     --
                     --                    ==== In case of a rare QR failure use
                     --                    .    eigenvalues of the trailing 2-by-2
                     --                    .    principal submatrix.  ====
                     --
                     if KS >= KBOT then
                        AA := H (KBOT - 1, KBOT - 1);
                        CC := H (KBOT, KBOT - 1);
                        BB := H (KBOT - 1, KBOT);
                        DD := H (KBOT, KBOT);
                        DLANV2 (AA, BB, CC, DD, WR (KBOT - 1), WI (KBOT - 1), WR (KBOT), WI (KBOT), CS, SN);
                        KS := KBOT - 1;
                     end if;
                  end if;
                  --
                  if KBOT - KS + 1 > NS then
                     --
                     --                    ==== Sort the shifts (Helps a little)
                     --                    .    double sort keeps complex conjugate
                     --                    .    pairs together. ====
                     --
                     SORTED := False;
                     K      := KBOT + 1;
                     loop
                        K := K - 1;
                        exit when K < KS + 1;
                        if SORTED then
                           goto L60;
                        end if;
                        SORTED := True;
                        I      := KS - 1;
                        loop
                           I := I + 1;
                           exit when I > K - 1;
                           if abs (WR (I)) + abs (WI (I)) < abs (WR (I + 1)) + abs (WI (I + 1)) then
                              SORTED := False;
                              --
                              SWAP       := WR (I);
                              WR (I)     := WR (I + 1);
                              WR (I + 1) := SWAP;
                              --
                              SWAP       := WI (I);
                              WI (I)     := WI (I + 1);
                              WI (I + 1) := SWAP;
                           end if;
                        end loop;
                     end loop;
                     <<L60>> null;
                  end if;
                  --
                  --                 ==== Shuffle shifts into pairs of real shifts
                  --                 .    and pairs of complex conjugate shifts
                  --                 .    assuming complex conjugate shifts are
                  --                 .    already adjacent to one another. (Yes,
                  --                 .    they are.)  ====
                  --
                  I := KBOT + 2;
                  loop
                     I := I - 2;
                     exit when I < KS + 2;
                     if WI (I) /= -WI (I - 1) then
                        --
                        SWAP       := WR (I);
                        WR (I)     := WR (I - 1);
                        WR (I - 1) := WR (I - 2);
                        WR (I - 2) := SWAP;
                        --
                        SWAP       := WI (I);
                        WI (I)     := WI (I - 1);
                        WI (I - 1) := WI (I - 2);
                        WI (I - 2) := SWAP;
                     end if;
                  end loop;
               end if;
               --
               --              ==== If there are only two shifts and both are
               --              .    real, then use only one.  ====
               --
               if KBOT - KS + 1 = 2 then
                  if WI (KBOT) = ZERO then
                     if abs (WR (KBOT) - H (KBOT, KBOT)) < abs (WR (KBOT - 1) - H (KBOT, KBOT)) 
                        then WR (KBOT - 1) := WR (KBOT);
                        else WR (KBOT) := WR (KBOT - 1);
                     end if;
                  end if;
               end if;
               --
               --              ==== Use up to NS of the the smallest magnatiude
               --              .    shifts.  If there aren't NS shifts available,
               --              .    then use them all, possibly dropping one to
               --              .    make the number of shifts even. ====
               --
               NS := min (NS, KBOT - KS + 1);
               NS := NS - "mod" (NS, 2);
               KS := KBOT - NS + 1;
               --
               --              ==== Small-bulge multi-shift QR sweep:
               --              .    split workspace under the subdiagonal into
               --              .    - a KDU-by-KDU work array U in the lower
               --              .      left-hand-corner,
               --              .    - a KDU-by-at-least-KDU-but-more-is-better
               --              .      (KDU-by-NHo) horizontal work array WH along
               --              .      the bottom edge,
               --              .    - and an at-least-KDU-but-more-is-better-by-KDU
               --              .      (NVE-by-KDU) vertical work WV arrow along
               --              .      the left-hand-edge. ====
               --
               KDU := 3 * NS - 3;
               KU  := N - KDU + 1;
               KWH := KDU + 1;
               NHO := (N - KDU + 1 - 4) - (KDU + 1) + 1;
               KWV := KDU + 4;
               NVE := N - KDU - KWV + 1;
               --
               --              ==== Small-bulge multi-shift QR sweep ====
               --
               DLAQR5
                 (WANTT,
                  WANTZ,
                  KACC22,
                  N,
                  KTOP,
                  KBOT,
                  NS,
                  WR (KS)'Address,
                  WI (KS)'Address,
                  H'Address,
                  LDH,
                  ILOZ,
                  IHIZ,
                  Z'Address,
                  LDZ,
                  WORK'Address,
                  3,
                  H (KU, 1)'Address,
                  LDH,
                  NVE,
                  H (KWV, 1)'Address,
                  LDH,
                  NHO,
                  H (KU, KWH)'Address,
                  LDH);
            end if;
            --
            --           ==== Note progress (or the lack of it). ====
            --
            if LD > 0 
               then NDFL := 1;
               else NDFL := NDFL + 1;
            end if;
            --
            --           ==== End of main loop ====
         end loop;
         --
         --        ==== Iteration limit exceeded.  Set INFO to show where
         --        .    the problem occurred and exit. ====
         --
         INFO := KBOT;
         <<L90>> null;
      end if;
      --
      --     ==== Return the optimal value of LWORK. ====
      --
      WORK (1) := Real (LWKOPT);
      --
      --     ==== End of DLAQR4 ====
      --
   end DLAQR4;

   procedure DLAQR5
     (WANTT  : Boolean;
      WANTZ  : Boolean;
      KACC22 : Integer;
      N      : Integer;
      KTOP   : Integer;
      KBOT   : Integer;
      NSHFTS : Integer;
      SR_adr : Address;
      SI_adr : Address;
      H_adr  : Address;
      LDH    : Integer;
      ILOZ   : Integer;
      IHIZ   : Integer;
      Z_adr  : Address;
      LDZ    : Integer;
      V_adr  : Address;
      LDV    : Integer;
      U_adr  : Address;
      LDU    : Integer;
      NV     : Integer;
      WV_adr : Address;
      LDWV   : Integer;
      NH     : Integer;
      WH_adr : Address;
      LDWH   : Integer)
   is

      SR : Ftn_Real_Vector (1 .. NSHFTS);
      SI : Ftn_Real_Vector (1 .. NSHFTS);
      H  : Ftn_Real_Matrix (1 .. LDH, 1 .. N);
      Z  : Ftn_Real_Matrix (1 .. LDZ, 1 .. IHIZ);
      V  : Ftn_Real_Matrix (1 .. LDV, 1 .. NSHFTS / 2);
      U  : Ftn_Real_Matrix (1 .. LDU, 1 .. 3 * NSHFTS - 3);
      WV : Ftn_Real_Matrix (1 .. LDWV, 1 .. 3 * NSHFTS - 3);
      WH : Ftn_Real_Matrix (1 .. LDWH, 1 .. NH);

      for SR'Address use SR_adr;
      for SI'Address use SI_adr;
      for H'Address use H_adr;
      for Z'Address use Z_adr;
      for V'Address use V_adr;
      for U'Address use U_adr;
      for WV'Address use WV_adr;
      for WH'Address use WH_adr;

      pragma Import (Ada, SR);
      pragma Import (Ada, SI);
      pragma Import (Ada, H);
      pragma Import (Ada, Z);
      pragma Import (Ada, V);
      pragma Import (Ada, U);
      pragma Import (Ada, WV);
      pragma Import (Ada, WH);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      ALPHA  : Real;
      BETA   : Real;
      H11    : Real;
      H12    : Real;
      H21    : Real;
      H22    : Real;
      REFSUM : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SCL    : Real;
      SMLNUM : Real;
      SWAP   : Real;
      TST1   : Real;
      TST2   : Real;
      ULP    : Real;
      I      : Integer;
      I2     : Integer;
      I4     : Integer;
      INCOL  : Integer;
      J      : Integer;
      J2     : Integer;
      J4     : Integer;
      JBOT   : Integer;
      JCOL   : Integer;
      JLEN   : Integer;
      JROW   : Integer;
      JTOP   : Integer;
      K      : Integer;
      K1     : Integer;
      KDU    : Integer;
      KMS    : Integer;
      KNZ    : Integer;
      KRCOL  : Integer;
      KZS    : Integer;
      M      : Integer;
      M22    : Integer;
      MBOT   : Integer;
      MEND   : Integer;
      MSTART : Integer;
      MTOP   : Integer;
      NBMPS  : Integer;
      NDCOL  : Integer;
      NS     : Integer;
      NU     : Integer;
      ACCUM  : Boolean;
      BLK22  : Boolean;
      BMP22  : Boolean;
      VT     : Ftn_Real_Vector (1 .. 3);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAQR5( WANTT, WANTZ, KACC22, N, KTOP, KBOT, NSHFTS,
   --                          SR, SI, H, LDH, ILOZ, IHIZ, Z, LDZ, V, LDV, U,
   --                          LDU, NV, WV, LDWV, NH, WH, LDWH )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHIZ, ILOZ, KACC22, KBOT, KTOP, LDH, LDU, LDV,
   --      $                   LDWH, LDWV, LDZ, N, NH, NSHFTS, NV
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   H( LDH, * ), SI( * ), SR( * ), U( LDU, * ),
   --      $                   V( LDV, * ), WH( LDWH, * ), WV( LDWV, * ),
   --      $                   Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     DLAQR5, called by DLAQR0, performs a
   --     single small-bulge multi-shift QR sweep.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL scalar
   --              WANTT = .true. if the quasi-triangular Schur factor
   --              is being computed.  WANTT is set to .false. otherwise.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL scalar
   --              WANTZ = .true. if the orthogonal Schur factor is being
   --              computed.  WANTZ is set to .false. otherwise.
   --
   --  [in] KACC22
   --           KACC22 is integer with value 0, 1, or 2.
   --              Specifies the computation mode of far-from-diagonal
   --              orthogonal updates.
   --         = 0: DLAQR5 does not accumulate reflections and does not
   --              use matrix-matrix multiply to update far-from-diagonal
   --              matrix entries.
   --         = 1: DLAQR5 accumulates reflections and uses matrix-matrix
   --              multiply to update the far-from-diagonal matrix entries.
   --         = 2: DLAQR5 accumulates reflections, uses matrix-matrix
   --              multiply to update the far-from-diagonal matrix entries,
   --              and takes advantage of 2-by-2 block structure during
   --              matrix multiplies.
   --
   --  [in] N
   --           N is integer scalar
   --              N is the order of the Hessenberg matrix H upon which this
   --              subroutine operates.
   --
   --  [in] KTOP
   --           KTOP is integer scalar
   --
   --  [in] KBOT
   --           KBOT is integer scalar
   --              These are the first and last rows and columns of an
   --              isolated diagonal block upon which the QR sweep is to be
   --              applied. It is assumed without a check that
   --                        either KTOP = 1  or   H(KTOP,KTOP-1) = 0
   --              and
   --                        either KBOT = N  or   H(KBOT+1,KBOT) = 0.
   --
   --  [in] NSHFTS
   --           NSHFTS is integer scalar
   --              NSHFTS gives the number of simultaneous shifts.  NSHFTS
   --              must be positive and even.
   --
   --  [in,out] SR
   --           SR is DOUBLE PRECISION array of size (NSHFTS)
   --
   --  [in,out] SI
   --           SI is DOUBLE PRECISION array of size (NSHFTS)
   --              SR contains the real parts and SI contains the imaginary
   --              parts of the NSHFTS shifts of origin that define the
   --              multi-shift QR sweep.  On output SR and SI may be
   --              reordered.
   --
   --  [in,out] H
   --           H is DOUBLE PRECISION array of size (LDH,N)
   --              On input H contains a Hessenberg matrix.  On output a
   --              multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
   --              to the isolated diagonal block in rows and columns KTOP
   --              through KBOT.
   --
   --  [in] LDH
   --           LDH is integer scalar
   --              LDH is the leading dimension of H just as declared in the
   --              calling procedure.  LDH.GE.MAX(1,N).
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --              Specify the rows of Z to which transformations must be
   --              applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array of size (LDZ,IHI)
   --              If WANTZ = .TRUE., then the QR Sweep orthogonal
   --              similarity transformation is accumulated into
   --              Z(ILOZ:IHIZ,ILO:IHI) from the right.
   --              If WANTZ = .FALSE., then Z is unreferenced.
   --
   --  [in] LDZ
   --           LDZ is integer scalar
   --              LDA is the leading dimension of Z just as declared in
   --              the calling procedure. LDZ.GE.N.
   --
   --  [out] V
   --           V is DOUBLE PRECISION array of size (LDV,NSHFTS/2)
   --
   --  [in] LDV
   --           LDV is integer scalar
   --              LDV is the leading dimension of V as declared in the
   --              calling procedure.  LDV.GE.3.
   --
   --  [out] U
   --           U is DOUBLE PRECISION array of size
   --              (LDU,3*NSHFTS-3)
   --
   --  [in] LDU
   --           LDU is integer scalar
   --              LDU is the leading dimension of U just as declared in the
   --              in the calling subroutine.  LDU.GE.3*NSHFTS-3.
   --
   --  [in] NH
   --           NH is integer scalar
   --              NH is the number of columns in array WH available for
   --              workspace. NH.GE.1.
   --
   --  [out] WH
   --           WH is DOUBLE PRECISION array of size (LDWH,NH)
   --
   --  [in] LDWH
   --           LDWH is integer scalar
   --              Leading dimension of WH just as declared in the
   --              calling procedure.  LDWH.GE.3*NSHFTS-3.
   --
   --  [in] NV
   --           NV is integer scalar
   --              NV is the number of rows in WV agailable for workspace.
   --              NV.GE.1.
   --
   --  [out] WV
   --           WV is DOUBLE PRECISION array of size
   --              (LDWV,3*NSHFTS-3)
   --
   --  [in] LDWV
   --           LDWV is integer scalar
   --              LDWV is the leading dimension of WV as declared in the
   --              in the calling subroutine.  LDWV.GE.NV.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  References:
   --  ================
   --
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
   --        Performance, SIAM Journal of Matrix Analysis, volume 23, pages
   --        929--947, 2002.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. Intrinsic Functions ..
   --
   --      INTRINSIC          ABS, DBLE, MAX, MIN, MOD
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMM, DLABAD, DLACPY, DLAQR1, DLARFG, DLASET,
   --     $                   DTRMM
   --     ..
   --     .. Executable Statements ..
   --
   --     ==== If there are no shifts, then there is nothing to do. ====
   --
   begin
      if NSHFTS < 2 then
         return;
      end if;
      --
      --     ==== If the active block is empty or 1-by-1, then there
      --     .    is nothing to do. ====
      --
      if KTOP >= KBOT then
         return;
      end if;
      --
      --     ==== Shuffle shifts into pairs of real shifts and pairs
      --     .    of complex conjugate shifts assuming complex
      --     .    conjugate shifts are already adjacent to one
      --     .    another. ====
      --
      I := 1 - 2;
      loop
         I := I + 2;
         exit when I > NSHFTS - 2;
         if SI (I) /= -SI (I + 1) then
            --
            SWAP       := SR (I);
            SR (I)     := SR (I + 1);
            SR (I + 1) := SR (I + 2);
            SR (I + 2) := SWAP;
            --
            SWAP       := SI (I);
            SI (I)     := SI (I + 1);
            SI (I + 1) := SI (I + 2);
            SI (I + 2) := SWAP;
         end if;
      end loop;
      --
      --     ==== NSHFTS is supposed to be even, but if it is odd,
      --     .    then simply reduce it by one.  The shuffle above
      --     .    ensures that the dropped shift is real and that
      --     .    the remaining shifts are paired. ====
      --
      NS := NSHFTS - "mod" (NSHFTS, 2);
      --
      --     ==== Machine constants for deflation ====
      --
      SAFMIN := DLAMCH ('S');
      SAFMAX := ONE / SAFMIN;
      DLABAD (SAFMIN, SAFMAX);
      ULP    := DLAMCH ('P');
      SMLNUM := SAFMIN * (Real (N) / ULP);
      --
      --     ==== Use accumulated reflections to update far-from-diagonal
      --     .    entries ? ====
      --
      ACCUM := (KACC22 = 1) or (KACC22 = 2);
      --
      --     ==== If so, exploit the 2-by-2 block structure? ====
      --
      BLK22 := (NS > 2) and (KACC22 = 2);
      --
      --     ==== clear trash ====
      --
      if KTOP + 2 <= KBOT then
         H (KTOP + 2, KTOP) := ZERO;
      end if;
      --
      --     ==== NBMPS = number of 2-shift bulges in the chain ====
      --
      NBMPS := NS / 2;
      --
      --     ==== KDU = width of slab ====
      --
      KDU := 6 * NBMPS - 3;
      --
      --     ==== Create and chase chains of NBMPS bulges ====
      --
      INCOL := 3 * (1 - NBMPS) + KTOP - 1 - (3 * NBMPS - 2);
      loop
         INCOL := INCOL + (3 * NBMPS - 2);
         if (3 * NBMPS - 2) > 0 
            then exit when INCOL > KBOT - 2;
            else exit when INCOL < KBOT - 2;
         end if;
         NDCOL := INCOL + KDU;
         if ACCUM then
            DLASET ('A', KDU, KDU, ZERO, ONE, U'Address, LDU);
         end if;
         --
         --        ==== Near-the-diagonal bulge chase.  The following loop
         --        .    performs the near-the-diagonal part of a small bulge
         --        .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal
         --        .    chunk extends from column INCOL to column NDCOL
         --        .    (including both column INCOL and column NDCOL). The
         --        .    following loop chases a 3*NBMPS column long chain of
         --        .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL
         --        .    may be less than KTOP and and NDCOL may be greater than
         --        .    KBOT indicating phantom columns from which to chase
         --        .    bulges before they are actually introduced or to which
         --        .    to chase bulges beyond column KBOT.)  ====
         --
         KRCOL := INCOL - 1;
         loop
            KRCOL := KRCOL + 1;
            exit when KRCOL > min (INCOL + 3 * NBMPS - 3, KBOT - 2);
            --
            --           ==== Bulges number MTOP to MBOT are active Real implicit
            --           .    shift bulges.  There may or may not also be small
            --           .    2-by-2 bulge, if there is room.  The inactive bulges
            --           .    (if any) must wait until the active bulges have moved
            --           .    down the diagonal to make room.  The phantom matrix
            --           .    paradigm described above helps keep track.  ====
            --
            MTOP  := max (1, ((KTOP - 1) - KRCOL + 2) / 3 + 1);
            MBOT  := min (NBMPS, (KBOT - KRCOL) / 3);
            M22   := MBOT + 1;
            BMP22 := (MBOT < NBMPS) and (KRCOL + 3 * (M22 - 1)) = (KBOT - 2);
            --
            --           ==== Generate reflections to chase the chain right
            --           .    one column.  (The minimum value of K is KTOP-1.) ====
            --
            M := MTOP - 1;
            loop
               M := M + 1;
               exit when M > MBOT;
               K := KRCOL + 3 * (M - 1);
               if K = KTOP - 1 then
                  DLAQR1
                    (3,
                     H (KTOP, KTOP)'Address,
                     LDH,
                     SR (2 * M - 1),
                     SI (2 * M - 1),
                     SR (2 * M),
                     SI (2 * M),
                     V (1, M)'Address);
                  ALPHA := V (1, M);
                  DLARFG (3, ALPHA, V (2, M)'Address, 1, V (1, M));
               else
                  BETA     := H (K + 1, K);
                  V (2, M) := H (K + 2, K);
                  V (3, M) := H (K + 3, K);
                  DLARFG (3, BETA, V (2, M)'Address, 1, V (1, M));
                  --
                  --                 ==== A Bulge may collapse because of vigilant
                  --                 .    deflation or destructive underflow.  In the
                  --                 .    underflow case, try the two-small-subdiagonals
                  --                 .    trick to try to reinflate the bulge.  ====
                  --
                  if H (K + 3, K) /= ZERO or H (K + 3, K + 1) /= ZERO or H (K + 3, K + 2) = ZERO then
                     --
                     --                    ==== Typical case: not collapsed (yet). ====
                     --
                     H (K + 1, K) := BETA;
                     H (K + 2, K) := ZERO;
                     H (K + 3, K) := ZERO;
                  else
                     --
                     --                    ==== Atypical case: collapsed.  Attempt to
                     --                    .    reintroduce ignoring H(K+1,K) and H(K+2,K).
                     --                    .    If the fill resulting from the new
                     --                    .    reflector is too large, then abandon it.
                     --                    .    Otherwise, use the new one. ====
                     --
                     DLAQR1
                       (3,
                        H (K + 1, K + 1)'Address,
                        LDH,
                        SR (2 * M - 1),
                        SI (2 * M - 1),
                        SR (2 * M),
                        SI (2 * M),
                        VT'Address);
                     ALPHA := VT (1);
                     DLARFG (3, ALPHA, VT (2)'Address, 1, VT (1));
                     REFSUM := VT (1) * (H (K + 1, K) + VT (2) * H (K + 2, K));
                     --
                     if abs (H (K + 2, K) - REFSUM * VT (2)) + abs (REFSUM * VT (3)) >
                        ULP * (abs (H (K, K)) + abs (H (K + 1, K + 1)) + abs (H (K + 2, K + 2)))
                     then
                        --
                        --                       ==== Starting a new bulge here would
                        --                       .    create non-negligible fill.  Use
                        --                       .    the old one with trepidation. ====
                        --
                        H (K + 1, K) := BETA;
                        H (K + 2, K) := ZERO;
                        H (K + 3, K) := ZERO;
                     else
                        --
                        --                       ==== Stating a new bulge here would
                        --                       .    create only negligible fill.
                        --                       .    Replace the old reflector with
                        --                       .    the new one. ====
                        --
                        H (K + 1, K) := H (K + 1, K) - REFSUM;
                        H (K + 2, K) := ZERO;
                        H (K + 3, K) := ZERO;
                        V (1, M)     := VT (1);
                        V (2, M)     := VT (2);
                        V (3, M)     := VT (3);
                     end if;
                  end if;
               end if;
            end loop;
            --
            --           ==== Generate a 2-by-2 reflection, if needed. ====
            --
            K := KRCOL + 3 * (M22 - 1);
            if BMP22 then
               if K = KTOP - 1 then
                  DLAQR1
                    (2,
                     H (K + 1, K + 1)'Address,
                     LDH,
                     SR (2 * M22 - 1),
                     SI (2 * M22 - 1),
                     SR (2 * M22),
                     SI (2 * M22),
                     V (1, M22)'Address);
                  BETA := V (1, M22);
                  DLARFG (2, BETA, V (2, M22)'Address, 1, V (1, M22));
               else
                  BETA       := H (K + 1, K);
                  V (2, M22) := H (K + 2, K);
                  DLARFG (2, BETA, V (2, M22)'Address, 1, V (1, M22));
                  H (K + 1, K) := BETA;
                  H (K + 2, K) := ZERO;
               end if;
            end if;
            --
            --           ==== Multiply H by reflections from the left ====
            --
            if ACCUM then
               JBOT := min (NDCOL, KBOT);
            elsif WANTT then
               JBOT := N;
            else
               JBOT := KBOT;
            end if;
            J := max (KTOP, KRCOL) - 1;
            loop
               J := J + 1;
               exit when J > JBOT;
               MEND := min (MBOT, (J - KRCOL + 2) / 3);
               M    := MTOP - 1;
               loop
                  M := M + 1;
                  exit when M > MEND;
                  K            := KRCOL + 3 * (M - 1);
                  REFSUM       := V (1, M) * (H (K + 1, J) + V (2, M) * H (K + 2, J) + V (3, M) * H (K + 3, J));
                  H (K + 1, J) := H (K + 1, J) - REFSUM;
                  H (K + 2, J) := H (K + 2, J) - REFSUM * V (2, M);
                  H (K + 3, J) := H (K + 3, J) - REFSUM * V (3, M);
               end loop;
            end loop;
            if BMP22 then
               K := KRCOL + 3 * (M22 - 1);
               J := max (K + 1, KTOP) - 1;
               loop
                  J := J + 1;
                  exit when J > JBOT;
                  REFSUM       := V (1, M22) * (H (K + 1, J) + V (2, M22) * H (K + 2, J));
                  H (K + 1, J) := H (K + 1, J) - REFSUM;
                  H (K + 2, J) := H (K + 2, J) - REFSUM * V (2, M22);
               end loop;
            end if;
            --
            --           ==== Multiply H by reflections from the right.
            --           .    Delay filling in the last row until the
            --           .    vigilant deflation check is complete. ====
            --
            if ACCUM then
               JTOP := max (KTOP, INCOL);
            elsif WANTT then
               JTOP := 1;
            else
               JTOP := KTOP;
            end if;
            M := MTOP - 1;
            loop
               M := M + 1;
               exit when M > MBOT;
               if V (1, M) /= ZERO then
                  K := KRCOL + 3 * (M - 1);
                  J := JTOP - 1;
                  loop
                     J := J + 1;
                     exit when J > min (KBOT, K + 3);
                     REFSUM       := V (1, M) * (H (J, K + 1) + V (2, M) * H (J, K + 2) + V (3, M) * H (J, K + 3));
                     H (J, K + 1) := H (J, K + 1) - REFSUM;
                     H (J, K + 2) := H (J, K + 2) - REFSUM * V (2, M);
                     H (J, K + 3) := H (J, K + 3) - REFSUM * V (3, M);
                  end loop;
                  --
                  if ACCUM then
                     --
                     --                    ==== Accumulate U. (If necessary, update Z later
                     --                    .    with with an efficient matrix-matrix
                     --                    .    multiply.) ====
                     --
                     KMS := K - INCOL;
                     J   := max (1, KTOP - INCOL) - 1;
                     loop
                        J := J + 1;
                        exit when J > KDU;
                        REFSUM         := V (1, M) *
                                          (U (J, KMS + 1) + V (2, M) * U (J, KMS + 2) + V (3, M) * U (J, KMS + 3));
                        U (J, KMS + 1) := U (J, KMS + 1) - REFSUM;
                        U (J, KMS + 2) := U (J, KMS + 2) - REFSUM * V (2, M);
                        U (J, KMS + 3) := U (J, KMS + 3) - REFSUM * V (3, M);
                     end loop;
                  elsif WANTZ then
                     --
                     --                    ==== U is not accumulated, so update Z
                     --                    .    now by multiplying by reflections
                     --                    .    from the right. ====
                     --
                     J := ILOZ - 1;
                     loop
                        J := J + 1;
                        exit when J > IHIZ;
                        REFSUM       := V (1, M) * (Z (J, K + 1) + V (2, M) * Z (J, K + 2) + V (3, M) * Z (J, K + 3));
                        Z (J, K + 1) := Z (J, K + 1) - REFSUM;
                        Z (J, K + 2) := Z (J, K + 2) - REFSUM * V (2, M);
                        Z (J, K + 3) := Z (J, K + 3) - REFSUM * V (3, M);
                     end loop;
                  end if;
               end if;
            end loop;
            --
            --           ==== Special case: 2-by-2 reflection (if needed) ====
            --
            K := KRCOL + 3 * (M22 - 1);
            if BMP22 then
               if V (1, M22) /= ZERO then
                  J := JTOP - 1;
                  loop
                     J := J + 1;
                     exit when J > min (KBOT, K + 3);
                     REFSUM       := V (1, M22) * (H (J, K + 1) + V (2, M22) * H (J, K + 2));
                     H (J, K + 1) := H (J, K + 1) - REFSUM;
                     H (J, K + 2) := H (J, K + 2) - REFSUM * V (2, M22);
                  end loop;
                  --
                  if ACCUM then
                     KMS := K - INCOL;
                     J   := max (1, KTOP - INCOL) - 1;
                     loop
                        J := J + 1;
                        exit when J > KDU;
                        REFSUM         := V (1, M22) * (U (J, KMS + 1) + V (2, M22) * U (J, KMS + 2));
                        U (J, KMS + 1) := U (J, KMS + 1) - REFSUM;
                        U (J, KMS + 2) := U (J, KMS + 2) - REFSUM * V (2, M22);
                     end loop;
                  elsif WANTZ then
                     J := ILOZ - 1;
                     loop
                        J := J + 1;
                        exit when J > IHIZ;
                        REFSUM       := V (1, M22) * (Z (J, K + 1) + V (2, M22) * Z (J, K + 2));
                        Z (J, K + 1) := Z (J, K + 1) - REFSUM;
                        Z (J, K + 2) := Z (J, K + 2) - REFSUM * V (2, M22);
                     end loop;
                  end if;
               end if;
            end if;
            --
            --           ==== Vigilant deflation check ====
            --
            MSTART := MTOP;
            if KRCOL + 3 * (MSTART - 1) < KTOP then
               MSTART := MSTART + 1;
            end if;
            MEND := MBOT;
            if BMP22 then
               MEND := MEND + 1;
            end if;
            if KRCOL = KBOT - 2 then
               MEND := MEND + 1;
            end if;
            M := MSTART - 1;
            loop
               M := M + 1;
               exit when M > MEND;
               K := min (KBOT - 1, KRCOL + 3 * (M - 1));
               --
               --              ==== The following convergence test requires that
               --              .    the tradition small-compared-to-nearby-diagonals
               --              .    criterion and the Ahues & Tisseur (LAWN 122, 1997)
               --              .    criteria both be satisfied.  The latter improves
               --              .    accuracy in some examples. Falling back on an
               --              .    alternate convergence criterion when TST1 or TST2
               --              .    is zero (as done here) is traditional but probably
               --              .    unnecessary. ====
               --
               if H (K + 1, K) /= ZERO then
                  TST1 := abs (H (K, K)) + abs (H (K + 1, K + 1));
                  if TST1 = ZERO then
                     if K >= KTOP + 1 then
                        TST1 := TST1 + abs (H (K, K - 1));
                     end if;
                     if K >= KTOP + 2 then
                        TST1 := TST1 + abs (H (K, K - 2));
                     end if;
                     if K >= KTOP + 3 then
                        TST1 := TST1 + abs (H (K, K - 3));
                     end if;
                     if K <= KBOT - 2 then
                        TST1 := TST1 + abs (H (K + 2, K + 1));
                     end if;
                     if K <= KBOT - 3 then
                        TST1 := TST1 + abs (H (K + 3, K + 1));
                     end if;
                     if K <= KBOT - 4 then
                        TST1 := TST1 + abs (H (K + 4, K + 1));
                     end if;
                  end if;
                  if abs (H (K + 1, K)) <= max (SMLNUM, ULP * TST1) then
                     H12  := max (abs (H (K + 1, K)), abs (H (K, K + 1)));
                     H21  := min (abs (H (K + 1, K)), abs (H (K, K + 1)));
                     H11  := max (abs (H (K + 1, K + 1)), abs (H (K, K) - H (K + 1, K + 1)));
                     H22  := min (abs (H (K + 1, K + 1)), abs (H (K, K) - H (K + 1, K + 1)));
                     SCL  := H11 + H12;
                     TST2 := H22 * (H11 / SCL);
                     --
                     if TST2 = ZERO or H21 * (H12 / SCL) <= max (SMLNUM, ULP * TST2) then
                        H (K + 1, K) := ZERO;
                     end if;
                  end if;
               end if;
            end loop;
            --
            --           ==== Fill in the last row of each bulge. ====
            --
            MEND := min (NBMPS, (KBOT - KRCOL - 1) / 3);
            M    := MTOP - 1;
            loop
               M := M + 1;
               exit when M > MEND;
               K                := KRCOL + 3 * (M - 1);
               REFSUM           := V (1, M) * V (3, M) * H (K + 4, K + 3);
               H (K + 4, K + 1) := -REFSUM;
               H (K + 4, K + 2) := -REFSUM * V (2, M);
               H (K + 4, K + 3) := H (K + 4, K + 3) - REFSUM * V (3, M);
            end loop;
            --
            --           ==== End of near-the-diagonal bulge chase. ====
            --
         end loop;
         --
         --        ==== Use U (if accumulated) to update far-from-diagonal
         --        .    entries in H.  If required, use U to update Z as
         --        .    well. ====
         --
         if ACCUM then
            if WANTT then
               JTOP := 1;
               JBOT := N;
            else
               JTOP := KTOP;
               JBOT := KBOT;
            end if;
            if (not BLK22) or (INCOL < KTOP) or (NDCOL > KBOT) or (NS <= 2) then
               --
               --              ==== Updates not exploiting the 2-by-2 block
               --              .    structure of U.  K1 and NU keep track of
               --              .    the location and size of U in the special
               --              .    cases of introducing bulges and chasing
               --              .    bulges off the bottom.  In these special
               --              .    cases and in case the number of shifts
               --              .    is NS = 2, there is no 2-by-2 block
               --              .    structure to exploit.  ====
               --
               K1 := max (1, KTOP - INCOL);
               NU := (KDU - max (0, NDCOL - KBOT)) - K1 + 1;
               --
               --              ==== Horizontal Multiply ====
               --
               JCOL := min (NDCOL, KBOT) + 1 - NH;
               loop
                  JCOL := JCOL + NH;
                  exit when JCOL > JBOT;
                  JLEN := min (NH, JBOT - JCOL + 1);
                  DGEMM
                    ('C',
                     'N',
                     NU,
                     JLEN,
                     NU,
                     ONE,
                     U (K1, K1)'Address,
                     LDU,
                     H (INCOL + K1, JCOL)'Address,
                     LDH,
                     ZERO,
                     WH'Address,
                     LDWH);
                  DLACPY ('A', NU, JLEN, WH'Address, LDWH, H (INCOL + K1, JCOL)'Address, LDH);
               end loop;
               --
               --              ==== Vertical multiply ====
               --
               JROW := JTOP - NV;
               loop
                  JROW := JROW + NV;
                  exit when JROW > max (KTOP, INCOL) - 1;
                  JLEN := min (NV, max (KTOP, INCOL) - JROW);
                  DGEMM
                    ('N',
                     'N',
                     JLEN,
                     NU,
                     NU,
                     ONE,
                     H (JROW, INCOL + K1)'Address,
                     LDH,
                     U (K1, K1)'Address,
                     LDU,
                     ZERO,
                     WV'Address,
                     LDWV);
                  DLACPY ('A', JLEN, NU, WV'Address, LDWV, H (JROW, INCOL + K1)'Address, LDH);
               end loop;
               --
               --              ==== Z multiply (also vertical) ====
               --
               if WANTZ then
                  JROW := ILOZ - NV;
                  loop
                     JROW := JROW + NV;
                     exit when JROW > IHIZ;
                     JLEN := min (NV, IHIZ - JROW + 1);
                     DGEMM
                       ('N',
                        'N',
                        JLEN,
                        NU,
                        NU,
                        ONE,
                        Z (JROW, INCOL + K1)'Address,
                        LDZ,
                        U (K1, K1)'Address,
                        LDU,
                        ZERO,
                        WV'Address,
                        LDWV);
                     DLACPY ('A', JLEN, NU, WV'Address, LDWV, Z (JROW, INCOL + K1)'Address, LDZ);
                  end loop;
               end if;
            else
               --
               --              ==== Updates exploiting U's 2-by-2 block structure.
               --              .    (I2, I4, J2, J4 are the last rows and columns
               --              .    of the blocks.) ====
               --
               I2 := (KDU + 1) / 2;
               I4 := KDU;
               J2 := I4 - I2;
               J4 := KDU;
               --
               --              ==== KZS and KNZ deal with the band of zeros
               --              .    along the diagonal of one of the triangular
               --              .    blocks. ====
               --
               KZS := (J4 - J2) - (NS + 1);
               KNZ := NS + 1;
               --
               --              ==== Horizontal multiply ====
               --
               JCOL := min (NDCOL, KBOT) + 1 - NH;
               loop
                  JCOL := JCOL + NH;
                  exit when JCOL > JBOT;
                  JLEN := min (NH, JBOT - JCOL + 1);
                  --
                  --                 ==== Copy bottom of H to top+KZS of scratch ====
                  --                  (The first KZS rows get multiplied by zero.) ====
                  --
                  DLACPY ('A', KNZ, JLEN, H (INCOL + 1 + J2, JCOL)'Address, LDH, WH (KZS + 1, 1)'Address, LDWH);
                  --
                  --                 ==== Multiply by U21**T ====
                  --
                  DLASET ('A', KZS, JLEN, ZERO, ZERO, WH'Address, LDWH);
                  DTRMM
                    ('L',
                     'U',
                     'C',
                     'N',
                     KNZ,
                     JLEN,
                     ONE,
                     U (J2 + 1, 1 + KZS)'Address,
                     LDU,
                     WH (KZS + 1, 1)'Address,
                     LDWH);
                  --
                  --                 ==== Multiply top of H by U11**T ====
                  --
                  DGEMM
                    ('C',
                     'N',
                     I2,
                     JLEN,
                     J2,
                     ONE,
                     U'Address,
                     LDU,
                     H (INCOL + 1, JCOL)'Address,
                     LDH,
                     ONE,
                     WH'Address,
                     LDWH);
                  --
                  --                 ==== Copy top of H to bottom of WH ====
                  --
                  DLACPY ('A', J2, JLEN, H (INCOL + 1, JCOL)'Address, LDH, WH (I2 + 1, 1)'Address, LDWH);
                  --
                  --                 ==== Multiply by U21**T ====
                  --
                  DTRMM ('L', 'L', 'C', 'N', J2, JLEN, ONE, U (1, I2 + 1)'Address, LDU, WH (I2 + 1, 1)'Address, LDWH);
                  --
                  --                 ==== Multiply by U22 ====
                  --
                  DGEMM
                    ('C',
                     'N',
                     I4 - I2,
                     JLEN,
                     J4 - J2,
                     ONE,
                     U (J2 + 1, I2 + 1)'Address,
                     LDU,
                     H (INCOL + 1 + J2, JCOL)'Address,
                     LDH,
                     ONE,
                     WH (I2 + 1, 1)'Address,
                     LDWH);
                  --
                  --                 ==== Copy it back ====
                  --
                  DLACPY ('A', KDU, JLEN, WH'Address, LDWH, H (INCOL + 1, JCOL)'Address, LDH);
               end loop;
               --
               --              ==== Vertical multiply ====
               --
               JROW := JTOP - NV;
               loop
                  JROW := JROW + NV;
                  exit when JROW > max (INCOL, KTOP) - 1;
                  JLEN := min (NV, max (INCOL, KTOP) - JROW);
                  --
                  --                 ==== Copy right of H to scratch (the first KZS
                  --                 .    columns get multiplied by zero) ====
                  --
                  DLACPY ('A', JLEN, KNZ, H (JROW, INCOL + 1 + J2)'Address, LDH, WV (1, 1 + KZS)'Address, LDWV);
                  --
                  --                 ==== Multiply by U21 ====
                  --
                  DLASET ('A', JLEN, KZS, ZERO, ZERO, WV'Address, LDWV);
                  DTRMM
                    ('R',
                     'U',
                     'N',
                     'N',
                     JLEN,
                     KNZ,
                     ONE,
                     U (J2 + 1, 1 + KZS)'Address,
                     LDU,
                     WV (1, 1 + KZS)'Address,
                     LDWV);
                  --
                  --                 ==== Multiply by U11 ====
                  --
                  DGEMM
                    ('N',
                     'N',
                     JLEN,
                     I2,
                     J2,
                     ONE,
                     H (JROW, INCOL + 1)'Address,
                     LDH,
                     U'Address,
                     LDU,
                     ONE,
                     WV'Address,
                     LDWV);
                  --
                  --                 ==== Copy left of H to right of scratch ====
                  --
                  DLACPY ('A', JLEN, J2, H (JROW, INCOL + 1)'Address, LDH, WV (1, 1 + I2)'Address, LDWV);
                  --
                  --                 ==== Multiply by U21 ====
                  --
                  DTRMM ('R', 'L', 'N', 'N', JLEN, I4 - I2, ONE, U (1, I2 + 1)'Address, LDU, WV (1, 1 + I2)'Address, LDWV);
                  --
                  --                 ==== Multiply by U22 ====
                  --
                  DGEMM
                    ('N',
                     'N',
                     JLEN,
                     I4 - I2,
                     J4 - J2,
                     ONE,
                     H (JROW, INCOL + 1 + J2)'Address,
                     LDH,
                     U (J2 + 1, I2 + 1)'Address,
                     LDU,
                     ONE,
                     WV (1, 1 + I2)'Address,
                     LDWV);
                  --
                  --                 ==== Copy it back ====
                  --
                  DLACPY ('A', JLEN, KDU, WV'Address, LDWV, H (JROW, INCOL + 1)'Address, LDH);
               end loop;
               --
               --              ==== Multiply Z (also vertical) ====
               --
               if WANTZ then
                  JROW := ILOZ - NV;
                  loop
                     JROW := JROW + NV;
                     exit when JROW > IHIZ;
                     JLEN := min (NV, IHIZ - JROW + 1);
                     --
                     --                    ==== Copy right of Z to left of scratch (first
                     --                    .     KZS columns get multiplied by zero) ====
                     --
                     DLACPY ('A', JLEN, KNZ, Z (JROW, INCOL + 1 + J2)'Address, LDZ, WV (1, 1 + KZS)'Address, LDWV);
                     --
                     --                    ==== Multiply by U12 ====
                     --
                     DLASET ('A', JLEN, KZS, ZERO, ZERO, WV'Address, LDWV);
                     DTRMM
                       ('R',
                        'U',
                        'N',
                        'N',
                        JLEN,
                        KNZ,
                        ONE,
                        U (J2 + 1, 1 + KZS)'Address,
                        LDU,
                        WV (1, 1 + KZS)'Address,
                        LDWV);
                     --
                     --                    ==== Multiply by U11 ====
                     --
                     DGEMM
                       ('N',
                        'N',
                        JLEN,
                        I2,
                        J2,
                        ONE,
                        Z (JROW, INCOL + 1)'Address,
                        LDZ,
                        U'Address,
                        LDU,
                        ONE,
                        WV'Address,
                        LDWV);
                     --
                     --                    ==== Copy left of Z to right of scratch ====
                     --
                     DLACPY ('A', JLEN, J2, Z (JROW, INCOL + 1)'Address, LDZ, WV (1, 1 + I2)'Address, LDWV);
                     --
                     --                    ==== Multiply by U21 ====
                     --
                     DTRMM
                       ('R',
                        'L',
                        'N',
                        'N',
                        JLEN,
                        I4 - I2,
                        ONE,
                        U (1, I2 + 1)'Address,
                        LDU,
                        WV (1, 1 + I2)'Address,
                        LDWV);
                     --
                     --                    ==== Multiply by U22 ====
                     --
                     DGEMM
                       ('N',
                        'N',
                        JLEN,
                        I4 - I2,
                        J4 - J2,
                        ONE,
                        Z (JROW, INCOL + 1 + J2)'Address,
                        LDZ,
                        U (J2 + 1, I2 + 1)'Address,
                        LDU,
                        ONE,
                        WV (1, 1 + I2)'Address,
                        LDWV);
                     --
                     --                    ==== Copy the result back to Z ====
                     --
                     DLACPY ('A', JLEN, KDU, WV'Address, LDWV, Z (JROW, INCOL + 1)'Address, LDZ);
                  end loop;
               end if;
            end if;
         end if;
         JROW := JROW + 3 * NBMPS - 2;
      end loop;
      --
      --     ==== End of DLAQR5 ====
      --
   end DLAQR5;

   procedure DLARF
     (SIDE     : Character;
      M        : Integer;
      N        : Integer;
      V_adr    : Address;
      INCV     : Integer;
      TAU      : Real;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address)
   is

      V    : Ftn_Real_Vector (1 .. 1 + (max (M, N) - 1) * abs (INCV));
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (M, N));

      for V'Address use V_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, V);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      ONE       : constant Real := 1.0e0;
      ZERO      : constant Real := 0.0e0;
      APPLYLEFT : Boolean;
      I         : Integer;
      LASTV     : Integer;
      LASTC     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK)
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE
   --       INTEGER            INCV, LDC, M, N
   --       DOUBLE PRECISION   TAU
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   C( LDC, * ), V( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLARF applies a real elementary reflector H to a real m by n matrix
   --  C, from either the left or the right. H is represented in the form
   --
   --        H = I - tau * v * v**T
   --
   --  where tau is a real scalar and v is a real vector.
   --
   --  If tau = 0, then H is taken to be the unit matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': form  H * C
   --           = 'R': form  C * H
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C.
   --
   --  [in] V
   --           V is DOUBLE PRECISION array, dimension
   --                      (1 + (M-1)*abs(INCV)) if SIDE = 'L'
   --                   or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
   --           The vector v in the representation of H. V is not used if
   --           TAU = 0.
   --
   --  [in] INCV
   --           INCV is INTEGER
   --           The increment between elements of v. INCV <> 0.
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION
   --           The value tau in the representation of H.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the m by n matrix C.
   --           On exit, C is overwritten by the matrix H * C if SIDE = 'L',
   --           or C * H if SIDE = 'R'.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension
   --                          (N) if SIDE = 'L'
   --                       or (M) if SIDE = 'R'
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMV, DGER
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      INTEGER            ILADLR, ILADLC
   --      EXTERNAL           LSAME, ILADLR, ILADLC
   --     ..
   --     .. Executable Statements ..
   --
   begin
      APPLYLEFT := LSAME (SIDE, 'L');
      LASTV     := 0;
      LASTC     := 0;
      if TAU /= ZERO then
         --     Set up variables for scanning V.  LASTV begins pointing to the end
         --     of V.
         if APPLYLEFT 
            then LASTV := M;
            else LASTV := N;
         end if;
         if INCV > 0 
            then I := 1 + (LASTV - 1) * INCV;
            else I := 1;
         end if;
         --     Look for the last non-zero row in V.
         while LASTV > 0 and V (I) = ZERO loop
            LASTV := LASTV - 1;
            I     := I - INCV;
         end loop;
         if APPLYLEFT then
            --     Scan for the last non-zero column in C(1:lastv,:).
            LASTC := ILADLC (LASTV, N, C, LDC);
         else
            --     Scan for the last non-zero row in C(:,1:lastv).
            LASTC := ILADLR (M, LASTV, C, LDC);
         end if;
      end if;
      --     Note that lastc.eq.0 renders the BLAS operations null; no special
      --     case is needed at this level.
      if APPLYLEFT then
         --
         --        Form  H * C
         --
         if LASTV > 0 then
            --
            --           w(1:lastc,1) := C(1:lastv,1:lastc)**T * v(1:lastv,1)
            --
            DGEMV ('T', LASTV, LASTC, ONE, C'Address, LDC, V'Address, INCV, ZERO, WORK'Address, 1);
            --
            --           C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)**T
            --
            DGER (LASTV, LASTC, -TAU, V'Address, INCV, WORK'Address, 1, C'Address, LDC);
         end if;
      else
         --
         --        Form  C * H
         --
         if LASTV > 0 then
            --
            --           w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1)
            --
            DGEMV ('N', LASTC, LASTV, ONE, C'Address, LDC, V'Address, INCV, ZERO, WORK'Address, 1);
            --
            --           C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)**T
            --
            DGER (LASTC, LASTV, -TAU, WORK'Address, 1, V'Address, INCV, C'Address, LDC);
         end if;
      end if;
      return;
      --
      --     End of DLARF
      --
   end DLARF;

   procedure DLARFB
     (SIDE     : Character;
      TRANS    : Character;
      DIRECT   : Character;
      STOREV   : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      V_adr    : Address;
      LDV      : Integer;
      T_adr    : Address;
      LDT      : Integer;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LDWORK   : Integer)
   is

      V    : Ftn_Real_Matrix (1 .. LDV, 1 .. max (K, M, N));
      T    : Ftn_Real_Matrix (1 .. LDT, 1 .. K);
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Matrix (1 .. LDWORK, 1 .. K);

      for V'Address use V_adr;
      for T'Address use T_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, V);
      pragma Import (Ada, T);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      ONE    : constant Real := 1.0e0;
      TRANST : Character;
      I      : Integer;
      J      : Integer;
      LASTV  : Integer;
      LASTC  : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
   --                          T, LDT, C, LDC, WORK, LDWORK )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIRECT, SIDE, STOREV, TRANS
   --       INTEGER            K, LDC, LDT, LDV, LDWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   C( LDC, * ), T( LDT, * ), V( LDV, * ),
   --      $                   WORK( LDWORK, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLARFB applies a real block reflector H or its transpose H**T to a
   --  real m by n matrix C, from either the left or the right.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply H or H**T from the Left
   --           = 'R': apply H or H**T from the Right
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply H (No transpose)
   --           = 'T': apply H**T (Transpose)
   --
   --  [in] DIRECT
   --           DIRECT is CHARACTER*1
   --           Indicates how H is formed from a product of elementary
   --           reflectors
   --           = 'F': H = H(1) H(2) . . . H(k) (Forward)
   --           = 'B': H = H(k) . . . H(2) H(1) (Backward)
   --
   --  [in] STOREV
   --           STOREV is CHARACTER*1
   --           Indicates how the vectors which define the elementary
   --           reflectors are stored:
   --           = 'C': Columnwise
   --           = 'R': Rowwise
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C.
   --
   --  [in] K
   --           K is INTEGER
   --           The order of the matrix T (= the number of elementary
   --           reflectors whose product defines the block reflector).
   --
   --  [in] V
   --           V is DOUBLE PRECISION array, dimension
   --                                 (LDV,K) if STOREV = 'C'
   --                                 (LDV,M) if STOREV = 'R' and SIDE = 'L'
   --                                 (LDV,N) if STOREV = 'R' and SIDE = 'R'
   --           The matrix V. See Further Details.
   --
   --  [in] LDV
   --           LDV is INTEGER
   --           The leading dimension of the array V.
   --           If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
   --           if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
   --           if STOREV = 'R', LDV >= K.
   --
   --  [in] T
   --           T is DOUBLE PRECISION array, dimension (LDT,K)
   --           The triangular k by k matrix T in the representation of the
   --           block reflector.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= K.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the m by n matrix C.
   --           On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (LDWORK,K)
   --
   --  [in] LDWORK
   --           LDWORK is INTEGER
   --           The leading dimension of the array WORK.
   --           If SIDE = 'L', LDWORK >= max(1,N);
   --           if SIDE = 'R', LDWORK >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The shape of the matrix V and the storage of the vectors which define
   --   the H(i) is best illustrated by the following example with n = 5 and
   --   k = 3. The elements equal to 1 are not stored; the corresponding
   --   array elements are modified but restored on exit. The rest of the
   --   array is not used.
   --
   --   DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
   --
   --                V = (  1       )                 V = (  1 v1 v1 v1 v1 )
   --                    ( v1  1    )                     (     1 v2 v2 v2 )
   --                    ( v1 v2  1 )                     (        1 v3 v3 )
   --                    ( v1 v2 v3 )
   --                    ( v1 v2 v3 )
   --
   --   DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
   --
   --                V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
   --                    ( v1 v2 v3 )                     ( v2 v2 v2  1    )
   --                    (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
   --                    (     1 v3 )
   --                    (        1 )
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      INTEGER            ILADLR, ILADLC
   --      EXTERNAL           LSAME, ILADLR, ILADLC
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DGEMM, DTRMM
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if M <= 0 or N <= 0 then
         return;
      end if;
      --
      if LSAME (TRANS, 'N') 
         then TRANST := 'T';
         else TRANST := 'N';
      end if;
      --
      if LSAME (STOREV, 'C') then
         --
         if LSAME (DIRECT, 'F') then
            --
            --           Let  V =  ( V1 )    (first K rows)
            --                     ( V2 )
            --           where  V1  is unit lower triangular.
            --
            if LSAME (SIDE, 'L') then
               --
               --              Form  H * C  or  H**T * C  where  C = ( C1 )
               --                                                    ( C2 )
               --
               LASTV := max (K, ILADLR (M, K, V, LDV));
               LASTC := ILADLC (LASTV, N, C, LDC);
               --
               --              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in WORK)
               --
               --              W := C1**T
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  DCOPY (LASTC, C (J, 1)'Address, LDC, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V1
               --
               DTRMM ('R', 'L', 'N', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C2**T *V2
                  --
                  DGEMM
                    ('T',
                     'N',
                     LASTC,
                     K,
                     LASTV - K,
                     ONE,
                     C (K + 1, 1)'Address,
                     LDC,
                     V (K + 1, 1)'Address,
                     LDV,
                     ONE,
                     WORK'Address,
                     LDWORK);
               end if;
               --
               --              W := W * T**T  or  W * T
               --
               DTRMM ('R', 'U', TRANST, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - V * W**T
               --
               if LASTV > K then
                  --
                  --                 C2 := C2 - V2 * W**T
                  --
                  DGEMM
                    ('N',
                     'T',
                     LASTV - K,
                     LASTC,
                     K,
                     -ONE,
                     V (K + 1, 1)'Address,
                     LDV,
                     WORK'Address,
                     LDWORK,
                     ONE,
                     C (K + 1, 1)'Address,
                     LDC);
               end if;
               --
               --              W := W * V1**T
               --
               DTRMM ('R', 'L', 'T', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W**T
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (J, I) := C (J, I) - WORK (I, J);
                  end loop;
               end loop;
            --
            elsif LSAME (SIDE, 'R') then
               --
               --              Form  C * H  or  C * H**T  where  C = ( C1  C2 )
               --
               LASTV := max (K, ILADLR (N, K, V, LDV));
               LASTC := ILADLR (M, LASTV, C, LDC);
               --
               --              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
               --
               --              W := C1
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  DCOPY (LASTC, C (1, J)'Address, 1, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V1
               --
               DTRMM ('R', 'L', 'N', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C2 * V2
                  --
                  DGEMM
                    ('N',
                     'N',
                     LASTC,
                     K,
                     LASTV - K,
                     ONE,
                     C (1, K + 1)'Address,
                     LDC,
                     V (K + 1, 1)'Address,
                     LDV,
                     ONE,
                     WORK'Address,
                     LDWORK);
               end if;
               --
               --              W := W * T  or  W * T**T
               --
               DTRMM ('R', 'U', TRANS, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - W * V**T
               --
               if LASTV > K then
                  --
                  --                 C2 := C2 - W * V2**T
                  --
                  DGEMM
                    ('N',
                     'T',
                     LASTC,
                     LASTV - K,
                     K,
                     -ONE,
                     WORK'Address,
                     LDWORK,
                     V (K + 1, 1)'Address,
                     LDV,
                     ONE,
                     C (1, K + 1)'Address,
                     LDC);
               end if;
               --
               --              W := W * V1**T
               --
               DTRMM ('R', 'L', 'T', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (I, J) := C (I, J) - WORK (I, J);
                  end loop;
               end loop;
            end if;
         --
         else
            --
            --           Let  V =  ( V1 )
            --                     ( V2 )    (last K rows)
            --           where  V2  is unit upper triangular.
            --
            if LSAME (SIDE, 'L') then
               --
               --              Form  H * C  or  H**T * C  where  C = ( C1 )
               --                                                    ( C2 )
               --
               LASTV := max (K, ILADLR (M, K, V, LDV));
               LASTC := ILADLC (LASTV, N, C, LDC);
               --
               --              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in WORK)
               --
               --              W := C2**T
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  DCOPY (LASTC, C (LASTV - K + J, 1)'Address, LDC, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V2
               --
               DTRMM ('R', 'U', 'N', 'U', LASTC, K, ONE, V (LASTV - K + 1, 1)'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C1**T*V1
                  --
                  DGEMM ('T', 'N', LASTC, K, LASTV - K, ONE, C'Address, LDC, V'Address, LDV, ONE, WORK'Address, LDWORK);
               end if;
               --
               --              W := W * T**T  or  W * T
               --
               DTRMM ('R', 'L', TRANST, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - V * W**T
               --
               if LASTV > K then
                  --
                  --                 C1 := C1 - V1 * W**T
                  --
                  DGEMM ('N', 'T', LASTV - K, LASTC, K, -ONE, V'Address, LDV, WORK'Address, LDWORK, ONE, C'Address, LDC);
               end if;
               --
               --              W := W * V2**T
               --
               DTRMM ('R', 'U', 'T', 'U', LASTC, K, ONE, V (LASTV - K + 1, 1)'Address, LDV, WORK'Address, LDWORK);
               --
               --              C2 := C2 - W**T
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (LASTV - K + J, I) := C (LASTV - K + J, I) - WORK (I, J);
                  end loop;
               end loop;
            --
            elsif LSAME (SIDE, 'R') then
               --
               --              Form  C * H  or  C * H**T  where  C = ( C1  C2 )
               --
               LASTV := max (K, ILADLR (N, K, V, LDV));
               LASTC := ILADLR (M, LASTV, C, LDC);
               --
               --              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
               --
               --              W := C2
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  DCOPY (LASTC, C (1, N - K + J)'Address, 1, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V2
               --
               DTRMM ('R', 'U', 'N', 'U', LASTC, K, ONE, V (LASTV - K + 1, 1)'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C1 * V1
                  --
                  DGEMM ('N', 'N', LASTC, K, LASTV - K, ONE, C'Address, LDC, V'Address, LDV, ONE, WORK'Address, LDWORK);
               end if;
               --
               --              W := W * T  or  W * T**T
               --
               DTRMM ('R', 'L', TRANS, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - W * V**T
               --
               if LASTV > K then
                  --
                  --                 C1 := C1 - W * V1**T
                  --
                  DGEMM ('N', 'T', LASTC, LASTV - K, K, -ONE, WORK'Address, LDWORK, V'Address, LDV, ONE, C'Address, LDC);
               end if;
               --
               --              W := W * V2**T
               --
               DTRMM ('R', 'U', 'T', 'U', LASTC, K, ONE, V (LASTV - K + 1, 1)'Address, LDV, WORK'Address, LDWORK);
               --
               --              C2 := C2 - W
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (I, LASTV - K + J) := C (I, LASTV - K + J) - WORK (I, J);
                  end loop;
               end loop;
            end if;
         end if;
      --
      elsif LSAME (STOREV, 'R') then
         --
         if LSAME (DIRECT, 'F') then
            --
            --           Let  V =  ( V1  V2 )    (V1: first K columns)
            --           where  V1  is unit upper triangular.
            --
            if LSAME (SIDE, 'L') then
               --
               --              Form  H * C  or  H**T * C  where  C = ( C1 )
               --                                                    ( C2 )
               --
               LASTV := max (K, ILADLC (K, M, V, LDV));
               LASTC := ILADLC (LASTV, N, C, LDC);
               --
               --              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (stored in WORK)
               --
               --              W := C1**T
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  DCOPY (LASTC, C (J, 1)'Address, LDC, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V1**T
               --
               DTRMM ('R', 'U', 'T', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C2**T*V2**T
                  --
                  DGEMM
                    ('T',
                     'T',
                     LASTC,
                     K,
                     LASTV - K,
                     ONE,
                     C (K + 1, 1)'Address,
                     LDC,
                     V (1, K + 1)'Address,
                     LDV,
                     ONE,
                     WORK'Address,
                     LDWORK);
               end if;
               --
               --              W := W * T**T  or  W * T
               --
               DTRMM ('R', 'U', TRANST, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - V**T * W**T
               --
               if LASTV > K then
                  --
                  --                 C2 := C2 - V2**T * W**T
                  --
                  DGEMM
                    ('T',
                     'T',
                     LASTV - K,
                     LASTC,
                     K,
                     -ONE,
                     V (1, K + 1)'Address,
                     LDV,
                     WORK'Address,
                     LDWORK,
                     ONE,
                     C (K + 1, 1)'Address,
                     LDC);
               end if;
               --
               --              W := W * V1
               --
               DTRMM ('R', 'U', 'N', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W**T
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (J, I) := C (J, I) - WORK (I, J);
                  end loop;
               end loop;
            --
            elsif LSAME (SIDE, 'R') then
               --
               --              Form  C * H  or  C * H**T  where  C = ( C1  C2 )
               --
               LASTV := max (K, ILADLC (K, N, V, LDV));
               LASTC := ILADLR (M, LASTV, C, LDC);
               --
               --              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK)
               --
               --              W := C1
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  DCOPY (LASTC, C (1, J)'Address, 1, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V1**T
               --
               DTRMM ('R', 'U', 'T', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C2 * V2**T
                  --
                  DGEMM
                    ('N',
                     'T',
                     LASTC,
                     K,
                     LASTV - K,
                     ONE,
                     C (1, K + 1)'Address,
                     LDC,
                     V (1, K + 1)'Address,
                     LDV,
                     ONE,
                     WORK'Address,
                     LDWORK);
               end if;
               --
               --              W := W * T  or  W * T**T
               --
               DTRMM ('R', 'U', TRANS, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - W * V
               --
               if LASTV > K then
                  --
                  --                 C2 := C2 - W * V2
                  --
                  DGEMM
                    ('N',
                     'N',
                     LASTC,
                     LASTV - K,
                     K,
                     -ONE,
                     WORK'Address,
                     LDWORK,
                     V (1, K + 1)'Address,
                     LDV,
                     ONE,
                     C (1, K + 1)'Address,
                     LDC);
               end if;
               --
               --              W := W * V1
               --
               DTRMM ('R', 'U', 'N', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (I, J) := C (I, J) - WORK (I, J);
                  end loop;
               end loop;
               --
            end if;
         --
         else
            --
            --           Let  V =  ( V1  V2 )    (V2: last K columns)
            --           where  V2  is unit lower triangular.
            --
            if LSAME (SIDE, 'L') then
               --
               --              Form  H * C  or  H**T * C  where  C = ( C1 )
               --                                                    ( C2 )
               --
               LASTV := max (K, ILADLC (K, M, V, LDV));
               LASTC := ILADLC (LASTV, N, C, LDC);
               --
               --              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (stored in WORK)
               --
               --              W := C2**T
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  DCOPY (LASTC, C (LASTV - K + J, 1)'Address, LDC, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V2**T
               --
               DTRMM ('R', 'L', 'T', 'U', LASTC, K, ONE, V (1, LASTV - K + 1)'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C1**T * V1**T
                  --
                  DGEMM ('T', 'T', LASTC, K, LASTV - K, ONE, C'Address, LDC, V'Address, LDV, ONE, WORK'Address, LDWORK);
               end if;
               --
               --              W := W * T**T  or  W * T
               --
               DTRMM ('R', 'L', TRANST, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - V**T * W**T
               --
               if LASTV > K then
                  --
                  --                 C1 := C1 - V1**T * W**T
                  --
                  DGEMM ('T', 'T', LASTV - K, LASTC, K, -ONE, V'Address, LDV, WORK'Address, LDWORK, ONE, C'Address, LDC);
               end if;
               --
               --              W := W * V2
               --
               DTRMM ('R', 'L', 'N', 'U', LASTC, K, ONE, V (1, LASTV - K + 1)'Address, LDV, WORK'Address, LDWORK);
               --
               --              C2 := C2 - W**T
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (LASTV - K + J, I) := C (LASTV - K + J, I) - WORK (I, J);
                  end loop;
               end loop;
            --
            elsif LSAME (SIDE, 'R') then
               --
               --              Form  C * H  or  C * H**T  where  C = ( C1  C2 )
               --
               LASTV := max (K, ILADLC (K, N, V, LDV));
               LASTC := ILADLR (M, LASTV, C, LDC);
               --
               --              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK)
               --
               --              W := C2
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  DCOPY (LASTC, C (1, LASTV - K + J)'Address, 1, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V2**T
               --
               DTRMM ('R', 'L', 'T', 'U', LASTC, K, ONE, V (1, LASTV - K + 1)'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C1 * V1**T
                  --
                  DGEMM ('N', 'T', LASTC, K, LASTV - K, ONE, C'Address, LDC, V'Address, LDV, ONE, WORK'Address, LDWORK);
               end if;
               --
               --              W := W * T  or  W * T**T
               --
               DTRMM ('R', 'L', TRANS, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - W * V
               --
               if LASTV > K then
                  --
                  --                 C1 := C1 - W * V1
                  --
                  DGEMM ('N', 'N', LASTC, LASTV - K, K, -ONE, WORK'Address, LDWORK, V'Address, LDV, ONE, C'Address, LDC);
               end if;
               --
               --              W := W * V2
               --
               DTRMM ('R', 'L', 'N', 'U', LASTC, K, ONE, V (1, LASTV - K + 1)'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (I, LASTV - K + J) := C (I, LASTV - K + J) - WORK (I, J);
                  end loop;
               end loop;
               --
            end if;
            --
         end if;
      end if;
      --
      return;
      --
      --     End of DLARFB
      --
   end DLARFB;

   procedure DLARFG
     (N     : Integer;
      ALPHA : in out Real;
      X_adr : Address;
      INCX  : Integer;
      TAU   : in out Real)
   is

      X : Ftn_Real_Vector (1 .. 1 + (N - 2) * abs (INCX));

      for X'Address use X_adr;

      pragma Import (Ada, X);

      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
      J      : Integer;
      KNT    : Integer;
      BETA   : Real;
      RSAFMN : Real;
      SAFMIN : Real;
      XNORM  : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLARFG( N, ALPHA, X, INCX, TAU )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, N
   --       DOUBLE PRECISION   ALPHA, TAU
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   X( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLARFG generates a real elementary reflector H of order n, such
   --  that
   --
   --        H * ( alpha ) = ( beta ),   H**T * H = I.
   --            (   x   )   (   0  )
   --
   --  where alpha and beta are scalars, and x is an (n-1)-element real
   --  vector. H is represented in the form
   --
   --        H = I - tau * ( 1 ) * ( 1 v**T ),
   --                      ( v )
   --
   --  where tau is a real scalar and v is a real (n-1)-element
   --  vector.
   --
   --  If the elements of x are all zero, then tau = 0 and H is taken to be
   --  the unit matrix.
   --
   --  Otherwise  1 <= tau <= 2.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the elementary reflector.
   --
   --  [in,out] ALPHA
   --           ALPHA is DOUBLE PRECISION
   --           On entry, the value alpha.
   --           On exit, it is overwritten with the value beta.
   --
   --  [in,out] X
   --           X is DOUBLE PRECISION array, dimension
   --                          (1+(N-2)*abs(INCX))
   --           On entry, the vector x.
   --           On exit, it is overwritten with the vector v.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --           The increment between elements of X. INCX > 0.
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION
   --           The value tau.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH, DLAPY2, DNRM2
   --      EXTERNAL           DLAMCH, DLAPY2, DNRM2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SIGN
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DSCAL
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N <= 1 then
         TAU := ZERO;
         return;
      end if;
      --
      XNORM := DNRM2 (N - 1, X'Address, INCX);
      --
      if XNORM = ZERO then
         --
         --        H  =  I
         --
         TAU := ZERO;
      else
         --
         --        general case
         --
         BETA   := -sign (DLAPY2 (ALPHA, XNORM), ALPHA);
         SAFMIN := DLAMCH ('S') / DLAMCH ('E');
         KNT    := 0;
         if abs (BETA) < SAFMIN then
            --
            --           XNORM, BETA may be inaccurate; scale X and recompute them
            --
            RSAFMN := ONE / SAFMIN;
            <<L10>> null;
            KNT := KNT + 1;
            DSCAL (N - 1, RSAFMN, X'Address, INCX);
            BETA  := BETA * RSAFMN;
            ALPHA := ALPHA * RSAFMN;
            if abs (BETA) < SAFMIN then
               goto L10;
            end if;
            --
            --           New BETA is at most 1, at least SAFMIN
            --
            XNORM := DNRM2 (N - 1, X'Address, INCX);
            BETA  := -sign (DLAPY2 (ALPHA, XNORM), ALPHA);
         end if;
         TAU := (BETA - ALPHA) / BETA;
         DSCAL (N - 1, ONE / (ALPHA - BETA), X'Address, INCX);
         --
         --        If ALPHA is subnormal, it may lose relative accuracy
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > KNT;
            BETA := BETA * SAFMIN;
         end loop;
         ALPHA := BETA;
      end if;
      --
      return;
      --
      --     End of DLARFG
      --
   end DLARFG;

   procedure DLARFT
     (DIRECT  : Character;
      STOREV  : Character;
      N       : Integer;
      K       : Integer;
      V_adr   : Address;
      LDV     : Integer;
      TAU_adr : Address;
      T_adr   : Address;
      LDT     : Integer)
   is

      V   : Ftn_Real_Matrix (1 .. LDV, 1 .. max (K, N));
      TAU : Ftn_Real_Vector (1 .. K);
      T   : Ftn_Real_Matrix (1 .. LDT, 1 .. K);

      for V'Address use V_adr;
      for TAU'Address use TAU_adr;
      for T'Address use T_adr;

      pragma Import (Ada, V);
      pragma Import (Ada, TAU);
      pragma Import (Ada, T);

      ONE       : constant Real := 1.0e0;
      ZERO      : constant Real := 0.0e0;
      I         : Integer;
      J         : Integer;
      PREVLASTV : Integer;
      LASTV     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIRECT, STOREV
   --       INTEGER            K, LDT, LDV, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   T( LDT, * ), TAU( * ), V( LDV, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLARFT forms the triangular factor T of a real block reflector H
   --  of order n, which is defined as a product of k elementary reflectors.
   --
   --  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
   --
   --  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
   --
   --  If STOREV = 'C', the vector which defines the elementary reflector
   --  H(i) is stored in the i-th column of the array V, and
   --
   --     H  =  I - V * T * V**T
   --
   --  If STOREV = 'R', the vector which defines the elementary reflector
   --  H(i) is stored in the i-th row of the array V, and
   --
   --     H  =  I - V**T * T * V
   --
   --  Arguments:
   --  ==========
   --
   --  [in] DIRECT
   --           DIRECT is CHARACTER*1
   --           Specifies the order in which the elementary reflectors are
   --           multiplied to form the block reflector:
   --           = 'F': H = H(1) H(2) . . . H(k) (Forward)
   --           = 'B': H = H(k) . . . H(2) H(1) (Backward)
   --
   --  [in] STOREV
   --           STOREV is CHARACTER*1
   --           Specifies how the vectors which define the elementary
   --           reflectors are stored (see also Further Details):
   --           = 'C': columnwise
   --           = 'R': rowwise
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the block reflector H. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The order of the triangular factor T (= the number of
   --           elementary reflectors). K >= 1.
   --
   --  [in] V
   --           V is DOUBLE PRECISION array, dimension
   --                                (LDV,K) if STOREV = 'C'
   --                                (LDV,N) if STOREV = 'R'
   --           The matrix V. See further details.
   --
   --  [in] LDV
   --           LDV is INTEGER
   --           The leading dimension of the array V.
   --           If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i).
   --
   --  [out] T
   --           T is DOUBLE PRECISION array, dimension (LDT,K)
   --           The k by k triangular factor T of the block reflector.
   --           If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
   --           lower triangular. The rest of the array is not used.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= K.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The shape of the matrix V and the storage of the vectors which define
   --   the H(i) is best illustrated by the following example with n = 5 and
   --   k = 3. The elements equal to 1 are not stored.
   --
   --   DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
   --
   --                V = (  1       )                 V = (  1 v1 v1 v1 v1 )
   --                    ( v1  1    )                     (     1 v2 v2 v2 )
   --                    ( v1 v2  1 )                     (        1 v3 v3 )
   --                    ( v1 v2 v3 )
   --                    ( v1 v2 v3 )
   --
   --   DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
   --
   --                V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
   --                    ( v1 v2 v3 )                     ( v2 v2 v2  1    )
   --                    (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
   --                    (     1 v3 )
   --                    (        1 )
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMV, DTRMV
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if N = 0 then
         return;
      end if;
      --
      if LSAME (DIRECT, 'F') then
         PREVLASTV := N;
         I         := 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            PREVLASTV := max (I, PREVLASTV);
            if TAU (I) = ZERO then
               --
               --              H(i)  =  I
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > I;
                  T (J, I) := ZERO;
               end loop;
            else
               --
               --              general case
               --
               if LSAME (STOREV, 'C') then
                  --                 Skip any trailing zeros.
                  LASTV := N + 1;
                  loop
                     LASTV := LASTV - 1;
                     exit when LASTV < I + 1;
                     exit when V (LASTV, I) /= ZERO;
                  end loop;
                  J := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > I - 1;
                     T (J, I) := -TAU (I) * V (I, J);
                  end loop;
                  J := min (LASTV, PREVLASTV);
                  --
                  --                 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)**T * V(i:j,i)
                  --
                  DGEMV
                    ('T',
                     J - I,
                     I - 1,
                     -TAU (I),
                     V (I + 1, 1)'Address,
                     LDV,
                     V (I + 1, I)'Address,
                     1,
                     ONE,
                     T (1, I)'Address,
                     1);
               else
                  --                 Skip any trailing zeros.
                  LASTV := N + 1;
                  loop
                     LASTV := LASTV - 1;
                     exit when LASTV < I + 1;
                     exit when V (I, LASTV) /= ZERO;
                  end loop;
                  J := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > I - 1;
                     T (J, I) := -TAU (I) * V (J, I);
                  end loop;
                  J := min (LASTV, PREVLASTV);
                  --
                  --                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)**T
                  --
                  DGEMV
                    ('N',
                     I - 1,
                     J - I,
                     -TAU (I),
                     V (1, I + 1)'Address,
                     LDV,
                     V (I, I + 1)'Address,
                     LDV,
                     ONE,
                     T (1, I)'Address,
                     1);
               end if;
               --
               --              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)
               --
               DTRMV ('U', 'N', 'N', I - 1, T'Address, LDT, T (1, I)'Address, 1);
               T (I, I) := TAU (I);
               if I > 1 
                  then PREVLASTV := max (PREVLASTV, LASTV);
                  else PREVLASTV := LASTV;
               end if;
            end if;
         end loop;
      else
         PREVLASTV := 1;
         I         := K + 1;
         loop
            I := I - 1;
            exit when I < 1;
            if TAU (I) = ZERO then
               --
               --              H(i)  =  I
               --
               J := I - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  T (J, I) := ZERO;
               end loop;
            else
               --
               --              general case
               --
               if I < K then
                  if LSAME (STOREV, 'C') then
                     --                    Skip any leading zeros.
                     LASTV := 1 - 1;
                     loop
                        LASTV := LASTV + 1;
                        exit when LASTV > I - 1;
                        exit when V (LASTV, I) /= ZERO;
                     end loop;
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > K;
                        T (J, I) := -TAU (I) * V (N - K + I, J);
                     end loop;
                     J := max (LASTV, PREVLASTV);
                     --
                     --                    T(i+1:k,i) = -tau(i) * V(j:n-k+i,i+1:k)**T * V(j:n-k+i,i)
                     --
                     DGEMV
                       ('T',
                        N - K + I - J,
                        K - I,
                        -TAU (I),
                        V (J, I + 1)'Address,
                        LDV,
                        V (J, I)'Address,
                        1,
                        ONE,
                        T (I + 1, I)'Address,
                        1);
                  else
                     --                    Skip any leading zeros.
                     LASTV := 1 - 1;
                     loop
                        LASTV := LASTV + 1;
                        exit when LASTV > I - 1;
                        exit when V (I, LASTV) /= ZERO;
                     end loop;
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > K;
                        T (J, I) := -TAU (I) * V (J, N - K + I);
                     end loop;
                     J := max (LASTV, PREVLASTV);
                     --
                     --                    T(i+1:k,i) = -tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)**T
                     --
                     DGEMV
                       ('N',
                        K - I,
                        N - K + I - J,
                        -TAU (I),
                        V (I + 1, J)'Address,
                        LDV,
                        V (I, J)'Address,
                        LDV,
                        ONE,
                        T (I + 1, I)'Address,
                        1);
                  end if;
                  --
                  --                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)
                  --
                  DTRMV ('L', 'N', 'N', K - I, T (I + 1, I + 1)'Address, LDT, T (I + 1, I)'Address, 1);
                  if I > 1 
                     then PREVLASTV := min (PREVLASTV, LASTV);
                     else PREVLASTV := LASTV;
                  end if;
               end if;
               T (I, I) := TAU (I);
            end if;
         end loop;
      end if;
      return;
      --
      --     End of DLARFT
      --
   end DLARFT;

   procedure DLARFX
     (SIDE     : Character;
      M        : Integer;
      N        : Integer;
      V_adr    : Address;
      TAU      : Real;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address)
   is

      V    : Ftn_Real_Vector (1 .. max (M, N));
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (M, N));

      for V'Address use V_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, V);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      ZERO : constant Real := 0.0e0;
      ONE  : constant Real := 1.0e0;
      J    : Integer;
      SUM  : Real;
      T1   : Real;
      T10  : Real;
      T2   : Real;
      T3   : Real;
      T4   : Real;
      T5   : Real;
      T6   : Real;
      T7   : Real;
      T8   : Real;
      T9   : Real;
      V1   : Real;
      V10  : Real;
      V2   : Real;
      V3   : Real;
      V4   : Real;
      V5   : Real;
      V6   : Real;
      V7   : Real;
      V8   : Real;
      V9   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLARFX( SIDE, M, N, V, TAU, C, LDC, WORK)
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE
   --       INTEGER            LDC, M, N
   --       DOUBLE PRECISION   TAU
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   C( LDC, * ), V( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLARFX applies a real elementary reflector H to a real m by n
   --  matrix C, from either the left or the right. H is represented in the
   --  form
   --
   --        H = I - tau * v * v**T
   --
   --  where tau is a real scalar and v is a real vector.
   --
   --  If tau = 0, then H is taken to be the unit matrix
   --
   --  This version uses inline code if H has order < 11.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': form  H * C
   --           = 'R': form  C * H
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C.
   --
   --  [in] V
   --           V is DOUBLE PRECISION array, dimension (M) if SIDE = 'L'
   --                                      or (N) if SIDE = 'R'
   --           The vector v in the representation of H.
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION
   --           The value tau in the representation of H.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the m by n matrix C.
   --           On exit, C is overwritten by the matrix H * C if SIDE = 'L',
   --           or C * H if SIDE = 'R'.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDA >= (1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension
   --                       (N) if SIDE = 'L'
   --                       or (M) if SIDE = 'R'
   --           WORK is not referenced if H has order < 11.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if TAU = ZERO then
         return;
      end if;
      if LSAME (SIDE, 'L') then
         --
         --        Form  H * C, where H has order m.
         --
         --         GO TO ( 10, 30, 50, 70, 90, 110, 130, 150,
         --     $           170, 190 )M
         if M = 1 then
            goto L10;
         elsif M = 2 then
            goto L30;
         elsif M = 3 then
            goto L50;
         elsif M = 4 then
            goto L70;
         elsif M = 5 then
            goto L90;
         elsif M = 6 then
            goto L110;
         elsif M = 7 then
            goto L130;
         elsif M = 8 then
            goto L150;
         elsif M = 9 then
            goto L170;
         elsif M = 10 then
            goto L190;
         end if;
         --
         --        Code for general M
         --
         DLARF (SIDE, M, N, V'Address, 1, TAU, C'Address, LDC, WORK'Address);
         goto L410;
         <<L10>> null;
         --
         --        Special code for 1 x 1 Householder
         --
         T1 := ONE - TAU * V (1) * V (1);
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            C (1, J) := T1 * C (1, J);
         end loop;
         goto L410;
         <<L30>> null;
         --
         --        Special code for 2 x 2 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM      := V1 * C (1, J) + V2 * C (2, J);
            C (1, J) := C (1, J) - SUM * T1;
            C (2, J) := C (2, J) - SUM * T2;
         end loop;
         goto L410;
         <<L50>> null;
         --
         --        Special code for 3 x 3 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM      := V1 * C (1, J) + V2 * C (2, J) + V3 * C (3, J);
            C (1, J) := C (1, J) - SUM * T1;
            C (2, J) := C (2, J) - SUM * T2;
            C (3, J) := C (3, J) - SUM * T3;
         end loop;
         goto L410;
         <<L70>> null;
         --
         --        Special code for 4 x 4 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM      := V1 * C (1, J) + V2 * C (2, J) + V3 * C (3, J) + V4 * C (4, J);
            C (1, J) := C (1, J) - SUM * T1;
            C (2, J) := C (2, J) - SUM * T2;
            C (3, J) := C (3, J) - SUM * T3;
            C (4, J) := C (4, J) - SUM * T4;
         end loop;
         goto L410;
         <<L90>> null;
         --
         --        Special code for 5 x 5 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM      := V1 * C (1, J) + V2 * C (2, J) + V3 * C (3, J) + V4 * C (4, J) + V5 * C (5, J);
            C (1, J) := C (1, J) - SUM * T1;
            C (2, J) := C (2, J) - SUM * T2;
            C (3, J) := C (3, J) - SUM * T3;
            C (4, J) := C (4, J) - SUM * T4;
            C (5, J) := C (5, J) - SUM * T5;
         end loop;
         goto L410;
         <<L110>> null;
         --
         --        Special code for 6 x 6 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         V6 := V (6);
         T6 := TAU * V6;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM      := V1 * C (1, J) + V2 * C (2, J) + V3 * C (3, J) + V4 * C (4, J) + V5 * C (5, J) + V6 * C (6, J);
            C (1, J) := C (1, J) - SUM * T1;
            C (2, J) := C (2, J) - SUM * T2;
            C (3, J) := C (3, J) - SUM * T3;
            C (4, J) := C (4, J) - SUM * T4;
            C (5, J) := C (5, J) - SUM * T5;
            C (6, J) := C (6, J) - SUM * T6;
         end loop;
         goto L410;
         <<L130>> null;
         --
         --        Special code for 7 x 7 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         V6 := V (6);
         T6 := TAU * V6;
         V7 := V (7);
         T7 := TAU * V7;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM      := V1 * C (1, J) +
                        V2 * C (2, J) +
                        V3 * C (3, J) +
                        V4 * C (4, J) +
                        V5 * C (5, J) +
                        V6 * C (6, J) +
                        V7 * C (7, J);
            C (1, J) := C (1, J) - SUM * T1;
            C (2, J) := C (2, J) - SUM * T2;
            C (3, J) := C (3, J) - SUM * T3;
            C (4, J) := C (4, J) - SUM * T4;
            C (5, J) := C (5, J) - SUM * T5;
            C (6, J) := C (6, J) - SUM * T6;
            C (7, J) := C (7, J) - SUM * T7;
         end loop;
         goto L410;
         <<L150>> null;
         --
         --        Special code for 8 x 8 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         V6 := V (6);
         T6 := TAU * V6;
         V7 := V (7);
         T7 := TAU * V7;
         V8 := V (8);
         T8 := TAU * V8;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM      := V1 * C (1, J) +
                        V2 * C (2, J) +
                        V3 * C (3, J) +
                        V4 * C (4, J) +
                        V5 * C (5, J) +
                        V6 * C (6, J) +
                        V7 * C (7, J) +
                        V8 * C (8, J);
            C (1, J) := C (1, J) - SUM * T1;
            C (2, J) := C (2, J) - SUM * T2;
            C (3, J) := C (3, J) - SUM * T3;
            C (4, J) := C (4, J) - SUM * T4;
            C (5, J) := C (5, J) - SUM * T5;
            C (6, J) := C (6, J) - SUM * T6;
            C (7, J) := C (7, J) - SUM * T7;
            C (8, J) := C (8, J) - SUM * T8;
         end loop;
         goto L410;
         <<L170>> null;
         --
         --        Special code for 9 x 9 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         V6 := V (6);
         T6 := TAU * V6;
         V7 := V (7);
         T7 := TAU * V7;
         V8 := V (8);
         T8 := TAU * V8;
         V9 := V (9);
         T9 := TAU * V9;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM      := V1 * C (1, J) +
                        V2 * C (2, J) +
                        V3 * C (3, J) +
                        V4 * C (4, J) +
                        V5 * C (5, J) +
                        V6 * C (6, J) +
                        V7 * C (7, J) +
                        V8 * C (8, J) +
                        V9 * C (9, J);
            C (1, J) := C (1, J) - SUM * T1;
            C (2, J) := C (2, J) - SUM * T2;
            C (3, J) := C (3, J) - SUM * T3;
            C (4, J) := C (4, J) - SUM * T4;
            C (5, J) := C (5, J) - SUM * T5;
            C (6, J) := C (6, J) - SUM * T6;
            C (7, J) := C (7, J) - SUM * T7;
            C (8, J) := C (8, J) - SUM * T8;
            C (9, J) := C (9, J) - SUM * T9;
         end loop;
         goto L410;
         <<L190>> null;
         --
         --        Special code for 10 x 10 Householder
         --
         V1  := V (1);
         T1  := TAU * V1;
         V2  := V (2);
         T2  := TAU * V2;
         V3  := V (3);
         T3  := TAU * V3;
         V4  := V (4);
         T4  := TAU * V4;
         V5  := V (5);
         T5  := TAU * V5;
         V6  := V (6);
         T6  := TAU * V6;
         V7  := V (7);
         T7  := TAU * V7;
         V8  := V (8);
         T8  := TAU * V8;
         V9  := V (9);
         T9  := TAU * V9;
         V10 := V (10);
         T10 := TAU * V10;
         J   := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM       := V1 * C (1, J) +
                         V2 * C (2, J) +
                         V3 * C (3, J) +
                         V4 * C (4, J) +
                         V5 * C (5, J) +
                         V6 * C (6, J) +
                         V7 * C (7, J) +
                         V8 * C (8, J) +
                         V9 * C (9, J) +
                         V10 * C (10, J);
            C (1, J)  := C (1, J) - SUM * T1;
            C (2, J)  := C (2, J) - SUM * T2;
            C (3, J)  := C (3, J) - SUM * T3;
            C (4, J)  := C (4, J) - SUM * T4;
            C (5, J)  := C (5, J) - SUM * T5;
            C (6, J)  := C (6, J) - SUM * T6;
            C (7, J)  := C (7, J) - SUM * T7;
            C (8, J)  := C (8, J) - SUM * T8;
            C (9, J)  := C (9, J) - SUM * T9;
            C (10, J) := C (10, J) - SUM * T10;
         end loop;
         goto L410;
      else
         --
         --        Form  C * H, where H has order n.
         --
         --         GO TO ( 210, 230, 250, 270, 290, 310, 330, 350,
         --     $           370, 390 )N
         if N = 1 then
            goto L210;
         elsif N = 2 then
            goto L230;
         elsif N = 3 then
            goto L250;
         elsif N = 4 then
            goto L270;
         elsif N = 5 then
            goto L290;
         elsif N = 6 then
            goto L310;
         elsif N = 7 then
            goto L330;
         elsif N = 8 then
            goto L350;
         elsif N = 9 then
            goto L370;
         elsif N = 10 then
            goto L390;
         end if;
         --
         --        Code for general N
         --
         DLARF (SIDE, M, N, V'Address, 1, TAU, C'Address, LDC, WORK'Address);
         goto L410;
         <<L210>> null;
         --
         --        Special code for 1 x 1 Householder
         --
         T1 := ONE - TAU * V (1) * V (1);
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            C (J, 1) := T1 * C (J, 1);
         end loop;
         goto L410;
         <<L230>> null;
         --
         --        Special code for 2 x 2 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM      := V1 * C (J, 1) + V2 * C (J, 2);
            C (J, 1) := C (J, 1) - SUM * T1;
            C (J, 2) := C (J, 2) - SUM * T2;
         end loop;
         goto L410;
         <<L250>> null;
         --
         --        Special code for 3 x 3 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM      := V1 * C (J, 1) + V2 * C (J, 2) + V3 * C (J, 3);
            C (J, 1) := C (J, 1) - SUM * T1;
            C (J, 2) := C (J, 2) - SUM * T2;
            C (J, 3) := C (J, 3) - SUM * T3;
         end loop;
         goto L410;
         <<L270>> null;
         --
         --        Special code for 4 x 4 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM      := V1 * C (J, 1) + V2 * C (J, 2) + V3 * C (J, 3) + V4 * C (J, 4);
            C (J, 1) := C (J, 1) - SUM * T1;
            C (J, 2) := C (J, 2) - SUM * T2;
            C (J, 3) := C (J, 3) - SUM * T3;
            C (J, 4) := C (J, 4) - SUM * T4;
         end loop;
         goto L410;
         <<L290>> null;
         --
         --        Special code for 5 x 5 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM      := V1 * C (J, 1) + V2 * C (J, 2) + V3 * C (J, 3) + V4 * C (J, 4) + V5 * C (J, 5);
            C (J, 1) := C (J, 1) - SUM * T1;
            C (J, 2) := C (J, 2) - SUM * T2;
            C (J, 3) := C (J, 3) - SUM * T3;
            C (J, 4) := C (J, 4) - SUM * T4;
            C (J, 5) := C (J, 5) - SUM * T5;
         end loop;
         goto L410;
         <<L310>> null;
         --
         --        Special code for 6 x 6 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         V6 := V (6);
         T6 := TAU * V6;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM      := V1 * C (J, 1) + V2 * C (J, 2) + V3 * C (J, 3) + V4 * C (J, 4) + V5 * C (J, 5) + V6 * C (J, 6);
            C (J, 1) := C (J, 1) - SUM * T1;
            C (J, 2) := C (J, 2) - SUM * T2;
            C (J, 3) := C (J, 3) - SUM * T3;
            C (J, 4) := C (J, 4) - SUM * T4;
            C (J, 5) := C (J, 5) - SUM * T5;
            C (J, 6) := C (J, 6) - SUM * T6;
         end loop;
         goto L410;
         <<L330>> null;
         --
         --        Special code for 7 x 7 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         V6 := V (6);
         T6 := TAU * V6;
         V7 := V (7);
         T7 := TAU * V7;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM      := V1 * C (J, 1) +
                        V2 * C (J, 2) +
                        V3 * C (J, 3) +
                        V4 * C (J, 4) +
                        V5 * C (J, 5) +
                        V6 * C (J, 6) +
                        V7 * C (J, 7);
            C (J, 1) := C (J, 1) - SUM * T1;
            C (J, 2) := C (J, 2) - SUM * T2;
            C (J, 3) := C (J, 3) - SUM * T3;
            C (J, 4) := C (J, 4) - SUM * T4;
            C (J, 5) := C (J, 5) - SUM * T5;
            C (J, 6) := C (J, 6) - SUM * T6;
            C (J, 7) := C (J, 7) - SUM * T7;
         end loop;
         goto L410;
         <<L350>> null;
         --
         --        Special code for 8 x 8 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         V6 := V (6);
         T6 := TAU * V6;
         V7 := V (7);
         T7 := TAU * V7;
         V8 := V (8);
         T8 := TAU * V8;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM      := V1 * C (J, 1) +
                        V2 * C (J, 2) +
                        V3 * C (J, 3) +
                        V4 * C (J, 4) +
                        V5 * C (J, 5) +
                        V6 * C (J, 6) +
                        V7 * C (J, 7) +
                        V8 * C (J, 8);
            C (J, 1) := C (J, 1) - SUM * T1;
            C (J, 2) := C (J, 2) - SUM * T2;
            C (J, 3) := C (J, 3) - SUM * T3;
            C (J, 4) := C (J, 4) - SUM * T4;
            C (J, 5) := C (J, 5) - SUM * T5;
            C (J, 6) := C (J, 6) - SUM * T6;
            C (J, 7) := C (J, 7) - SUM * T7;
            C (J, 8) := C (J, 8) - SUM * T8;
         end loop;
         goto L410;
         <<L370>> null;
         --
         --        Special code for 9 x 9 Householder
         --
         V1 := V (1);
         T1 := TAU * V1;
         V2 := V (2);
         T2 := TAU * V2;
         V3 := V (3);
         T3 := TAU * V3;
         V4 := V (4);
         T4 := TAU * V4;
         V5 := V (5);
         T5 := TAU * V5;
         V6 := V (6);
         T6 := TAU * V6;
         V7 := V (7);
         T7 := TAU * V7;
         V8 := V (8);
         T8 := TAU * V8;
         V9 := V (9);
         T9 := TAU * V9;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM      := V1 * C (J, 1) +
                        V2 * C (J, 2) +
                        V3 * C (J, 3) +
                        V4 * C (J, 4) +
                        V5 * C (J, 5) +
                        V6 * C (J, 6) +
                        V7 * C (J, 7) +
                        V8 * C (J, 8) +
                        V9 * C (J, 9);
            C (J, 1) := C (J, 1) - SUM * T1;
            C (J, 2) := C (J, 2) - SUM * T2;
            C (J, 3) := C (J, 3) - SUM * T3;
            C (J, 4) := C (J, 4) - SUM * T4;
            C (J, 5) := C (J, 5) - SUM * T5;
            C (J, 6) := C (J, 6) - SUM * T6;
            C (J, 7) := C (J, 7) - SUM * T7;
            C (J, 8) := C (J, 8) - SUM * T8;
            C (J, 9) := C (J, 9) - SUM * T9;
         end loop;
         goto L410;
         <<L390>> null;
         --
         --        Special code for 10 x 10 Householder
         --
         V1  := V (1);
         T1  := TAU * V1;
         V2  := V (2);
         T2  := TAU * V2;
         V3  := V (3);
         T3  := TAU * V3;
         V4  := V (4);
         T4  := TAU * V4;
         V5  := V (5);
         T5  := TAU * V5;
         V6  := V (6);
         T6  := TAU * V6;
         V7  := V (7);
         T7  := TAU * V7;
         V8  := V (8);
         T8  := TAU * V8;
         V9  := V (9);
         T9  := TAU * V9;
         V10 := V (10);
         T10 := TAU * V10;
         J   := 1 - 1;
         loop
            J := J + 1;
            exit when J > M;
            SUM       := V1 * C (J, 1) +
                         V2 * C (J, 2) +
                         V3 * C (J, 3) +
                         V4 * C (J, 4) +
                         V5 * C (J, 5) +
                         V6 * C (J, 6) +
                         V7 * C (J, 7) +
                         V8 * C (J, 8) +
                         V9 * C (J, 9) +
                         V10 * C (J, 10);
            C (J, 1)  := C (J, 1) - SUM * T1;
            C (J, 2)  := C (J, 2) - SUM * T2;
            C (J, 3)  := C (J, 3) - SUM * T3;
            C (J, 4)  := C (J, 4) - SUM * T4;
            C (J, 5)  := C (J, 5) - SUM * T5;
            C (J, 6)  := C (J, 6) - SUM * T6;
            C (J, 7)  := C (J, 7) - SUM * T7;
            C (J, 8)  := C (J, 8) - SUM * T8;
            C (J, 9)  := C (J, 9) - SUM * T9;
            C (J, 10) := C (J, 10) - SUM * T10;
         end loop;
         goto L410;
      end if;
      <<L410>> null;
      return;
      --
      --     End of DLARFX
      --
   end DLARFX;

   procedure DLARTG
     (F  : Real;
      G  : Real;
      CS : in out Real;
      SN : in out Real;
      R  : in out Real)
   is
      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      COUNT  : Integer;
      I      : Integer;
      EPS    : Real;
      F1     : Real;
      G1     : Real;
      SAFMIN : Real;
      SAFMN2 : Real;
      SAFMX2 : Real;
      SCALE  : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLARTG( F, G, CS, SN, R )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   CS, F, G, R, SN
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLARTG generate a plane rotation so that
   --
   --     [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
   --     [ -SN  CS  ]     [ G ]     [ 0 ]
   --
   --  This is a slower, more accurate version of the BLAS1 routine DROTG,
   --  with the following other differences:
   --     F and G are unchanged on return.
   --     If G=0, then CS=1 and SN=0.
   --     If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
   --        floating point operations (saves work in DBDSQR when
   --        there are zeros on the diagonal).
   --
   --  If F exceeds G in magnitude, CS will be positive.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] F
   --           F is DOUBLE PRECISION
   --           The first component of vector to be rotated.
   --
   --  [in] G
   --           G is DOUBLE PRECISION
   --           The second component of vector to be rotated.
   --
   --  [out] CS
   --           CS is DOUBLE PRECISION
   --           The cosine of the rotation.
   --
   --  [out] SN
   --           SN is DOUBLE PRECISION
   --           The sine of the rotation.
   --
   --  [out] R
   --           R is DOUBLE PRECISION
   --           The nonzero component of the rotated vector.
   --
   --   This version has a few statements commented out for thread safety
   --   (machine parameters are computed on each entry). 10 feb 03, SJH.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --      PARAMETER          ( ONE = 1.0D0 )
   --      PARAMETER          ( TWO = 2.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     LOGICAL            FIRST
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, INT, LOG, MAX, SQRT
   --     ..
   --     .. Save statement ..
   --     SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
   --     ..
   --     .. Data statements ..
   --     DATA               FIRST / .TRUE. /
   --     ..
   --     .. Executable Statements ..
   --
   --     IF( FIRST ) THEN
   begin
      SAFMIN := DLAMCH ('S');
      EPS    := DLAMCH ('E');
      SAFMN2 := DLAMCH ('B') ** int (Log (SAFMIN / EPS) / Log (DLAMCH ('B')) / TWO);
      SAFMX2 := ONE / SAFMN2;
      --        FIRST = .FALSE.
      --     END IF
      if G = ZERO then
         CS := ONE;
         SN := ZERO;
         R  := F;
      elsif F = ZERO then
         CS := ZERO;
         SN := ONE;
         R  := G;
      else
         F1    := F;
         G1    := G;
         SCALE := max (abs (F1), abs (G1));
         if SCALE >= SAFMX2 then
            COUNT := 0;
            <<L10>> null;
            COUNT := COUNT + 1;
            F1    := F1 * SAFMN2;
            G1    := G1 * SAFMN2;
            SCALE := max (abs (F1), abs (G1));
            if SCALE >= SAFMX2 then
               goto L10;
            end if;
            R  := Sqrt (F1 ** 2 + G1 ** 2);
            CS := F1 / R;
            SN := G1 / R;
            I  := 1 - 1;
            loop
               I := I + 1;
               exit when I > COUNT;
               R := R * SAFMX2;
            end loop;
         elsif SCALE <= SAFMN2 then
            COUNT := 0;
            <<L30>> null;
            COUNT := COUNT + 1;
            F1    := F1 * SAFMX2;
            G1    := G1 * SAFMX2;
            SCALE := max (abs (F1), abs (G1));
            if SCALE <= SAFMN2 then
               goto L30;
            end if;
            R  := Sqrt (F1 ** 2 + G1 ** 2);
            CS := F1 / R;
            SN := G1 / R;
            I  := 1 - 1;
            loop
               I := I + 1;
               exit when I > COUNT;
               R := R * SAFMN2;
            end loop;
         else
            R  := Sqrt (F1 ** 2 + G1 ** 2);
            CS := F1 / R;
            SN := G1 / R;
         end if;
         if abs (F) > abs (G) and CS < ZERO then
            CS := -CS;
            SN := -SN;
            R  := -R;
         end if;
      end if;
      return;
      --
      --     End of DLARTG
      --
   end DLARTG;

   procedure DLAS2
     (F     : Real;
      G     : Real;
      H     : Real;
      SSMIN : in out Real;
      SSMAX : in out Real)
   is
      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      AS     : Real;
      Ftn_AT : Real;
      AU     : Real;
      C      : Real;
      FA     : Real;
      FHMN   : Real;
      FHMX   : Real;
      GA     : Real;
      HA     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLAS2( F, G, H, SSMIN, SSMAX )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   F, G, H, SSMAX, SSMIN
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLAS2  computes the singular values of the 2-by-2 matrix
   --     [  F   G  ]
   --     [  0   H  ].
   --  On return, SSMIN is the smaller singular value and SSMAX is the
   --  larger singular value.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] F
   --           F is DOUBLE PRECISION
   --           The (1,1) element of the 2-by-2 matrix.
   --
   --  [in] G
   --           G is DOUBLE PRECISION
   --           The (1,2) element of the 2-by-2 matrix.
   --
   --  [in] H
   --           H is DOUBLE PRECISION
   --           The (2,2) element of the 2-by-2 matrix.
   --
   --  [out] SSMIN
   --           SSMIN is DOUBLE PRECISION
   --           The smaller singular value.
   --
   --  [out] SSMAX
   --           SSMAX is DOUBLE PRECISION
   --           The larger singular value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Barring over/underflow, all output quantities are correct to within
   --   a few units in the last place (ulps), even in the absence of a guard
   --   digit in addition/subtraction.
   --
   --   In IEEE arithmetic, the code works correctly if one matrix element is
   --   infinite.
   --
   --   Overflow will not occur unless the largest singular value itself
   --   overflows, or is within a few ulps of overflow. (On machines with
   --   partial overflow, like the Cray, overflow may occur if the largest
   --   singular value is within a factor of 2 of overflow.)
   --
   --   Underflow is harmless if underflow is gradual. Otherwise, results
   --   may correspond to a matrix modified by perturbations of size near
   --   the underflow threshold.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  ====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --      PARAMETER          ( ONE = 1.0D0 )
   --      PARAMETER          ( TWO = 2.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      FA   := abs (F);
      GA   := abs (G);
      HA   := abs (H);
      FHMN := min (FA, HA);
      FHMX := max (FA, HA);
      if FHMN = ZERO then
         SSMIN := ZERO;
         if FHMX = ZERO 
            then SSMAX := GA;
            else SSMAX := max (FHMX, GA) * Sqrt (ONE + (min (FHMX, GA) / max (FHMX, GA)) ** 2);
         end if;
      else
         if GA < FHMX then
            AS     := ONE + FHMN / FHMX;
            Ftn_AT := (FHMX - FHMN) / FHMX;
            AU     := (GA / FHMX) ** 2;
            C      := TWO / (Sqrt (AS * AS + AU) + Sqrt (Ftn_AT * Ftn_AT + AU));
            SSMIN  := FHMN * C;
            SSMAX  := FHMX / C;
         else
            AU := FHMX / GA;
            if AU = ZERO then
               --
               --              Avoid possible harmful underflow if exponent range
               --              asymmetric (true SSMIN may not underflow even if
               --              AU underflows)
               --
               SSMIN := (FHMN * FHMX) / GA;
               SSMAX := GA;
            else
               AS     := ONE + FHMN / FHMX;
               Ftn_AT := (FHMX - FHMN) / FHMX;
               C      := ONE / (Sqrt (ONE + (AS * AU) ** 2) + Sqrt (ONE + (Ftn_AT * AU) ** 2));
               SSMIN  := (FHMN * C) * AU;
               SSMIN  := SSMIN + SSMIN;
               SSMAX  := GA / (C + C);
            end if;
         end if;
      end if;
      return;
      --
      --     End of DLAS2
      --
   end DLAS2;

   procedure DLASCL
     (the_TYPE : Character;
      KL       : Integer;
      KU       : Integer;
      CFROM    : Real;
      CTO      : Real;
      M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      INFO     : in out Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);

      for A'Address use A_adr;

      pragma Import (Ada, A);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      DONE   : Boolean;
      I      : Integer;
      ITYPE  : Integer;
      J      : Integer;
      K1     : Integer;
      K2     : Integer;
      K3     : Integer;
      K4     : Integer;
      BIGNUM : Real;
      CFROM1 : Real;
      CFROMC : Real;
      CTO1   : Real;
      CTOC   : Real;
      MUL    : Real;
      SMLNUM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          TYPE
   --       INTEGER            INFO, KL, KU, LDA, M, N
   --       DOUBLE PRECISION   CFROM, CTO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASCL multiplies the M by N real matrix A by the real scalar
   --  CTO/CFROM.  This is done without over/underflow as long as the final
   --  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
   --  A may be full, upper triangular, lower triangular, upper Hessenberg,
   --  or banded.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] TYPE
   --           TYPE is CHARACTER*1
   --           TYPE indices the storage type of the input matrix.
   --           = 'G':  A is a full matrix.
   --           = 'L':  A is a lower triangular matrix.
   --           = 'U':  A is an upper triangular matrix.
   --           = 'H':  A is an upper Hessenberg matrix.
   --           = 'B':  A is a symmetric band matrix with lower bandwidth KL
   --                   and upper bandwidth KU and with the only the lower
   --                   half stored.
   --           = 'Q':  A is a symmetric band matrix with lower bandwidth KL
   --                   and upper bandwidth KU and with the only the upper
   --                   half stored.
   --           = 'Z':  A is a band matrix with lower bandwidth KL and upper
   --                   bandwidth KU. See DGBTRF for storage details.
   --
   --  [in] KL
   --           KL is INTEGER
   --           The lower bandwidth of A.  Referenced only if TYPE = 'B',
   --           'Q' or 'Z'.
   --
   --  [in] KU
   --           KU is INTEGER
   --           The upper bandwidth of A.  Referenced only if TYPE = 'B',
   --           'Q' or 'Z'.
   --
   --  [in] CFROM
   --           CFROM is DOUBLE PRECISION
   --
   --  [in] CTO
   --           CTO is DOUBLE PRECISION
   --
   --           The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
   --           without over/underflow if the final result CTO*A(I,J)/CFROM
   --           can be represented without over/underflow.  CFROM must be
   --           nonzero.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The matrix to be multiplied by CTO/CFROM.  See TYPE for the
   --           storage type.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           0  - successful exit
   --           <0 - if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME, DISNAN
   --      DOUBLE PRECISION   DLAMCH
   --      EXTERNAL           LSAME, DLAMCH, DISNAN
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      --
      if LSAME (the_TYPE, 'G') then
         ITYPE := 0;
      elsif LSAME (the_TYPE, 'L') then
         ITYPE := 1;
      elsif LSAME (the_TYPE, 'U') then
         ITYPE := 2;
      elsif LSAME (the_TYPE, 'H') then
         ITYPE := 3;
      elsif LSAME (the_TYPE, 'B') then
         ITYPE := 4;
      elsif LSAME (the_TYPE, 'Q') then
         ITYPE := 5;
      elsif LSAME (the_TYPE, 'Z') then
         ITYPE := 6;
      else
         ITYPE := -1;
      end if;
      --
      if ITYPE = -1 then
         INFO := -1;
      elsif CFROM = ZERO or DISNAN (CFROM) then
         INFO := -4;
      elsif DISNAN (CTO) then
         INFO := -5;
      elsif M < 0 then
         INFO := -6;
      elsif N < 0 or (ITYPE = 4 and N /= M) or (ITYPE = 5 and N /= M) then
         INFO := -7;
      elsif ITYPE <= 3 and LDA < max (1, M) then
         INFO := -9;
      elsif ITYPE >= 4 then
         if KL < 0 or KL > max (M - 1, 0) then
            INFO := -2;
         elsif KU < 0 or KU > max (N - 1, 0) or ((ITYPE = 4 or ITYPE = 5) and KL /= KU) then
            INFO := -3;
         elsif (ITYPE = 4 and LDA < KL + 1) or (ITYPE = 5 and LDA < KU + 1) or (ITYPE = 6 and LDA < 2 * KL + KU + 1) then
            INFO := -9;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DLASCL", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 or M = 0 then
         return;
      end if;
      --
      --     Get machine parameters
      --
      SMLNUM := DLAMCH ('S');
      BIGNUM := ONE / SMLNUM;
      --
      CFROMC := CFROM;
      CTOC   := CTO;
      --
      <<L10>> null;
      CFROM1 := CFROMC * SMLNUM;
      if CFROM1 = CFROMC then
         --        CFROMC is an inf.  Multiply by a correctly signed zero for
         --        finite CTOC, or a NaN if CTOC is infinite.
         MUL  := CTOC / CFROMC;
         DONE := True;
         CTO1 := CTOC;
      else
         CTO1 := CTOC / BIGNUM;
         if CTO1 = CTOC then
            --           CTOC is either 0 or an inf.  In both cases, CTOC itself
            --           serves as the correct multiplication factor.
            MUL    := CTOC;
            DONE   := True;
            CFROMC := ONE;
         elsif abs (CFROM1) > abs (CTOC) and CTOC /= ZERO then
            MUL    := SMLNUM;
            DONE   := False;
            CFROMC := CFROM1;
         elsif abs (CTO1) > abs (CFROMC) then
            MUL  := BIGNUM;
            DONE := False;
            CTOC := CTO1;
         else
            MUL  := CTOC / CFROMC;
            DONE := True;
         end if;
      end if;
      --
      if ITYPE = 0 then
         --
         --        Full matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 1 then
         --
         --        Lower triangular matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := J - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 2 then
         --
         --        Upper triangular matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J, M);
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 3 then
         --
         --        Upper Hessenberg matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J + 1, M);
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 4 then
         --
         --        Lower half of a symmetric band matrix
         --
         K3 := KL + 1;
         K4 := N + 1;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (K3, K4 - J);
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 5 then
         --
         --        Upper half of a symmetric band matrix
         --
         K1 := KU + 2;
         K3 := KU + 1;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := max (K1 - J, 1) - 1;
            loop
               I := I + 1;
               exit when I > K3;
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 6 then
         --
         --        Band matrix
         --
         K1 := KL + KU + 2;
         K2 := KL + 1;
         K3 := 2 * KL + KU + 1;
         K4 := KL + KU + 1 + M;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := max (K1 - J, K2) - 1;
            loop
               I := I + 1;
               exit when I > min (K3, K4 - J);
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
         --
      end if;
      --
      if not DONE then
         goto L10;
      end if;
      --
      return;
      --
      --     End of DLASCL
      --
   end DLASCL;

   procedure DLASD0
     (N         : Integer;
      SQRE      : Integer;
      D_adr     : Address;
      E_adr     : Address;
      U_adr     : Address;
      LDU       : Integer;
      VT_adr    : Address;
      LDVT      : Integer;
      SMLSIZ    : Integer;
      IWORK_adr : Address;
      WORK_adr  : Address;
      INFO      : in out Integer)
   is

      the_M : constant Integer := max (N, N + 1);

      D     : Ftn_Real_Vector (1 .. N);
      E     : Ftn_Real_Vector (1 .. the_M - 1);
      U     : Ftn_Real_Matrix (1 .. LDU, 1 .. N); -- doc. says LDQ
      VT    : Ftn_Real_Matrix (1 .. LDVT, 1 .. the_M);
      IWORK : Ftn_Integer_Vector (1 .. 8 * N);
      WORK  : Ftn_Real_Vector (1 .. 3 * the_M * the_M + 2 * the_M);

      for D'Address use D_adr;
      for E'Address use E_adr;
      for U'Address use U_adr;
      for VT'Address use VT_adr;
      for IWORK'Address use IWORK_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, U);
      pragma Import (Ada, VT);
      pragma Import (Ada, IWORK);
      pragma Import (Ada, WORK);

      I     : Integer;
      I1    : Integer;
      IC    : Integer;
      IDXQ  : Integer;
      IDXQC : Integer;
      IM1   : Integer;
      INODE : Integer;
      ITEMP : Integer;
      IWK   : Integer;
      J     : Integer;
      LF    : Integer;
      LL    : Integer;
      LVL   : Integer;
      M     : Integer;
      NCC   : Integer;
      ND    : Integer;
      NDB1  : Integer;
      NDIML : Integer;
      NDIMR : Integer;
      NL    : Integer;
      NLF   : Integer;
      NLP1  : Integer;
      NLVL  : Integer;
      NR    : Integer;
      NRF   : Integer;
      NRP1  : Integer;
      SQREI : Integer;
      ALPHA : Real;
      BETA  : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD0( N, SQRE, D, E, U, LDU, VT, LDVT, SMLSIZ, IWORK,
   --                          WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDU, LDVT, N, SMLSIZ, SQRE
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   D( * ), E( * ), U( LDU, * ), VT( LDVT, * ),
   --      $                   WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  Using a divide and conquer approach, DLASD0 computes the singular
   --  value decomposition (SVD) of a real upper bidiagonal N-by-M
   --  matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
   --  The algorithm computes orthogonal matrices U and VT such that
   --  B = U * S * VT. The singular values S are overwritten on D.
   --
   --  A related subroutine, DLASDA, computes only the singular values,
   --  and optionally, the singular vectors in compact form.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --          On entry, the row dimension of the upper bidiagonal matrix.
   --          This is also the dimension of the main diagonal array D.
   --
   --  [in] SQRE
   --           SQRE is INTEGER
   --          Specifies the column dimension of the bidiagonal matrix.
   --          = 0: The bidiagonal matrix has column dimension M = N;
   --          = 1: The bidiagonal matrix has column dimension M = N+1;
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry D contains the main diagonal of the bidiagonal
   --          matrix.
   --          On exit D, if INFO = 0, contains its singular values.
   --
   --  [in] E
   --           E is DOUBLE PRECISION array, dimension (M-1)
   --          Contains the subdiagonal entries of the bidiagonal matrix.
   --          On exit, E has been destroyed.
   --
   --  [out] U
   --           U is DOUBLE PRECISION array, dimension at least (LDQ, N)
   --          On exit, U contains the left singular vectors.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --          On entry, leading dimension of U.
   --
   --  [out] VT
   --           VT is DOUBLE PRECISION array, dimension at least (LDVT, M)
   --          On exit, VT**T contains the right singular vectors.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --          On entry, leading dimension of VT.
   --
   --  [in] SMLSIZ
   --           SMLSIZ is INTEGER
   --          On entry, maximum size of the subproblems at the
   --          bottom of the computation tree.
   --
   --  [out] IWORK
   --           IWORK is INTEGER work array.
   --          Dimension must be at least (8 * N)
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION work array.
   --          Dimension must be at least (3 * M**2 + 2 * M)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, a singular value did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASD1, DLASDQ, DLASDT, XERBLA
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if N < 0 then
         INFO := -1;
      elsif (SQRE < 0) or (SQRE > 1) then
         INFO := -2;
      end if;
      --
      M := N + SQRE;
      --
      if LDU < N then
         INFO := -6;
      elsif LDVT < M then
         INFO := -8;
      elsif SMLSIZ < 3 then
         INFO := -9;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASD0", -INFO);
         return;
      end if;
      --
      --     If the input matrix is too small, call DLASDQ to find the SVD.
      --
      if N <= SMLSIZ then
         DLASDQ
           ('U',
            SQRE,
            N,
            M,
            N,
            0,
            D'Address,
            E'Address,
            VT'Address,
            LDVT,
            U'Address,
            LDU,
            U'Address,
            LDU,
            WORK'Address,
            INFO);
         return;
      end if;
      --
      --     Set up the computation tree.
      --
      INODE := 1;
      NDIML := INODE + N;
      NDIMR := NDIML + N;
      IDXQ  := NDIMR + N;
      IWK   := IDXQ + N;
      DLASDT (N, NLVL, ND, IWORK (INODE)'Address, IWORK (NDIML)'Address, IWORK (NDIMR)'Address, SMLSIZ);
      --
      --     For the nodes on bottom level of the tree, solve
      --     their subproblems by DLASDQ.
      --
      NDB1 := (ND + 1) / 2;
      NCC  := 0;
      I    := NDB1 - 1;
      loop
         I := I + 1;
         exit when I > ND;
         --
         --     IC : center row of each node
         --     NL : number of rows of left  subproblem
         --     NR : number of rows of right subproblem
         --     NLF: starting row of the left   subproblem
         --     NRF: starting row of the right  subproblem
         --
         I1    := I - 1;
         IC    := IWORK (INODE + I1);
         NL    := IWORK (NDIML + I1);
         NLP1  := NL + 1;
         NR    := IWORK (NDIMR + I1);
         NRP1  := NR + 1;
         NLF   := IC - NL;
         NRF   := IC + 1;
         SQREI := 1;
         DLASDQ
           ('U',
            SQREI,
            NL,
            NLP1,
            NL,
            NCC,
            D (NLF)'Address,
            E (NLF)'Address,
            VT (NLF, NLF)'Address,
            LDVT,
            U (NLF, NLF)'Address,
            LDU,
            U (NLF, NLF)'Address,
            LDU,
            WORK'Address,
            INFO);
         if INFO /= 0 then
            return;
         end if;
         ITEMP := IDXQ + NLF - 2;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > NL;
            IWORK (ITEMP + J) := J;
         end loop;
         if I = ND 
            then SQREI := SQRE;
            else SQREI := 1;
         end if;
         NRP1 := NR + SQREI;
         DLASDQ
           ('U',
            SQREI,
            NR,
            NRP1,
            NR,
            NCC,
            D (NRF)'Address,
            E (NRF)'Address,
            VT (NRF, NRF)'Address,
            LDVT,
            U (NRF, NRF)'Address,
            LDU,
            U (NRF, NRF)'Address,
            LDU,
            WORK'Address,
            INFO);
         if INFO /= 0 then
            return;
         end if;
         ITEMP := IDXQ + IC;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > NR;
            IWORK (ITEMP + J - 1) := J;
         end loop;
      end loop;
      --
      --     Now conquer each subproblem bottom-up.
      --
      LVL := NLVL + 1;
      loop
         LVL := LVL - 1;
         exit when LVL < 1;
         --
         --        Find the first node LF and last node LL on the
         --        current level LVL.
         --
         if LVL = 1 then
            LF := 1;
            LL := 1;
         else
            LF := 2 ** (LVL - 1);
            LL := 2 * LF - 1;
         end if;
         I := LF - 1;
         loop
            I := I + 1;
            exit when I > LL;
            IM1 := I - 1;
            IC  := IWORK (INODE + IM1);
            NL  := IWORK (NDIML + IM1);
            NR  := IWORK (NDIMR + IM1);
            NLF := IC - NL;
            if (SQRE = 0) and (I = LL) 
               then SQREI := SQRE;
               else SQREI := 1;
            end if;
            IDXQC := IDXQ + NLF - 1;
            ALPHA := D (IC);
            BETA  := E (IC);
            DLASD1
              (NL,
               NR,
               SQREI,
               D (NLF)'Address,
               ALPHA,
               BETA,
               U (NLF, NLF)'Address,
               LDU,
               VT (NLF, NLF)'Address,
               LDVT,
               IWORK (IDXQC)'Address,
               IWORK (IWK)'Address,
               WORK'Address,
               INFO);
            if INFO /= 0 then
               return;
            end if;
         end loop;
      end loop;
      --
      return;
      --
      --     End of DLASD0
      --
   end DLASD0;

   procedure DLASD1
     (NL        : Integer;
      NR        : Integer;
      SQRE      : Integer;
      D_adr     : Address;
      ALPHA     : in out Real;
      BETA      : in out Real;
      U_adr     : Address;
      LDU       : Integer;
      VT_adr    : Address;
      LDVT      : Integer;
      IDXQ_adr  : Address;
      IWORK_adr : Address;
      WORK_adr  : Address;
      INFO      : in out Integer)
   is

      the_N : constant Integer := NL + NR + 1;
      the_M : constant Integer := NL + NR + 1 + SQRE;

      D     : Ftn_Real_Vector (1 .. the_N);
      U     : Ftn_Real_Matrix (1 .. LDU, 1 .. the_N);
      VT    : Ftn_Real_Matrix (1 .. LDVT, 1 .. the_M);
      IDXQ  : Ftn_Integer_Vector (1 .. the_N);
      IWORK : Ftn_Integer_Vector (1 .. 4 * the_N);
      WORK  : Ftn_Real_Vector (1 .. 3 * the_M * the_M + 2 * the_M);

      for D'Address use D_adr;
      for U'Address use U_adr;
      for VT'Address use VT_adr;
      for IDXQ'Address use IDXQ_adr;
      for IWORK'Address use IWORK_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, U);
      pragma Import (Ada, VT);
      pragma Import (Ada, IDXQ);
      pragma Import (Ada, IWORK);
      pragma Import (Ada, WORK);

      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
      COLTYP : Integer;
      I      : Integer;
      IDX    : Integer;
      IDXC   : Integer;
      IDXP   : Integer;
      IQ     : Integer;
      ISIGMA : Integer;
      IU2    : Integer;
      IVT2   : Integer;
      IZ     : Integer;
      K      : Integer;
      LDQ    : Integer;
      LDU2   : Integer;
      LDVT2  : Integer;
      M      : Integer;
      N      : Integer;
      N1     : Integer;
      N2     : Integer;
      ORGNRM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD1( NL, NR, SQRE, D, ALPHA, BETA, U, LDU, VT, LDVT,
   --                          IDXQ, IWORK, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDU, LDVT, NL, NR, SQRE
   --       DOUBLE PRECISION   ALPHA, BETA
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IDXQ( * ), IWORK( * )
   --       DOUBLE PRECISION   D( * ), U( LDU, * ), VT( LDVT, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
   --  where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.
   --
   --  A related subroutine DLASD7 handles the case in which the singular
   --  values (and the singular vectors in factored form) are desired.
   --
   --  DLASD1 computes the SVD as follows:
   --
   --                ( D1(in)    0    0       0 )
   --    B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
   --                (   0       0   D2(in)   0 )
   --
   --      = U(out) * ( D(out) 0) * VT(out)
   --
   --  where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
   --  with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
   --  elsewhere; and the entry b is empty if SQRE = 0.
   --
   --  The left singular vectors of the original matrix are stored in U, and
   --  the transpose of the right singular vectors are stored in VT, and the
   --  singular values are in D.  The algorithm consists of three stages:
   --
   --     The first stage consists of deflating the size of the problem
   --     when there are multiple singular values or when there are zeros in
   --     the Z vector.  For each such occurence the dimension of the
   --     secular equation problem is reduced by one.  This stage is
   --     performed by the routine DLASD2.
   --
   --     The second stage consists of calculating the updated
   --     singular values. This is done by finding the square roots of the
   --     roots of the secular equation via the routine DLASD4 (as called
   --     by DLASD3). This routine also calculates the singular vectors of
   --     the current problem.
   --
   --     The final stage consists of computing the updated singular vectors
   --     directly using the updated singular values.  The singular vectors
   --     for the current problem are multiplied with the singular vectors
   --     from the overall problem.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] NL
   --           NL is INTEGER
   --          The row dimension of the upper block.  NL >= 1.
   --
   --  [in] NR
   --           NR is INTEGER
   --          The row dimension of the lower block.  NR >= 1.
   --
   --  [in] SQRE
   --           SQRE is INTEGER
   --          = 0: the lower block is an NR-by-NR square matrix.
   --          = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
   --
   --          The bidiagonal matrix has row dimension N = NL + NR + 1,
   --          and column dimension M = N + SQRE.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array,
   --                         dimension (N = NL+NR+1).
   --          On entry D(1:NL,1:NL) contains the singular values of the
   --          upper block; and D(NL+2:N) contains the singular values of
   --          the lower block. On exit D(1:N) contains the singular values
   --          of the modified matrix.
   --
   --  [in,out] ALPHA
   --           ALPHA is DOUBLE PRECISION
   --          Contains the diagonal element associated with the added row.
   --
   --  [in,out] BETA
   --           BETA is DOUBLE PRECISION
   --          Contains the off-diagonal element associated with the added
   --          row.
   --
   --  [in,out] U
   --           U is DOUBLE PRECISION array, dimension(LDU,N)
   --          On entry U(1:NL, 1:NL) contains the left singular vectors of
   --          the upper block; U(NL+2:N, NL+2:N) contains the left singular
   --          vectors of the lower block. On exit U contains the left
   --          singular vectors of the bidiagonal matrix.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --          The leading dimension of the array U.  LDU >= max( 1, N ).
   --
   --  [in,out] VT
   --           VT is DOUBLE PRECISION array, dimension(LDVT,M)
   --          where M = N + SQRE.
   --          On entry VT(1:NL+1, 1:NL+1)**T contains the right singular
   --          vectors of the upper block; VT(NL+2:M, NL+2:M)**T contains
   --          the right singular vectors of the lower block. On exit
   --          VT**T contains the right singular vectors of the
   --          bidiagonal matrix.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --          The leading dimension of the array VT.  LDVT >= max( 1, M ).
   --
   --  [out] IDXQ
   --           IDXQ is INTEGER array, dimension(N)
   --          This contains the permutation which will reintegrate the
   --          subproblem just solved back into sorted order, i.e.
   --          D( IDXQ( I = 1, N ) ) will be in ascending order.
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension( 4 * N )
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension( 3*M**2 + 2*M )
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, a singular value did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLAMRG, DLASCL, DLASD2, DLASD3, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if NL < 1 then
         INFO := -1;
      elsif NR < 1 then
         INFO := -2;
      elsif (SQRE < 0) or (SQRE > 1) then
         INFO := -3;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASD1", -INFO);
         return;
      end if;
      --
      N := NL + NR + 1;
      M := N + SQRE;
      --
      --     The following values are for bookkeeping purposes only.  They are
      --     integer pointers which indicate the portion of the workspace
      --     used by a particular array in DLASD2 and DLASD3.
      --
      LDU2  := N;
      LDVT2 := M;
      --
      IZ     := 1;
      ISIGMA := IZ + M;
      IU2    := ISIGMA + N;
      IVT2   := IU2 + LDU2 * N;
      IQ     := IVT2 + LDVT2 * M;
      --
      IDX    := 1;
      IDXC   := IDX + N;
      COLTYP := IDXC + N;
      IDXP   := COLTYP + N;
      --
      --     Scale.
      --
      ORGNRM     := max (abs (ALPHA), abs (BETA));
      D (NL + 1) := ZERO;
      I          := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         if abs (D (I)) > ORGNRM then
            ORGNRM := abs (D (I));
         end if;
      end loop;
      DLASCL ('G', 0, 0, ORGNRM, ONE, N, 1, D'Address, N, INFO);
      ALPHA := ALPHA / ORGNRM;
      BETA  := BETA / ORGNRM;
      --
      --     Deflate singular values.
      --
      DLASD2
        (NL,
         NR,
         SQRE,
         K,
         D'Address,
         WORK (IZ)'Address,
         ALPHA,
         BETA,
         U'Address,
         LDU,
         VT'Address,
         LDVT,
         WORK (ISIGMA)'Address,
         WORK (IU2)'Address,
         LDU2,
         WORK (IVT2)'Address,
         LDVT2,
         IWORK (IDXP)'Address,
         IWORK (IDX)'Address,
         IWORK (IDXC)'Address,
         IDXQ'Address,
         IWORK (COLTYP)'Address,
         INFO);
      --
      --     Solve Secular Equation and update singular vectors.
      --
      LDQ := K;
      DLASD3
        (NL,
         NR,
         SQRE,
         K,
         D'Address,
         WORK (IQ)'Address,
         LDQ,
         WORK (ISIGMA)'Address,
         U'Address,
         LDU,
         WORK (IU2)'Address,
         LDU2,
         VT'Address,
         LDVT,
         WORK (IVT2)'Address,
         LDVT2,
         IWORK (IDXC)'Address,
         IWORK (COLTYP)'Address,
         WORK (IZ)'Address,
         INFO);
      if INFO /= 0 then
         return;
      end if;
      --
      --     Unscale.
      --
      DLASCL ('G', 0, 0, ONE, ORGNRM, N, 1, D'Address, N, INFO);
      --
      --     Prepare the IDXQ sorting permutation.
      --
      N1 := K;
      N2 := N - K;
      DLAMRG (N1, N2, D'Address, 1, -1, IDXQ'Address);
      --
      return;
      --
      --     End of DLASD1
      --
   end DLASD1;

   procedure DLASD2
     (NL         : Integer;
      NR         : Integer;
      SQRE       : Integer;
      K          : in out Integer;
      D_adr      : Address;
      Z_adr      : Address;
      ALPHA      : Real;
      BETA       : Real;
      U_adr      : Address;
      LDU        : Integer;
      VT_adr     : Address;
      LDVT       : Integer;
      DSIGMA_adr : Address;
      U2_adr     : Address;
      LDU2       : Integer;
      VT2_adr    : Address;
      LDVT2      : Integer;
      IDXP_adr   : Address;
      IDX_adr    : Address;
      IDXC_adr   : Address;
      IDXQ_adr   : Address;
      COLTYP_adr : Address;
      INFO       : in out Integer)
   is

      the_N : constant Integer := NL + NR + 1;
      the_M : constant Integer := NL + NR + 1 + SQRE;

      D      : Ftn_Real_Vector (1 .. the_N);
      Z      : Ftn_Real_Vector (1 .. the_N);
      U      : Ftn_Real_Matrix (1 .. LDU, 1 .. the_N);
      VT     : Ftn_Real_Matrix (1 .. LDVT, 1 .. the_M);
      DSIGMA : Ftn_Real_Vector (1 .. the_N);
      U2     : Ftn_Real_Matrix (1 .. LDU2, 1 .. the_N);
      VT2    : Ftn_Real_Matrix (1 .. LDVT2, 1 .. the_N);
      IDXP   : Ftn_Integer_Vector (1 .. the_N);
      IDX    : Ftn_Integer_Vector (1 .. the_N);
      IDXC   : Ftn_Integer_Vector (1 .. the_N);
      IDXQ   : Ftn_Integer_Vector (1 .. the_N);
      COLTYP : Ftn_Integer_Vector (1 .. the_N);

      for D'Address use D_adr;
      for Z'Address use Z_adr;
      for U'Address use U_adr;
      for VT'Address use VT_adr;
      for DSIGMA'Address use DSIGMA_adr;
      for U2'Address use U2_adr;
      for VT2'Address use VT2_adr;
      for IDXP'Address use IDXP_adr;
      for IDX'Address use IDX_adr;
      for IDXC'Address use IDXC_adr;
      for IDXQ'Address use IDXQ_adr;
      for COLTYP'Address use COLTYP_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Z);
      pragma Import (Ada, U);
      pragma Import (Ada, VT);
      pragma Import (Ada, DSIGMA);
      pragma Import (Ada, U2);
      pragma Import (Ada, VT2);
      pragma Import (Ada, IDXP);
      pragma Import (Ada, IDX);
      pragma Import (Ada, IDXC);
      pragma Import (Ada, IDXQ);
      pragma Import (Ada, COLTYP);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      EIGHT  : constant Real := 8.0e0;
      CTOT   : Ftn_Integer_Vector (1 .. 4);
      PSM    : Ftn_Integer_Vector (1 .. 4);
      CT     : Integer;
      I      : Integer;
      IDXI   : Integer;
      IDXJ   : Integer;
      IDXJP  : Integer;
      J      : Integer;
      JP     : Integer;
      JPREV  : Integer;
      K2     : Integer;
      M      : Integer;
      N      : Integer;
      NLP1   : Integer;
      NLP2   : Integer;
      C      : Real;
      EPS    : Real;
      HLFTOL : Real;
      S      : Real;
      TAU    : Real;
      TOL    : Real;
      Z1     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD2( NL, NR, SQRE, K, D, Z, ALPHA, BETA, U, LDU, VT,
   --                          LDVT, DSIGMA, U2, LDU2, VT2, LDVT2, IDXP, IDX,
   --                          IDXC, IDXQ, COLTYP, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDU, LDU2, LDVT, LDVT2, NL, NR, SQRE
   --       DOUBLE PRECISION   ALPHA, BETA
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            COLTYP( * ), IDX( * ), IDXC( * ), IDXP( * ),
   --      $                   IDXQ( * )
   --       DOUBLE PRECISION   D( * ), DSIGMA( * ), U( LDU, * ),
   --      $                   U2( LDU2, * ), VT( LDVT, * ), VT2( LDVT2, * ),
   --      $                   Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASD2 merges the two sets of singular values together into a single
   --  sorted set.  Then it tries to deflate the size of the problem.
   --  There are two ways in which deflation can occur:  when two or more
   --  singular values are close together or if there is a tiny entry in the
   --  Z vector.  For each such occurrence the order of the related secular
   --  equation problem is reduced by one.
   --
   --  DLASD2 is called from DLASD1.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] NL
   --           NL is INTEGER
   --          The row dimension of the upper block.  NL >= 1.
   --
   --  [in] NR
   --           NR is INTEGER
   --          The row dimension of the lower block.  NR >= 1.
   --
   --  [in] SQRE
   --           SQRE is INTEGER
   --          = 0: the lower block is an NR-by-NR square matrix.
   --          = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
   --
   --          The bidiagonal matrix has N = NL + NR + 1 rows and
   --          M = N + SQRE >= N columns.
   --
   --  [out] K
   --           K is INTEGER
   --          Contains the dimension of the non-deflated matrix,
   --          This is the order of the related secular equation. 1 <= K <=N.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension(N)
   --          On entry D contains the singular values of the two submatrices
   --          to be combined.  On exit D contains the trailing (N-K) updated
   --          singular values (those which were deflated) sorted into
   --          increasing order.
   --
   --  [out] Z
   --           Z is DOUBLE PRECISION array, dimension(N)
   --          On exit Z contains the updating row vector in the secular
   --          equation.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION
   --          Contains the diagonal element associated with the added row.
   --
   --  [in] BETA
   --           BETA is DOUBLE PRECISION
   --          Contains the off-diagonal element associated with the added
   --          row.
   --
   --  [in,out] U
   --           U is DOUBLE PRECISION array, dimension(LDU,N)
   --          On entry U contains the left singular vectors of two
   --          submatrices in the two square blocks with corners at (1,1),
   --          (NL, NL), and (NL+2, NL+2), (N,N).
   --          On exit U contains the trailing (N-K) updated left singular
   --          vectors (those which were deflated) in its last N-K columns.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --          The leading dimension of the array U.  LDU >= N.
   --
   --  [in,out] VT
   --           VT is DOUBLE PRECISION array, dimension(LDVT,M)
   --          On entry VT**T contains the right singular vectors of two
   --          submatrices in the two square blocks with corners at (1,1),
   --          (NL+1, NL+1), and (NL+2, NL+2), (M,M).
   --          On exit VT**T contains the trailing (N-K) updated right singular
   --          vectors (those which were deflated) in its last N-K columns.
   --          In case SQRE =1, the last row of VT spans the right null
   --          space.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --          The leading dimension of the array VT.  LDVT >= M.
   --
   --  [out] DSIGMA
   --           DSIGMA is DOUBLE PRECISION array, dimension (N)
   --          Contains a copy of the diagonal elements (K-1 singular values
   --          and one zero) in the secular equation.
   --
   --  [out] U2
   --           U2 is DOUBLE PRECISION array, dimension(LDU2,N)
   --          Contains a copy of the first K-1 left singular vectors which
   --          will be used by DLASD3 in a matrix multiply (DGEMM) to solve
   --          for the new left singular vectors. U2 is arranged into four
   --          blocks. The first block contains a column with 1 at NL+1 and
   --          zero everywhere else; the second block contains non-zero
   --          entries only at and above NL; the third contains non-zero
   --          entries only below NL+1; and the fourth is dense.
   --
   --  [in] LDU2
   --           LDU2 is INTEGER
   --          The leading dimension of the array U2.  LDU2 >= N.
   --
   --  [out] VT2
   --           VT2 is DOUBLE PRECISION array, dimension(LDVT2,N)
   --          VT2**T contains a copy of the first K right singular vectors
   --          which will be used by DLASD3 in a matrix multiply (DGEMM) to
   --          solve for the new right singular vectors. VT2 is arranged into
   --          three blocks. The first block contains a row that corresponds
   --          to the special 0 diagonal element in SIGMA; the second block
   --          contains non-zeros only at and before NL +1; the third block
   --          contains non-zeros only at and after  NL +2.
   --
   --  [in] LDVT2
   --           LDVT2 is INTEGER
   --          The leading dimension of the array VT2.  LDVT2 >= M.
   --
   --  [out] IDXP
   --           IDXP is INTEGER array dimension(N)
   --          This will contain the permutation used to place deflated
   --          values of D at the end of the array. On output IDXP(2:K)
   --          points to the nondeflated D-values and IDXP(K+1:N)
   --          points to the deflated singular values.
   --
   --  [out] IDX
   --           IDX is INTEGER array dimension(N)
   --          This will contain the permutation used to sort the contents of
   --          D into ascending order.
   --
   --  [out] IDXC
   --           IDXC is INTEGER array dimension(N)
   --          This will contain the permutation used to arrange the columns
   --          of the deflated U matrix into three groups:  the first group
   --          contains non-zero entries only at and above NL, the second
   --          contains non-zero entries only below NL+2, and the third is
   --          dense.
   --
   --  [in,out] IDXQ
   --           IDXQ is INTEGER array dimension(N)
   --          This contains the permutation which separately sorts the two
   --          sub-problems in D into ascending order.  Note that entries in
   --          the first hlaf of this permutation must first be moved one
   --          position backward; and entries in the second half
   --          must first have NL+1 added to their values.
   --
   --  [out] COLTYP
   --           COLTYP is INTEGER array dimension(N)
   --          As workspace, this will contain a label which will indicate
   --          which of the following types a column in the U2 matrix or a
   --          row in the VT2 matrix is:
   --          1 : non-zero in the upper half only
   --          2 : non-zero in the lower half only
   --          3 : dense
   --          4 : deflated
   --
   --          On exit, it is an array of dimension 4, with COLTYP(I) being
   --          the dimension of the I-th type columns.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, TWO = 2.0D+0, EIGHT = 8.0D+0 )
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH, DLAPY2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLACPY, DLAMRG, DLASET, DROT, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if NL < 1 then
         INFO := -1;
      elsif NR < 1 then
         INFO := -2;
      elsif (SQRE /= 1) and (SQRE /= 0) then
         INFO := -3;
      end if;
      --
      N := NL + NR + 1;
      M := N + SQRE;
      --
      if LDU < N then
         INFO := -10;
      elsif LDVT < M then
         INFO := -12;
      elsif LDU2 < N then
         INFO := -15;
      elsif LDVT2 < M then
         INFO := -17;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASD2", -INFO);
         return;
      end if;
      --
      NLP1 := NL + 1;
      NLP2 := NL + 2;
      --
      --     Generate the first part of the vector Z; and move the singular
      --     values in the first part of D one position backward.
      --
      Z1    := ALPHA * VT (NLP1, NLP1);
      Z (1) := Z1;
      I     := NL + 1;
      loop
         I := I - 1;
         exit when I < 1;
         Z (I + 1)    := ALPHA * VT (I, NLP1);
         D (I + 1)    := D (I);
         IDXQ (I + 1) := IDXQ (I) + 1;
      end loop;
      --
      --     Generate the second part of the vector Z.
      --
      I := NLP2 - 1;
      loop
         I := I + 1;
         exit when I > M;
         Z (I) := BETA * VT (I, NLP2);
      end loop;
      --
      --     Initialize some reference arrays.
      --
      I := 2 - 1;
      loop
         I := I + 1;
         exit when I > NLP1;
         COLTYP (I) := 1;
      end loop;
      I := NLP2 - 1;
      loop
         I := I + 1;
         exit when I > N;
         COLTYP (I) := 2;
      end loop;
      --
      --     Sort the singular values into increasing order
      --
      I := NLP2 - 1;
      loop
         I := I + 1;
         exit when I > N;
         IDXQ (I) := IDXQ (I) + NLP1;
      end loop;
      --
      --     DSIGMA, IDXC, IDXC, and the first column of U2
      --     are used as storage space.
      --
      I := 2 - 1;
      loop
         I := I + 1;
         exit when I > N;
         DSIGMA (I) := D (IDXQ (I));
         U2 (I, 1)  := Z (IDXQ (I));
         IDXC (I)   := COLTYP (IDXQ (I));
      end loop;
      --
      DLAMRG (NL, NR, DSIGMA (2)'Address, 1, 1, IDX (2)'Address);
      --
      I := 2 - 1;
      loop
         I := I + 1;
         exit when I > N;
         IDXI       := 1 + IDX (I);
         D (I)      := DSIGMA (IDXI);
         Z (I)      := U2 (IDXI, 1);
         COLTYP (I) := IDXC (IDXI);
      end loop;
      --
      --     Calculate the allowable deflation tolerance
      --
      EPS := DLAMCH ('E');
      TOL := max (abs (ALPHA), abs (BETA));
      TOL := EIGHT * EPS * max (abs (D (N)), TOL);
      --
      --     There are 2 kinds of deflation -- first a value in the z-vector
      --     is small, second two (or more) singular values are very close
      --     together (their difference is small).
      --
      --     If the value in the z-vector is small, we simply permute the
      --     array so that the corresponding singular value is moved to the
      --     end.
      --
      --     If two values in the D-vector are close, we perform a two-sided
      --     rotation designed to make one of the corresponding z-vector
      --     entries zero, and then permute the array so that the deflated
      --     singular value is moved to the end.
      --
      --     If there are multiple singular values then the problem deflates.
      --     Here the number of equal singular values are found.  As each equal
      --     singular value is found, an elementary reflector is computed to
      --     rotate the corresponding singular subspace so that the
      --     corresponding components of Z are zero in this new basis.
      --
      K  := 1;
      K2 := N + 1;
      J  := 2 - 1;
      loop
         J := J + 1;
         exit when J > N;
         if abs (Z (J)) <= TOL then
            --
            --           Deflate due to small z component.
            --
            K2         := K2 - 1;
            IDXP (K2)  := J;
            COLTYP (J) := 4;
            if J = N then
               -- ?? ---------------------------
               goto L120;
               -- ?? ---------------------------
            end if;
         else
            JPREV := J;
            -- ?? ---------------------------
            goto L90;
            -- ?? ---------------------------
         end if;
      end loop;
      <<L90>> null;
      J := JPREV;
      <<L100>> null;
      J := J + 1;
      if J > N then
         -- ?? ---------------------------
         goto L110;
         -- ?? ---------------------------
      end if;
      if abs (Z (J)) <= TOL then
         --
         --        Deflate due to small z component.
         --
         K2         := K2 - 1;
         IDXP (K2)  := J;
         COLTYP (J) := 4;
      else
         --
         --        Check if singular values are close enough to allow deflation.
         --
         if abs (D (J) - D (JPREV)) <= TOL then
            --
            --           Deflation is possible.
            --
            S := Z (JPREV);
            C := Z (J);
            --
            --           Find sqrt(a**2+b**2) without overflow or
            --           destructive underflow.
            --
            TAU       := DLAPY2 (C, S);
            C         := C / TAU;
            S         := -S / TAU;
            Z (J)     := TAU;
            Z (JPREV) := ZERO;
            --
            --           Apply back the Givens rotation to the left and right
            --           singular vector matrices.
            --
            IDXJP := IDXQ (IDX (JPREV) + 1);
            IDXJ  := IDXQ (IDX (J) + 1);
            if IDXJP <= NLP1 then
               IDXJP := IDXJP - 1;
            end if;
            if IDXJ <= NLP1 then
               IDXJ := IDXJ - 1;
            end if;
            DROT (N, U (1, IDXJP)'Address, 1, U (1, IDXJ)'Address, 1, C, S);
            DROT (M, VT (IDXJP, 1)'Address, LDVT, VT (IDXJ, 1)'Address, LDVT, C, S);
            if COLTYP (J) /= COLTYP (JPREV) then
               COLTYP (J) := 3;
            end if;
            COLTYP (JPREV) := 4;
            K2             := K2 - 1;
            IDXP (K2)      := JPREV;
            JPREV          := J;
         else
            K          := K + 1;
            U2 (K, 1)  := Z (JPREV);
            DSIGMA (K) := D (JPREV);
            IDXP (K)   := JPREV;
            JPREV      := J;
         end if;
      end if;
      -- ?? ---------------------------
      goto L100;
      -- ?? ---------------------------
      <<L110>> null;
      --
      --     Record the last singular value.
      --
      K          := K + 1;
      U2 (K, 1)  := Z (JPREV);
      DSIGMA (K) := D (JPREV);
      IDXP (K)   := JPREV;
      --
      <<L120>> null;
      --
      --     Count up the total number of the various types of columns, then
      --     form a permutation which positions the four column types into
      --     four groups of uniform structure (although one or more of these
      --     groups may be empty).
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > 4;
         CTOT (J) := 0;
      end loop;
      J := 2 - 1;
      loop
         J := J + 1;
         exit when J > N;
         CT        := COLTYP (J);
         CTOT (CT) := CTOT (CT) + 1;
      end loop;
      --
      --     PSM(*) = Position in SubMatrix (of types 1 through 4)
      --
      PSM (1) := 2;
      PSM (2) := 2 + CTOT (1);
      PSM (3) := PSM (2) + CTOT (2);
      PSM (4) := PSM (3) + CTOT (3);
      --
      --     Fill out the IDXC array so that the permutation which it induces
      --     will place all type-1 columns first, all type-2 columns next,
      --     then all type-3's, and finally all type-4's, starting from the
      --     second column. This applies similarly to the rows of VT.
      --
      J := 2 - 1;
      loop
         J := J + 1;
         exit when J > N;
         JP               := IDXP (J);
         CT               := COLTYP (JP);
         IDXC (PSM (CT))  := J;
         PSM (CT)         := PSM (CT) + 1;
      end loop;
      --
      --     Sort the singular values and corresponding singular vectors into
      --     DSIGMA, U2, and VT2 respectively.  The singular values/vectors
      --     which were not deflated go into the first K slots of DSIGMA, U2,
      --     and VT2 respectively, while those which were deflated go into the
      --     last N - K slots, except that the first column/row will be treated
      --     separately.
      --
      J := 2 - 1;
      loop
         J := J + 1;
         exit when J > N;
         JP         := IDXP (J);
         DSIGMA (J) := D (JP);
         IDXJ       := IDXQ (IDX (IDXP (IDXC (J))) + 1);
         if IDXJ <= NLP1 then
            IDXJ := IDXJ - 1;
         end if;
         DCOPY (N, U (1, IDXJ)'Address, 1, U2 (1, J)'Address, 1);
         DCOPY (M, VT (IDXJ, 1)'Address, LDVT, VT2 (J, 1)'Address, LDVT2);
      end loop;
      --
      --     Determine DSIGMA(1), DSIGMA(2) and Z(1)
      --
      DSIGMA (1) := ZERO;
      HLFTOL     := TOL / TWO;
      if abs (DSIGMA (2)) <= HLFTOL then
         DSIGMA (2) := HLFTOL;
      end if;
      if M > N then
         Z (1) := DLAPY2 (Z1, Z (M));
         if Z (1) <= TOL then
            C     := ONE;
            S     := ZERO;
            Z (1) := TOL;
         else
            C := Z1 / Z (1);
            S := Z (M) / Z (1);
         end if;
      else
         if abs (Z1) <= TOL 
            then Z (1) := TOL;
            else Z (1) := Z1;
         end if;
      end if;
      --
      --     Move the rest of the updating row to Z.
      --
      DCOPY (K - 1, U2 (2, 1)'Address, 1, Z (2)'Address, 1);
      --
      --     Determine the first column of U2, the first row of VT2 and the
      --     last row of VT.
      --
      DLASET ('A', N, 1, ZERO, ZERO, U2'Address, LDU2);
      U2 (NLP1, 1) := ONE;
      if M > N then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > NLP1;
            VT (M, I)  := -S * VT (NLP1, I);
            VT2 (1, I) := C * VT (NLP1, I);
         end loop;
         I := NLP2 - 1;
         loop
            I := I + 1;
            exit when I > M;
            VT2 (1, I) := S * VT (M, I);
            VT (M, I)  := C * VT (M, I);
         end loop;
      else
         DCOPY (M, VT (NLP1, 1)'Address, LDVT, VT2 (1, 1)'Address, LDVT2);
      end if;
      if M > N then
         DCOPY (M, VT (M, 1)'Address, LDVT, VT2 (M, 1)'Address, LDVT2);
      end if;
      --
      --     The deflated singular values and their corresponding vectors go
      --     into the back of D, U, and V respectively.
      --
      if N > K then
         DCOPY (N - K, DSIGMA (K + 1)'Address, 1, D (K + 1)'Address, 1);
         DLACPY ('A', N, N - K, U2 (1, K + 1)'Address, LDU2, U (1, K + 1)'Address, LDU);
         DLACPY ('A', N - K, M, VT2 (K + 1, 1)'Address, LDVT2, VT (K + 1, 1)'Address, LDVT);
      end if;
      --
      --     Copy CTOT into COLTYP for referencing in DLASD3.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > 4;
         COLTYP (J) := CTOT (J);
      end loop;
      --
      return;
      --
      --     End of DLASD2
      --
   end DLASD2;

   procedure DLASD3
     (NL         : Integer;
      NR         : Integer;
      SQRE       : Integer;
      K          : Integer;
      D_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      DSIGMA_adr : Address;
      U_adr      : Address;
      LDU        : Integer;
      U2_adr     : Address;
      LDU2       : Integer;
      VT_adr     : Address;
      LDVT       : Integer;
      VT2_adr    : Address;
      LDVT2      : Integer;
      IDXC_adr   : Address;
      CTOT_adr   : Address;
      Z_adr      : Address;
      INFO       : in out Integer)
   is

      the_N : constant Integer := NL + NR + 1;
      the_M : constant Integer := NL + NR + 1 + SQRE;

      D      : Ftn_Real_Vector (1 .. K);
      Q      : Ftn_Real_Matrix (1 .. LDQ, 1 .. K);
      DSIGMA : Ftn_Real_Vector (1 .. K);
      U      : Ftn_Real_Matrix (1 .. LDU, 1 .. the_N);
      U2     : Ftn_Real_Matrix (1 .. LDU2, 1 .. the_N);
      VT     : Ftn_Real_Matrix (1 .. LDVT, 1 .. the_M);
      VT2    : Ftn_Real_Matrix (1 .. LDVT2, 1 .. the_N);
      IDXC   : Ftn_Integer_Vector (1 .. the_N);
      CTOT   : Ftn_Integer_Vector (1 .. 4);
      Z      : Ftn_Real_Vector (1 .. K);

      for D'Address use D_adr;
      for Q'Address use Q_adr;
      for DSIGMA'Address use DSIGMA_adr;
      for U'Address use U_adr;
      for U2'Address use U2_adr;
      for VT'Address use VT_adr;
      for VT2'Address use VT2_adr;
      for IDXC'Address use IDXC_adr;
      for CTOT'Address use CTOT_adr;
      for Z'Address use Z_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Q);
      pragma Import (Ada, DSIGMA);
      pragma Import (Ada, U);
      pragma Import (Ada, U2);
      pragma Import (Ada, VT);
      pragma Import (Ada, VT2);
      pragma Import (Ada, IDXC);
      pragma Import (Ada, CTOT);
      pragma Import (Ada, Z);

      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
      NEGONE : constant Real := -1.0e0;
      CTEMP  : Integer;
      I      : Integer;
      J      : Integer;
      JC     : Integer;
      KTEMP  : Integer;
      M      : Integer;
      N      : Integer;
      NLP1   : Integer;
      NLP2   : Integer;
      NRP1   : Integer;
      RHO    : Real;
      TEMP   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD3( NL, NR, SQRE, K, D, Q, LDQ, DSIGMA, U, LDU, U2,
   --                          LDU2, VT, LDVT, VT2, LDVT2, IDXC, CTOT, Z,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDQ, LDU, LDU2, LDVT, LDVT2, NL, NR,
   --      $                   SQRE
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            CTOT( * ), IDXC( * )
   --       DOUBLE PRECISION   D( * ), DSIGMA( * ), Q( LDQ, * ), U( LDU, * ),
   --      $                   U2( LDU2, * ), VT( LDVT, * ), VT2( LDVT2, * ),
   --      $                   Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASD3 finds all the square roots of the roots of the secular
   --  equation, as defined by the values in D and Z.  It makes the
   --  appropriate calls to DLASD4 and then updates the singular
   --  vectors by matrix multiplication.
   --
   --  This code makes very mild assumptions about floating point
   --  arithmetic. It will work on machines with a guard digit in
   --  add/subtract, or on those binary machines without guard digits
   --  which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
   --  It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.
   --
   --  DLASD3 is called from DLASD1.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] NL
   --           NL is INTEGER
   --          The row dimension of the upper block.  NL >= 1.
   --
   --  [in] NR
   --           NR is INTEGER
   --          The row dimension of the lower block.  NR >= 1.
   --
   --  [in] SQRE
   --           SQRE is INTEGER
   --          = 0: the lower block is an NR-by-NR square matrix.
   --          = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
   --
   --          The bidiagonal matrix has N = NL + NR + 1 rows and
   --          M = N + SQRE >= N columns.
   --
   --  [in] K
   --           K is INTEGER
   --          The size of the secular equation, 1 =< K = < N.
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension(K)
   --          On exit the square roots of the roots of the secular equation,
   --          in ascending order.
   --
   --  [out] Q
   --           Q is DOUBLE PRECISION array,
   --                      dimension at least (LDQ,K).
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  LDQ >= K.
   --
   --  [in] DSIGMA
   --           DSIGMA is DOUBLE PRECISION array, dimension(K)
   --          The first K elements of this array contain the old roots
   --          of the deflated updating problem.  These are the poles
   --          of the secular equation.
   --
   --  [out] U
   --           U is DOUBLE PRECISION array, dimension (LDU, N)
   --          The last N - K columns of this matrix contain the deflated
   --          left singular vectors.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --          The leading dimension of the array U.  LDU >= N.
   --
   --  [in,out] U2
   --           U2 is DOUBLE PRECISION array, dimension (LDU2, N)
   --          The first K columns of this matrix contain the non-deflated
   --          left singular vectors for the split problem.
   --
   --  [in] LDU2
   --           LDU2 is INTEGER
   --          The leading dimension of the array U2.  LDU2 >= N.
   --
   --  [out] VT
   --           VT is DOUBLE PRECISION array, dimension (LDVT, M)
   --          The last M - K columns of VT**T contain the deflated
   --          right singular vectors.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --          The leading dimension of the array VT.  LDVT >= N.
   --
   --  [in,out] VT2
   --           VT2 is DOUBLE PRECISION array, dimension (LDVT2, N)
   --          The first K columns of VT2**T contain the non-deflated
   --          right singular vectors for the split problem.
   --
   --  [in] LDVT2
   --           LDVT2 is INTEGER
   --          The leading dimension of the array VT2.  LDVT2 >= N.
   --
   --  [in] IDXC
   --           IDXC is INTEGER array, dimension ( N )
   --          The permutation used to arrange the columns of U (and rows of
   --          VT) into three groups:  the first group contains non-zero
   --          entries only at and above (or before) NL +1; the second
   --          contains non-zero entries only at and below (or after) NL+2;
   --          and the third is dense. The first column of U and the row of
   --          VT are treated separately, however.
   --
   --          The rows of the singular vectors found by DLASD4
   --          must be likewise permuted before the matrix multiplies can
   --          take place.
   --
   --  [in] CTOT
   --           CTOT is INTEGER array, dimension ( 4 )
   --          A count of the total number of the various types of columns
   --          in U (or rows in VT), as described in IDXC. The fourth column
   --          type is any column which has been deflated.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension (K)
   --          The first K elements of this array contain the components
   --          of the deflation-adjusted updating row vector.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --          = 0:  successful exit.
   --          < 0:  if INFO = -i, the i-th argument had an illegal value.
   --          > 0:  if INFO = 1, a singular value did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0, NEGONE = -1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMC3, DNRM2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DGEMM, DLACPY, DLASCL, DLASD4, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if NL < 1 then
         INFO := -1;
      elsif NR < 1 then
         INFO := -2;
      elsif (SQRE /= 1) and (SQRE /= 0) then
         INFO := -3;
      end if;
      --
      N    := NL + NR + 1;
      M    := N + SQRE;
      NLP1 := NL + 1;
      NLP2 := NL + 2;
      --
      if (K < 1) or (K > N) then
         INFO := -4;
      elsif LDQ < K then
         INFO := -7;
      elsif LDU < N then
         INFO := -10;
      elsif LDU2 < N then
         INFO := -12;
      elsif LDVT < M then
         INFO := -14;
      elsif LDVT2 < M then
         INFO := -16;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASD3", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if K = 1 then
         D (1) := abs (Z (1));
         DCOPY (M, VT2 (1, 1)'Address, LDVT2, VT (1, 1)'Address, LDVT);
         if Z (1) > ZERO then
            DCOPY (N, U2 (1, 1)'Address, 1, U (1, 1)'Address, 1);
         else
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               U (I, 1) := -U2 (I, 1);
            end loop;
         end if;
         return;
      end if;
      --
      --     Modify values DSIGMA(i) to make sure all DSIGMA(i)-DSIGMA(j) can
      --     be computed with high relative accuracy (barring over/underflow).
      --     This is a problem on machines without a guard digit in
      --     add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
      --     The following code replaces DSIGMA(I) by 2*DSIGMA(I)-DSIGMA(I),
      --     which on any of these machines zeros out the bottommost
      --     bit of DSIGMA(I) if it is 1; this makes the subsequent
      --     subtractions DSIGMA(I)-DSIGMA(J) unproblematic when cancellation
      --     occurs. On binary machines with a guard digit (almost all
      --     machines) it does not change DSIGMA(I) at all. On hexadecimal
      --     and decimal machines with a guard digit, it slightly
      --     changes the bottommost bits of DSIGMA(I). It does not account
      --     for hexadecimal or decimal machines without guard digits
      --     (we know of none). We use a subroutine call to compute
      --     2*DSIGMA(I) to prevent optimizing compilers from eliminating
      --     this code.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         DSIGMA (I) := DLAMC3 (DSIGMA (I), DSIGMA (I)) - DSIGMA (I);
      end loop;
      --
      --     Keep a copy of Z.
      --
      DCOPY (K, Z'Address, 1, Q'Address, 1);
      --
      --     Normalize Z.
      --
      RHO := DNRM2 (K, Z'Address, 1);
      DLASCL ('G', 0, 0, RHO, ONE, K, 1, Z'Address, K, INFO);
      RHO := RHO * RHO;
      --
      --     Find the new singular values.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > K;
         DLASD4 (K, J, DSIGMA'Address, Z'Address, U (1, J)'Address, RHO, D (J), VT (1, J)'Address, INFO);
         --
         --        If the zero finder fails, the computation is terminated.
         --
         if INFO /= 0 then
            return;
         end if;
      end loop;
      --
      --     Compute updated Z.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         Z (I) := U (I, K) * VT (I, K);
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > I - 1;
            Z (I) := Z (I) * (U (I, J) * VT (I, J) / (DSIGMA (I) - DSIGMA (J)) / (DSIGMA (I) + DSIGMA (J)));
         end loop;
         J := I - 1;
         loop
            J := J + 1;
            exit when J > K - 1;
            Z (I) := Z (I) *
                     (U (I, J) * VT (I, J) / (DSIGMA (I) - DSIGMA (J + 1)) / (DSIGMA (I) + DSIGMA (J + 1)));
         end loop;
         Z (I) := sign (Sqrt (abs (Z (I))), Q (I, 1));
      end loop;
      --
      --     Compute left singular vectors of the modified diagonal matrix,
      --     and store related information for the right singular vectors.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         VT (1, I) := Z (1) / U (1, I) / VT (1, I);
         U (1, I)  := NEGONE;
         J         := 2 - 1;
         loop
            J := J + 1;
            exit when J > K;
            VT (J, I) := Z (J) / U (J, I) / VT (J, I);
            U (J, I)  := DSIGMA (J) * VT (J, I);
         end loop;
         TEMP     := DNRM2 (K, U (1, I)'Address, 1);
         Q (1, I) := U (1, I) / TEMP;
         J        := 2 - 1;
         loop
            J := J + 1;
            exit when J > K;
            JC       := IDXC (J);
            Q (J, I) := U (JC, I) / TEMP;
         end loop;
      end loop;
      --
      --     Update the left singular vector matrix.
      --
      if K = 2 then
         DGEMM ('N', 'N', N, K, K, ONE, U2'Address, LDU2, Q'Address, LDQ, ZERO, U'Address, LDU);
         goto L100;
      end if;
      if CTOT (1) > 0 then
         DGEMM
           ('N',
            'N',
            NL,
            K,
            CTOT (1),
            ONE,
            U2 (1, 2)'Address,
            LDU2,
            Q (2, 1)'Address,
            LDQ,
            ZERO,
            U (1, 1)'Address,
            LDU);
         if CTOT (3) > 0 then
            KTEMP := 2 + CTOT (1) + CTOT (2);
            DGEMM
              ('N',
               'N',
               NL,
               K,
               CTOT (3),
               ONE,
               U2 (1, KTEMP)'Address,
               LDU2,
               Q (KTEMP, 1)'Address,
               LDQ,
               ONE,
               U (1, 1)'Address,
               LDU);
         end if;
      elsif CTOT (3) > 0 then
         KTEMP := 2 + CTOT (1) + CTOT (2);
         DGEMM
           ('N',
            'N',
            NL,
            K,
            CTOT (3),
            ONE,
            U2 (1, KTEMP)'Address,
            LDU2,
            Q (KTEMP, 1)'Address,
            LDQ,
            ZERO,
            U (1, 1)'Address,
            LDU);
      else
         DLACPY ('F', NL, K, U2'Address, LDU2, U'Address, LDU);
      end if;
      DCOPY (K, Q (1, 1)'Address, LDQ, U (NLP1, 1)'Address, LDU);
      KTEMP := 2 + CTOT (1);
      CTEMP := CTOT (2) + CTOT (3);
      DGEMM
        ('N',
         'N',
         NR,
         K,
         CTEMP,
         ONE,
         U2 (NLP2, KTEMP)'Address,
         LDU2,
         Q (KTEMP, 1)'Address,
         LDQ,
         ZERO,
         U (NLP2, 1)'Address,
         LDU);
      --
      --     Generate the right singular vectors.
      --
      <<L100>> null;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         TEMP     := DNRM2 (K, VT (1, I)'Address, 1);
         Q (I, 1) := VT (1, I) / TEMP;
         J        := 2 - 1;
         loop
            J := J + 1;
            exit when J > K;
            JC       := IDXC (J);
            Q (I, J) := VT (JC, I) / TEMP;
         end loop;
      end loop;
      --
      --     Update the right singular vector matrix.
      --
      if K = 2 then
         DGEMM ('N', 'N', K, M, K, ONE, Q'Address, LDQ, VT2'Address, LDVT2, ZERO, VT'Address, LDVT);
         return;
      end if;
      KTEMP := 1 + CTOT (1);
      DGEMM
        ('N',
         'N',
         K,
         NLP1,
         KTEMP,
         ONE,
         Q (1, 1)'Address,
         LDQ,
         VT2 (1, 1)'Address,
         LDVT2,
         ZERO,
         VT (1, 1)'Address,
         LDVT);
      KTEMP := 2 + CTOT (1) + CTOT (2);
      if KTEMP <= LDVT2 then
         DGEMM
           ('N',
            'N',
            K,
            NLP1,
            CTOT (3),
            ONE,
            Q (1, KTEMP)'Address,
            LDQ,
            VT2 (KTEMP, 1)'Address,
            LDVT2,
            ONE,
            VT (1, 1)'Address,
            LDVT);
      end if;
      --
      KTEMP := CTOT (1) + 1;
      NRP1  := NR + SQRE;
      if KTEMP > 1 then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            Q (I, KTEMP) := Q (I, 1);
         end loop;
         I := NLP2 - 1;
         loop
            I := I + 1;
            exit when I > M;
            VT2 (KTEMP, I) := VT2 (1, I);
         end loop;
      end if;
      CTEMP := 1 + CTOT (2) + CTOT (3);
      DGEMM
        ('N',
         'N',
         K,
         NRP1,
         CTEMP,
         ONE,
         Q (1, KTEMP)'Address,
         LDQ,
         VT2 (KTEMP, NLP2)'Address,
         LDVT2,
         ZERO,
         VT (1, NLP2)'Address,
         LDVT);
      --
      return;
      --
      --     End of DLASD3
      --
   end DLASD3;

   procedure DLASD4
     (N             : Integer;
      I             : Integer;
      D_adr         : Address;
      Z_adr         : Address;
      Ftn_DELTA_adr : Address;
      RHO           : Real;
      SIGMA         : in out Real;
      WORK_adr      : Address;
      INFO          : in out Integer)
   is

      D         : Ftn_Real_Vector (1 .. N);
      Z         : Ftn_Real_Vector (1 .. N);
      Ftn_DELTA : Ftn_Real_Vector (1 .. N);
      WORK      : Ftn_Real_Vector (1 .. N);

      for D'Address use D_adr;
      for Z'Address use Z_adr;
      for Ftn_DELTA'Address use Ftn_DELTA_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Z);
      pragma Import (Ada, Ftn_DELTA);
      pragma Import (Ada, WORK);

      MAXIT  : constant Integer := 64;
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      TWO    : constant Real    := 2.0e0;
      THREE  : constant Real    := 3.0e0;
      FOUR   : constant Real    := 4.0e0;
      EIGHT  : constant Real    := 8.0e0;
      TEN    : constant Real    := 10.0e0;
      ORGATI : Boolean;
      SWTCH  : Boolean;
      SWTCH3 : Boolean;
      II     : Integer;
      IIM1   : Integer;
      IIP1   : Integer;
      IP1    : Integer;
      ITER   : Integer;
      J      : Integer;
      NITER  : Integer;
      A      : Real;
      B      : Real;
      C      : Real;
      DELSQ  : Real;
      DELSQ2 : Real;
      DPHI   : Real;
      DPSI   : Real;
      DTIIM  : Real;
      DTIIP  : Real;
      DTIPSQ : Real;
      DTISQ  : Real;
      DTNSQ  : Real;
      DTNSQ1 : Real;
      DW     : Real;
      EPS    : Real;
      ERRETM : Real;
      ETA    : Real;
      PHI    : Real;
      PREW   : Real;
      PSI    : Real;
      RHOINV : Real;
      SG2LB  : Real;
      SG2UB  : Real;
      TAU    : Real;
      TEMP   : Real;
      TEMP1  : Real;
      TEMP2  : Real;
      W      : Real;
      DD     : Ftn_Real_Vector (1 .. 3);
      ZZ     : Ftn_Real_Vector (1 .. 3);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD4( N, I, D, Z, DELTA, RHO, SIGMA, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            I, INFO, N
   --       DOUBLE PRECISION   RHO, SIGMA
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), DELTA( * ), WORK( * ), Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  This subroutine computes the square root of the I-th updated
   --  eigenvalue of a positive symmetric rank-one modification to
   --  a positive diagonal matrix whose entries are given as the squares
   --  of the corresponding entries in the array d, and that
   --
   --         0 <= D(i) < D(j)  for  i < j
   --
   --  and that RHO > 0. This is arranged by the calling routine, and is
   --  no loss in generality.  The rank-one modified system is thus
   --
   --         diag( D ) * diag( D ) +  RHO * Z * Z_transpose.
   --
   --  where we assume the Euclidean norm of Z is 1.
   --
   --  The method consists of approximating the rational functions in the
   --  secular equation by simpler interpolating rational functions.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --          The length of all arrays.
   --
   --  [in] I
   --           I is INTEGER
   --          The index of the eigenvalue to be computed.  1 <= I <= N.
   --
   --  [in] D
   --           D is DOUBLE PRECISION array, dimension ( N )
   --          The original eigenvalues.  It is assumed that they are in
   --          order, 0 <= D(I) < D(J)  for I < J.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension ( N )
   --          The components of the updating vector.
   --
   --  [out] DELTA
   --           DELTA is DOUBLE PRECISION array, dimension ( N )
   --          If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
   --          component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
   --          contains the information necessary to construct the
   --          (singular) eigenvectors.
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --          The scalar in the symmetric updating formula.
   --
   --  [out] SIGMA
   --           SIGMA is DOUBLE PRECISION
   --          The computed sigma_I, the I-th updated eigenvalue.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension ( N )
   --          If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
   --          component.  If N = 1, then WORK( 1 ) = 1.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --          = 0:  successful exit
   --          > 0:  if INFO = 1, the updating process failed.
   --
   --  Internal Parameters:
   --  =========================
   --
   --   LOGICAL variable ORGATI (origin-at-i?) is used for distinguishing
   --   whether D(i) or D(i+1) is treated as the origin.
   --
   --             ORGATI = .true.    origin at i
   --             ORGATI = .false.   origin at i+1
   --
   --   LOGICAL variable SWTCH3 (switch-for-3-poles?) is for noting
   --   if we are working with THREE poles!
   --
   --   MAXIT is the maximum number of iterations allowed for each
   --   eigenvalue.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ren-Cang Li, Computer Science Division, University of California
   --      at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( MAXIT = 64 )
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, TWO = 2.0D+0, THREE = 3.0D+0, FOUR = 4.0D+0, EIGHT = 8.0D+0, TEN =
   --10.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLAED6, DLASD5
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Since this routine is called in an inner loop, we do no argument
   --     checking.
   --
   --     Quick return for N=1 and 2.
   --
   begin
      INFO := 0;
      if N = 1 then
         --
         --        Presumably, I=1 upon entry
         --
         SIGMA         := Sqrt (D (1) * D (1) + RHO * Z (1) * Z (1));
         Ftn_DELTA (1) := ONE;
         WORK (1)      := ONE;
         return;
      end if;
      if N = 2 then
         DLASD5 (I, D, Z, Ftn_DELTA, RHO, SIGMA, WORK);
         return;
      end if;
      --
      --     Compute machine epsilon
      --
      EPS    := DLAMCH ('E');
      RHOINV := ONE / RHO;
      --
      --     The case I = N
      --
      if I = N then
         --
         --        Initialize some basic variables
         --
         II    := N - 1;
         NITER := 1;
         --
         --        Calculate initial guess
         --
         TEMP := RHO / TWO;
         --
         --        If ||Z||_2 is not one, then TEMP should be set to
         --        RHO * ||Z||_2^2 / TWO
         --
         TEMP1 := TEMP / (D (N) + Sqrt (D (N) * D (N) + TEMP));
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            WORK (J)      := D (J) + D (N) + TEMP1;
            Ftn_DELTA (J) := (D (J) - D (N)) - TEMP1;
         end loop;
         --
         PSI := ZERO;
         J   := 1 - 1;
         loop
            J := J + 1;
            exit when J > N - 2;
            PSI := PSI + Z (J) * Z (J) / (Ftn_DELTA (J) * WORK (J));
         end loop;
         --
         C := RHOINV + PSI;
         W := C + Z (II) * Z (II) / (Ftn_DELTA (II) * WORK (II)) + Z (N) * Z (N) / (Ftn_DELTA (N) * WORK (N));
         --
         if W <= ZERO then
            TEMP1 := Sqrt (D (N) * D (N) + RHO);
            TEMP  := Z (N - 1) * Z (N - 1) / ((D (N - 1) + TEMP1) * (D (N) - D (N - 1) + RHO / (D (N) + TEMP1))) +
                     Z (N) * Z (N) / RHO;
            --
            --           The following TAU is to approximate
            --           SIGMA_n^2 - D( N )*D( N )
            --
            if C <= TEMP then
               TAU := RHO;
            else
               DELSQ := (D (N) - D (N - 1)) * (D (N) + D (N - 1));
               A     := -C * DELSQ + Z (N - 1) * Z (N - 1) + Z (N) * Z (N);
               B     := Z (N) * Z (N) * DELSQ;
               if A < ZERO 
                  then TAU := TWO * B / (Sqrt (A * A + FOUR * B * C) - A);
                  else TAU := (A + Sqrt (A * A + FOUR * B * C)) / (TWO * C);
               end if;
            end if;
         --
         --           It can be proved that
         --               D(N)^2+RHO/2 <= SIGMA_n^2 < D(N)^2+TAU <= D(N)^2+RHO
         --
         else
            DELSQ := (D (N) - D (N - 1)) * (D (N) + D (N - 1));
            A     := -C * DELSQ + Z (N - 1) * Z (N - 1) + Z (N) * Z (N);
            B     := Z (N) * Z (N) * DELSQ;
            --
            --           The following TAU is to approximate
            --           SIGMA_n^2 - D( N )*D( N )
            --
            if A < ZERO 
               then TAU := TWO * B / (Sqrt (A * A + FOUR * B * C) - A);
               else TAU := (A + Sqrt (A * A + FOUR * B * C)) / (TWO * C);
            end if;
            --
            --           It can be proved that
            --           D(N)^2 < D(N)^2+TAU < SIGMA(N)^2 < D(N)^2+RHO/2
            --
         end if;
         --
         --        The following ETA is to approximate SIGMA_n - D( N )
         --
         ETA := TAU / (D (N) + Sqrt (D (N) * D (N) + TAU));
         --
         SIGMA := D (N) + ETA;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            Ftn_DELTA (J) := (D (J) - D (I)) - ETA;
            WORK (J)      := D (J) + D (I) + ETA;
         end loop;
         --
         --        Evaluate PSI and the derivative DPSI
         --
         DPSI   := ZERO;
         PSI    := ZERO;
         ERRETM := ZERO;
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > II;
            TEMP   := Z (J) / (Ftn_DELTA (J) * WORK (J));
            PSI    := PSI + Z (J) * TEMP;
            DPSI   := DPSI + TEMP * TEMP;
            ERRETM := ERRETM + PSI;
         end loop;
         ERRETM := abs (ERRETM);
         --
         --        Evaluate PHI and the derivative DPHI
         --
         TEMP   := Z (N) / (Ftn_DELTA (N) * WORK (N));
         PHI    := Z (N) * TEMP;
         DPHI   := TEMP * TEMP;
         ERRETM := EIGHT * (-PHI - PSI) + ERRETM - PHI + RHOINV + abs (TAU) * (DPSI + DPHI);
         --
         W := RHOINV + PHI + PSI;
         --
         --        Test for convergence
         --
         if abs (W) <= EPS * ERRETM then
            goto L240;
         end if;
         --
         --        Calculate the new step
         --
         NITER  := NITER + 1;
         DTNSQ1 := WORK (N - 1) * Ftn_DELTA (N - 1);
         DTNSQ  := WORK (N) * Ftn_DELTA (N);
         C      := W - DTNSQ1 * DPSI - DTNSQ * DPHI;
         A      := (DTNSQ + DTNSQ1) * W - DTNSQ * DTNSQ1 * (DPSI + DPHI);
         B      := DTNSQ * DTNSQ1 * W;
         if C < ZERO then
            C := abs (C);
         end if;
         if C = ZERO then
            ETA := RHO - SIGMA * SIGMA;
         elsif A >= ZERO then
            ETA := (A + Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
         else
            ETA := TWO * B / (A - Sqrt (abs (A * A - FOUR * B * C)));
         end if;
         --
         --        Note, eta should be positive if w is negative, and
         --        eta should be negative otherwise. However,
         --        if for some reason caused by roundoff, eta*w > 0,
         --        we simply use one Newton step instead. This way
         --        will guarantee eta*w < 0.
         --
         if W * ETA > ZERO then
            ETA := -W / (DPSI + DPHI);
         end if;
         TEMP := ETA - DTNSQ;
         if TEMP > RHO then
            ETA := RHO + DTNSQ;
         end if;
         --
         TAU := TAU + ETA;
         ETA := ETA / (SIGMA + Sqrt (ETA + SIGMA * SIGMA));
         J   := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            Ftn_DELTA (J) := Ftn_DELTA (J) - ETA;
            WORK (J)      := WORK (J) + ETA;
         end loop;
         --
         SIGMA := SIGMA + ETA;
         --
         --        Evaluate PSI and the derivative DPSI
         --
         DPSI   := ZERO;
         PSI    := ZERO;
         ERRETM := ZERO;
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > II;
            TEMP   := Z (J) / (WORK (J) * Ftn_DELTA (J));
            PSI    := PSI + Z (J) * TEMP;
            DPSI   := DPSI + TEMP * TEMP;
            ERRETM := ERRETM + PSI;
         end loop;
         ERRETM := abs (ERRETM);
         --
         --        Evaluate PHI and the derivative DPHI
         --
         TEMP   := Z (N) / (WORK (N) * Ftn_DELTA (N));
         PHI    := Z (N) * TEMP;
         DPHI   := TEMP * TEMP;
         ERRETM := EIGHT * (-PHI - PSI) + ERRETM - PHI + RHOINV + abs (TAU) * (DPSI + DPHI);
         --
         W := RHOINV + PHI + PSI;
         --
         --        Main loop to update the values of the array   DELTA
         --
         ITER := NITER + 1;
         --
         NITER := ITER - 1;
         loop
            NITER := NITER + 1;
            exit when NITER > MAXIT;
            --
            --           Test for convergence
            --
            if abs (W) <= EPS * ERRETM then
               goto L240;
            end if;
            --
            --           Calculate the new step
            --
            DTNSQ1 := WORK (N - 1) * Ftn_DELTA (N - 1);
            DTNSQ  := WORK (N) * Ftn_DELTA (N);
            C      := W - DTNSQ1 * DPSI - DTNSQ * DPHI;
            A      := (DTNSQ + DTNSQ1) * W - DTNSQ1 * DTNSQ * (DPSI + DPHI);
            B      := DTNSQ1 * DTNSQ * W;
            if A >= ZERO 
               then ETA := (A + Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
               else ETA := TWO * B / (A - Sqrt (abs (A * A - FOUR * B * C)));
            end if;
            --
            --           Note, eta should be positive if w is negative, and
            --           eta should be negative otherwise. However,
            --           if for some reason caused by roundoff, eta*w > 0,
            --           we simply use one Newton step instead. This way
            --           will guarantee eta*w < 0.
            --
            if W * ETA > ZERO then
               ETA := -W / (DPSI + DPHI);
            end if;
            TEMP := ETA - DTNSQ;
            if TEMP <= ZERO then
               ETA := ETA / TWO;
            end if;
            --
            TAU := TAU + ETA;
            ETA := ETA / (SIGMA + Sqrt (ETA + SIGMA * SIGMA));
            J   := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               Ftn_DELTA (J) := Ftn_DELTA (J) - ETA;
               WORK (J)      := WORK (J) + ETA;
            end loop;
            --
            SIGMA := SIGMA + ETA;
            --
            --           Evaluate PSI and the derivative DPSI
            --
            DPSI   := ZERO;
            PSI    := ZERO;
            ERRETM := ZERO;
            J      := 1 - 1;
            loop
               J := J + 1;
               exit when J > II;
               TEMP   := Z (J) / (WORK (J) * Ftn_DELTA (J));
               PSI    := PSI + Z (J) * TEMP;
               DPSI   := DPSI + TEMP * TEMP;
               ERRETM := ERRETM + PSI;
            end loop;
            ERRETM := abs (ERRETM);
            --
            --           Evaluate PHI and the derivative DPHI
            --
            TEMP   := Z (N) / (WORK (N) * Ftn_DELTA (N));
            PHI    := Z (N) * TEMP;
            DPHI   := TEMP * TEMP;
            ERRETM := EIGHT * (-PHI - PSI) + ERRETM - PHI + RHOINV + abs (TAU) * (DPSI + DPHI);
            --
            W := RHOINV + PHI + PSI;
         end loop;
         --
         --        Return with INFO = 1, NITER = MAXIT and not converged
         --
         INFO := 1;
         goto L240;
      --
      --        End for the case I = N
      --
      else
         --
         --        The case for I < N
         --
         NITER := 1;
         IP1   := I + 1;
         --
         --        Calculate initial guess
         --
         DELSQ  := (D (IP1) - D (I)) * (D (IP1) + D (I));
         DELSQ2 := DELSQ / TWO;
         TEMP   := DELSQ2 / (D (I) + Sqrt (D (I) * D (I) + DELSQ2));
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            WORK (J)      := D (J) + D (I) + TEMP;
            Ftn_DELTA (J) := (D (J) - D (I)) - TEMP;
         end loop;
         --
         PSI := ZERO;
         J   := 1 - 1;
         loop
            J := J + 1;
            exit when J > I - 1;
            PSI := PSI + Z (J) * Z (J) / (WORK (J) * Ftn_DELTA (J));
         end loop;
         --
         PHI := ZERO;
         J   := N + 1;
         loop
            J := J - 1;
            exit when J < I + 2;
            PHI := PHI + Z (J) * Z (J) / (WORK (J) * Ftn_DELTA (J));
         end loop;
         C := RHOINV + PSI + PHI;
         W := C + Z (I) * Z (I) / (WORK (I) * Ftn_DELTA (I)) + Z (IP1) * Z (IP1) / (WORK (IP1) * Ftn_DELTA (IP1));
         --
         if W > ZERO then
            --
            --           d(i)^2 < the ith sigma^2 < (d(i)^2+d(i+1)^2)/2
            --
            --           We choose d(i) as origin.
            --
            ORGATI := True;
            SG2LB  := ZERO;
            SG2UB  := DELSQ2;
            A      := C * DELSQ + Z (I) * Z (I) + Z (IP1) * Z (IP1);
            B      := Z (I) * Z (I) * DELSQ;
            if A > ZERO 
               then TAU := TWO * B / (A + Sqrt (abs (A * A - FOUR * B * C)));
               else TAU := (A - Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
            end if;
            --
            --           TAU now is an estimation of SIGMA^2 - D( I )^2. The
            --           following, however, is the corresponding estimation of
            --           SIGMA - D( I ).
            --
            ETA := TAU / (D (I) + Sqrt (D (I) * D (I) + TAU));
         else
            --
            --           (d(i)^2+d(i+1)^2)/2 <= the ith sigma^2 < d(i+1)^2/2
            --
            --           We choose d(i+1) as origin.
            --
            ORGATI := False;
            SG2LB  := -DELSQ2;
            SG2UB  := ZERO;
            A      := C * DELSQ - Z (I) * Z (I) - Z (IP1) * Z (IP1);
            B      := Z (IP1) * Z (IP1) * DELSQ;
            if A < ZERO 
               then TAU := TWO * B / (A - Sqrt (abs (A * A + FOUR * B * C)));
               else TAU := -(A + Sqrt (abs (A * A + FOUR * B * C))) / (TWO * C);
            end if;
            --
            --           TAU now is an estimation of SIGMA^2 - D( IP1 )^2. The
            --           following, however, is the corresponding estimation of
            --           SIGMA - D( IP1 ).
            --
            ETA := TAU / (D (IP1) + Sqrt (abs (D (IP1) * D (IP1) + TAU)));
         end if;
         --
         if ORGATI then
            II    := I;
            SIGMA := D (I) + ETA;
            J     := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               WORK (J)      := D (J) + D (I) + ETA;
               Ftn_DELTA (J) := (D (J) - D (I)) - ETA;
            end loop;
         else
            II    := I + 1;
            SIGMA := D (IP1) + ETA;
            J     := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               WORK (J)      := D (J) + D (IP1) + ETA;
               Ftn_DELTA (J) := (D (J) - D (IP1)) - ETA;
            end loop;
         end if;
         IIM1 := II - 1;
         IIP1 := II + 1;
         --
         --        Evaluate PSI and the derivative DPSI
         --
         DPSI   := ZERO;
         PSI    := ZERO;
         ERRETM := ZERO;
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > IIM1;
            TEMP   := Z (J) / (WORK (J) * Ftn_DELTA (J));
            PSI    := PSI + Z (J) * TEMP;
            DPSI   := DPSI + TEMP * TEMP;
            ERRETM := ERRETM + PSI;
         end loop;
         ERRETM := abs (ERRETM);
         --
         --        Evaluate PHI and the derivative DPHI
         --
         DPHI := ZERO;
         PHI  := ZERO;
         J    := N + 1;
         loop
            J := J - 1;
            exit when J < IIP1;
            TEMP   := Z (J) / (WORK (J) * Ftn_DELTA (J));
            PHI    := PHI + Z (J) * TEMP;
            DPHI   := DPHI + TEMP * TEMP;
            ERRETM := ERRETM + PHI;
         end loop;
         --
         W := RHOINV + PHI + PSI;
         --
         --        W is the value of the secular function with
         --        its ii-th element removed.
         --
         SWTCH3 := False;
         if ORGATI then
            if W < ZERO then
               SWTCH3 := True;
            end if;
         else
            if W > ZERO then
               SWTCH3 := True;
            end if;
         end if;
         if II = 1 or II = N then
            SWTCH3 := False;
         end if;
         --
         TEMP   := Z (II) / (WORK (II) * Ftn_DELTA (II));
         DW     := DPSI + DPHI + TEMP * TEMP;
         TEMP   := Z (II) * TEMP;
         W      := W + TEMP;
         ERRETM := EIGHT * (PHI - PSI) + ERRETM + TWO * RHOINV + THREE * abs (TEMP) + abs (TAU) * DW;
         --
         --        Test for convergence
         --
         if abs (W) <= EPS * ERRETM then
            goto L240;
         end if;
         --
         if W <= ZERO 
            then SG2LB := max (SG2LB, TAU);
            else SG2UB := min (SG2UB, TAU);
         end if;
         --
         --        Calculate the new step
         --
         NITER := NITER + 1;
         if not SWTCH3 then
            DTIPSQ := WORK (IP1) * Ftn_DELTA (IP1);
            DTISQ  := WORK (I) * Ftn_DELTA (I);
            if ORGATI 
               then C := W - DTIPSQ * DW + DELSQ * (Z (I) / DTISQ) ** 2;
               else C := W - DTISQ * DW - DELSQ * (Z (IP1) / DTIPSQ) ** 2;
            end if;
            A := (DTIPSQ + DTISQ) * W - DTIPSQ * DTISQ * DW;
            B := DTIPSQ * DTISQ * W;
            if C = ZERO then
               if A = ZERO then
                  if ORGATI 
                     then A := Z (I) * Z (I) + DTIPSQ * DTIPSQ * (DPSI + DPHI);
                     else A := Z (IP1) * Z (IP1) + DTISQ * DTISQ * (DPSI + DPHI);
                  end if;
               end if;
               ETA := B / A;
            elsif A <= ZERO then
               ETA := (A - Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
            else
               ETA := TWO * B / (A + Sqrt (abs (A * A - FOUR * B * C)));
            end if;
         else
            --
            --           Interpolation using THREE most relevant poles
            --
            DTIIM := WORK (IIM1) * Ftn_DELTA (IIM1);
            DTIIP := WORK (IIP1) * Ftn_DELTA (IIP1);
            TEMP  := RHOINV + PSI + PHI;
            if ORGATI then
               TEMP1  := Z (IIM1) / DTIIM;
               TEMP1  := TEMP1 * TEMP1;
               C      := (TEMP - DTIIP * (DPSI + DPHI)) - (D (IIM1) - D (IIP1)) * (D (IIM1) + D (IIP1)) * TEMP1;
               ZZ (1) := Z (IIM1) * Z (IIM1);
               if DPSI < TEMP1 
                  then ZZ (3) := DTIIP * DTIIP * DPHI;
                  else ZZ (3) := DTIIP * DTIIP * ((DPSI - TEMP1) + DPHI);
               end if;
            else
               TEMP1 := Z (IIP1) / DTIIP;
               TEMP1 := TEMP1 * TEMP1;
               C     := (TEMP - DTIIM * (DPSI + DPHI)) - (D (IIP1) - D (IIM1)) * (D (IIM1) + D (IIP1)) * TEMP1;
               if DPHI < TEMP1 
                  then ZZ (1) := DTIIM * DTIIM * DPSI;
                  else ZZ (1) := DTIIM * DTIIM * (DPSI + (DPHI - TEMP1));
               end if;
               ZZ (3) := Z (IIP1) * Z (IIP1);
            end if;
            ZZ (2) := Z (II) * Z (II);
            DD (1) := DTIIM;
            DD (2) := Ftn_DELTA (II) * WORK (II);
            DD (3) := DTIIP;
            DLAED6 (NITER, ORGATI, C, DD'Address, ZZ'Address, W, ETA, INFO);
            if INFO /= 0 then
               goto L240;
            end if;
         end if;
         --
         --        Note, eta should be positive if w is negative, and
         --        eta should be negative otherwise. However,
         --        if for some reason caused by roundoff, eta*w > 0,
         --        we simply use one Newton step instead. This way
         --        will guarantee eta*w < 0.
         --
         if W * ETA >= ZERO then
            ETA := -W / DW;
         end if;
         if ORGATI then
            TEMP1 := WORK (I) * Ftn_DELTA (I);
            TEMP  := ETA - TEMP1;
         else
            TEMP1 := WORK (IP1) * Ftn_DELTA (IP1);
            TEMP  := ETA - TEMP1;
         end if;
         if TEMP > SG2UB or TEMP < SG2LB then
            if W < ZERO 
               then ETA := (SG2UB - TAU) / TWO;
               else ETA := (SG2LB - TAU) / TWO;
            end if;
         end if;
         --
         TAU := TAU + ETA;
         ETA := ETA / (SIGMA + Sqrt (SIGMA * SIGMA + ETA));
         --
         PREW := W;
         --
         SIGMA := SIGMA + ETA;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            WORK (J)      := WORK (J) + ETA;
            Ftn_DELTA (J) := Ftn_DELTA (J) - ETA;
         end loop;
         --
         --        Evaluate PSI and the derivative DPSI
         --
         DPSI   := ZERO;
         PSI    := ZERO;
         ERRETM := ZERO;
         J      := 1 - 1;
         loop
            J := J + 1;
            exit when J > IIM1;
            TEMP   := Z (J) / (WORK (J) * Ftn_DELTA (J));
            PSI    := PSI + Z (J) * TEMP;
            DPSI   := DPSI + TEMP * TEMP;
            ERRETM := ERRETM + PSI;
         end loop;
         ERRETM := abs (ERRETM);
         --
         --        Evaluate PHI and the derivative DPHI
         --
         DPHI := ZERO;
         PHI  := ZERO;
         J    := N + 1;
         loop
            J := J - 1;
            exit when J < IIP1;
            TEMP   := Z (J) / (WORK (J) * Ftn_DELTA (J));
            PHI    := PHI + Z (J) * TEMP;
            DPHI   := DPHI + TEMP * TEMP;
            ERRETM := ERRETM + PHI;
         end loop;
         --
         TEMP   := Z (II) / (WORK (II) * Ftn_DELTA (II));
         DW     := DPSI + DPHI + TEMP * TEMP;
         TEMP   := Z (II) * TEMP;
         W      := RHOINV + PHI + PSI + TEMP;
         ERRETM := EIGHT * (PHI - PSI) + ERRETM + TWO * RHOINV + THREE * abs (TEMP) + abs (TAU) * DW;
         --
         if W <= ZERO 
            then SG2LB := max (SG2LB, TAU);
            else SG2UB := min (SG2UB, TAU);
         end if;
         --
         SWTCH := False;
         if ORGATI then
            if -W > abs (PREW) / TEN then
               SWTCH := True;
            end if;
         else
            if W > abs (PREW) / TEN then
               SWTCH := True;
            end if;
         end if;
         --
         --        Main loop to update the values of the array   DELTA and WORK
         --
         ITER := NITER + 1;
         --
         NITER := ITER - 1;
         loop
            NITER := NITER + 1;
            exit when NITER > MAXIT;
            --
            --           Test for convergence
            --
            if abs (W) <= EPS * ERRETM then
               goto L240;
            end if;
            --
            --           Calculate the new step
            --
            if not SWTCH3 then
               DTIPSQ := WORK (IP1) * Ftn_DELTA (IP1);
               DTISQ  := WORK (I) * Ftn_DELTA (I);
               if not SWTCH then
                  if ORGATI 
                     then C := W - DTIPSQ * DW + DELSQ * (Z (I) / DTISQ) ** 2;
                     else C := W - DTISQ * DW - DELSQ * (Z (IP1) / DTIPSQ) ** 2;
                  end if;
               else
                  TEMP := Z (II) / (WORK (II) * Ftn_DELTA (II));
                  if ORGATI 
                     then DPSI := DPSI + TEMP * TEMP;
                     else DPHI := DPHI + TEMP * TEMP;
                  end if;
                  C := W - DTISQ * DPSI - DTIPSQ * DPHI;
               end if;
               A := (DTIPSQ + DTISQ) * W - DTIPSQ * DTISQ * DW;
               B := DTIPSQ * DTISQ * W;
               if C = ZERO then
                  if A = ZERO then
                     if not SWTCH then
                        if ORGATI 
                           then A := Z (I) * Z (I) + DTIPSQ * DTIPSQ * (DPSI + DPHI);
                           else A := Z (IP1) * Z (IP1) + DTISQ * DTISQ * (DPSI + DPHI);
                        end if;
                     else
                        A := DTISQ * DTISQ * DPSI + DTIPSQ * DTIPSQ * DPHI;
                     end if;
                  end if;
                  ETA := B / A;
               elsif A <= ZERO then
                  ETA := (A - Sqrt (abs (A * A - FOUR * B * C))) / (TWO * C);
               else
                  ETA := TWO * B / (A + Sqrt (abs (A * A - FOUR * B * C)));
               end if;
            else
               --
               --              Interpolation using THREE most relevant poles
               --
               DTIIM := WORK (IIM1) * Ftn_DELTA (IIM1);
               DTIIP := WORK (IIP1) * Ftn_DELTA (IIP1);
               TEMP  := RHOINV + PSI + PHI;
               if SWTCH then
                  C      := TEMP - DTIIM * DPSI - DTIIP * DPHI;
                  ZZ (1) := DTIIM * DTIIM * DPSI;
                  ZZ (3) := DTIIP * DTIIP * DPHI;
               else
                  if ORGATI then
                     TEMP1  := Z (IIM1) / DTIIM;
                     TEMP1  := TEMP1 * TEMP1;
                     TEMP2  := (D (IIM1) - D (IIP1)) * (D (IIM1) + D (IIP1)) * TEMP1;
                     C      := TEMP - DTIIP * (DPSI + DPHI) - TEMP2;
                     ZZ (1) := Z (IIM1) * Z (IIM1);
                     if DPSI < TEMP1 
                        then ZZ (3) := DTIIP * DTIIP * DPHI;
                        else ZZ (3) := DTIIP * DTIIP * ((DPSI - TEMP1) + DPHI);
                     end if;
                  else
                     TEMP1 := Z (IIP1) / DTIIP;
                     TEMP1 := TEMP1 * TEMP1;
                     TEMP2 := (D (IIP1) - D (IIM1)) * (D (IIM1) + D (IIP1)) * TEMP1;
                     C     := TEMP - DTIIM * (DPSI + DPHI) - TEMP2;
                     if DPHI < TEMP1 
                        then ZZ (1) := DTIIM * DTIIM * DPSI;
                        else ZZ (1) := DTIIM * DTIIM * (DPSI + (DPHI - TEMP1));
                     end if;
                     ZZ (3) := Z (IIP1) * Z (IIP1);
                  end if;
               end if;
               DD (1) := DTIIM;
               DD (2) := Ftn_DELTA (II) * WORK (II);
               DD (3) := DTIIP;
               DLAED6 (NITER, ORGATI, C, DD'Address, ZZ'Address, W, ETA, INFO);
               if INFO /= 0 then
                  goto L240;
               end if;
            end if;
            --
            --           Note, eta should be positive if w is negative, and
            --           eta should be negative otherwise. However,
            --           if for some reason caused by roundoff, eta*w > 0,
            --           we simply use one Newton step instead. This way
            --           will guarantee eta*w < 0.
            --
            if W * ETA >= ZERO then
               ETA := -W / DW;
            end if;
            if ORGATI then
               TEMP1 := WORK (I) * Ftn_DELTA (I);
               TEMP  := ETA - TEMP1;
            else
               TEMP1 := WORK (IP1) * Ftn_DELTA (IP1);
               TEMP  := ETA - TEMP1;
            end if;
            if TEMP > SG2UB or TEMP < SG2LB then
               if W < ZERO 
                  then ETA := (SG2UB - TAU) / TWO;
                  else ETA := (SG2LB - TAU) / TWO;
               end if;
            end if;
            --
            TAU := TAU + ETA;
            ETA := ETA / (SIGMA + Sqrt (SIGMA * SIGMA + ETA));
            --
            SIGMA := SIGMA + ETA;
            J     := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               WORK (J)      := WORK (J) + ETA;
               Ftn_DELTA (J) := Ftn_DELTA (J) - ETA;
            end loop;
            --
            PREW := W;
            --
            --           Evaluate PSI and the derivative DPSI
            --
            DPSI   := ZERO;
            PSI    := ZERO;
            ERRETM := ZERO;
            J      := 1 - 1;
            loop
               J := J + 1;
               exit when J > IIM1;
               TEMP   := Z (J) / (WORK (J) * Ftn_DELTA (J));
               PSI    := PSI + Z (J) * TEMP;
               DPSI   := DPSI + TEMP * TEMP;
               ERRETM := ERRETM + PSI;
            end loop;
            ERRETM := abs (ERRETM);
            --
            --           Evaluate PHI and the derivative DPHI
            --
            DPHI := ZERO;
            PHI  := ZERO;
            J    := N + 1;
            loop
               J := J - 1;
               exit when J < IIP1;
               TEMP   := Z (J) / (WORK (J) * Ftn_DELTA (J));
               PHI    := PHI + Z (J) * TEMP;
               DPHI   := DPHI + TEMP * TEMP;
               ERRETM := ERRETM + PHI;
            end loop;
            --
            TEMP   := Z (II) / (WORK (II) * Ftn_DELTA (II));
            DW     := DPSI + DPHI + TEMP * TEMP;
            TEMP   := Z (II) * TEMP;
            W      := RHOINV + PHI + PSI + TEMP;
            ERRETM := EIGHT * (PHI - PSI) + ERRETM + TWO * RHOINV + THREE * abs (TEMP) + abs (TAU) * DW;
            if W * PREW > ZERO and abs (W) > abs (PREW) / TEN then
               SWTCH := not SWTCH;
            end if;
            --
            if W <= ZERO 
               then SG2LB := max (SG2LB, TAU);
               else SG2UB := min (SG2UB, TAU);
            end if;
            --
         end loop;
         --
         --        Return with INFO = 1, NITER = MAXIT and not converged
         --
         INFO := 1;
         --
      end if;
      --
      <<L240>> null;
      return;
      --
      --     End of DLASD4
      --
   end DLASD4;

   procedure DLASD5
     (I         : Integer;
      D         : in out Ftn_Real_Vector;
      Z         : in out Ftn_Real_Vector;
      Ftn_DELTA : in out Ftn_Real_Vector;
      RHO       : Real;
      DSIGMA    : in out Real;
      WORK      : in out Ftn_Real_Vector)
   is
      ZERO  : constant Real := 0.0e0;
      ONE   : constant Real := 1.0e0;
      TWO   : constant Real := 2.0e0;
      THREE : constant Real := 3.0e0;
      FOUR  : constant Real := 4.0e0;
      B     : Real;
      C     : Real;
      DEL   : Real;
      DELSQ : Real;
      TAU   : Real;
      W     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD5( I, D, Z, DELTA, RHO, DSIGMA, WORK )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            I
   --       DOUBLE PRECISION   DSIGMA, RHO
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( 2 ), DELTA( 2 ), WORK( 2 ), Z( 2 )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  This subroutine computes the square root of the I-th eigenvalue
   --  of a positive symmetric rank-one modification of a 2-by-2 diagonal
   --  matrix
   --
   --             diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .
   --
   --  The diagonal entries in the array D are assumed to satisfy
   --
   --             0 <= D(i) < D(j)  for  i < j .
   --
   --  We also assume RHO > 0 and that the Euclidean norm of the vector
   --  Z is one.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] I
   --           I is INTEGER
   --          The index of the eigenvalue to be computed.  I = 1 or I = 2.
   --
   --  [in] D
   --           D is DOUBLE PRECISION array, dimension ( 2 )
   --          The original eigenvalues.  We assume 0 <= D(1) < D(2).
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension ( 2 )
   --          The components of the updating vector.
   --
   --  [out] DELTA
   --           DELTA is DOUBLE PRECISION array, dimension ( 2 )
   --          Contains (D(j) - sigma_I) in its  j-th component.
   --          The vector DELTA contains the information necessary
   --          to construct the eigenvectors.
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --          The scalar in the symmetric updating formula.
   --
   --  [out] DSIGMA
   --           DSIGMA is DOUBLE PRECISION
   --          The computed sigma_I, the I-th updated eigenvalue.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension ( 2 )
   --          WORK contains (D(j) + sigma_I) in its  j-th component.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ren-Cang Li, Computer Science Division, University of California
   --      at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, TWO = 2.0D+0, THREE = 3.0D+0, FOUR = 4.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      DEL   := D (2) - D (1);
      DELSQ := DEL * (D (2) + D (1));
      if I = 1 then
         W := ONE +
              FOUR * RHO * (Z (2) * Z (2) / (D (1) + THREE * D (2)) - Z (1) * Z (1) / (THREE * D (1) + D (2))) /
              DEL;
         if W > ZERO then
            B := DELSQ + RHO * (Z (1) * Z (1) + Z (2) * Z (2));
            C := RHO * Z (1) * Z (1) * DELSQ;
            --
            --           B > ZERO, always
            --
            --           The following TAU is DSIGMA * DSIGMA - D( 1 ) * D( 1 )
            --
            TAU := TWO * C / (B + Sqrt (abs (B * B - FOUR * C)));
            --
            --           The following TAU is DSIGMA - D( 1 )
            --
            TAU           := TAU / (D (1) + Sqrt (D (1) * D (1) + TAU));
            DSIGMA        := D (1) + TAU;
            Ftn_DELTA (1) := -TAU;
            Ftn_DELTA (2) := DEL - TAU;
            WORK (1)      := TWO * D (1) + TAU;
            WORK (2)      := (D (1) + TAU) + D (2);
         --           DELTA( 1 ) = -Z( 1 ) / TAU
         --           DELTA( 2 ) = Z( 2 ) / ( DEL-TAU )
         else
            B := -DELSQ + RHO * (Z (1) * Z (1) + Z (2) * Z (2));
            C := RHO * Z (2) * Z (2) * DELSQ;
            --
            --           The following TAU is DSIGMA * DSIGMA - D( 2 ) * D( 2 )
            --
            if B > ZERO 
               then TAU := -TWO * C / (B + Sqrt (B * B + FOUR * C));
               else TAU := (B - Sqrt (B * B + FOUR * C)) / TWO;
            end if;
            --
            --           The following TAU is DSIGMA - D( 2 )
            --
            TAU           := TAU / (D (2) + Sqrt (abs (D (2) * D (2) + TAU)));
            DSIGMA        := D (2) + TAU;
            Ftn_DELTA (1) := -(DEL + TAU);
            Ftn_DELTA (2) := -TAU;
            WORK (1)      := D (1) + TAU + D (2);
            WORK (2)      := TWO * D (2) + TAU;
            --           DELTA( 1 ) = -Z( 1 ) / ( DEL+TAU )
            --           DELTA( 2 ) = -Z( 2 ) / TAU
         end if;
      --        TEMP = SQRT( DELTA( 1 )*DELTA( 1 )+DELTA( 2 )*DELTA( 2 ) )
      --        DELTA( 1 ) = DELTA( 1 ) / TEMP
      --        DELTA( 2 ) = DELTA( 2 ) / TEMP
      else
         --
         --        Now I=2
         --
         B := -DELSQ + RHO * (Z (1) * Z (1) + Z (2) * Z (2));
         C := RHO * Z (2) * Z (2) * DELSQ;
         --
         --        The following TAU is DSIGMA * DSIGMA - D( 2 ) * D( 2 )
         --
         if B > ZERO 
            then TAU := (B + Sqrt (B * B + FOUR * C)) / TWO;
            else TAU := TWO * C / (-B + Sqrt (B * B + FOUR * C));
         end if;
         --
         --        The following TAU is DSIGMA - D( 2 )
         --
         TAU           := TAU / (D (2) + Sqrt (D (2) * D (2) + TAU));
         DSIGMA        := D (2) + TAU;
         Ftn_DELTA (1) := -(DEL + TAU);
         Ftn_DELTA (2) := -TAU;
         WORK (1)      := D (1) + TAU + D (2);
         WORK (2)      := TWO * D (2) + TAU;
         --        DELTA( 1 ) = -Z( 1 ) / ( DEL+TAU )
         --        DELTA( 2 ) = -Z( 2 ) / TAU
         --        TEMP = SQRT( DELTA( 1 )*DELTA( 1 )+DELTA( 2 )*DELTA( 2 ) )
         --        DELTA( 1 ) = DELTA( 1 ) / TEMP
         --        DELTA( 2 ) = DELTA( 2 ) / TEMP
      end if;
      return;
      --
      --     End of DLASD5
      --
   end DLASD5;

   procedure DLASD6
     (ICOMPQ     : Integer;
      NL         : Integer;
      NR         : Integer;
      SQRE       : Integer;
      D_adr      : Address;
      VF_adr     : Address;
      VL_adr     : Address;
      ALPHA      : in out Real;
      BETA       : in out Real;
      IDXQ_adr   : Address;
      PERM_adr   : Address;
      GIVPTR     : in out Integer;
      GIVCOL_adr : Address;
      LDGCOL     : Integer;
      GIVNUM_adr : Address;
      LDGNUM     : Integer;
      POLES_adr  : Address;
      DIFL_adr   : Address;
      DIFR_adr   : Address;
      Z_adr      : Address;
      K          : in out Integer;
      C          : in out Real;
      S          : in out Real;
      WORK_adr   : Address;
      IWORK_adr  : Address;
      INFO       : in out Integer)
   is

      the_N : constant Integer := NL + NR + 1;
      the_M : constant Integer := NL + NR + 1 + SQRE;

      D      : Ftn_Real_Vector (1 .. the_N);
      VF     : Ftn_Real_Vector (1 .. the_M);
      VL     : Ftn_Real_Vector (1 .. the_M);
      IDXQ   : Ftn_Integer_Vector (1 .. the_N);
      PERM   : Ftn_Integer_Vector (1 .. the_N);
      GIVCOL : Ftn_Integer_Matrix (1 .. LDGCOL, 1 .. 2);
      GIVNUM : Ftn_Real_Matrix (1 .. LDGNUM, 1 .. 2);
      POLES  : Ftn_Real_Matrix (1 .. LDGNUM, 1 .. 2);
      DIFL   : Ftn_Real_Vector (1 .. the_N);
      DIFR   : Ftn_Real_Matrix (1 .. LDGNUM, 1 .. 2); -- doc. says could be 1d or 2d array?
      Z      : Ftn_Real_Vector (1 .. the_M);
      WORK   : Ftn_Real_Vector (1 .. 4 * the_M);
      IWORK  : Ftn_Integer_Vector (1 .. 3 * the_N);

      for D'Address use D_adr;
      for VF'Address use VF_adr;
      for VL'Address use VL_adr;
      for IDXQ'Address use IDXQ_adr;
      for PERM'Address use PERM_adr;
      for GIVCOL'Address use GIVCOL_adr;
      for GIVNUM'Address use GIVNUM_adr;
      for POLES'Address use POLES_adr;
      for DIFL'Address use DIFL_adr;
      for DIFR'Address use DIFR_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, VF);
      pragma Import (Ada, VL);
      pragma Import (Ada, IDXQ);
      pragma Import (Ada, PERM);
      pragma Import (Ada, GIVCOL);
      pragma Import (Ada, GIVNUM);
      pragma Import (Ada, POLES);
      pragma Import (Ada, DIFL);
      pragma Import (Ada, DIFR);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);
      pragma Import (Ada, IWORK);

      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
      I      : Integer;
      IDX    : Integer;
      IDXC   : Integer;
      IDXP   : Integer;
      ISIGMA : Integer;
      IVFW   : Integer;
      IVLW   : Integer;
      IW     : Integer;
      M      : Integer;
      N      : Integer;
      N1     : Integer;
      N2     : Integer;
      ORGNRM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD6( ICOMPQ, NL, NR, SQRE, D, VF, VL, ALPHA, BETA,
   --                          IDXQ, PERM, GIVPTR, GIVCOL, LDGCOL, GIVNUM,
   --                          LDGNUM, POLES, DIFL, DIFR, Z, K, C, S, WORK,
   --                          IWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            GIVPTR, ICOMPQ, INFO, K, LDGCOL, LDGNUM, NL,
   --      $                   NR, SQRE
   --       DOUBLE PRECISION   ALPHA, BETA, C, S
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            GIVCOL( LDGCOL, * ), IDXQ( * ), IWORK( * ),
   --      $                   PERM( * )
   --       DOUBLE PRECISION   D( * ), DIFL( * ), DIFR( * ),
   --      $                   GIVNUM( LDGNUM, * ), POLES( LDGNUM, * ),
   --      $                   VF( * ), VL( * ), WORK( * ), Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASD6 computes the SVD of an updated upper bidiagonal matrix B
   --  obtained by merging two smaller ones by appending a row. This
   --  routine is used only for the problem which requires all singular
   --  values and optionally singular vector matrices in factored form.
   --  B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
   --  A related subroutine, DLASD1, handles the case in which all singular
   --  values and singular vectors of the bidiagonal matrix are desired.
   --
   --  DLASD6 computes the SVD as follows:
   --
   --                ( D1(in)    0    0       0 )
   --    B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
   --                (   0       0   D2(in)   0 )
   --
   --      = U(out) * ( D(out) 0) * VT(out)
   --
   --  where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
   --  with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
   --  elsewhere; and the entry b is empty if SQRE = 0.
   --
   --  The singular values of B can be computed using D1, D2, the first
   --  components of all the right singular vectors of the lower block, and
   --  the last components of all the right singular vectors of the upper
   --  block. These components are stored and updated in VF and VL,
   --  respectively, in DLASD6. Hence U and VT are not explicitly
   --  referenced.
   --
   --  The singular values are stored in D. The algorithm consists of two
   --  stages:
   --
   --        The first stage consists of deflating the size of the problem
   --        when there are multiple singular values or if there is a zero
   --        in the Z vector. For each such occurence the dimension of the
   --        secular equation problem is reduced by one. This stage is
   --        performed by the routine DLASD7.
   --
   --        The second stage consists of calculating the updated
   --        singular values. This is done by finding the roots of the
   --        secular equation via the routine DLASD4 (as called by DLASD8).
   --        This routine also updates VF and VL and computes the distances
   --        between the updated singular values and the old singular
   --        values.
   --
   --  DLASD6 is called from DLASDA.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ICOMPQ
   --           ICOMPQ is INTEGER
   --          Specifies whether singular vectors are to be computed in
   --          factored form:
   --          = 0: Compute singular values only.
   --          = 1: Compute singular vectors in factored form as well.
   --
   --  [in] NL
   --           NL is INTEGER
   --          The row dimension of the upper block.  NL >= 1.
   --
   --  [in] NR
   --           NR is INTEGER
   --          The row dimension of the lower block.  NR >= 1.
   --
   --  [in] SQRE
   --           SQRE is INTEGER
   --          = 0: the lower block is an NR-by-NR square matrix.
   --          = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
   --
   --          The bidiagonal matrix has row dimension N = NL + NR + 1,
   --          and column dimension M = N + SQRE.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension ( NL+NR+1 ).
   --          On entry D(1:NL,1:NL) contains the singular values of the
   --          upper block, and D(NL+2:N) contains the singular values
   --          of the lower block. On exit D(1:N) contains the singular
   --          values of the modified matrix.
   --
   --  [in,out] VF
   --           VF is DOUBLE PRECISION array, dimension ( M )
   --          On entry, VF(1:NL+1) contains the first components of all
   --          right singular vectors of the upper block; and VF(NL+2:M)
   --          contains the first components of all right singular vectors
   --          of the lower block. On exit, VF contains the first components
   --          of all right singular vectors of the bidiagonal matrix.
   --
   --  [in,out] VL
   --           VL is DOUBLE PRECISION array, dimension ( M )
   --          On entry, VL(1:NL+1) contains the  last components of all
   --          right singular vectors of the upper block; and VL(NL+2:M)
   --          contains the last components of all right singular vectors of
   --          the lower block. On exit, VL contains the last components of
   --          all right singular vectors of the bidiagonal matrix.
   --
   --  [in,out] ALPHA
   --           ALPHA is DOUBLE PRECISION
   --          Contains the diagonal element associated with the added row.
   --
   --  [in,out] BETA
   --           BETA is DOUBLE PRECISION
   --          Contains the off-diagonal element associated with the added
   --          row.
   --
   --  [out] IDXQ
   --           IDXQ is INTEGER array, dimension ( N )
   --          This contains the permutation which will reintegrate the
   --          subproblem just solved back into sorted order, i.e.
   --          D( IDXQ( I = 1, N ) ) will be in ascending order.
   --
   --  [out] PERM
   --           PERM is INTEGER array, dimension ( N )
   --          The permutations (from deflation and sorting) to be applied
   --          to each block. Not referenced if ICOMPQ = 0.
   --
   --  [out] GIVPTR
   --           GIVPTR is INTEGER
   --          The number of Givens rotations which took place in this
   --          subproblem. Not referenced if ICOMPQ = 0.
   --
   --  [out] GIVCOL
   --           GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
   --          Each pair of numbers indicates a pair of columns to take place
   --          in a Givens rotation. Not referenced if ICOMPQ = 0.
   --
   --  [in] LDGCOL
   --           LDGCOL is INTEGER
   --          leading dimension of GIVCOL, must be at least N.
   --
   --  [out] GIVNUM
   --           GIVNUM is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
   --          Each number indicates the C or S value to be used in the
   --          corresponding Givens rotation. Not referenced if ICOMPQ = 0.
   --
   --  [in] LDGNUM
   --           LDGNUM is INTEGER
   --          The leading dimension of GIVNUM and POLES, must be at least N.
   --
   --  [out] POLES
   --           POLES is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
   --          On exit, POLES(1,*) is an array containing the new singular
   --          values obtained from solving the secular equation, and
   --          POLES(2,*) is an array containing the poles in the secular
   --          equation. Not referenced if ICOMPQ = 0.
   --
   --  [out] DIFL
   --           DIFL is DOUBLE PRECISION array, dimension ( N )
   --          On exit, DIFL(I) is the distance between I-th updated
   --          (undeflated) singular value and the I-th (undeflated) old
   --          singular value.
   --
   --  [out] DIFR
   --           DIFR is DOUBLE PRECISION array,
   --                   dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
   --                   dimension ( N ) if ICOMPQ = 0.
   --          On exit, DIFR(I, 1) is the distance between I-th updated
   --          (undeflated) singular value and the I+1-th (undeflated) old
   --          singular value.
   --
   --          If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
   --          normalizing factors for the right singular vector matrix.
   --
   --          See DLASD8 for details on DIFL and DIFR.
   --
   --  [out] Z
   --           Z is DOUBLE PRECISION array, dimension ( M )
   --          The first elements of this array contain the components
   --          of the deflation-adjusted updating row vector.
   --
   --  [out] K
   --           K is INTEGER
   --          Contains the dimension of the non-deflated matrix,
   --          This is the order of the related secular equation. 1 <= K <=N.
   --
   --  [out] C
   --           C is DOUBLE PRECISION
   --          C contains garbage if SQRE =0 and the C-value of a Givens
   --          rotation related to the right null space if SQRE = 1.
   --
   --  [out] S
   --           S is DOUBLE PRECISION
   --          S contains garbage if SQRE =0 and the S-value of a Givens
   --          rotation related to the right null space if SQRE = 1.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension ( 4 * M )
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension ( 3 * N )
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, a singular value did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLAMRG, DLASCL, DLASD7, DLASD8, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      N    := NL + NR + 1;
      M    := N + SQRE;
      --
      if (ICOMPQ < 0) or (ICOMPQ > 1) then
         INFO := -1;
      elsif NL < 1 then
         INFO := -2;
      elsif NR < 1 then
         INFO := -3;
      elsif (SQRE < 0) or (SQRE > 1) then
         INFO := -4;
      elsif LDGCOL < N then
         INFO := -14;
      elsif LDGNUM < N then
         INFO := -16;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASD6", -INFO);
         return;
      end if;
      --
      --     The following values are for bookkeeping purposes only.  They are
      --     integer pointers which indicate the portion of the workspace
      --     used by a particular array in DLASD7 and DLASD8.
      --
      ISIGMA := 1;
      IW     := ISIGMA + N;
      IVFW   := IW + M;
      IVLW   := IVFW + M;
      --
      IDX  := 1;
      IDXC := IDX + N;
      IDXP := IDXC + N;
      --
      --     Scale.
      --
      ORGNRM     := max (abs (ALPHA), abs (BETA));
      D (NL + 1) := ZERO;
      I          := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         if abs (D (I)) > ORGNRM then
            ORGNRM := abs (D (I));
         end if;
      end loop;
      DLASCL ('G', 0, 0, ORGNRM, ONE, N, 1, D'Address, N, INFO);
      ALPHA := ALPHA / ORGNRM;
      BETA  := BETA / ORGNRM;
      --
      --     Sort and Deflate singular values.
      --
      DLASD7
        (ICOMPQ,
         NL,
         NR,
         SQRE,
         K,
         D'Address,
         Z'Address,
         WORK (IW)'Address,
         VF'Address,
         WORK (IVFW)'Address,
         VL'Address,
         WORK (IVLW)'Address,
         ALPHA,
         BETA,
         WORK (ISIGMA)'Address,
         IWORK (IDX)'Address,
         IWORK (IDXP)'Address,
         IDXQ'Address,
         PERM'Address,
         GIVPTR,
         GIVCOL'Address,
         LDGCOL,
         GIVNUM'Address,
         LDGNUM,
         C,
         S,
         INFO);
      --
      --     Solve Secular Equation, compute DIFL, DIFR, and update VF, VL.
      --
      DLASD8
        (ICOMPQ,
         K,
         D'Address,
         Z'Address,
         VF'Address,
         VL'Address,
         DIFL'Address,
         DIFR'Address,
         LDGNUM,
         WORK (ISIGMA)'Address,
         WORK (IW)'Address,
         INFO);
      --
      --     Handle error returned
      --
      if INFO /= 0 then
         XERBLA ("DLASD8", -INFO);
         return;
      end if;
      --
      --     Save the poles if ICOMPQ = 1.
      --
      if ICOMPQ = 1 then
         DCOPY (K, D'Address, 1, POLES (1, 1)'Address, 1);
         DCOPY (K, WORK (ISIGMA)'Address, 1, POLES (1, 2)'Address, 1);
      end if;
      --
      --     Unscale.
      --
      DLASCL ('G', 0, 0, ONE, ORGNRM, N, 1, D'Address, N, INFO);
      --
      --     Prepare the IDXQ sorting permutation.
      --
      N1 := K;
      N2 := N - K;
      DLAMRG (N1, N2, D'Address, 1, -1, IDXQ'Address);
      --
      return;
      --
      --     End of DLASD6
      --
   end DLASD6;

   procedure DLASD7
     (ICOMPQ     : Integer;
      NL         : Integer;
      NR         : Integer;
      SQRE       : Integer;
      K          : in out Integer;
      D_adr      : Address;
      Z_adr      : Address;
      ZW_adr     : Address;
      VF_adr     : Address;
      VFW_adr    : Address;
      VL_adr     : Address;
      VLW_adr    : Address;
      ALPHA      : Real;
      BETA       : Real;
      DSIGMA_adr : Address;
      IDX_adr    : Address;
      IDXP_adr   : Address;
      IDXQ_adr   : Address;
      PERM_adr   : Address;
      GIVPTR     : in out Integer;
      GIVCOL_adr : Address;
      LDGCOL     : Integer;
      GIVNUM_adr : Address;
      LDGNUM     : Integer;
      C          : in out Real;
      S          : in out Real;
      INFO       : in out Integer)
   is

      the_N : constant Integer := NL + NR + 1;
      the_M : constant Integer := NL + NR + 1 + SQRE;

      D      : Ftn_Real_Vector (1 .. the_N);
      Z      : Ftn_Real_Vector (1 .. the_M);
      ZW     : Ftn_Real_Vector (1 .. the_M);
      VF     : Ftn_Real_Vector (1 .. the_M);
      VFW    : Ftn_Real_Vector (1 .. the_M);
      VL     : Ftn_Real_Vector (1 .. the_M);
      VLW    : Ftn_Real_Vector (1 .. the_M);
      DSIGMA : Ftn_Real_Vector (1 .. the_N);
      IDX    : Ftn_Integer_Vector (1 .. the_N);
      IDXP   : Ftn_Integer_Vector (1 .. the_N);
      IDXQ   : Ftn_Integer_Vector (1 .. the_N);
      PERM   : Ftn_Integer_Vector (1 .. the_N);
      GIVCOL : Ftn_Integer_Matrix (1 .. LDGCOL, 1 .. 2);
      GIVNUM : Ftn_Real_Matrix (1 .. LDGNUM, 1 .. 2);

      for D'Address use D_adr;
      for Z'Address use Z_adr;
      for ZW'Address use ZW_adr;
      for VF'Address use VF_adr;
      for VFW'Address use VFW_adr;
      for VL'Address use VL_adr;
      for VLW'Address use VLW_adr;
      for DSIGMA'Address use DSIGMA_adr;
      for IDX'Address use IDX_adr;
      for IDXP'Address use IDXP_adr;
      for IDXQ'Address use IDXQ_adr;
      for PERM'Address use PERM_adr;
      for GIVCOL'Address use GIVCOL_adr;
      for GIVNUM'Address use GIVNUM_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Z);
      pragma Import (Ada, ZW);
      pragma Import (Ada, VF);
      pragma Import (Ada, VFW);
      pragma Import (Ada, VL);
      pragma Import (Ada, VLW);
      pragma Import (Ada, DSIGMA);
      pragma Import (Ada, IDX);
      pragma Import (Ada, IDXP);
      pragma Import (Ada, IDXQ);
      pragma Import (Ada, PERM);
      pragma Import (Ada, GIVCOL);
      pragma Import (Ada, GIVNUM);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      EIGHT  : constant Real := 8.0e0;
      I      : Integer;
      IDXI   : Integer;
      IDXJ   : Integer;
      IDXJP  : Integer;
      J      : Integer;
      JP     : Integer;
      JPREV  : Integer;
      K2     : Integer;
      M      : Integer;
      N      : Integer;
      NLP1   : Integer;
      NLP2   : Integer;
      EPS    : Real;
      HLFTOL : Real;
      TAU    : Real;
      TOL    : Real;
      Z1     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD7( ICOMPQ, NL, NR, SQRE, K, D, Z, ZW, VF, VFW, VL,
   --                          VLW, ALPHA, BETA, DSIGMA, IDX, IDXP, IDXQ,
   --                          PERM, GIVPTR, GIVCOL, LDGCOL, GIVNUM, LDGNUM,
   --                          C, S, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            GIVPTR, ICOMPQ, INFO, K, LDGCOL, LDGNUM, NL,
   --      $                   NR, SQRE
   --       DOUBLE PRECISION   ALPHA, BETA, C, S
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            GIVCOL( LDGCOL, * ), IDX( * ), IDXP( * ),
   --      $                   IDXQ( * ), PERM( * )
   --       DOUBLE PRECISION   D( * ), DSIGMA( * ), GIVNUM( LDGNUM, * ),
   --      $                   VF( * ), VFW( * ), VL( * ), VLW( * ), Z( * ),
   --      $                   ZW( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASD7 merges the two sets of singular values together into a single
   --  sorted set. Then it tries to deflate the size of the problem. There
   --  are two ways in which deflation can occur:  when two or more singular
   --  values are close together or if there is a tiny entry in the Z
   --  vector. For each such occurrence the order of the related
   --  secular equation problem is reduced by one.
   --
   --  DLASD7 is called from DLASD6.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ICOMPQ
   --           ICOMPQ is INTEGER
   --           Specifies whether singular vectors are to be computed
   --           in compact form, as follows:
   --           = 0: Compute singular values only.
   --           = 1: Compute singular vectors of upper
   --                bidiagonal matrix in compact form.
   --
   --  [in] NL
   --           NL is INTEGER
   --          The row dimension of the upper block. NL >= 1.
   --
   --  [in] NR
   --           NR is INTEGER
   --          The row dimension of the lower block. NR >= 1.
   --
   --  [in] SQRE
   --           SQRE is INTEGER
   --          = 0: the lower block is an NR-by-NR square matrix.
   --          = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
   --
   --          The bidiagonal matrix has
   --          N = NL + NR + 1 rows and
   --          M = N + SQRE >= N columns.
   --
   --  [out] K
   --           K is INTEGER
   --          Contains the dimension of the non-deflated matrix, this is
   --          the order of the related secular equation. 1 <= K <=N.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension ( N )
   --          On entry D contains the singular values of the two submatrices
   --          to be combined. On exit D contains the trailing (N-K) updated
   --          singular values (those which were deflated) sorted into
   --          increasing order.
   --
   --  [out] Z
   --           Z is DOUBLE PRECISION array, dimension ( M )
   --          On exit Z contains the updating row vector in the secular
   --          equation.
   --
   --  [out] ZW
   --           ZW is DOUBLE PRECISION array, dimension ( M )
   --          Workspace for Z.
   --
   --  [in,out] VF
   --           VF is DOUBLE PRECISION array, dimension ( M )
   --          On entry, VF(1:NL+1) contains the first components of all
   --          right singular vectors of the upper block; and VF(NL+2:M)
   --          contains the first components of all right singular vectors
   --          of the lower block. On exit, VF contains the first components
   --          of all right singular vectors of the bidiagonal matrix.
   --
   --  [out] VFW
   --           VFW is DOUBLE PRECISION array, dimension ( M )
   --          Workspace for VF.
   --
   --  [in,out] VL
   --           VL is DOUBLE PRECISION array, dimension ( M )
   --          On entry, VL(1:NL+1) contains the  last components of all
   --          right singular vectors of the upper block; and VL(NL+2:M)
   --          contains the last components of all right singular vectors
   --          of the lower block. On exit, VL contains the last components
   --          of all right singular vectors of the bidiagonal matrix.
   --
   --  [out] VLW
   --           VLW is DOUBLE PRECISION array, dimension ( M )
   --          Workspace for VL.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION
   --          Contains the diagonal element associated with the added row.
   --
   --  [in] BETA
   --           BETA is DOUBLE PRECISION
   --          Contains the off-diagonal element associated with the added
   --          row.
   --
   --  [out] DSIGMA
   --           DSIGMA is DOUBLE PRECISION array, dimension ( N )
   --          Contains a copy of the diagonal elements (K-1 singular values
   --          and one zero) in the secular equation.
   --
   --  [out] IDX
   --           IDX is INTEGER array, dimension ( N )
   --          This will contain the permutation used to sort the contents of
   --          D into ascending order.
   --
   --  [out] IDXP
   --           IDXP is INTEGER array, dimension ( N )
   --          This will contain the permutation used to place deflated
   --          values of D at the end of the array. On output IDXP(2:K)
   --          points to the nondeflated D-values and IDXP(K+1:N)
   --          points to the deflated singular values.
   --
   --  [in] IDXQ
   --           IDXQ is INTEGER array, dimension ( N )
   --          This contains the permutation which separately sorts the two
   --          sub-problems in D into ascending order.  Note that entries in
   --          the first half of this permutation must first be moved one
   --          position backward; and entries in the second half
   --          must first have NL+1 added to their values.
   --
   --  [out] PERM
   --           PERM is INTEGER array, dimension ( N )
   --          The permutations (from deflation and sorting) to be applied
   --          to each singular block. Not referenced if ICOMPQ = 0.
   --
   --  [out] GIVPTR
   --           GIVPTR is INTEGER
   --          The number of Givens rotations which took place in this
   --          subproblem. Not referenced if ICOMPQ = 0.
   --
   --  [out] GIVCOL
   --           GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
   --          Each pair of numbers indicates a pair of columns to take place
   --          in a Givens rotation. Not referenced if ICOMPQ = 0.
   --
   --  [in] LDGCOL
   --           LDGCOL is INTEGER
   --          The leading dimension of GIVCOL, must be at least N.
   --
   --  [out] GIVNUM
   --           GIVNUM is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
   --          Each number indicates the C or S value to be used in the
   --          corresponding Givens rotation. Not referenced if ICOMPQ = 0.
   --
   --  [in] LDGNUM
   --           LDGNUM is INTEGER
   --          The leading dimension of GIVNUM, must be at least N.
   --
   --  [out] C
   --           C is DOUBLE PRECISION
   --          C contains garbage if SQRE =0 and the C-value of a Givens
   --          rotation related to the right null space if SQRE = 1.
   --
   --  [out] S
   --           S is DOUBLE PRECISION
   --          S contains garbage if SQRE =0 and the S-value of a Givens
   --          rotation related to the right null space if SQRE = 1.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --          = 0:  successful exit.
   --          < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, TWO = 2.0D+0, EIGHT = 8.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLAMRG, DROT, XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH, DLAPY2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      N    := NL + NR + 1;
      M    := N + SQRE;
      --
      if (ICOMPQ < 0) or (ICOMPQ > 1) then
         INFO := -1;
      elsif NL < 1 then
         INFO := -2;
      elsif NR < 1 then
         INFO := -3;
      elsif (SQRE < 0) or (SQRE > 1) then
         INFO := -4;
      elsif LDGCOL < N then
         INFO := -22;
      elsif LDGNUM < N then
         INFO := -24;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASD7", -INFO);
         return;
      end if;
      --
      NLP1 := NL + 1;
      NLP2 := NL + 2;
      if ICOMPQ = 1 then
         GIVPTR := 0;
      end if;
      --
      --     Generate the first part of the vector Z and move the singular
      --     values in the first part of D one position backward.
      --
      Z1        := ALPHA * VL (NLP1);
      VL (NLP1) := ZERO;
      TAU       := VF (NLP1);
      I         := NL + 1;
      loop
         I := I - 1;
         exit when I < 1;
         Z (I + 1)    := ALPHA * VL (I);
         VL (I)       := ZERO;
         VF (I + 1)   := VF (I);
         D (I + 1)    := D (I);
         IDXQ (I + 1) := IDXQ (I) + 1;
      end loop;
      VF (1) := TAU;
      --
      --     Generate the second part of the vector Z.
      --
      I := NLP2 - 1;
      loop
         I := I + 1;
         exit when I > M;
         Z (I)  := BETA * VF (I);
         VF (I) := ZERO;
      end loop;
      --
      --     Sort the singular values into increasing order
      --
      I := NLP2 - 1;
      loop
         I := I + 1;
         exit when I > N;
         IDXQ (I) := IDXQ (I) + NLP1;
      end loop;
      --
      --     DSIGMA, IDXC, IDXC, and ZW are used as storage space.
      --
      I := 2 - 1;
      loop
         I := I + 1;
         exit when I > N;
         DSIGMA (I) := D (IDXQ (I));
         ZW (I)     := Z (IDXQ (I));
         VFW (I)    := VF (IDXQ (I));
         VLW (I)    := VL (IDXQ (I));
      end loop;
      --
      DLAMRG (NL, NR, DSIGMA (2)'Address, 1, 1, IDX (2)'Address);
      --
      I := 2 - 1;
      loop
         I := I + 1;
         exit when I > N;
         IDXI   := 1 + IDX (I);
         D (I)  := DSIGMA (IDXI);
         Z (I)  := ZW (IDXI);
         VF (I) := VFW (IDXI);
         VL (I) := VLW (IDXI);
      end loop;
      --
      --     Calculate the allowable deflation tolerence
      --
      EPS := DLAMCH ('E');
      TOL := max (abs (ALPHA), abs (BETA));
      TOL := EIGHT * EIGHT * EPS * max (abs (D (N)), TOL);
      --
      --     There are 2 kinds of deflation -- first a value in the z-vector
      --     is small, second two (or more) singular values are very close
      --     together (their difference is small).
      --
      --     If the value in the z-vector is small, we simply permute the
      --     array so that the corresponding singular value is moved to the
      --     end.
      --
      --     If two values in the D-vector are close, we perform a two-sided
      --     rotation designed to make one of the corresponding z-vector
      --     entries zero, and then permute the array so that the deflated
      --     singular value is moved to the end.
      --
      --     If there are multiple singular values then the problem deflates.
      --     Here the number of equal singular values are found.  As each equal
      --     singular value is found, an elementary reflector is computed to
      --     rotate the corresponding singular subspace so that the
      --     corresponding components of Z are zero in this new basis.
      --
      K  := 1;
      K2 := N + 1;
      J  := 2 - 1;
      loop
         J := J + 1;
         exit when J > N;
         if abs (Z (J)) <= TOL then
            --
            --           Deflate due to small z component.
            --
            K2        := K2 - 1;
            IDXP (K2) := J;
            if J = N then
               -- ?? ---------------------------
               goto L100;
               -- ?? ---------------------------
            end if;
         else
            JPREV := J;
            -- ?? ---------------------------
            goto L70;
            -- ?? ---------------------------
         end if;
      end loop;
      <<L70>> null;
      J := JPREV;
      <<L80>> null;
      J := J + 1;
      if J > N then
         -- ?? ---------------------------
         goto L90;
         -- ?? ---------------------------
      end if;
      if abs (Z (J)) <= TOL then
         --
         --        Deflate due to small z component.
         --
         K2        := K2 - 1;
         IDXP (K2) := J;
      else
         --
         --        Check if singular values are close enough to allow deflation.
         --
         if abs (D (J) - D (JPREV)) <= TOL then
            --
            --           Deflation is possible.
            --
            S := Z (JPREV);
            C := Z (J);
            --
            --           Find sqrt(a**2+b**2) without overflow or
            --           destructive underflow.
            --
            TAU       := DLAPY2 (C, S);
            Z (J)     := TAU;
            Z (JPREV) := ZERO;
            C         := C / TAU;
            S         := -S / TAU;
            --
            --           Record the appropriate Givens rotation
            --
            if ICOMPQ = 1 then
               GIVPTR := GIVPTR + 1;
               IDXJP  := IDXQ (IDX (JPREV) + 1);
               IDXJ   := IDXQ (IDX (J) + 1);
               if IDXJP <= NLP1 then
                  IDXJP := IDXJP - 1;
               end if;
               if IDXJ <= NLP1 then
                  IDXJ := IDXJ - 1;
               end if;
               GIVCOL (GIVPTR, 2) := IDXJP;
               GIVCOL (GIVPTR, 1) := IDXJ;
               GIVNUM (GIVPTR, 2) := C;
               GIVNUM (GIVPTR, 1) := S;
            end if;
            DROT (1, VF (JPREV)'Address, 1, VF (J)'Address, 1, C, S);
            DROT (1, VL (JPREV)'Address, 1, VL (J)'Address, 1, C, S);
            K2        := K2 - 1;
            IDXP (K2) := JPREV;
            JPREV     := J;
         else
            K          := K + 1;
            ZW (K)     := Z (JPREV);
            DSIGMA (K) := D (JPREV);
            IDXP (K)   := JPREV;
            JPREV      := J;
         end if;
      end if;
      -- ?? ---------------------------
      goto L80;
      -- ?? ---------------------------
      <<L90>> null;
      --
      --     Record the last singular value.
      --
      K          := K + 1;
      ZW (K)     := Z (JPREV);
      DSIGMA (K) := D (JPREV);
      IDXP (K)   := JPREV;
      --
      <<L100>> null;
      --
      --     Sort the singular values into DSIGMA. The singular values which
      --     were not deflated go into the first K slots of DSIGMA, except
      --     that DSIGMA(1) is treated separately.
      --
      J := 2 - 1;
      loop
         J := J + 1;
         exit when J > N;
         JP         := IDXP (J);
         DSIGMA (J) := D (JP);
         VFW (J)    := VF (JP);
         VLW (J)    := VL (JP);
      end loop;
      if ICOMPQ = 1 then
         J := 2 - 1;
         loop
            J := J + 1;
            exit when J > N;
            JP       := IDXP (J);
            PERM (J) := IDXQ (IDX (JP) + 1);
            if PERM (J) <= NLP1 then
               PERM (J) := PERM (J) - 1;
            end if;
         end loop;
      end if;
      --
      --     The deflated singular values go back into the last N - K slots of D.
      --
      DCOPY (N - K, DSIGMA (K + 1)'Address, 1, D (K + 1)'Address, 1);
      --
      --     Determine DSIGMA(1), DSIGMA(2), Z(1), VF(1), VL(1), VF(M), and
      --     VL(M).
      --
      DSIGMA (1) := ZERO;
      HLFTOL     := TOL / TWO;
      if abs (DSIGMA (2)) <= HLFTOL then
         DSIGMA (2) := HLFTOL;
      end if;
      if M > N then
         Z (1) := DLAPY2 (Z1, Z (M));
         if Z (1) <= TOL then
            C     := ONE;
            S     := ZERO;
            Z (1) := TOL;
         else
            C := Z1 / Z (1);
            S := -Z (M) / Z (1);
         end if;
         DROT (1, VF (M)'Address, 1, VF (1)'Address, 1, C, S);
         DROT (1, VL (M)'Address, 1, VL (1)'Address, 1, C, S);
      else
         if abs (Z1) <= TOL 
            then Z (1) := TOL;
            else Z (1) := Z1;
         end if;
      end if;
      --
      --     Restore Z, VF, and VL.
      --
      DCOPY (K - 1, ZW (2)'Address, 1, Z (2)'Address, 1);
      DCOPY (N - 1, VFW (2)'Address, 1, VF (2)'Address, 1);
      DCOPY (N - 1, VLW (2)'Address, 1, VL (2)'Address, 1);
      --
      return;
      --
      --     End of DLASD7
      --
   end DLASD7;

   procedure DLASD8
     (ICOMPQ     : Integer;
      K          : Integer;
      D_adr      : Address;
      Z_adr      : Address;
      VF_adr     : Address;
      VL_adr     : Address;
      DIFL_adr   : Address;
      DIFR_adr   : Address;
      LDDIFR     : Integer;
      DSIGMA_adr : Address;
      WORK_adr   : Address;
      INFO       : in out Integer)
   is

      D      : Ftn_Real_Vector (1 .. K);
      Z      : Ftn_Real_Vector (1 .. K);
      VF     : Ftn_Real_Vector (1 .. K);
      VL     : Ftn_Real_Vector (1 .. K);
      DIFL   : Ftn_Real_Vector (1 .. K);
      DIFR   : Ftn_Real_Matrix (1 .. LDDIFR, 1 .. 2); -- doc. says could be 1d or 2d array?
      DSIGMA : Ftn_Real_Vector (1 .. K);
      WORK   : Ftn_Real_Vector (1 .. 3 * K);

      for D'Address use D_adr;
      for Z'Address use Z_adr;
      for VF'Address use VF_adr;
      for VL'Address use VL_adr;
      for DIFL'Address use DIFL_adr;
      for DIFR'Address use DIFR_adr;
      for DSIGMA'Address use DSIGMA_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Z);
      pragma Import (Ada, VF);
      pragma Import (Ada, VL);
      pragma Import (Ada, DIFL);
      pragma Import (Ada, DIFR);
      pragma Import (Ada, DSIGMA);
      pragma Import (Ada, WORK);

      ONE    : constant Real := 1.0e0;
      I      : Integer;
      IWK1   : Integer;
      IWK2   : Integer;
      IWK2I  : Integer;
      IWK3   : Integer;
      IWK3I  : Integer;
      J      : Integer;
      DIFLJ  : Real;
      DIFRJ  : Real;
      DJ     : Real;
      DSIGJ  : Real;
      DSIGJP : Real;
      RHO    : Real;
      TEMP   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASD8( ICOMPQ, K, D, Z, VF, VL, DIFL, DIFR, LDDIFR,
   --                          DSIGMA, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            ICOMPQ, INFO, K, LDDIFR
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), DIFL( * ), DIFR( LDDIFR, * ),
   --      $                   DSIGMA( * ), VF( * ), VL( * ), WORK( * ),
   --      $                   Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASD8 finds the square roots of the roots of the secular equation,
   --  as defined by the values in DSIGMA and Z. It makes the appropriate
   --  calls to DLASD4, and stores, for each  element in D, the distance
   --  to its two nearest poles (elements in DSIGMA). It also updates
   --  the arrays VF and VL, the first and last components of all the
   --  right singular vectors of the original bidiagonal matrix.
   --
   --  DLASD8 is called from DLASD6.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ICOMPQ
   --           ICOMPQ is INTEGER
   --           Specifies whether singular vectors are to be computed in
   --           factored form in the calling routine:
   --           = 0: Compute singular values only.
   --           = 1: Compute singular vectors in factored form as well.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of terms in the rational function to be solved
   --           by DLASD4.  K >= 1.
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension ( K )
   --           On output, D contains the updated singular values.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension ( K )
   --           On entry, the first K elements of this array contain the
   --           components of the deflation-adjusted updating row vector.
   --           On exit, Z is updated.
   --
   --  [in,out] VF
   --           VF is DOUBLE PRECISION array, dimension ( K )
   --           On entry, VF contains  information passed through DBEDE8.
   --           On exit, VF contains the first K components of the first
   --           components of all right singular vectors of the bidiagonal
   --           matrix.
   --
   --  [in,out] VL
   --           VL is DOUBLE PRECISION array, dimension ( K )
   --           On entry, VL contains  information passed through DBEDE8.
   --           On exit, VL contains the first K components of the last
   --           components of all right singular vectors of the bidiagonal
   --           matrix.
   --
   --  [out] DIFL
   --           DIFL is DOUBLE PRECISION array, dimension ( K )
   --           On exit, DIFL(I) = D(I) - DSIGMA(I).
   --
   --  [out] DIFR
   --           DIFR is DOUBLE PRECISION array,
   --                    dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
   --                    dimension ( K ) if ICOMPQ = 0.
   --           On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
   --           defined and will not be referenced.
   --
   --           If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
   --           normalizing factors for the right singular vector matrix.
   --
   --  [in] LDDIFR
   --           LDDIFR is INTEGER
   --           The leading dimension of DIFR, must be at least K.
   --
   --  [in,out] DSIGMA
   --           DSIGMA is DOUBLE PRECISION array, dimension ( K )
   --           On entry, the first K elements of this array contain the old
   --           roots of the deflated updating problem.  These are the poles
   --           of the secular equation.
   --           On exit, the elements of DSIGMA may be very slightly altered
   --           in value.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension at least 3 * K
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, a singular value did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLASCL, DLASD4, DLASET, XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DDOT, DLAMC3, DNRM2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if (ICOMPQ < 0) or (ICOMPQ > 1) then
         INFO := -1;
      elsif K < 1 then
         INFO := -2;
      elsif LDDIFR < K then
         INFO := -9;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASD8", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if K = 1 then
         D (1)    := abs (Z (1));
         DIFL (1) := D (1);
         if ICOMPQ = 1 then
            DIFL (2)    := ONE;
            DIFR (1, 2) := ONE;
         end if;
         return;
      end if;
      --
      --     Modify values DSIGMA(i) to make sure all DSIGMA(i)-DSIGMA(j) can
      --     be computed with high relative accuracy (barring over/underflow).
      --     This is a problem on machines without a guard digit in
      --     add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
      --     The following code replaces DSIGMA(I) by 2*DSIGMA(I)-DSIGMA(I),
      --     which on any of these machines zeros out the bottommost
      --     bit of DSIGMA(I) if it is 1; this makes the subsequent
      --     subtractions DSIGMA(I)-DSIGMA(J) unproblematic when cancellation
      --     occurs. On binary machines with a guard digit (almost all
      --     machines) it does not change DSIGMA(I) at all. On hexadecimal
      --     and decimal machines with a guard digit, it slightly
      --     changes the bottommost bits of DSIGMA(I). It does not account
      --     for hexadecimal or decimal machines without guard digits
      --     (we know of none). We use a subroutine call to compute
      --     2*DLAMBDA(I) to prevent optimizing compilers from eliminating
      --     this code.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         DSIGMA (I) := DLAMC3 (DSIGMA (I), DSIGMA (I)) - DSIGMA (I);
      end loop;
      --
      --     Book keeping.
      --
      IWK1  := 1;
      IWK2  := IWK1 + K;
      IWK3  := IWK2 + K;
      IWK2I := IWK2 - 1;
      IWK3I := IWK3 - 1;
      --
      --     Normalize Z.
      --
      RHO := DNRM2 (K, Z'Address, 1);
      DLASCL ('G', 0, 0, RHO, ONE, K, 1, Z'Address, K, INFO);
      RHO := RHO * RHO;
      --
      --     Initialize WORK(IWK3).
      --
      DLASET ('A', K, 1, ONE, ONE, WORK (IWK3)'Address, K);
      --
      --     Compute the updated singular values, the arrays DIFL, DIFR,
      --     and the updated Z.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > K;
         DLASD4 (K, J, DSIGMA'Address, Z'Address, WORK (IWK1)'Address, RHO, D (J), WORK (IWK2)'Address, INFO);
         --
         --        If the root finder fails, the computation is terminated.
         --
         if INFO /= 0 then
            XERBLA ("DLASD4", -INFO);
            return;
         end if;
         WORK (IWK3I + J) := WORK (IWK3I + J) * WORK (J) * WORK (IWK2I + J);
         DIFL (J)         := -WORK (J);
         DIFR (J, 1)      := -WORK (J + 1);
         I                := 1 - 1;
         loop
            I := I + 1;
            exit when I > J - 1;
            WORK (IWK3I + I) := WORK (IWK3I + I) * WORK (I) * WORK (IWK2I + I) /
                                (DSIGMA (I) - DSIGMA (J)) /
                                (DSIGMA (I) + DSIGMA (J));
         end loop;
         I := J + 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            WORK (IWK3I + I) := WORK (IWK3I + I) * WORK (I) * WORK (IWK2I + I) /
                                (DSIGMA (I) - DSIGMA (J)) /
                                (DSIGMA (I) + DSIGMA (J));
         end loop;
      end loop;
      --
      --     Compute updated Z.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         Z (I) := sign (Sqrt (abs (WORK (IWK3I + I))), Z (I));
      end loop;
      --
      --     Update VF and VL.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > K;
         DIFLJ := DIFL (J);
         DJ    := D (J);
         DSIGJ := -DSIGMA (J);
         if J < K then
            DIFRJ  := -DIFR (J, 1);
            DSIGJP := -DSIGMA (J + 1);
         end if;
         WORK (J) := -Z (J) / DIFLJ / (DSIGMA (J) + DJ);
         I        := 1 - 1;
         loop
            I := I + 1;
            exit when I > J - 1;
            WORK (I) := Z (I) / (DLAMC3 (DSIGMA (I), DSIGJ) - DIFLJ) / (DSIGMA (I) + DJ);
         end loop;
         I := J + 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            WORK (I) := Z (I) / (DLAMC3 (DSIGMA (I), DSIGJP) + DIFRJ) / (DSIGMA (I) + DJ);
         end loop;
         TEMP             := DNRM2 (K, WORK'Address, 1);
         WORK (IWK2I + J) := DDOT (K, WORK'Address, 1, VF'Address, 1) / TEMP;
         WORK (IWK3I + J) := DDOT (K, WORK'Address, 1, VL'Address, 1) / TEMP;
         if ICOMPQ = 1 then
            DIFR (J, 2) := TEMP;
         end if;
      end loop;
      --
      DCOPY (K, WORK (IWK2)'Address, 1, VF'Address, 1);
      DCOPY (K, WORK (IWK3)'Address, 1, VL'Address, 1);
      --
      return;
      --
      --     End of DLASD8
      --
   end DLASD8;

   procedure DLASDA
     (ICOMPQ     : Integer;
      SMLSIZ     : Integer;
      N          : Integer;
      SQRE       : Integer;
      D_adr      : Address;
      E_adr      : Address;
      U_adr      : Address;
      LDU        : Integer;
      VT_adr     : Address;
      K_adr      : Address;
      DIFL_adr   : Address;
      DIFR_adr   : Address;
      Z_adr      : Address;
      POLES_adr  : Address;
      GIVPTR_adr : Address;
      GIVCOL_adr : Address;
      LDGCOL     : Integer;
      PERM_adr   : Address;
      GIVNUM_adr : Address;
      C_adr      : Address;
      S_adr      : Address;
      WORK_adr   : Address;
      IWORK_adr  : Address;
      INFO       : in out Integer)
   is

      the_M    : constant Integer := max (N, N + 1);
      the_NLVL : constant Integer := int (log2 (Real (N) / Real (SMLSIZ))); -- LCB, fix this

      D      : Ftn_Real_Vector (1 .. N);
      E      : Ftn_Real_Vector (1 .. the_M - 1);
      U      : Ftn_Real_Matrix (1 .. LDU, 1 .. SMLSIZ);
      VT     : Ftn_Real_Matrix (1 .. LDU, 1 .. SMLSIZ + 1);
      K      : Ftn_Integer_Vector (1 .. N);
      DIFL   : Ftn_Real_Matrix (1 .. LDU, 1 .. the_NLVL);
      DIFR   : Ftn_Real_Matrix (1 .. LDU, 1 .. 2 * the_NLVL); -- doc. says could be 1d or 2d array?
      Z      : Ftn_Real_Matrix (1 .. LDU, 1 .. the_NLVL);
      POLES  : Ftn_Real_Matrix (1 .. LDU, 1 .. 2 * the_NLVL);
      GIVPTR : Ftn_Integer_Vector (1 .. N);
      GIVCOL : Ftn_Integer_Matrix (1 .. LDGCOL, 1 .. 2 * the_NLVL);
      PERM   : Ftn_Integer_Matrix (1 .. LDGCOL, 1 .. the_NLVL);
      GIVNUM : Ftn_Real_Matrix (1 .. LDU, 1 .. 2 * the_NLVL);
      C      : Ftn_Real_Vector (1 .. N);
      S      : Ftn_Real_Vector (1 .. N);
      WORK   : Ftn_Real_Vector (1 .. 6 * N + (SMLSIZ + 1) * (SMLSIZ + 1));
      IWORK  : Ftn_Integer_Vector (1 .. 7 * N);

      for D'Address use D_adr;
      for E'Address use E_adr;
      for U'Address use U_adr;
      for VT'Address use VT_adr;
      for K'Address use K_adr;
      for DIFL'Address use DIFL_adr;
      for DIFR'Address use DIFR_adr;
      for Z'Address use Z_adr;
      for POLES'Address use POLES_adr;
      for GIVPTR'Address use GIVPTR_adr;
      for GIVCOL'Address use GIVCOL_adr;
      for PERM'Address use PERM_adr;
      for GIVNUM'Address use GIVNUM_adr;
      for C'Address use C_adr;
      for S'Address use S_adr;
      for WORK'Address use WORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, U);
      pragma Import (Ada, VT);
      pragma Import (Ada, K);
      pragma Import (Ada, DIFL);
      pragma Import (Ada, DIFR);
      pragma Import (Ada, Z);
      pragma Import (Ada, POLES);
      pragma Import (Ada, GIVPTR);
      pragma Import (Ada, GIVCOL);
      pragma Import (Ada, PERM);
      pragma Import (Ada, GIVNUM);
      pragma Import (Ada, C);
      pragma Import (Ada, S);
      pragma Import (Ada, WORK);
      pragma Import (Ada, IWORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      I      : Integer;
      I1     : Integer;
      IC     : Integer;
      IDXQ   : Integer;
      IDXQI  : Integer;
      IM1    : Integer;
      INODE  : Integer;
      ITEMP  : Integer;
      IWK    : Integer;
      J      : Integer;
      LF     : Integer;
      LL     : Integer;
      LVL    : Integer;
      LVL2   : Integer;
      M      : Integer;
      NCC    : Integer;
      ND     : Integer;
      NDB1   : Integer;
      NDIML  : Integer;
      NDIMR  : Integer;
      NL     : Integer;
      NLF    : Integer;
      NLP1   : Integer;
      NLVL   : Integer;
      NR     : Integer;
      NRF    : Integer;
      NRP1   : Integer;
      NRU    : Integer;
      NWORK1 : Integer;
      NWORK2 : Integer;
      SMLSZP : Integer;
      SQREI  : Integer;
      VF     : Integer;
      VFI    : Integer;
      VL     : Integer;
      VLI    : Integer;
      ALPHA  : Real;
      BETA   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASDA( ICOMPQ, SMLSIZ, N, SQRE, D, E, U, LDU, VT, K,
   --                          DIFL, DIFR, Z, POLES, GIVPTR, GIVCOL, LDGCOL,
   --                          PERM, GIVNUM, C, S, WORK, IWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            ICOMPQ, INFO, LDGCOL, LDU, N, SMLSIZ, SQRE
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            GIVCOL( LDGCOL, * ), GIVPTR( * ), IWORK( * ),
   --      $                   K( * ), PERM( LDGCOL, * )
   --       DOUBLE PRECISION   C( * ), D( * ), DIFL( LDU, * ), DIFR( LDU, * ),
   --      $                   E( * ), GIVNUM( LDU, * ), POLES( LDU, * ),
   --      $                   S( * ), U( LDU, * ), VT( LDU, * ), WORK( * ),
   --      $                   Z( LDU, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  Using a divide and conquer approach, DLASDA computes the singular
   --  value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
   --  B with diagonal D and offdiagonal E, where M = N + SQRE. The
   --  algorithm computes the singular values in the SVD B = U * S * VT.
   --  The orthogonal matrices U and VT are optionally computed in
   --  compact form.
   --
   --  A related subroutine, DLASD0, computes the singular values and
   --  the singular vectors in explicit form.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ICOMPQ
   --           ICOMPQ is INTEGER
   --          Specifies whether singular vectors are to be computed
   --          in compact form, as follows
   --          = 0: Compute singular values only.
   --          = 1: Compute singular vectors of upper bidiagonal
   --               matrix in compact form.
   --
   --  [in] SMLSIZ
   --           SMLSIZ is INTEGER
   --          The maximum size of the subproblems at the bottom of the
   --          computation tree.
   --
   --  [in] N
   --           N is INTEGER
   --          The row dimension of the upper bidiagonal matrix. This is
   --          also the dimension of the main diagonal array D.
   --
   --  [in] SQRE
   --           SQRE is INTEGER
   --          Specifies the column dimension of the bidiagonal matrix.
   --          = 0: The bidiagonal matrix has column dimension M = N;
   --          = 1: The bidiagonal matrix has column dimension M = N + 1.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension ( N )
   --          On entry D contains the main diagonal of the bidiagonal
   --          matrix. On exit D, if INFO = 0, contains its singular values.
   --
   --  [in] E
   --           E is DOUBLE PRECISION array, dimension ( M-1 )
   --          Contains the subdiagonal entries of the bidiagonal matrix.
   --          On exit, E has been destroyed.
   --
   --  [out] U
   --           U is DOUBLE PRECISION array,
   --          dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
   --          if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
   --          singular vector matrices of all subproblems at the bottom
   --          level.
   --
   --  [in] LDU
   --           LDU is INTEGER, LDU = > N.
   --          The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
   --          GIVNUM, and Z.
   --
   --  [out] VT
   --           VT is DOUBLE PRECISION array,
   --          dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
   --          if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT**T contains the right
   --          singular vector matrices of all subproblems at the bottom
   --          level.
   --
   --  [out] K
   --           K is INTEGER array,
   --          dimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
   --          If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
   --          secular equation on the computation tree.
   --
   --  [out] DIFL
   --           DIFL is DOUBLE PRECISION array, dimension ( LDU, NLVL ),
   --          where NLVL = floor(log_2 (N/SMLSIZ)).
   --
   --  [out] DIFR
   --           DIFR is DOUBLE PRECISION array,
   --                   dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
   --                   dimension ( N ) if ICOMPQ = 0.
   --          If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
   --          record distances between singular values on the I-th
   --          level and singular values on the (I -1)-th level, and
   --          DIFR(1:N, 2 * I ) contains the normalizing factors for
   --          the right singular vector matrix. See DLASD8 for details.
   --
   --  [out] Z
   --           Z is DOUBLE PRECISION array,
   --                   dimension ( LDU, NLVL ) if ICOMPQ = 1 and
   --                   dimension ( N ) if ICOMPQ = 0.
   --          The first K elements of Z(1, I) contain the components of
   --          the deflation-adjusted updating row vector for subproblems
   --          on the I-th level.
   --
   --  [out] POLES
   --           POLES is DOUBLE PRECISION array,
   --          dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
   --          if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
   --          POLES(1, 2*I) contain  the new and old singular values
   --          involved in the secular equations on the I-th level.
   --
   --  [out] GIVPTR
   --           GIVPTR is INTEGER array,
   --          dimension ( N ) if ICOMPQ = 1, and not referenced if
   --          ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records
   --          the number of Givens rotations performed on the I-th
   --          problem on the computation tree.
   --
   --  [out] GIVCOL
   --           GIVCOL is INTEGER array,
   --          dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
   --          referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
   --          GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
   --          of Givens rotations performed on the I-th level on the
   --          computation tree.
   --
   --  [in] LDGCOL
   --           LDGCOL is INTEGER, LDGCOL = > N.
   --          The leading dimension of arrays GIVCOL and PERM.
   --
   --  [out] PERM
   --           PERM is INTEGER array,
   --          dimension ( LDGCOL, NLVL ) if ICOMPQ = 1, and not referenced
   --          if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
   --          permutations done on the I-th level of the computation tree.
   --
   --  [out] GIVNUM
   --           GIVNUM is DOUBLE PRECISION array,
   --          dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
   --          referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
   --          GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
   --          values of Givens rotations performed on the I-th level on
   --          the computation tree.
   --
   --  [out] C
   --           C is DOUBLE PRECISION array,
   --          dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
   --          If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
   --          C( I ) contains the C-value of a Givens rotation related to
   --          the right null space of the I-th subproblem.
   --
   --  [out] S
   --           S is DOUBLE PRECISION array, dimension ( N ) if
   --          ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
   --          and the I-th subproblem is not square, on exit, S( I )
   --          contains the S-value of a Givens rotation related to
   --          the right null space of the I-th subproblem.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension
   --          (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).
   --
   --  [out] IWORK
   --           IWORK is INTEGER array.
   --          Dimension must be at least (7 * N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, a singular value did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLASD6, DLASDQ, DLASDT, DLASET, XERBLA
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if (ICOMPQ < 0) or (ICOMPQ > 1) then
         INFO := -1;
      elsif SMLSIZ < 3 then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif (SQRE < 0) or (SQRE > 1) then
         INFO := -4;
      elsif LDU < (N + SQRE) then
         INFO := -8;
      elsif LDGCOL < N then
         INFO := -17;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASDA", -INFO);
         return;
      end if;
      --
      M := N + SQRE;
      --
      --     If the input matrix is too small, call DLASDQ to find the SVD.
      --
      if N <= SMLSIZ then
         if ICOMPQ = 0 then
            DLASDQ
              ('U',
               SQRE,
               N,
               0,
               0,
               0,
               D'Address,
               E'Address,
               VT'Address,
               LDU,
               U'Address,
               LDU,
               U'Address,
               LDU,
               WORK'Address,
               INFO);
         else
            DLASDQ
              ('U',
               SQRE,
               N,
               M,
               N,
               0,
               D'Address,
               E'Address,
               VT'Address,
               LDU,
               U'Address,
               LDU,
               U'Address,
               LDU,
               WORK'Address,
               INFO);
         end if;
         return;
      end if;
      --
      --     Book-keeping and  set up the computation tree.
      --
      INODE := 1;
      NDIML := INODE + N;
      NDIMR := NDIML + N;
      IDXQ  := NDIMR + N;
      IWK   := IDXQ + N;
      --
      NCC := 0;
      NRU := 0;
      --
      SMLSZP := SMLSIZ + 1;
      VF     := 1;
      VL     := VF + M;
      NWORK1 := VL + M;
      NWORK2 := NWORK1 + SMLSZP * SMLSZP;
      --
      DLASDT (N, NLVL, ND, IWORK (INODE)'Address, IWORK (NDIML)'Address, IWORK (NDIMR)'Address, SMLSIZ);
      --
      --     for the nodes on bottom level of the tree, solve
      --     their subproblems by DLASDQ.
      --
      NDB1 := (ND + 1) / 2;
      I    := NDB1 - 1;
      loop
         I := I + 1;
         exit when I > ND;
         --
         --        IC : center row of each node
         --        NL : number of rows of left  subproblem
         --        NR : number of rows of right subproblem
         --        NLF: starting row of the left   subproblem
         --        NRF: starting row of the right  subproblem
         --
         I1    := I - 1;
         IC    := IWORK (INODE + I1);
         NL    := IWORK (NDIML + I1);
         NLP1  := NL + 1;
         NR    := IWORK (NDIMR + I1);
         NLF   := IC - NL;
         NRF   := IC + 1;
         IDXQI := IDXQ + NLF - 2;
         VFI   := VF + NLF - 1;
         VLI   := VL + NLF - 1;
         SQREI := 1;
         if ICOMPQ = 0 then
            DLASET ('A', NLP1, NLP1, ZERO, ONE, WORK (NWORK1)'Address, SMLSZP);
            DLASDQ
              ('U',
               SQREI,
               NL,
               NLP1,
               NRU,
               NCC,
               D (NLF)'Address,
               E (NLF)'Address,
               WORK (NWORK1)'Address,
               SMLSZP,
               WORK (NWORK2)'Address,
               NL,
               WORK (NWORK2)'Address,
               NL,
               WORK (NWORK2)'Address,
               INFO);
            ITEMP := NWORK1 + NL * SMLSZP;
            DCOPY (NLP1, WORK (NWORK1)'Address, 1, WORK (VFI)'Address, 1);
            DCOPY (NLP1, WORK (ITEMP)'Address, 1, WORK (VLI)'Address, 1);
         else
            DLASET ('A', NL, NL, ZERO, ONE, U (NLF, 1)'Address, LDU);
            DLASET ('A', NLP1, NLP1, ZERO, ONE, VT (NLF, 1)'Address, LDU);
            DLASDQ
              ('U',
               SQREI,
               NL,
               NLP1,
               NL,
               NCC,
               D (NLF)'Address,
               E (NLF)'Address,
               VT (NLF, 1)'Address,
               LDU,
               U (NLF, 1)'Address,
               LDU,
               U (NLF, 1)'Address,
               LDU,
               WORK (NWORK1)'Address,
               INFO);
            DCOPY (NLP1, VT (NLF, 1)'Address, 1, WORK (VFI)'Address, 1);
            DCOPY (NLP1, VT (NLF, NLP1)'Address, 1, WORK (VLI)'Address, 1);
         end if;
         if INFO /= 0 then
            return;
         end if;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > NL;
            IWORK (IDXQI + J) := J;
         end loop;
         if (I = ND) and (SQRE = 0) 
            then SQREI := 0;
            else SQREI := 1;
         end if;
         IDXQI := IDXQI + NLP1;
         VFI   := VFI + NLP1;
         VLI   := VLI + NLP1;
         NRP1  := NR + SQREI;
         if ICOMPQ = 0 then
            DLASET ('A', NRP1, NRP1, ZERO, ONE, WORK (NWORK1)'Address, SMLSZP);
            DLASDQ
              ('U',
               SQREI,
               NR,
               NRP1,
               NRU,
               NCC,
               D (NRF)'Address,
               E (NRF)'Address,
               WORK (NWORK1)'Address,
               SMLSZP,
               WORK (NWORK2)'Address,
               NR,
               WORK (NWORK2)'Address,
               NR,
               WORK (NWORK2)'Address,
               INFO);
            ITEMP := NWORK1 + (NRP1 - 1) * SMLSZP;
            DCOPY (NRP1, WORK (NWORK1)'Address, 1, WORK (VFI)'Address, 1);
            DCOPY (NRP1, WORK (ITEMP)'Address, 1, WORK (VLI)'Address, 1);
         else
            DLASET ('A', NR, NR, ZERO, ONE, U (NRF, 1)'Address, LDU);
            DLASET ('A', NRP1, NRP1, ZERO, ONE, VT (NRF, 1)'Address, LDU);
            DLASDQ
              ('U',
               SQREI,
               NR,
               NRP1,
               NR,
               NCC,
               D (NRF)'Address,
               E (NRF)'Address,
               VT (NRF, 1)'Address,
               LDU,
               U (NRF, 1)'Address,
               LDU,
               U (NRF, 1)'Address,
               LDU,
               WORK (NWORK1)'Address,
               INFO);
            DCOPY (NRP1, VT (NRF, 1)'Address, 1, WORK (VFI)'Address, 1);
            DCOPY (NRP1, VT (NRF, NRP1)'Address, 1, WORK (VLI)'Address, 1);
         end if;
         if INFO /= 0 then
            return;
         end if;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > NR;
            IWORK (IDXQI + J) := J;
         end loop;
      end loop;
      --
      --     Now conquer each subproblem bottom-up.
      --
      J   := 2 ** NLVL;
      LVL := NLVL + 1;
      loop
         LVL := LVL - 1;
         exit when LVL < 1;
         LVL2 := LVL * 2 - 1;
         --
         --        Find the first node LF and last node LL on
         --        the current level LVL.
         --
         if LVL = 1 then
            LF := 1;
            LL := 1;
         else
            LF := 2 ** (LVL - 1);
            LL := 2 * LF - 1;
         end if;
         I := LF - 1;
         loop
            I := I + 1;
            exit when I > LL;
            IM1 := I - 1;
            IC  := IWORK (INODE + IM1);
            NL  := IWORK (NDIML + IM1);
            NR  := IWORK (NDIMR + IM1);
            NLF := IC - NL;
            NRF := IC + 1;
            if I = LL 
               then SQREI := SQRE;
               else SQREI := 1;
            end if;
            VFI   := VF + NLF - 1;
            VLI   := VL + NLF - 1;
            IDXQI := IDXQ + NLF - 1;
            ALPHA := D (IC);
            BETA  := E (IC);
            if ICOMPQ = 0 then
               DLASD6
                 (ICOMPQ,
                  NL,
                  NR,
                  SQREI,
                  D (NLF)'Address,
                  WORK (VFI)'Address,
                  WORK (VLI)'Address,
                  ALPHA,
                  BETA,
                  IWORK (IDXQI)'Address,
                  PERM'Address,
                  GIVPTR (1),
                  GIVCOL'Address,
                  LDGCOL,
                  GIVNUM'Address,
                  LDU,
                  POLES'Address,
                  DIFL'Address,
                  DIFR'Address,
                  Z'Address,
                  K (1),
                  C (1),
                  S (1),
                  WORK (NWORK1)'Address,
                  IWORK (IWK)'Address,
                  INFO);
            else
               J := J - 1;
               DLASD6
                 (ICOMPQ,
                  NL,
                  NR,
                  SQREI,
                  D (NLF)'Address,
                  WORK (VFI)'Address,
                  WORK (VLI)'Address,
                  ALPHA,
                  BETA,
                  IWORK (IDXQI)'Address,
                  PERM (NLF, LVL)'Address,
                  GIVPTR (J),
                  GIVCOL (NLF, LVL2)'Address,
                  LDGCOL,
                  GIVNUM (NLF, LVL2)'Address,
                  LDU,
                  POLES (NLF, LVL2)'Address,
                  DIFL (NLF, LVL)'Address,
                  DIFR (NLF, LVL2)'Address,
                  Z (NLF, LVL)'Address,
                  K (J),
                  C (J),
                  S (J),
                  WORK (NWORK1)'Address,
                  IWORK (IWK)'Address,
                  INFO);
            end if;
            if INFO /= 0 then
               return;
            end if;
         end loop;
      end loop;
      --
      return;
      --
      --     End of DLASDA
      --
   end DLASDA;

   procedure DLASDQ
     (UPLO     : Character;
      SQRE     : Integer;
      N        : Integer;
      NCVT     : Integer;
      NRU      : Integer;
      NCC      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      VT_adr   : Address;
      LDVT     : Integer;
      U_adr    : Address;
      LDU      : Integer;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      D    : Ftn_Real_Vector (1 .. N);
      E    : Ftn_Real_Vector (1 .. N - 1);
      VT   : Ftn_Real_Matrix (1 .. LDVT, 1 .. NCVT);
      U    : Ftn_Real_Matrix (1 .. LDU, 1 .. N);
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. NCC);
      WORK : Ftn_Real_Vector (1 .. 4 * N);

      for D'Address use D_adr;
      for E'Address use E_adr;
      for VT'Address use VT_adr;
      for U'Address use U_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, VT);
      pragma Import (Ada, U);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      ROTATE : Boolean;
      I      : Integer;
      ISUB   : Integer;
      IUPLO  : Integer;
      J      : Integer;
      NP1    : Integer;
      SQRE1  : Integer;
      CS     : Real;
      R      : Real;
      SMIN   : Real;
      SN     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASDQ( UPLO, SQRE, N, NCVT, NRU, NCC, D, E, VT, LDVT,
   --                          U, LDU, C, LDC, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDC, LDU, LDVT, N, NCC, NCVT, NRU, SQRE
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   C( LDC, * ), D( * ), E( * ), U( LDU, * ),
   --      $                   VT( LDVT, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASDQ computes the singular value decomposition (SVD) of a real
   --  (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
   --  E, accumulating the transformations if desired. Letting B denote
   --  the input bidiagonal matrix, the algorithm computes orthogonal
   --  matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
   --  of P). The singular values S are overwritten on D.
   --
   --  The input matrix U  is changed to U  * Q  if desired.
   --  The input matrix VT is changed to P**T * VT if desired.
   --  The input matrix C  is changed to Q**T * C  if desired.
   --
   --  See "Computing  Small Singular Values of Bidiagonal Matrices With
   --  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
   --  LAPACK Working Note #3, for a detailed description of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --         On entry, UPLO specifies whether the input bidiagonal matrix
   --         is upper or lower bidiagonal, and wether it is square are
   --         not.
   --            UPLO = 'U' or 'u'   B is upper bidiagonal.
   --            UPLO = 'L' or 'l'   B is lower bidiagonal.
   --
   --  [in] SQRE
   --           SQRE is INTEGER
   --         = 0: then the input matrix is N-by-N.
   --         = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
   --              (N+1)-by-N if UPLU = 'L'.
   --
   --         The bidiagonal matrix has
   --         N = NL + NR + 1 rows and
   --         M = N + SQRE >= N columns.
   --
   --  [in] N
   --           N is INTEGER
   --         On entry, N specifies the number of rows and columns
   --         in the matrix. N must be at least 0.
   --
   --  [in] NCVT
   --           NCVT is INTEGER
   --         On entry, NCVT specifies the number of columns of
   --         the matrix VT. NCVT must be at least 0.
   --
   --  [in] NRU
   --           NRU is INTEGER
   --         On entry, NRU specifies the number of rows of
   --         the matrix U. NRU must be at least 0.
   --
   --  [in] NCC
   --           NCC is INTEGER
   --         On entry, NCC specifies the number of columns of
   --         the matrix C. NCC must be at least 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --         On entry, D contains the diagonal entries of the
   --         bidiagonal matrix whose SVD is desired. On normal exit,
   --         D contains the singular values in ascending order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array.
   --         dimension is (N-1) if SQRE = 0 and N if SQRE = 1.
   --         On entry, the entries of E contain the offdiagonal entries
   --         of the bidiagonal matrix whose SVD is desired. On normal
   --         exit, E will contain 0. If the algorithm does not converge,
   --         D and E will contain the diagonal and superdiagonal entries
   --         of a bidiagonal matrix orthogonally equivalent to the one
   --         given as input.
   --
   --  [in,out] VT
   --           VT is DOUBLE PRECISION array, dimension (LDVT, NCVT)
   --         On entry, contains a matrix which on exit has been
   --         premultiplied by P**T, dimension N-by-NCVT if SQRE = 0
   --         and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --         On entry, LDVT specifies the leading dimension of VT as
   --         declared in the calling (sub) program. LDVT must be at
   --         least 1. If NCVT is nonzero LDVT must also be at least N.
   --
   --  [in,out] U
   --           U is DOUBLE PRECISION array, dimension (LDU, N)
   --         On entry, contains a  matrix which on exit has been
   --         postmultiplied by Q, dimension NRU-by-N if SQRE = 0
   --         and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).
   --
   --  [in] LDU
   --           LDU is INTEGER
   --         On entry, LDU  specifies the leading dimension of U as
   --         declared in the calling (sub) program. LDU must be at
   --         least max( 1, NRU ) .
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC, NCC)
   --         On entry, contains an N-by-NCC matrix which on exit
   --         has been premultiplied by Q**T  dimension N-by-NCC if SQRE = 0
   --         and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).
   --
   --  [in] LDC
   --           LDC is INTEGER
   --         On entry, LDC  specifies the leading dimension of C as
   --         declared in the calling (sub) program. LDC must be at
   --         least 1. If NCC is nonzero, LDC must also be at least N.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (4*N)
   --         Workspace. Only referenced if one of NCVT, NRU, or NCC is
   --         nonzero, and if N is at least 2.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --         On exit, a value of 0 indicates a successful exit.
   --         If INFO < 0, argument number -INFO is illegal.
   --         If INFO > 0, the algorithm did not converge, and INFO
   --         specifies how many superdiagonals did not converge.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DBDSQR, DLARTG, DLASR, DSWAP, XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO  := 0;
      IUPLO := 0;
      if LSAME (UPLO, 'U') then
         IUPLO := 1;
      end if;
      if LSAME (UPLO, 'L') then
         IUPLO := 2;
      end if;
      if IUPLO = 0 then
         INFO := -1;
      elsif (SQRE < 0) or (SQRE > 1) then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif NCVT < 0 then
         INFO := -4;
      elsif NRU < 0 then
         INFO := -5;
      elsif NCC < 0 then
         INFO := -6;
      elsif (NCVT = 0 and LDVT < 1) or (NCVT > 0 and LDVT < max (1, N)) then
         INFO := -10;
      elsif LDU < max (1, NRU) then
         INFO := -12;
      elsif (NCC = 0 and LDC < 1) or (NCC > 0 and LDC < max (1, N)) then
         INFO := -14;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASDQ", -INFO);
         return;
      end if;
      if N = 0 then
         return;
      end if;
      --
      --     ROTATE is true if any singular vectors desired, false otherwise
      --
      ROTATE := (NCVT > 0) or (NRU > 0) or (NCC > 0);
      NP1    := N + 1;
      SQRE1  := SQRE;
      --
      --     If matrix non-square upper bidiagonal, rotate to be lower
      --     bidiagonal.  The rotations are on the right.
      --
      if (IUPLO = 1) and (SQRE1 = 1) then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            DLARTG (D (I), E (I), CS, SN, R);
            D (I)     := R;
            E (I)     := SN * D (I + 1);
            D (I + 1) := CS * D (I + 1);
            if ROTATE then
               WORK (I)     := CS;
               WORK (N + I) := SN;
            end if;
         end loop;
         DLARTG (D (N), E (N), CS, SN, R);
         D (N) := R;
         E (N) := ZERO;
         if ROTATE then
            WORK (N)     := CS;
            WORK (N + N) := SN;
         end if;
         IUPLO := 2;
         SQRE1 := 0;
         --
         --        Update singular vectors if desired.
         --
         if NCVT > 0 then
            DLASR ('L', 'V', 'F', NP1, NCVT, WORK (1)'Address, WORK (NP1)'Address, VT'Address, LDVT);
         end if;
      end if;
      --
      --     If matrix lower bidiagonal, rotate to be upper bidiagonal
      --     by applying Givens rotations on the left.
      --
      if IUPLO = 2 then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            DLARTG (D (I), E (I), CS, SN, R);
            D (I)     := R;
            E (I)     := SN * D (I + 1);
            D (I + 1) := CS * D (I + 1);
            if ROTATE then
               WORK (I)     := CS;
               WORK (N + I) := SN;
            end if;
         end loop;
         --
         --        If matrix (N+1)-by-N lower bidiagonal, one additional
         --        rotation is needed.
         --
         if SQRE1 = 1 then
            DLARTG (D (N), E (N), CS, SN, R);
            D (N) := R;
            if ROTATE then
               WORK (N)     := CS;
               WORK (N + N) := SN;
            end if;
         end if;
         --
         --        Update singular vectors if desired.
         --
         if NRU > 0 then
            if SQRE1 = 0 
               then DLASR ('R', 'V', 'F', NRU, N, WORK (1)'Address, WORK (NP1)'Address, U'Address, LDU);
               else DLASR ('R', 'V', 'F', NRU, NP1, WORK (1)'Address, WORK (NP1)'Address, U'Address, LDU);
            end if;
         end if;
         if NCC > 0 then
            if SQRE1 = 0 
               then DLASR ('L', 'V', 'F', N, NCC, WORK (1)'Address, WORK (NP1)'Address, C'Address, LDC);
               else DLASR ('L', 'V', 'F', NP1, NCC, WORK (1)'Address, WORK (NP1)'Address, C'Address, LDC);
            end if;
         end if;
      end if;
      --
      --     Call DBDSQR to compute the SVD of the reduced real
      --     N-by-N upper bidiagonal matrix.
      --
      DBDSQR
        ('U',
         N,
         NCVT,
         NRU,
         NCC,
         D'Address,
         E'Address,
         VT'Address,
         LDVT,
         U'Address,
         LDU,
         C'Address,
         LDC,
         WORK'Address,
         INFO);
      --
      --     Sort the singular values into ascending order (insertion sort on
      --     singular values, but only one transposition per singular vector)
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         --
         --        Scan for smallest D(I).
         --
         ISUB := I;
         SMIN := D (I);
         J    := I + 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if D (J) < SMIN then
               ISUB := J;
               SMIN := D (J);
            end if;
         end loop;
         if ISUB /= I then
            --
            --           Swap singular values and vectors.
            --
            D (ISUB) := D (I);
            D (I)    := SMIN;
            if NCVT > 0 then
               DSWAP (NCVT, VT (ISUB, 1)'Address, LDVT, VT (I, 1)'Address, LDVT);
            end if;
            if NRU > 0 then
               DSWAP (NRU, U (1, ISUB)'Address, 1, U (1, I)'Address, 1);
            end if;
            if NCC > 0 then
               DSWAP (NCC, C (ISUB, 1)'Address, LDC, C (I, 1)'Address, LDC);
            end if;
         end if;
      end loop;
      --
      return;
      --
      --     End of DLASDQ
      --
   end DLASDQ;

   procedure DLASDT
     (N         : Integer;
      LVL       : in out Integer;
      ND        : in out Integer;
      INODE_adr : Address;
      NDIML_adr : Address;
      NDIMR_adr : Address;
      MSUB      : Integer)
   is

      INODE : Ftn_Integer_Vector (1 .. N);
      NDIML : Ftn_Integer_Vector (1 .. N);
      NDIMR : Ftn_Integer_Vector (1 .. N);

      for INODE'Address use INODE_adr;
      for NDIML'Address use NDIML_adr;
      for NDIMR'Address use NDIMR_adr;

      pragma Import (Ada, INODE);
      pragma Import (Ada, NDIML);
      pragma Import (Ada, NDIMR);

      TWO   : constant Real := 2.0e0;
      I     : Integer;
      IL    : Integer;
      IR    : Integer;
      LLST  : Integer;
      MAXN  : Integer;
      NCRNT : Integer;
      NLVL  : Integer;
      TEMP  : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASDT( N, LVL, ND, INODE, NDIML, NDIMR, MSUB )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            LVL, MSUB, N, ND
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            INODE( * ), NDIML( * ), NDIMR( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASDT creates a tree of subproblems for bidiagonal divide and
   --  conquer.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           On entry, the number of diagonal elements of the
   --           bidiagonal matrix.
   --
   --  [out] LVL
   --           LVL is INTEGER
   --           On exit, the number of levels on the computation tree.
   --
   --  [out] ND
   --           ND is INTEGER
   --           On exit, the number of nodes on the tree.
   --
   --  [out] INODE
   --           INODE is INTEGER array, dimension ( N )
   --           On exit, centers of subproblems.
   --
   --  [out] NDIML
   --           NDIML is INTEGER array, dimension ( N )
   --           On exit, row dimensions of left children.
   --
   --  [out] NDIMR
   --           NDIMR is INTEGER array, dimension ( N )
   --           On exit, row dimensions of right children.
   --
   --  [in] MSUB
   --           MSUB is INTEGER
   --           On entry, the maximum row dimension each subproblem at the
   --           bottom of the tree can be of.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( TWO = 2.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, INT, LOG, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Find the number of levels on the tree.
   --
   begin
      MAXN := max (1, N);
      TEMP := Log (Real (MAXN) / Real (MSUB + 1)) / Log (TWO);
      LVL  := int (TEMP) + 1;
      --
      I         := N / 2;
      INODE (1) := I + 1;
      NDIML (1) := I;
      NDIMR (1) := N - I - 1;
      IL        := 0;
      IR        := 1;
      LLST      := 1;
      NLVL      := 1 - 1;
      loop
         NLVL := NLVL + 1;
         exit when NLVL > LVL - 1;
         --
         --        Constructing the tree at (NLVL+1)-st level. The number of
         --        nodes created on this level is LLST * 2.
         --
         I := 0 - 1;
         loop
            I := I + 1;
            exit when I > LLST - 1;
            IL         := IL + 2;
            IR         := IR + 2;
            NCRNT      := LLST + I;
            NDIML (IL) := NDIML (NCRNT) / 2;
            NDIMR (IL) := NDIML (NCRNT) - NDIML (IL) - 1;
            INODE (IL) := INODE (NCRNT) - NDIMR (IL) - 1;
            NDIML (IR) := NDIMR (NCRNT) / 2;
            NDIMR (IR) := NDIMR (NCRNT) - NDIML (IR) - 1;
            INODE (IR) := INODE (NCRNT) + NDIML (IR) + 1;
         end loop;
         LLST := LLST * 2;
      end loop;
      ND := LLST * 2 - 1;
      --
      return;
      --
      --     End of DLASDT
      --
   end DLASDT;

   procedure DLASET
     (UPLO  : Character;
      M     : Integer;
      N     : Integer;
      ALPHA : Real;
      BETA  : Real;
      A_adr : Address;
      LDA   : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);

      for A'Address use A_adr;

      pragma Import (Ada, A);

      I : Integer;
      J : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASET( UPLO, M, N, ALPHA, BETA, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            LDA, M, N
   --       DOUBLE PRECISION   ALPHA, BETA
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASET initializes an m-by-n matrix A to BETA on the diagonal and
   --  ALPHA on the offdiagonals.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies the part of the matrix A to be set.
   --           = 'U':      Upper triangular part is set; the strictly lower
   --                       triangular part of A is not changed.
   --           = 'L':      Lower triangular part is set; the strictly upper
   --                       triangular part of A is not changed.
   --           Otherwise:  All of the matrix A is set.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in] ALPHA
   --           ALPHA is DOUBLE PRECISION
   --           The constant to which the offdiagonal elements are to be set.
   --
   --  [in] BETA
   --           BETA is DOUBLE PRECISION
   --           The constant to which the diagonal elements are to be set.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On exit, the leading m-by-n submatrix of A is set as follows:
   --
   --           if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
   --           if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
   --           otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,
   --
   --           and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if LSAME (UPLO, 'U') then
         --
         --        Set the strictly upper triangular or trapezoidal part of the
         --        array to ALPHA.
         --
         J := 2 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J - 1, M);
               A (I, J) := ALPHA;
            end loop;
         end loop;
      --
      elsif LSAME (UPLO, 'L') then
         --
         --        Set the strictly lower triangular or trapezoidal part of the
         --        array to ALPHA.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > min (M, N);
            I := J + 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := ALPHA;
            end loop;
         end loop;
      --
      else
         --
         --        Set the leading m-by-n submatrix to ALPHA.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := ALPHA;
            end loop;
         end loop;
      end if;
      --
      --     Set the first min(M,N) diagonal elements to BETA.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > min (M, N);
         A (I, I) := BETA;
      end loop;
      --
      return;
      --
      --     End of DLASET
      --
   end DLASET;

   procedure DLASQ1
     (N    : Integer;
      D    : in out Ftn_Real_Vector;
      E    : in out Ftn_Real_Vector;
      WORK : in out Ftn_Real_Vector;
      INFO : in out Integer)
   is
      ZERO   : constant Real := 0.0e0;
      I      : Integer;
      IINFO  : Integer;
      EPS    : Real;
      SCALE  : Real;
      SAFMIN : Real;
      SIGMN  : Real;
      SIGMX  : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASQ1( N, D, E, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASQ1 computes the singular values of a real N-by-N bidiagonal
   --  matrix with diagonal D and off-diagonal E. The singular values
   --  are computed to high relative accuracy, in the absence of
   --  denormalization, underflow and overflow. The algorithm was first
   --  presented in
   --
   --  "Accurate singular values and differential qd algorithms" by K. V.
   --  Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
   --  1994,
   --
   --  and the present implementation is described in "An implementation of
   --  the dqds Algorithm (Positive Case)", LAPACK Working Note.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --         The number of rows and columns in the matrix. N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --         On entry, D contains the diagonal elements of the
   --         bidiagonal matrix whose SVD is desired. On normal exit,
   --         D contains the singular values in decreasing order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N)
   --         On entry, elements E(1:N-1) contain the off-diagonal elements
   --         of the bidiagonal matrix whose SVD is desired.
   --         On exit, E is overwritten.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (4*N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --         = 0: successful exit
   --         < 0: if INFO = -i, the i-th argument had an illegal value
   --         > 0: the algorithm failed
   --              = 1, a split was marked by a positive value in E
   --              = 2, current block of Z not diagonalized after 100*N
   --                   iterations (in inner while loop)  On exit D and E
   --                   represent a matrix with the same singular values
   --                   which the calling subroutine could use to finish the
   --                   computation, or even feed back into DLASQ1
   --              = 3, termination criterion of outer while loop not met
   --                   (program created more than N unreduced blocks)
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLAS2, DLASCL, DLASQ2, DLASRT, XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO := 0;
      if N < 0 then
         INFO := -2;
         XERBLA ("DLASQ1", -INFO);
         return;
      elsif N = 0 then
         return;
      elsif N = 1 then
         D (1) := abs (D (1));
         return;
      elsif N = 2 then
         DLAS2 (D (1), E (1), D (2), SIGMN, SIGMX);
         D (1) := SIGMX;
         D (2) := SIGMN;
         return;
      end if;
      --
      --     Estimate the largest singular value.
      --
      SIGMX := ZERO;
      I     := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         D (I) := abs (D (I));
         SIGMX := max (SIGMX, abs (E (I)));
      end loop;
      D (N) := abs (D (N));
      --
      --     Early return if SIGMX is zero (matrix is already diagonal).
      --
      if SIGMX = ZERO then
         DLASRT ('D', N, D, IINFO);
         return;
      end if;
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         SIGMX := max (SIGMX, D (I));
      end loop;
      --
      --     Copy D and E into WORK (in the Z format) and scale (squaring the
      --     input data makes scaling by a power of the radix pointless).
      --
      EPS    := DLAMCH ('P');
      SAFMIN := DLAMCH ('S');
      SCALE  := Sqrt (EPS / SAFMIN);
      DCOPY (N, D'Address, 1, WORK (1)'Address, 2);
      DCOPY (N - 1, E'Address, 1, WORK (2)'Address, 2);
      DLASCL ('G', 0, 0, SIGMX, SCALE, 2 * N - 1, 1, WORK'Address, 2 * N - 1, IINFO);
      --
      --     Compute the q's and e's.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > 2 * N - 1;
         WORK (I) := WORK (I) ** 2;
      end loop;
      WORK (2 * N) := ZERO;
      --
      DLASQ2 (N, WORK, INFO);
      --
      if INFO = 0 then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            D (I) := Sqrt (WORK (I));
         end loop;
         DLASCL ('G', 0, 0, SCALE, SIGMX, N, 1, D'Address, N, IINFO);
      elsif INFO = 2 then
         --
         --     Maximum number of iterations exceeded.  Move data from WORK
         --     into D and E so the calling subroutine can try to finish
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            D (I) := Sqrt (WORK (2 * I - 1));
            E (I) := Sqrt (WORK (2 * I));
         end loop;
         DLASCL ('G', 0, 0, SCALE, SIGMX, N, 1, D'Address, N, IINFO);
         DLASCL ('G', 0, 0, SCALE, SIGMX, N, 1, E'Address, N, IINFO);
      end if;
      --
      return;
      --
      --     End of DLASQ1
      --
   end DLASQ1;

   procedure DLASQ2
     (N    : Integer;
      Z    : in out Ftn_Real_Vector;
      INFO : in out Integer)
   is
      CBIAS  : constant Real := 1.50e0;
      ZERO   : constant Real := 0.0e0;
      HALF   : constant Real := 0.5e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      FOUR   : constant Real := 4.0e0;
      HUNDRD : constant Real := 100.0e0;
      IEEE   : Boolean;
      I0     : Integer;
      I1     : Integer;
      I4     : Integer;
      IINFO  : Integer;
      IPN4   : Integer;
      ITER   : Integer;
      IWHILA : Integer;
      IWHILB : Integer;
      K      : Integer;
      KMIN   : Integer;
      N0     : Integer;
      N1     : Integer;
      NBIG   : Integer;
      NDIV   : Integer;
      NFAIL  : Integer;
      PP     : Integer;
      SPLT   : Integer;
      TTYPE  : Integer;
      D      : Real;
      DEE    : Real;
      DEEMIN : Real;
      DESIG  : Real;
      DMIN   : Real;
      DMIN1  : Real;
      DMIN2  : Real;
      DN     : Real;
      DN1    : Real;
      DN2    : Real;
      E      : Real;
      EMAX   : Real;
      EMIN   : Real;
      EPS    : Real;
      G      : Real;
      OLDEMN : Real;
      QMAX   : Real;
      QMIN   : Real;
      S      : Real;
      SAFMIN : Real;
      SIGMA  : Real;
      T      : Real;
      TAU    : Real;
      TEMP   : Real;
      TOL    : Real;
      TOL2   : Real;
      TRACE  : Real;
      ZMAX   : Real;
      TEMPE  : Real;
      TEMPQ  : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASQ2( N, Z, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASQ2 computes all the eigenvalues of the symmetric positive
   --  definite tridiagonal matrix associated with the qd array Z to high
   --  relative accuracy are computed to high relative accuracy, in the
   --  absence of denormalization, underflow and overflow.
   --
   --  To see the relation of Z to the tridiagonal matrix, let L be a
   --  unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
   --  let U be an upper bidiagonal matrix with 1's above and diagonal
   --  Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
   --  symmetric tridiagonal to which it is similar.
   --
   --  Note : DLASQ2 defines a LOGICAL variable, IEEE, which is true
   --  on machines which follow ieee-754 floating-point standard in their
   --  handling of infinities and NaNs, and false otherwise. This variable
   --  is passed to DLASQ3.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --         The number of rows and columns in the matrix. N >= 0.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension ( 4*N )
   --         On entry Z holds the qd array. On exit, entries 1 to N hold
   --         the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
   --         trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
   --         N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
   --         holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
   --         shifts that failed.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --         = 0: successful exit
   --         < 0: if the i-th argument is a scalar and had an illegal
   --              value, then INFO = -i, if the i-th argument is an
   --              array and the j-entry had an illegal value, then
   --              INFO = -(i*100+j)
   --         > 0: the algorithm failed
   --               = 1, a split was marked by a positive value in E
   --               = 2, current block of Z not diagonalized after 100*N
   --                    iterations (in inner while loop).  On exit Z holds
   --                    a qd array with the same eigenvalues as the given Z.
   --               = 3, termination criterion of outer while loop not met
   --                    (program created more than N unreduced blocks)
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Local Variables: I0:N0 defines a current unreduced segment of Z.
   --   The shifts are accumulated in SIGMA. Iteration count is in ITER.
   --   Ping-pong is controlled by PP (alternates between 0 and 1).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( CBIAS = 1.50D0 )
   --      PARAMETER          ( ZERO = 0.0D0, HALF = 0.5D0, ONE = 1.0D0, TWO = 2.0D0, FOUR = 4.0D0, HUNDRD = 100.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASQ3, DLASRT, XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH, ILAENV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments.
   --     (in case DLASQ2 is not called by DLASQ1)
   --
   begin
      INFO   := 0;
      EPS    := DLAMCH ('P');
      SAFMIN := DLAMCH ('S');
      TOL    := EPS * HUNDRD;
      TOL2   := TOL ** 2;
      --
      if N < 0 then
         INFO := -1;
         XERBLA ("DLASQ2", 1);
         return;
      elsif N = 0 then
         return;
      elsif N = 1 then
         --
         --        1-by-1 case.
         --
         if Z (1) < ZERO then
            INFO := -201;
            XERBLA ("DLASQ2", 2);
         end if;
         return;
      elsif N = 2 then
         --
         --        2-by-2 case.
         --
         if Z (2) < ZERO or Z (3) < ZERO then
            INFO := -2;
            XERBLA ("DLASQ2", 2);
            return;
         elsif Z (3) > Z (1) then
            D     := Z (3);
            Z (3) := Z (1);
            Z (1) := D;
         end if;
         Z (5) := Z (1) + Z (2) + Z (3);
         if Z (2) > Z (3) * TOL2 then
            T := HALF * ((Z (1) - Z (3)) + Z (2));
            S := Z (3) * (Z (2) / T);
            if S <= T 
               then S := Z (3) * (Z (2) / (T * (ONE + Sqrt (ONE + S / T))));
               else S := Z (3) * (Z (2) / (T + Sqrt (T) * Sqrt (T + S)));
            end if;
            T     := Z (1) + (S + Z (2));
            Z (3) := Z (3) * (Z (1) / T);
            Z (1) := T;
         end if;
         Z (2) := Z (3);
         Z (6) := Z (2) + Z (1);
         return;
      end if;
      --
      --     Check for negative data and compute sums of q's and e's.
      --
      Z (2 * N) := ZERO;
      EMIN      := Z (2);
      QMAX      := ZERO;
      ZMAX      := ZERO;
      D         := ZERO;
      E         := ZERO;
      --
      K := 1 - 2;
      loop
         K := K + 2;
         exit when K > 2 * (N - 1);
         if Z (K) < ZERO then
            INFO := -(200 + K);
            XERBLA ("DLASQ2", 2);
            return;
         elsif Z (K + 1) < ZERO then
            INFO := -(200 + K + 1);
            XERBLA ("DLASQ2", 2);
            return;
         end if;
         D    := D + Z (K);
         E    := E + Z (K + 1);
         QMAX := max (QMAX, Z (K));
         EMIN := min (EMIN, Z (K + 1));
         ZMAX := max (QMAX, ZMAX, Z (K + 1));
         K    := K + 2;
      end loop;
      if Z (2 * N - 1) < ZERO then
         INFO := -(200 + 2 * N - 1);
         XERBLA ("DLASQ2", 2);
         return;
      end if;
      D    := D + Z (2 * N - 1);
      QMAX := max (QMAX, Z (2 * N - 1));
      ZMAX := max (QMAX, ZMAX);
      --
      --     Check for diagonality.
      --
      if E = ZERO then
         K := 2 - 1;
         loop
            K := K + 1;
            exit when K > N;
            Z (K) := Z (2 * K - 1);
         end loop;
         DLASRT ('D', N, Z, IINFO);
         Z (2 * N - 1) := D;
         return;
      end if;
      --
      TRACE := D + E;
      --
      --     Check for zero data.
      --
      if TRACE = ZERO then
         Z (2 * N - 1) := ZERO;
         return;
      end if;
      --
      --     Check whether the machine is IEEE conformable.
      --
      IEEE := ILAENV (10, "DLASQ2", "N", 1, 2, 3, 4) = 1 and ILAENV (11, "DLASQ2", "N", 1, 2, 3, 4) = 1;
      --
      --     Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...).
      --
      K := 2 * N + 2;
      loop
         K := K - 2;
         exit when K < 2;
         Z (2 * K)     := ZERO;
         Z (2 * K - 1) := Z (K);
         Z (2 * K - 2) := ZERO;
         Z (2 * K - 3) := Z (K - 1);
         K             := K - 2;
      end loop;
      --
      I0 := 1;
      N0 := N;
      --
      --     Reverse the qd-array, if warranted.
      --
      if CBIAS * Z (4 * I0 - 3) < Z (4 * N0 - 3) then
         IPN4 := 4 * (I0 + N0);
         I4   := 4 * I0 - 4;
         loop
            I4 := I4 + 4;
            exit when I4 > 2 * (I0 + N0 - 1);
            TEMP              := Z (I4 - 3);
            Z (I4 - 3)        := Z (IPN4 - I4 - 3);
            Z (IPN4 - I4 - 3) := TEMP;
            TEMP              := Z (I4 - 1);
            Z (I4 - 1)        := Z (IPN4 - I4 - 5);
            Z (IPN4 - I4 - 5) := TEMP;
            I4                := I4 + 4;
         end loop;
      end if;
      --
      --     Initial split checking via dqd and Li's test.
      --
      PP := 0;
      --
      K := 1 - 1;
      loop
         K := K + 1;
         exit when K > 2;
         --
         D  := Z (4 * N0 + PP - 3);
         I4 := 4 * (N0 - 1) + PP + 4;
         loop
            I4 := I4 - 4;
            exit when I4 < 4 * I0 + PP;
            if Z (I4 - 1) <= TOL2 * D then
               Z (I4 - 1) := -ZERO;
               D          := Z (I4 - 3);
            else
               D := Z (I4 - 3) * (D / (D + Z (I4 - 1)));
            end if;
            I4 := I4 - 4;
         end loop;
         --
         --        dqd maps Z to ZZ plus Li's test.
         --
         EMIN := Z (4 * I0 + PP + 1);
         D    := Z (4 * I0 + PP - 3);
         I4   := 4 * I0 + PP - 4;
         loop
            I4 := I4 + 4;
            exit when I4 > 4 * (N0 - 1) + PP;
            Z (I4 - 2 * PP - 2) := D + Z (I4 - 1);
            if Z (I4 - 1) <= TOL2 * D then
               Z (I4 - 1)          := -ZERO;
               Z (I4 - 2 * PP - 2) := D;
               Z (I4 - 2 * PP)     := ZERO;
               D                   := Z (I4 + 1);
            elsif SAFMIN * Z (I4 + 1) < Z (I4 - 2 * PP - 2) and SAFMIN * Z (I4 - 2 * PP - 2) < Z (I4 + 1) then
               TEMP            := Z (I4 + 1) / Z (I4 - 2 * PP - 2);
               Z (I4 - 2 * PP) := Z (I4 - 1) * TEMP;
               D               := D * TEMP;
            else
               Z (I4 - 2 * PP) := Z (I4 + 1) * (Z (I4 - 1) / Z (I4 - 2 * PP - 2));
               D               := Z (I4 + 1) * (D / Z (I4 - 2 * PP - 2));
            end if;
            EMIN := min (EMIN, Z (I4 - 2 * PP));
            I4   := I4 + 4;
         end loop;
         Z (4 * N0 - PP - 2) := D;
         --
         --        Now find qmax.
         --
         QMAX := Z (4 * I0 - PP - 2);
         I4   := 4 * I0 - PP + 2 - 4;
         loop
            I4 := I4 + 4;
            exit when I4 > 4 * N0 - PP - 2;
            QMAX := max (QMAX, Z (I4));
            I4   := I4 + 4;
         end loop;
         --
         --        Prepare for the next iteration on K.
         --
         PP := 1 - PP;
      end loop;
      --
      --     Initialise variables to pass to DLASQ3.
      --
      TTYPE := 0;
      DMIN1 := ZERO;
      DMIN2 := ZERO;
      DN    := ZERO;
      DN1   := ZERO;
      DN2   := ZERO;
      G     := ZERO;
      TAU   := ZERO;
      --
      ITER  := 2;
      NFAIL := 0;
      NDIV  := 2 * (N0 - I0);
      --
      IWHILA := 1 - 1;
      loop
         IWHILA := IWHILA + 1;
         exit when IWHILA > N + 1;
         if N0 < 1 then
            goto L170;
         end if;
         --
         --        While array unfinished do
         --
         --        E(N0) holds the value of SIGMA when submatrix in I0:N0
         --        splits from the rest of the array, but is negated.
         --
         DESIG := ZERO;
         if N0 = N 
            then SIGMA := ZERO;
            else SIGMA := -Z (4 * N0 - 1);
         end if;
         if SIGMA < ZERO then
            INFO := 1;
            return;
         end if;
         --
         --        Find last unreduced submatrix's top index I0, find QMAX and
         --        EMIN. Find Gershgorin-type bound if Q's much greater than E's.
         --
         EMAX := ZERO;
         if N0 > I0 
            then EMIN := abs (Z (4 * N0 - 5));
            else EMIN := ZERO;
         end if;
         QMIN := Z (4 * N0 - 3);
         QMAX := QMIN;
         I4   := 4 * N0 + 4;
         loop
            I4 := I4 - 4;
            exit when I4 < 8;
            if Z (I4 - 5) <= ZERO then
               goto L100;
            end if;
            if QMIN >= FOUR * EMAX then
               QMIN := min (QMIN, Z (I4 - 3));
               EMAX := max (EMAX, Z (I4 - 5));
            end if;
            QMAX := max (QMAX, Z (I4 - 7) + Z (I4 - 5));
            EMIN := min (EMIN, Z (I4 - 5));
            I4   := I4 - 4;
         end loop;
         I4 := 4;
         --
         <<L100>> null;
         I0 := I4 / 4;
         PP := 0;
         --
         if N0 - I0 > 1 then
            DEE    := Z (4 * I0 - 3);
            DEEMIN := DEE;
            KMIN   := I0;
            I4     := 4 * I0 + 1 - 4;
            loop
               I4 := I4 + 4;
               exit when I4 > 4 * N0 - 3;
               DEE := Z (I4) * (DEE / (DEE + Z (I4 - 2)));
               if DEE <= DEEMIN then
                  DEEMIN := DEE;
                  KMIN   := (I4 + 3) / 4;
               end if;
               I4 := I4 + 4;
            end loop;
            if (KMIN - I0) * 2 < N0 - KMIN and DEEMIN <= HALF * Z (4 * N0 - 3) then
               IPN4 := 4 * (I0 + N0);
               PP   := 2;
               I4   := 4 * I0 - 4;
               loop
                  I4 := I4 + 4;
                  exit when I4 > 2 * (I0 + N0 - 1);
                  TEMP              := Z (I4 - 3);
                  Z (I4 - 3)        := Z (IPN4 - I4 - 3);
                  Z (IPN4 - I4 - 3) := TEMP;
                  TEMP              := Z (I4 - 2);
                  Z (I4 - 2)        := Z (IPN4 - I4 - 2);
                  Z (IPN4 - I4 - 2) := TEMP;
                  TEMP              := Z (I4 - 1);
                  Z (I4 - 1)        := Z (IPN4 - I4 - 5);
                  Z (IPN4 - I4 - 5) := TEMP;
                  TEMP              := Z (I4);
                  Z (I4)            := Z (IPN4 - I4 - 4);
                  Z (IPN4 - I4 - 4) := TEMP;
                  I4                := I4 + 4;
               end loop;
            end if;
         end if;
         --
         --        Put -(initial shift) into DMIN.
         --
         DMIN := -max (ZERO, QMIN - TWO * Sqrt (QMIN) * Sqrt (EMAX));
         --
         --        Now I0:N0 is unreduced.
         --        PP = 0 for ping, PP = 1 for pong.
         --        PP = 2 indicates that flipping was applied to the Z array and
         --               and that the tests for deflation upon entry in DLASQ3
         --               should not be performed.
         --
         NBIG   := 100 * (N0 - I0 + 1);
         IWHILB := 1 - 1;
         loop
            IWHILB := IWHILB + 1;
            exit when IWHILB > NBIG;
            if I0 > N0 then
               goto L150;
            end if;
            --
            --           While submatrix unfinished take a good dqds step.
            --
            DLASQ3
              (I0,
               N0,
               Z,
               PP,
               DMIN,
               SIGMA,
               DESIG,
               QMAX,
               NFAIL,
               ITER,
               NDIV,
               IEEE,
               TTYPE,
               DMIN1,
               DMIN2,
               DN,
               DN1,
               DN2,
               G,
               TAU);
            --
            PP := 1 - PP;
            --
            --           When EMIN is very small check for splits.
            --
            if PP = 0 and N0 - I0 >= 3 then
               if Z (4 * N0) <= TOL2 * QMAX or Z (4 * N0 - 1) <= TOL2 * SIGMA then
                  SPLT   := I0 - 1;
                  QMAX   := Z (4 * I0 - 3);
                  EMIN   := Z (4 * I0 - 1);
                  OLDEMN := Z (4 * I0);
                  I4     := 4 * I0 - 4;
                  loop
                     I4 := I4 + 4;
                     exit when I4 > 4 * (N0 - 3);
                     if Z (I4) <= TOL2 * Z (I4 - 3) or Z (I4 - 1) <= TOL2 * SIGMA then
                        Z (I4 - 1) := -SIGMA;
                        SPLT       := I4 / 4;
                        QMAX       := ZERO;
                        EMIN       := Z (I4 + 3);
                        OLDEMN     := Z (I4 + 4);
                     else
                        QMAX   := max (QMAX, Z (I4 + 1));
                        EMIN   := min (EMIN, Z (I4 - 1));
                        OLDEMN := min (OLDEMN, Z (I4));
                     end if;
                     I4 := I4 + 4;
                  end loop;
                  Z (4 * N0 - 1) := EMIN;
                  Z (4 * N0)     := OLDEMN;
                  I0             := SPLT + 1;
               end if;
            end if;
            --
         end loop;
         --
         INFO := 2;
         --
         --        Maximum number of iterations exceeded, restore the shift
         --        SIGMA and place the new d's and e's in a qd array.
         --        This might need to be done for several blocks
         --
         I1 := I0;
         N1 := N0;
         <<L145>> null;
         TEMPQ          := Z (4 * I0 - 3);
         Z (4 * I0 - 3) := Z (4 * I0 - 3) + SIGMA;
         K              := I0 + 1 - 1;
         loop
            K := K + 1;
            exit when K > N0;
            TEMPE         := Z (4 * K - 5);
            Z (4 * K - 5) := Z (4 * K - 5) * (TEMPQ / Z (4 * K - 7));
            TEMPQ         := Z (4 * K - 3);
            Z (4 * K - 3) := Z (4 * K - 3) + SIGMA + TEMPE - Z (4 * K - 5);
         end loop;
         --
         --        Prepare to do this on the previous block if there is one
         --
         if I1 > 1 then
            N1 := I1 - 1;
            while (I1 >= 2) and (Z (4 * I1 - 5) >= ZERO) loop
               I1 := I1 - 1;
            end loop;
            SIGMA := -Z (4 * N1 - 1);
            goto L145;
         end if;
         K := 1 - 1;
         loop
            K := K + 1;
            exit when K > N;
            Z (2 * K - 1) := Z (4 * K - 3);
            --
            --        Only the block 1..N0 is unfinished.  The rest of the e's
            --        must be essentially zero, although sometimes other data
            --        has been stored in them.
            --
            if K < N0 
               then Z (2 * K) := Z (4 * K - 1);
               else Z (2 * K) := 0.0;
            end if;
         end loop;
         return;
         --
         --        end IWHILB
         --
         <<L150>> null;
         --
      end loop;
      --
      INFO := 3;
      return;
      --
      --     end IWHILA
      --
      <<L170>> null;
      --
      --     Move q's to the front.
      --
      K := 2 - 1;
      loop
         K := K + 1;
         exit when K > N;
         Z (K) := Z (4 * K - 3);
      end loop;
      --
      --     Sort and compute sum of eigenvalues.
      --
      DLASRT ('D', N, Z, IINFO);
      --
      E := ZERO;
      K := N + 1;
      loop
         K := K - 1;
         exit when K < 1;
         E := E + Z (K);
      end loop;
      --
      --     Store trace, sum(eigenvalues) and information on performance.
      --
      Z (2 * N + 1) := TRACE;
      Z (2 * N + 2) := E;
      Z (2 * N + 3) := Real (ITER);
      Z (2 * N + 4) := Real (NDIV) / Real (N ** 2);
      Z (2 * N + 5) := HUNDRD * Real (NFAIL) / Real (ITER);
      return;
      --
      --     End of DLASQ2
      --
   end DLASQ2;

   procedure DLASQ3
     (I0    : Integer;
      N0    : in out Integer;
      Z     : in out Ftn_Real_Vector;
      PP    : in out Integer;
      DMIN  : in out Real;
      SIGMA : in out Real;
      DESIG : in out Real;
      QMAX  : in out Real; -- doc. says [in] but this routine does modify QMAX, see line 297
      NFAIL : in out Integer;
      ITER  : in out Integer;
      NDIV  : in out Integer;
      IEEE  : Boolean;
      TTYPE : in out Integer;
      DMIN1 : in out Real;
      DMIN2 : in out Real;
      DN    : in out Real;
      DN1   : in out Real;
      DN2   : in out Real;
      G     : in out Real;
      TAU   : in out Real)
   is
      CBIAS  : constant Real := 1.50e0;
      ZERO   : constant Real := 0.0e0;
      QURTR  : constant Real := 0.25e0;
      HALF   : constant Real := 0.5e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      HUNDRD : constant Real := 100.0e0;
      IPN4   : Integer;
      J4     : Integer;
      N0IN   : Integer;
      NN     : Integer;
      EPS    : Real;
      S      : Real;
      T      : Real;
      TEMP   : Real;
      TOL    : Real;
      TOL2   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,
   --                          ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2, DN, DN1,
   --                          DN2, G, TAU )
   --
   --       .. Scalar Arguments ..
   --       LOGICAL            IEEE
   --       INTEGER            I0, ITER, N0, NDIV, NFAIL, PP
   --       DOUBLE PRECISION   DESIG, DMIN, DMIN1, DMIN2, DN, DN1, DN2, G,
   --      $                   QMAX, SIGMA, TAU
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
   --  In case of failure it changes shifts, and tries again until output
   --  is positive.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] I0
   --           I0 is INTEGER
   --          First index.
   --
   --  [in,out] N0
   --           N0 is INTEGER
   --          Last index.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension ( 4*N )
   --          Z holds the qd array.
   --
   --  [in,out] PP
   --           PP is INTEGER
   --          PP=0 for ping, PP=1 for pong.
   --          PP=2 indicates that flipping was applied to the Z array
   --          and that the initial tests for deflation should not be
   --          performed.
   --
   --  [out] DMIN
   --           DMIN is DOUBLE PRECISION
   --          Minimum value of d.
   --
   --  [out] SIGMA
   --           SIGMA is DOUBLE PRECISION
   --          Sum of shifts used in current segment.
   --
   --  [in,out] DESIG
   --           DESIG is DOUBLE PRECISION
   --          Lower order part of SIGMA
   --
   --  [in] QMAX
   --           QMAX is DOUBLE PRECISION
   --          Maximum value of q.
   --
   --  [out] NFAIL
   --           NFAIL is INTEGER
   --          Number of times shift was too big.
   --
   --  [out] ITER
   --           ITER is INTEGER
   --          Number of iterations.
   --
   --  [out] NDIV
   --           NDIV is INTEGER
   --          Number of divisions.
   --
   --  [in] IEEE
   --           IEEE is LOGICAL
   --          Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).
   --
   --  [in,out] TTYPE
   --           TTYPE is INTEGER
   --          Shift type.
   --
   --  [in,out] DMIN1
   --           DMIN1 is DOUBLE PRECISION
   --
   --  [in,out] DMIN2
   --           DMIN2 is DOUBLE PRECISION
   --
   --  [in,out] DN
   --           DN is DOUBLE PRECISION
   --
   --  [in,out] DN1
   --           DN1 is DOUBLE PRECISION
   --
   --  [in,out] DN2
   --           DN2 is DOUBLE PRECISION
   --
   --  [in,out] G
   --           G is DOUBLE PRECISION
   --
   --  [in,out] TAU
   --           TAU is DOUBLE PRECISION
   --
   --          These are passed as arguments in order to save their values
   --          between calls to DLASQ3.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( CBIAS = 1.50D0 )
   --      PARAMETER          ( ZERO = 0.0D0, QURTR = 0.250D0, HALF = 0.5D0, ONE = 1.0D0, TWO = 2.0D0, HUNDRD = 100.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASQ4, DLASQ5, DLASQ6
   --     ..
   --     .. External Function ..
   --      EXTERNAL           DISNAN, DLAMCH
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      N0IN := N0;
      EPS  := DLAMCH ('P');
      TOL  := EPS * HUNDRD;
      TOL2 := TOL ** 2;
      --
      --     Check for deflation.
      --
      <<L10>> null;
      --
      if N0 < I0 then
         return;
      end if;
      if N0 = I0 then
         goto L20;
      end if;
      NN := 4 * N0 + PP;
      if N0 = (I0 + 1) then
         goto L40;
      end if;
      --
      --     Check whether E(N0-1) is negligible, 1 eigenvalue.
      --
      if Z (NN - 5) > TOL2 * (SIGMA + Z (NN - 3)) and Z (NN - 2 * PP - 4) > TOL2 * Z (NN - 7) then
         goto L30;
      end if;
      --
      <<L20>> null;
      --
      Z (4 * N0 - 3) := Z (4 * N0 + PP - 3) + SIGMA;
      N0             := N0 - 1;
      goto L10;
      --
      --     Check  whether E(N0-2) is negligible, 2 eigenvalues.
      --
      <<L30>> null;
      --
      if Z (NN - 9) > TOL2 * SIGMA and Z (NN - 2 * PP - 8) > TOL2 * Z (NN - 11) then
         goto L50;
      end if;
      --
      <<L40>> null;
      --
      if Z (NN - 3) > Z (NN - 7) then
         S          := Z (NN - 3);
         Z (NN - 3) := Z (NN - 7);
         Z (NN - 7) := S;
      end if;
      if Z (NN - 5) > Z (NN - 3) * TOL2 then
         T := HALF * ((Z (NN - 7) - Z (NN - 3)) + Z (NN - 5));
         S := Z (NN - 3) * (Z (NN - 5) / T);
         if S <= T 
            then S := Z (NN - 3) * (Z (NN - 5) / (T * (ONE + Sqrt (ONE + S / T))));
            else S := Z (NN - 3) * (Z (NN - 5) / (T + Sqrt (T) * Sqrt (T + S)));
         end if;
         T          := Z (NN - 7) + (S + Z (NN - 5));
         Z (NN - 3) := Z (NN - 3) * (Z (NN - 7) / T);
         Z (NN - 7) := T;
      end if;
      Z (4 * N0 - 7) := Z (NN - 7) + SIGMA;
      Z (4 * N0 - 3) := Z (NN - 3) + SIGMA;
      N0             := N0 - 2;
      goto L10;
      --
      <<L50>> null;
      if PP = 2 then
         PP := 0;
      end if;
      --
      --     Reverse the qd-array, if warranted.
      --
      if DMIN <= ZERO or N0 < N0IN then
         if CBIAS * Z (4 * I0 + PP - 3) < Z (4 * N0 + PP - 3) then
            IPN4 := 4 * (I0 + N0);
            J4   := 4 * I0 - 4;
            loop
               J4 := J4 + 4;
               exit when J4 > 2 * (I0 + N0 - 1);
               TEMP              := Z (J4 - 3);
               Z (J4 - 3)        := Z (IPN4 - J4 - 3);
               Z (IPN4 - J4 - 3) := TEMP;
               TEMP              := Z (J4 - 2);
               Z (J4 - 2)        := Z (IPN4 - J4 - 2);
               Z (IPN4 - J4 - 2) := TEMP;
               TEMP              := Z (J4 - 1);
               Z (J4 - 1)        := Z (IPN4 - J4 - 5);
               Z (IPN4 - J4 - 5) := TEMP;
               TEMP              := Z (J4);
               Z (J4)            := Z (IPN4 - J4 - 4);
               Z (IPN4 - J4 - 4) := TEMP;
               J4                := J4 + 4;
            end loop;
            if N0 - I0 <= 4 then
               Z (4 * N0 + PP - 1) := Z (4 * I0 + PP - 1);
               Z (4 * N0 - PP)     := Z (4 * I0 - PP);
            end if;
            DMIN2               := min (DMIN2, Z (4 * N0 + PP - 1));
            Z (4 * N0 + PP - 1) := min (Z (4 * N0 + PP - 1), Z (4 * I0 + PP - 1), Z (4 * I0 + PP + 3));
            Z (4 * N0 - PP)     := min (Z (4 * N0 - PP), Z (4 * I0 - PP), Z (4 * I0 - PP + 4));
            QMAX                := max (QMAX, Z (4 * I0 + PP - 3), Z (4 * I0 + PP + 1));
            DMIN                := -ZERO;
         end if;
      end if;
      --
      --     Choose a shift.
      --
      DLASQ4 (I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, DN1, DN2, TAU, TTYPE, G);
      --
      --     Call dqds until DMIN > 0.
      --
      <<L70>> null;
      --
      DLASQ5 (I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2, DN, DN1, DN2, IEEE, EPS);
      --
      NDIV := NDIV + (N0 - I0 + 2);
      ITER := ITER + 1;
      --
      --     Check status.
      --
      if DMIN >= ZERO and DMIN1 >= ZERO then
         --
         --        Success.
         --
         goto L90;
      --
      elsif DMIN < ZERO and DMIN1 > ZERO and Z (4 * (N0 - 1) - PP) < TOL * (SIGMA + DN1) and abs (DN) < TOL * SIGMA then
         --
         --        Convergence hidden by negative DN.
         --
         Z (4 * (N0 - 1) - PP + 2)   := ZERO;
         DMIN                        := ZERO;
         goto L90;
      elsif DMIN < ZERO then
         --
         --        TAU too big. Select new TAU and try again.
         --
         NFAIL := NFAIL + 1;
         if TTYPE < -22 then
            --
            --           Failed twice. Play it safe.
            --
            TAU := ZERO;
         elsif DMIN1 > ZERO then
            --
            --           Late failure. Gives excellent shift.
            --
            TAU   := (TAU + DMIN) * (ONE - TWO * EPS);
            TTYPE := TTYPE - 11;
         else
            --
            --           Early failure. Divide by 4.
            --
            TAU   := QURTR * TAU;
            TTYPE := TTYPE - 12;
         end if;
         goto L70;
      elsif DISNAN (DMIN) then
         --
         --        NaN.
         --
         if TAU = ZERO then
            goto L80;
         else
            TAU := ZERO;
            goto L70;
         end if;
      else
         --
         --        Possible underflow. Play it safe.
         --
         goto L80;
      end if;
      --
      --     Risk of underflow.
      --
      <<L80>> null;
      DLASQ6 (I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, DN1, DN2);
      NDIV := NDIV + (N0 - I0 + 2);
      ITER := ITER + 1;
      TAU  := ZERO;
      --
      <<L90>> null;
      if TAU < SIGMA then
         DESIG := DESIG + TAU;
         T     := SIGMA + DESIG;
         DESIG := DESIG - (T - SIGMA);
      else
         T     := SIGMA + TAU;
         DESIG := SIGMA - (T - TAU) + DESIG;
      end if;
      SIGMA := T;
      --
      return;
      --
      --     End of DLASQ3
      --
   end DLASQ3;

   procedure DLASQ4
     (I0    : Integer;
      N0    : Integer;
      Z     : in out Ftn_Real_Vector;
      PP    : Integer;
      N0IN  : Integer;
      DMIN  : Real;
      DMIN1 : Real;
      DMIN2 : Real;
      DN    : Real;
      DN1   : Real;
      DN2   : Real;
      TAU   : in out Real;
      TTYPE : in out Integer;
      G     : in out Real)
   is
      CNST1  : constant Real := 0.5630e0;
      CNST2  : constant Real := 1.010e0;
      CNST3  : constant Real := 1.050e0;
      QURTR  : constant Real := 0.25e0;
      THIRD  : constant Real := 1.0e0 / 3.0e0;
      HALF   : constant Real := 0.5e0;
      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      HUNDRD : constant Real := 100.0e0;
      I4     : Integer;
      NN     : Integer;
      NP     : Integer;
      A2     : Real;
      B1     : Real;
      B2     : Real;
      GAM    : Real;
      GAP1   : Real;
      GAP2   : Real;
      S      : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN,
   --                          DN1, DN2, TAU, TTYPE, G )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            I0, N0, N0IN, PP, TTYPE
   --       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DN1, DN2, G, TAU
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASQ4 computes an approximation TAU to the smallest eigenvalue
   --  using values of d from the previous transform.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] I0
   --           I0 is INTEGER
   --         First index.
   --
   --  [in] N0
   --           N0 is INTEGER
   --         Last index.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension ( 4*N )
   --         Z holds the qd array.
   --
   --  [in] PP
   --           PP is INTEGER
   --         PP=0 for ping, PP=1 for pong.
   --
   --  [in] N0IN
   --           N0IN is INTEGER
   --         The value of N0 at start of EIGTEST.
   --
   --  [in] DMIN
   --           DMIN is DOUBLE PRECISION
   --         Minimum value of d.
   --
   --  [in] DMIN1
   --           DMIN1 is DOUBLE PRECISION
   --         Minimum value of d, excluding D( N0 ).
   --
   --  [in] DMIN2
   --           DMIN2 is DOUBLE PRECISION
   --         Minimum value of d, excluding D( N0 ) and D( N0-1 ).
   --
   --  [in] DN
   --           DN is DOUBLE PRECISION
   --         d(N)
   --
   --  [in] DN1
   --           DN1 is DOUBLE PRECISION
   --         d(N-1)
   --
   --  [in] DN2
   --           DN2 is DOUBLE PRECISION
   --         d(N-2)
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION
   --         This is the shift.
   --
   --  [out] TTYPE
   --           TTYPE is INTEGER
   --         Shift type.
   --
   --  [in,out] G
   --           G is REAL
   --         G is passed as an argument in order to save its value between
   --         calls to DLASQ4.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   CNST1 = 9/16
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( CNST1 = 0.5630D0, CNST2 = 1.010D0, CNST3 = 1.050D0 )
   --      PARAMETER          ( QURTR = 0.250D0, THIRD = 0.3330D0, HALF = 0.50D0, ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0,
   --HUNDRD = 100.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     A negative DMIN forces the shift to take that absolute value
   --     TTYPE records the type of shift.
   --
   begin
      if DMIN <= ZERO then
         TAU   := -DMIN;
         TTYPE := -1;
         return;
      end if;
      --
      NN := 4 * N0 + PP;
      if N0IN = N0 then
         --
         --        No eigenvalues deflated.
         --
         if DMIN = DN or DMIN = DN1 then
            --
            B1 := Sqrt (Z (NN - 3)) * Sqrt (Z (NN - 5));
            B2 := Sqrt (Z (NN - 7)) * Sqrt (Z (NN - 9));
            A2 := Z (NN - 7) + Z (NN - 5);
            --
            --           Cases 2 and 3.
            --
            if DMIN = DN and DMIN1 = DN1 then
               GAP2 := DMIN2 - A2 - DMIN2 * QURTR;
               if GAP2 > ZERO and GAP2 > B2 
                  then GAP1 := A2 - DN - (B2 / GAP2) * B2;
                  else GAP1 := A2 - DN - (B1 + B2);
               end if;
               if GAP1 > ZERO and GAP1 > B1 then
                  S     := max (DN - (B1 / GAP1) * B1, HALF * DMIN);
                  TTYPE := -2;
               else
                  S := ZERO;
                  if DN > B1 then
                     S := DN - B1;
                  end if;
                  if A2 > (B1 + B2) then
                     S := min (S, A2 - (B1 + B2));
                  end if;
                  S     := max (S, THIRD * DMIN);
                  TTYPE := -3;
               end if;
            else
               --
               --              Case 4.
               --
               TTYPE := -4;
               S     := QURTR * DMIN;
               if DMIN = DN then
                  GAM := DN;
                  A2  := ZERO;
                  if Z (NN - 5) > Z (NN - 7) then
                     return;
                  end if;
                  B2 := Z (NN - 5) / Z (NN - 7);
                  NP := NN - 9;
               else
                  NP  := NN - 2 * PP;
                  B2  := Z (NP - 2);
                  GAM := DN1;
                  if Z (NP - 4) > Z (NP - 2) then
                     return;
                  end if;
                  A2 := Z (NP - 4) / Z (NP - 2);
                  if Z (NN - 9) > Z (NN - 11) then
                     return;
                  end if;
                  B2 := Z (NN - 9) / Z (NN - 11);
                  NP := NN - 13;
               end if;
               --
               --              Approximate contribution to norm squared from I < NN-1.
               --
               A2 := A2 + B2;
               I4 := NP + 4;
               loop
                  I4 := I4 - 4;
                  exit when I4 < 4 * I0 - 1 + PP;
                  if B2 = ZERO then
                     goto L20;
                  end if;
                  B1 := B2;
                  if Z (I4) > Z (I4 - 2) then
                     return;
                  end if;
                  B2 := B2 * (Z (I4) / Z (I4 - 2));
                  A2 := A2 + B2;
                  if HUNDRD * max (B2, B1) < A2 or CNST1 < A2 then
                     goto L20;
                  end if;
                  I4 := I4 - 4;
               end loop;
               <<L20>> null;
               A2 := CNST3 * A2;
               --
               --              Rayleigh quotient residual bound.
               --
               if A2 < CNST1 then
                  S := GAM * (ONE - Sqrt (A2)) / (ONE + A2);
               end if;
            end if;
         elsif DMIN = DN2 then
            --
            --           Case 5.
            --
            TTYPE := -5;
            S     := QURTR * DMIN;
            --
            --           Compute contribution to norm squared from I > NN-2.
            --
            NP  := NN - 2 * PP;
            B1  := Z (NP - 2);
            B2  := Z (NP - 6);
            GAM := DN2;
            if Z (NP - 8) > B2 or Z (NP - 4) > B1 then
               return;
            end if;
            A2 := (Z (NP - 8) / B2) * (ONE + Z (NP - 4) / B1);
            --
            --           Approximate contribution to norm squared from I < NN-2.
            --
            if N0 - I0 > 2 then
               B2 := Z (NN - 13) / Z (NN - 15);
               A2 := A2 + B2;
               I4 := NN - 17 + 4;
               loop
                  I4 := I4 - 4;
                  exit when I4 < 4 * I0 - 1 + PP;
                  if B2 = ZERO then
                     goto L40;
                  end if;
                  B1 := B2;
                  if Z (I4) > Z (I4 - 2) then
                     return;
                  end if;
                  B2 := B2 * (Z (I4) / Z (I4 - 2));
                  A2 := A2 + B2;
                  if HUNDRD * max (B2, B1) < A2 or CNST1 < A2 then
                     goto L40;
                  end if;
                  I4 := I4 - 4;
               end loop;
               <<L40>> null;
               A2 := CNST3 * A2;
            end if;
            --
            if A2 < CNST1 then
               S := GAM * (ONE - Sqrt (A2)) / (ONE + A2);
            end if;
         else
            --
            --           Case 6, no information to guide us.
            --
            if TTYPE = -6 then
               G := G + THIRD * (ONE - G);
            elsif TTYPE = -18 then
               G := QURTR * THIRD;
            else
               G := QURTR;
            end if;
            S     := G * DMIN;
            TTYPE := -6;
         end if;
      --
      elsif N0IN = (N0 + 1) then
         --
         --        One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN.
         --
         if DMIN1 = DN1 and DMIN2 = DN2 then
            --
            --           Cases 7 and 8.
            --
            TTYPE := -7;
            S     := THIRD * DMIN1;
            if Z (NN - 5) > Z (NN - 7) then
               return;
            end if;
            B1 := Z (NN - 5) / Z (NN - 7);
            B2 := B1;
            if B2 = ZERO then
               goto L60;
            end if;
            I4 := 4 * N0 - 9 + PP + 4;
            loop
               I4 := I4 - 4;
               exit when I4 < 4 * I0 - 1 + PP;
               A2 := B1;
               if Z (I4) > Z (I4 - 2) then
                  return;
               end if;
               B1 := B1 * (Z (I4) / Z (I4 - 2));
               B2 := B2 + B1;
               if HUNDRD * max (B1, A2) < B2 then
                  goto L60;
               end if;
               I4 := I4 - 4;
            end loop;
            <<L60>> null;
            B2   := Sqrt (CNST3 * B2);
            A2   := DMIN1 / (ONE + B2 ** 2);
            GAP2 := HALF * DMIN2 - A2;
            if GAP2 > ZERO and GAP2 > B2 * A2 then
               S := max (S, A2 * (ONE - CNST2 * A2 * (B2 / GAP2) * B2));
            else
               S     := max (S, A2 * (ONE - CNST2 * B2));
               TTYPE := -8;
            end if;
         else
            --
            --           Case 9.
            --
            S := QURTR * DMIN1;
            if DMIN1 = DN1 then
               S := HALF * DMIN1;
            end if;
            TTYPE := -9;
         end if;
      --
      elsif N0IN = (N0 + 2) then
         --
         --        Two eigenvalues deflated. Use DMIN2, DN2 for DMIN and DN.
         --
         --        Cases 10 and 11.
         --
         if DMIN2 = DN2 and TWO * Z (NN - 5) < Z (NN - 7) then
            TTYPE := -10;
            S     := THIRD * DMIN2;
            if Z (NN - 5) > Z (NN - 7) then
               return;
            end if;
            B1 := Z (NN - 5) / Z (NN - 7);
            B2 := B1;
            if B2 = ZERO then
               goto L80;
            end if;
            I4 := 4 * N0 - 9 + PP + 4;
            loop
               I4 := I4 - 4;
               exit when I4 < 4 * I0 - 1 + PP;
               if Z (I4) > Z (I4 - 2) then
                  return;
               end if;
               B1 := B1 * (Z (I4) / Z (I4 - 2));
               B2 := B2 + B1;
               if HUNDRD * B1 < B2 then
                  goto L80;
               end if;
               I4 := I4 - 4;
            end loop;
            <<L80>> null;
            B2   := Sqrt (CNST3 * B2);
            A2   := DMIN2 / (ONE + B2 ** 2);
            GAP2 := Z (NN - 7) + Z (NN - 9) - Sqrt (Z (NN - 11)) * Sqrt (Z (NN - 9)) - A2;
            if GAP2 > ZERO and GAP2 > B2 * A2 
               then S := max (S, A2 * (ONE - CNST2 * A2 * (B2 / GAP2) * B2));
               else S := max (S, A2 * (ONE - CNST2 * B2));
            end if;
         else
            S     := QURTR * DMIN2;
            TTYPE := -11;
         end if;
      elsif N0IN > (N0 + 2) then
         --
         --        Case 12, more than two eigenvalues deflated. No information.
         --
         S     := ZERO;
         TTYPE := -12;
      end if;
      --
      TAU := S;
      return;
      --
      --     End of DLASQ4
      --
   end DLASQ4;

   procedure DLASQ5
     (I0    : Integer;
      N0    : Integer;
      Z     : in out Ftn_Real_Vector;
      PP    : Integer;
      TAU   : in out Real;
      SIGMA : Real;
      DMIN  : in out Real;
      DMIN1 : in out Real;
      DMIN2 : in out Real;
      DN    : in out Real;
      DNM1  : in out Real;
      DNM2  : in out Real;
      IEEE  : Boolean;
      EPS   : Real)
   is
      ZERO    : constant Real := 0.0e0;
      HALF    : constant Real := 0.5e0;
      J4      : Integer;
      J4P2    : Integer;
      D       : Real;
      EMIN    : Real;
      TEMP    : Real;
      DTHRESH : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASQ5( I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2, DN,
   --                          DNM1, DNM2, IEEE, EPS )
   --
   --       .. Scalar Arguments ..
   --       LOGICAL            IEEE
   --       INTEGER            I0, N0, PP
   --       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, TAU, SIGMA, EPS
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASQ5 computes one dqds transform in ping-pong form, one
   --  version for IEEE machines another for non IEEE machines.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] I0
   --           I0 is INTEGER
   --         First index.
   --
   --  [in] N0
   --           N0 is INTEGER
   --         Last index.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension ( 4*N )
   --         Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
   --         an extra argument.
   --
   --  [in] PP
   --           PP is INTEGER
   --         PP=0 for ping, PP=1 for pong.
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION
   --         This is the shift.
   --
   --  [in] SIGMA
   --           SIGMA is DOUBLE PRECISION
   --         This is the accumulated shift up to this step.
   --
   --  [out] DMIN
   --           DMIN is DOUBLE PRECISION
   --         Minimum value of d.
   --
   --  [out] DMIN1
   --           DMIN1 is DOUBLE PRECISION
   --         Minimum value of d, excluding D( N0 ).
   --
   --  [out] DMIN2
   --           DMIN2 is DOUBLE PRECISION
   --         Minimum value of d, excluding D( N0 ) and D( N0-1 ).
   --
   --  [out] DN
   --           DN is DOUBLE PRECISION
   --         d(N0), the last value of d.
   --
   --  [out] DNM1
   --           DNM1 is DOUBLE PRECISION
   --         d(N0-1).
   --
   --  [out] DNM2
   --           DNM2 is DOUBLE PRECISION
   --         d(N0-2).
   --
   --  [in] IEEE
   --           IEEE is LOGICAL
   --         Flag for IEEE or non IEEE arithmetic.
   --
   --  [in] EPS
   --           EPS is DOUBLE PRECISION
   --         This is the value of epsilon used.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameter ..
   --      PARAMETER          ( ZERO = 0.0D0, HALF = 0.5 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if (N0 - I0 - 1) <= 0 then
         return;
      end if;
      --
      DTHRESH := EPS * (SIGMA + TAU);
      if TAU < DTHRESH * HALF then
         TAU := ZERO;
      end if;
      if TAU /= ZERO then
         J4    := 4 * I0 + PP - 3;
         EMIN  := Z (J4 + 4);
         D     := Z (J4) - TAU;
         DMIN  := D;
         DMIN1 := -Z (J4);
         --
         if IEEE then
            --
            --        Code for IEEE arithmetic.
            --
            if PP = 0 then
               J4 := 4 * I0 - 4;
               loop
                  J4 := J4 + 4;
                  exit when J4 > 4 * (N0 - 3);
                  Z (J4 - 2) := D + Z (J4 - 1);
                  TEMP       := Z (J4 + 1) / Z (J4 - 2);
                  D          := D * TEMP - TAU;
                  DMIN       := min (DMIN, D);
                  Z (J4)     := Z (J4 - 1) * TEMP;
                  EMIN       := min (Z (J4), EMIN);
                  J4         := J4 + 4;
               end loop;
            else
               J4 := 4 * I0 - 4;
               loop
                  J4 := J4 + 4;
                  exit when J4 > 4 * (N0 - 3);
                  Z (J4 - 3) := D + Z (J4);
                  TEMP       := Z (J4 + 2) / Z (J4 - 3);
                  D          := D * TEMP - TAU;
                  DMIN       := min (DMIN, D);
                  Z (J4 - 1) := Z (J4) * TEMP;
                  EMIN       := min (Z (J4 - 1), EMIN);
                  J4         := J4 + 4;
               end loop;
            end if;
            --
            --        Unroll last two steps.
            --
            DNM2       := D;
            DMIN2      := DMIN;
            J4         := 4 * (N0 - 2) - PP;
            J4P2       := J4 + 2 * PP - 1;
            Z (J4 - 2) := DNM2 + Z (J4P2);
            Z (J4)     := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
            DNM1       := Z (J4P2 + 2) * (DNM2 / Z (J4 - 2)) - TAU;
            DMIN       := min (DMIN, DNM1);
            --
            DMIN1      := DMIN;
            J4         := J4 + 4;
            J4P2       := J4 + 2 * PP - 1;
            Z (J4 - 2) := DNM1 + Z (J4P2);
            Z (J4)     := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
            DN         := Z (J4P2 + 2) * (DNM1 / Z (J4 - 2)) - TAU;
            DMIN       := min (DMIN, DN);
         --
         else
            --
            --        Code for non IEEE arithmetic.
            --
            if PP = 0 then
               J4 := 4 * I0 - 4;
               loop
                  J4 := J4 + 4;
                  exit when J4 > 4 * (N0 - 3);
                  Z (J4 - 2) := D + Z (J4 - 1);
                  if D < ZERO then
                     return;
                  else
                     Z (J4) := Z (J4 + 1) * (Z (J4 - 1) / Z (J4 - 2));
                     D      := Z (J4 + 1) * (D / Z (J4 - 2)) - TAU;
                  end if;
                  DMIN := min (DMIN, D);
                  EMIN := min (EMIN, Z (J4));
                  J4   := J4 + 4;
               end loop;
            else
               J4 := 4 * I0 - 4;
               loop
                  J4 := J4 + 4;
                  exit when J4 > 4 * (N0 - 3);
                  Z (J4 - 3) := D + Z (J4);
                  if D < ZERO then
                     return;
                  else
                     Z (J4 - 1) := Z (J4 + 2) * (Z (J4) / Z (J4 - 3));
                     D          := Z (J4 + 2) * (D / Z (J4 - 3)) - TAU;
                  end if;
                  DMIN := min (DMIN, D);
                  EMIN := min (EMIN, Z (J4 - 1));
                  J4   := J4 + 4;
               end loop;
            end if;
            --
            --        Unroll last two steps.
            --
            DNM2       := D;
            DMIN2      := DMIN;
            J4         := 4 * (N0 - 2) - PP;
            J4P2       := J4 + 2 * PP - 1;
            Z (J4 - 2) := DNM2 + Z (J4P2);
            if DNM2 < ZERO then
               return;
            else
               Z (J4) := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
               DNM1   := Z (J4P2 + 2) * (DNM2 / Z (J4 - 2)) - TAU;
            end if;
            DMIN := min (DMIN, DNM1);
            --
            DMIN1      := DMIN;
            J4         := J4 + 4;
            J4P2       := J4 + 2 * PP - 1;
            Z (J4 - 2) := DNM1 + Z (J4P2);
            if DNM1 < ZERO then
               return;
            else
               Z (J4) := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
               DN     := Z (J4P2 + 2) * (DNM1 / Z (J4 - 2)) - TAU;
            end if;
            DMIN := min (DMIN, DN);
            --
         end if;
      else
         --     This is the version that sets d's to zero if they are small enough
         J4    := 4 * I0 + PP - 3;
         EMIN  := Z (J4 + 4);
         D     := Z (J4) - TAU;
         DMIN  := D;
         DMIN1 := -Z (J4);
         if IEEE then
            --
            --     Code for IEEE arithmetic.
            --
            if PP = 0 then
               J4 := 4 * I0 - 4;
               loop
                  J4 := J4 + 4;
                  exit when J4 > 4 * (N0 - 3);
                  Z (J4 - 2) := D + Z (J4 - 1);
                  TEMP       := Z (J4 + 1) / Z (J4 - 2);
                  D          := D * TEMP - TAU;
                  if D < DTHRESH then
                     D := ZERO;
                  end if;
                  DMIN   := min (DMIN, D);
                  Z (J4) := Z (J4 - 1) * TEMP;
                  EMIN   := min (Z (J4), EMIN);
                  J4     := J4 + 4;
               end loop;
            else
               J4 := 4 * I0 - 4;
               loop
                  J4 := J4 + 4;
                  exit when J4 > 4 * (N0 - 3);
                  Z (J4 - 3) := D + Z (J4);
                  TEMP       := Z (J4 + 2) / Z (J4 - 3);
                  D          := D * TEMP - TAU;
                  if D < DTHRESH then
                     D := ZERO;
                  end if;
                  DMIN       := min (DMIN, D);
                  Z (J4 - 1) := Z (J4) * TEMP;
                  EMIN       := min (Z (J4 - 1), EMIN);
                  J4         := J4 + 4;
               end loop;
            end if;
            --
            --     Unroll last two steps.
            --
            DNM2       := D;
            DMIN2      := DMIN;
            J4         := 4 * (N0 - 2) - PP;
            J4P2       := J4 + 2 * PP - 1;
            Z (J4 - 2) := DNM2 + Z (J4P2);
            Z (J4)     := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
            DNM1       := Z (J4P2 + 2) * (DNM2 / Z (J4 - 2)) - TAU;
            DMIN       := min (DMIN, DNM1);
            --
            DMIN1      := DMIN;
            J4         := J4 + 4;
            J4P2       := J4 + 2 * PP - 1;
            Z (J4 - 2) := DNM1 + Z (J4P2);
            Z (J4)     := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
            DN         := Z (J4P2 + 2) * (DNM1 / Z (J4 - 2)) - TAU;
            DMIN       := min (DMIN, DN);
         --
         else
            --
            --     Code for non IEEE arithmetic.
            --
            if PP = 0 then
               J4 := 4 * I0 - 4;
               loop
                  J4 := J4 + 4;
                  exit when J4 > 4 * (N0 - 3);
                  Z (J4 - 2) := D + Z (J4 - 1);
                  if D < ZERO then
                     return;
                  else
                     Z (J4) := Z (J4 + 1) * (Z (J4 - 1) / Z (J4 - 2));
                     D      := Z (J4 + 1) * (D / Z (J4 - 2)) - TAU;
                  end if;
                  if D < DTHRESH then
                     D := ZERO;
                  end if;
                  DMIN := min (DMIN, D);
                  EMIN := min (EMIN, Z (J4));
                  J4   := J4 + 4;
               end loop;
            else
               J4 := 4 * I0 - 4;
               loop
                  J4 := J4 + 4;
                  exit when J4 > 4 * (N0 - 3);
                  Z (J4 - 3) := D + Z (J4);
                  if D < ZERO then
                     return;
                  else
                     Z (J4 - 1) := Z (J4 + 2) * (Z (J4) / Z (J4 - 3));
                     D          := Z (J4 + 2) * (D / Z (J4 - 3)) - TAU;
                  end if;
                  if D < DTHRESH then
                     D := ZERO;
                  end if;
                  DMIN := min (DMIN, D);
                  EMIN := min (EMIN, Z (J4 - 1));
                  J4   := J4 + 4;
               end loop;
            end if;
            --
            --     Unroll last two steps.
            --
            DNM2       := D;
            DMIN2      := DMIN;
            J4         := 4 * (N0 - 2) - PP;
            J4P2       := J4 + 2 * PP - 1;
            Z (J4 - 2) := DNM2 + Z (J4P2);
            if DNM2 < ZERO then
               return;
            else
               Z (J4) := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
               DNM1   := Z (J4P2 + 2) * (DNM2 / Z (J4 - 2)) - TAU;
            end if;
            DMIN := min (DMIN, DNM1);
            --
            DMIN1      := DMIN;
            J4         := J4 + 4;
            J4P2       := J4 + 2 * PP - 1;
            Z (J4 - 2) := DNM1 + Z (J4P2);
            if DNM1 < ZERO then
               return;
            else
               Z (J4) := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
               DN     := Z (J4P2 + 2) * (DNM1 / Z (J4 - 2)) - TAU;
            end if;
            DMIN := min (DMIN, DN);
            --
         end if;
      end if;
      --
      Z (J4 + 2)      := DN;
      Z (4 * N0 - PP) := EMIN;
      return;
      --
      --     End of DLASQ5
      --
   end DLASQ5;

   procedure DLASQ6
     (I0    : Integer;
      N0    : Integer;
      Z     : in out Ftn_Real_Vector;
      PP    : Integer;
      DMIN  : in out Real;
      DMIN1 : in out Real;
      DMIN2 : in out Real;
      DN    : in out Real;
      DNM1  : in out Real;
      DNM2  : in out Real)
   is
      ZERO   : constant Real := 0.0e0;
      J4     : Integer;
      J4P2   : Integer;
      D      : Real;
      EMIN   : Real;
      SAFMIN : Real;
      TEMP   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN,
   --                          DNM1, DNM2 )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            I0, N0, PP
   --       DOUBLE PRECISION   DMIN, DMIN1, DMIN2, DN, DNM1, DNM2
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   Z( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASQ6 computes one dqd (shift equal to zero) transform in
   --  ping-pong form, with protection against underflow and overflow.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] I0
   --           I0 is INTEGER
   --         First index.
   --
   --  [in] N0
   --           N0 is INTEGER
   --         Last index.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension ( 4*N )
   --         Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
   --         an extra argument.
   --
   --  [in] PP
   --           PP is INTEGER
   --         PP=0 for ping, PP=1 for pong.
   --
   --  [out] DMIN
   --           DMIN is DOUBLE PRECISION
   --         Minimum value of d.
   --
   --  [out] DMIN1
   --           DMIN1 is DOUBLE PRECISION
   --         Minimum value of d, excluding D( N0 ).
   --
   --  [out] DMIN2
   --           DMIN2 is DOUBLE PRECISION
   --         Minimum value of d, excluding D( N0 ) and D( N0-1 ).
   --
   --  [out] DN
   --           DN is DOUBLE PRECISION
   --         d(N0), the last value of d.
   --
   --  [out] DNM1
   --           DNM1 is DOUBLE PRECISION
   --         d(N0-1).
   --
   --  [out] DNM2
   --           DNM2 is DOUBLE PRECISION
   --         d(N0-2).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameter ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Function ..
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if (N0 - I0 - 1) <= 0 then
         return;
      end if;
      --
      SAFMIN := DLAMCH ('S');
      J4     := 4 * I0 + PP - 3;
      EMIN   := Z (J4 + 4);
      D      := Z (J4);
      DMIN   := D;
      --
      if PP = 0 then
         J4 := 4 * I0 - 4;
         loop
            J4 := J4 + 4;
            exit when J4 > 4 * (N0 - 3);
            Z (J4 - 2) := D + Z (J4 - 1);
            if Z (J4 - 2) = ZERO then
               Z (J4) := ZERO;
               D      := Z (J4 + 1);
               DMIN   := D;
               EMIN   := ZERO;
            elsif SAFMIN * Z (J4 + 1) < Z (J4 - 2) and SAFMIN * Z (J4 - 2) < Z (J4 + 1) then
               TEMP   := Z (J4 + 1) / Z (J4 - 2);
               Z (J4) := Z (J4 - 1) * TEMP;
               D      := D * TEMP;
            else
               Z (J4) := Z (J4 + 1) * (Z (J4 - 1) / Z (J4 - 2));
               D      := Z (J4 + 1) * (D / Z (J4 - 2));
            end if;
            DMIN := min (DMIN, D);
            EMIN := min (EMIN, Z (J4));
            J4   := J4 + 4;
         end loop;
      else
         J4 := 4 * I0 - 4;
         loop
            J4 := J4 + 4;
            exit when J4 > 4 * (N0 - 3);
            Z (J4 - 3) := D + Z (J4);
            if Z (J4 - 3) = ZERO then
               Z (J4 - 1) := ZERO;
               D          := Z (J4 + 2);
               DMIN       := D;
               EMIN       := ZERO;
            elsif SAFMIN * Z (J4 + 2) < Z (J4 - 3) and SAFMIN * Z (J4 - 3) < Z (J4 + 2) then
               TEMP       := Z (J4 + 2) / Z (J4 - 3);
               Z (J4 - 1) := Z (J4) * TEMP;
               D          := D * TEMP;
            else
               Z (J4 - 1) := Z (J4 + 2) * (Z (J4) / Z (J4 - 3));
               D          := Z (J4 + 2) * (D / Z (J4 - 3));
            end if;
            DMIN := min (DMIN, D);
            EMIN := min (EMIN, Z (J4 - 1));
            J4   := J4 + 4;
         end loop;
      end if;
      --
      --     Unroll last two steps.
      --
      DNM2       := D;
      DMIN2      := DMIN;
      J4         := 4 * (N0 - 2) - PP;
      J4P2       := J4 + 2 * PP - 1;
      Z (J4 - 2) := DNM2 + Z (J4P2);
      if Z (J4 - 2) = ZERO then
         Z (J4) := ZERO;
         DNM1   := Z (J4P2 + 2);
         DMIN   := DNM1;
         EMIN   := ZERO;
      elsif SAFMIN * Z (J4P2 + 2) < Z (J4 - 2) and SAFMIN * Z (J4 - 2) < Z (J4P2 + 2) then
         TEMP   := Z (J4P2 + 2) / Z (J4 - 2);
         Z (J4) := Z (J4P2) * TEMP;
         DNM1   := DNM2 * TEMP;
      else
         Z (J4) := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
         DNM1   := Z (J4P2 + 2) * (DNM2 / Z (J4 - 2));
      end if;
      DMIN := min (DMIN, DNM1);
      --
      DMIN1      := DMIN;
      J4         := J4 + 4;
      J4P2       := J4 + 2 * PP - 1;
      Z (J4 - 2) := DNM1 + Z (J4P2);
      if Z (J4 - 2) = ZERO then
         Z (J4) := ZERO;
         DN     := Z (J4P2 + 2);
         DMIN   := DN;
         EMIN   := ZERO;
      elsif SAFMIN * Z (J4P2 + 2) < Z (J4 - 2) and SAFMIN * Z (J4 - 2) < Z (J4P2 + 2) then
         TEMP   := Z (J4P2 + 2) / Z (J4 - 2);
         Z (J4) := Z (J4P2) * TEMP;
         DN     := DNM1 * TEMP;
      else
         Z (J4) := Z (J4P2 + 2) * (Z (J4P2) / Z (J4 - 2));
         DN     := Z (J4P2 + 2) * (DNM1 / Z (J4 - 2));
      end if;
      DMIN := min (DMIN, DN);
      --
      Z (J4 + 2)      := DN;
      Z (4 * N0 - PP) := EMIN;
      return;
      --
      --     End of DLASQ6
      --
   end DLASQ6;

   procedure DLASR
     (SIDE   : Character;
      PIVOT  : Character;
      DIRECT : Character;
      M      : Integer;
      N      : Integer;
      C_adr  : Address;
      S_adr  : Address;
      A_adr  : Address;
      LDA    : Integer)
   is

      C : Ftn_Real_Vector (1 .. max (M - 1, N - 1));
      S : Ftn_Real_Vector (1 .. max (M - 1, N - 1));
      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);

      for C'Address use C_adr;
      for S'Address use S_adr;
      for A'Address use A_adr;

      pragma Import (Ada, C);
      pragma Import (Ada, S);
      pragma Import (Ada, A);

      ONE   : constant Real := 1.0e0;
      ZERO  : constant Real := 0.0e0;
      I     : Integer;
      INFO  : Integer;
      J     : Integer;
      CTEMP : Real;
      STEMP : Real;
      TEMP  : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASR( SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIRECT, PIVOT, SIDE
   --       INTEGER            LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( * ), S( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASR applies a sequence of plane rotations to a real matrix A,
   --  from either the left or the right.
   --
   --  When SIDE = 'L', the transformation takes the form
   --
   --     A := P*A
   --
   --  and when SIDE = 'R', the transformation takes the form
   --
   --     A := A*P**T
   --
   --  where P is an orthogonal matrix consisting of a sequence of z plane
   --  rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
   --  and P**T is the transpose of P.
   --
   --  When DIRECT = 'F' (Forward sequence), then
   --
   --     P = P(z-1) * ... * P(2) * P(1)
   --
   --  and when DIRECT = 'B' (Backward sequence), then
   --
   --     P = P(1) * P(2) * ... * P(z-1)
   --
   --  where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
   --
   --     R(k) = (  c(k)  s(k) )
   --          = ( -s(k)  c(k) ).
   --
   --  When PIVOT = 'V' (Variable pivot), the rotation is performed
   --  for the plane (k,k+1), i.e., P(k) has the form
   --
   --     P(k) = (  1                                            )
   --            (       ...                                     )
   --            (              1                                )
   --            (                   c(k)  s(k)                  )
   --            (                  -s(k)  c(k)                  )
   --            (                                1              )
   --            (                                     ...       )
   --            (                                            1  )
   --
   --  where R(k) appears as a rank-2 modification to the identity matrix in
   --  rows and columns k and k+1.
   --
   --  When PIVOT = 'T' (Top pivot), the rotation is performed for the
   --  plane (1,k+1), so P(k) has the form
   --
   --     P(k) = (  c(k)                    s(k)                 )
   --            (         1                                     )
   --            (              ...                              )
   --            (                     1                         )
   --            ( -s(k)                    c(k)                 )
   --            (                                 1             )
   --            (                                      ...      )
   --            (                                             1 )
   --
   --  where R(k) appears in rows and columns 1 and k+1.
   --
   --  Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
   --  performed for the plane (k,z), giving P(k) the form
   --
   --     P(k) = ( 1                                             )
   --            (      ...                                      )
   --            (             1                                 )
   --            (                  c(k)                    s(k) )
   --            (                         1                     )
   --            (                              ...              )
   --            (                                     1         )
   --            (                 -s(k)                    c(k) )
   --
   --  where R(k) appears in rows and columns k and z.  The rotations are
   --  performed without ever forming P(k) explicitly.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           Specifies whether the plane rotation matrix P is applied to
   --           A on the left or the right.
   --           = 'L':  Left, compute A := P*A
   --           = 'R':  Right, compute A:= A*P**T
   --
   --  [in] PIVOT
   --           PIVOT is CHARACTER*1
   --           Specifies the plane for which P(k) is a plane rotation
   --           matrix.
   --           = 'V':  Variable pivot, the plane (k,k+1)
   --           = 'T':  Top pivot, the plane (1,k+1)
   --           = 'B':  Bottom pivot, the plane (k,z)
   --
   --  [in] DIRECT
   --           DIRECT is CHARACTER*1
   --           Specifies whether P is a forward or backward sequence of
   --           plane rotations.
   --           = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
   --           = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  If m <= 1, an immediate
   --           return is effected.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  If n <= 1, an
   --           immediate return is effected.
   --
   --  [in] C
   --           C is DOUBLE PRECISION array, dimension
   --                   (M-1) if SIDE = 'L'
   --                   (N-1) if SIDE = 'R'
   --           The cosines c(k) of the plane rotations.
   --
   --  [in] S
   --           S is DOUBLE PRECISION array, dimension
   --                   (M-1) if SIDE = 'L'
   --                   (N-1) if SIDE = 'R'
   --           The sines s(k) of the plane rotations.  The 2-by-2 plane
   --           rotation part of the matrix P(k), R(k), has the form
   --           R(k) = (  c(k)  s(k) )
   --                  ( -s(k)  c(k) ).
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The M-by-N matrix A.  On exit, A is overwritten by P*A if
   --           SIDE = 'R' or by A*P**T if SIDE = 'L'.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO := 0;
      if not (LSAME (SIDE, 'L') or LSAME (SIDE, 'R')) then
         INFO := 1;
      elsif not (LSAME (PIVOT, 'V') or LSAME (PIVOT, 'T') or LSAME (PIVOT, 'B')) then
         INFO := 2;
      elsif not (LSAME (DIRECT, 'F') or LSAME (DIRECT, 'B')) then
         INFO := 3;
      elsif M < 0 then
         INFO := 4;
      elsif N < 0 then
         INFO := 5;
      elsif LDA < max (1, M) then
         INFO := 9;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASR ", INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if (M = 0) or (N = 0) then
         return;
      end if;
      if LSAME (SIDE, 'L') then
         --
         --        Form  P * A
         --
         if LSAME (PIVOT, 'V') then
            if LSAME (DIRECT, 'F') then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > M - 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP         := A (J + 1, I);
                        A (J + 1, I) := CTEMP * TEMP - STEMP * A (J, I);
                        A (J, I)     := STEMP * TEMP + CTEMP * A (J, I);
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := M - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP         := A (J + 1, I);
                        A (J + 1, I) := CTEMP * TEMP - STEMP * A (J, I);
                        A (J, I)     := STEMP * TEMP + CTEMP * A (J, I);
                     end loop;
                  end if;
               end loop;
            end if;
         elsif LSAME (PIVOT, 'T') then
            if LSAME (DIRECT, 'F') then
               J := 2 - 1;
               loop
                  J := J + 1;
                  exit when J > M;
                  CTEMP := C (J - 1);
                  STEMP := S (J - 1);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP     := A (J, I);
                        A (J, I) := CTEMP * TEMP - STEMP * A (1, I);
                        A (1, I) := STEMP * TEMP + CTEMP * A (1, I);
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := M + 1;
               loop
                  J := J - 1;
                  exit when J < 2;
                  CTEMP := C (J - 1);
                  STEMP := S (J - 1);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP     := A (J, I);
                        A (J, I) := CTEMP * TEMP - STEMP * A (1, I);
                        A (1, I) := STEMP * TEMP + CTEMP * A (1, I);
                     end loop;
                  end if;
               end loop;
            end if;
         elsif LSAME (PIVOT, 'B') then
            if LSAME (DIRECT, 'F') then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > M - 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP     := A (J, I);
                        A (J, I) := STEMP * A (M, I) + CTEMP * TEMP;
                        A (M, I) := CTEMP * A (M, I) - STEMP * TEMP;
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := M - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP     := A (J, I);
                        A (J, I) := STEMP * A (M, I) + CTEMP * TEMP;
                        A (M, I) := CTEMP * A (M, I) - STEMP * TEMP;
                     end loop;
                  end if;
               end loop;
            end if;
         end if;
      elsif LSAME (SIDE, 'R') then
         --
         --        Form A * P**T
         --
         if LSAME (PIVOT, 'V') then
            if LSAME (DIRECT, 'F') then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N - 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP         := A (I, J + 1);
                        A (I, J + 1) := CTEMP * TEMP - STEMP * A (I, J);
                        A (I, J)     := STEMP * TEMP + CTEMP * A (I, J);
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := N - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP         := A (I, J + 1);
                        A (I, J + 1) := CTEMP * TEMP - STEMP * A (I, J);
                        A (I, J)     := STEMP * TEMP + CTEMP * A (I, J);
                     end loop;
                  end if;
               end loop;
            end if;
         elsif LSAME (PIVOT, 'T') then
            if LSAME (DIRECT, 'F') then
               J := 2 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  CTEMP := C (J - 1);
                  STEMP := S (J - 1);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP     := A (I, J);
                        A (I, J) := CTEMP * TEMP - STEMP * A (I, 1);
                        A (I, 1) := STEMP * TEMP + CTEMP * A (I, 1);
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 2;
                  CTEMP := C (J - 1);
                  STEMP := S (J - 1);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP     := A (I, J);
                        A (I, J) := CTEMP * TEMP - STEMP * A (I, 1);
                        A (I, 1) := STEMP * TEMP + CTEMP * A (I, 1);
                     end loop;
                  end if;
               end loop;
            end if;
         elsif LSAME (PIVOT, 'B') then
            if LSAME (DIRECT, 'F') then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N - 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP     := A (I, J);
                        A (I, J) := STEMP * A (I, N) + CTEMP * TEMP;
                        A (I, N) := CTEMP * A (I, N) - STEMP * TEMP;
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := N - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP     := A (I, J);
                        A (I, J) := STEMP * A (I, N) + CTEMP * TEMP;
                        A (I, N) := CTEMP * A (I, N) - STEMP * TEMP;
                     end loop;
                  end if;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of DLASR
      --
   end DLASR;

   procedure DLASRT
     (ID   : Character;
      N    : Integer;
      D    : in out Ftn_Real_Vector;
      INFO : in out Integer)
   is
      Ftn_SELECT : constant Integer := 20;
      DIR        : Integer;
      ENDD       : Integer;
      I          : Integer;
      J          : Integer;
      START      : Integer;
      STKPNT     : Integer;
      D1         : Real;
      D2         : Real;
      D3         : Real;
      DMNMX      : Real;
      TMP        : Real;
      STACK      : Ftn_Integer_Matrix (1 .. 2, 1 .. 32);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASRT( ID, N, D, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          ID
   --       INTEGER            INFO, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  Sort the numbers in D in increasing order (if ID = 'I') or
   --  in decreasing order (if ID = 'D' ).
   --
   --  Use Quick Sort, reverting to Insertion sort on arrays of
   --  size <= 20. Dimension of STACK limits N to about 2**32.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ID
   --           ID is CHARACTER*1
   --           = 'I': sort D in increasing order;
   --           = 'D': sort D in decreasing order.
   --
   --  [in] N
   --           N is INTEGER
   --           The length of the array D.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the array to be sorted.
   --           On exit, D has been sorted into increasing order
   --           (D(1) <= ... <= D(N) ) or into decreasing order
   --           (D(1) >= ... >= D(N) ), depending on ID.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( SELECT = 20 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input paramters.
   --
   begin
      INFO := 0;
      DIR  := -1;
      if LSAME (ID, 'D') then
         DIR := 0;
      elsif LSAME (ID, 'I') then
         DIR := 1;
      end if;
      if DIR = -1 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      end if;
      if INFO /= 0 then
         XERBLA ("DLASRT", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 1 then
         return;
      end if;
      --
      STKPNT       := 1;
      STACK (1, 1) := 1;
      STACK (2, 1) := N;
      <<L10>> null;
      START  := STACK (1, STKPNT);
      ENDD   := STACK (2, STKPNT);
      STKPNT := STKPNT - 1;
      if ENDD - START <= Ftn_SELECT and ENDD - START > 0 then
         --
         --        Do Insertion sort on D( START:ENDD )
         --
         if DIR = 0 then
            --
            --           Sort into decreasing order
            --
            I := START + 1 - 1;
            loop
               I := I + 1;
               exit when I > ENDD;
               J := I + 1;
               loop
                  J := J - 1;
                  exit when J < START + 1;
                  if D (J) > D (J - 1) then
                     DMNMX     := D (J);
                     D (J)     := D (J - 1);
                     D (J - 1) := DMNMX;
                  else
                     goto L30;
                  end if;
               end loop;
               <<L30>> null;
            end loop;
         --
         else
            --
            --           Sort into increasing order
            --
            I := START + 1 - 1;
            loop
               I := I + 1;
               exit when I > ENDD;
               J := I + 1;
               loop
                  J := J - 1;
                  exit when J < START + 1;
                  if D (J) < D (J - 1) then
                     DMNMX     := D (J);
                     D (J)     := D (J - 1);
                     D (J - 1) := DMNMX;
                  else
                     goto L50;
                  end if;
               end loop;
               <<L50>> null;
            end loop;
            --
         end if;
      --
      elsif ENDD - START > Ftn_SELECT then
         --
         --        Partition D( START:ENDD ) and stack parts, largest one first
         --
         --        Choose partition entry as median of 3
         --
         D1 := D (START);
         D2 := D (ENDD);
         I  := (START + ENDD) / 2;
         D3 := D (I);
         if D1 < D2 then
            if D3 < D1 then
               DMNMX := D1;
            elsif D3 < D2 then
               DMNMX := D3;
            else
               DMNMX := D2;
            end if;
         else
            if D3 < D2 then
               DMNMX := D2;
            elsif D3 < D1 then
               DMNMX := D3;
            else
               DMNMX := D1;
            end if;
         end if;
         --
         if DIR = 0 then
            --
            --           Sort into decreasing order
            --
            I := START - 1;
            J := ENDD + 1;
            <<L60>> null;
            <<L70>> null;
            J := J - 1;
            if D (J) < DMNMX then
               goto L70;
            end if;
            <<L80>> null;
            I := I + 1;
            if D (I) > DMNMX then
               goto L80;
            end if;
            if I < J then
               TMP   := D (I);
               D (I) := D (J);
               D (J) := TMP;
               goto L60;
            end if;
            if J - START > ENDD - J - 1 then
               STKPNT            := STKPNT + 1;
               STACK (1, STKPNT) := START;
               STACK (2, STKPNT) := J;
               STKPNT            := STKPNT + 1;
               STACK (1, STKPNT) := J + 1;
               STACK (2, STKPNT) := ENDD;
            else
               STKPNT            := STKPNT + 1;
               STACK (1, STKPNT) := J + 1;
               STACK (2, STKPNT) := ENDD;
               STKPNT            := STKPNT + 1;
               STACK (1, STKPNT) := START;
               STACK (2, STKPNT) := J;
            end if;
         else
            --
            --           Sort into increasing order
            --
            I := START - 1;
            J := ENDD + 1;
            <<L90>> null;
            <<L100>> null;
            J := J - 1;
            if D (J) > DMNMX then
               goto L100;
            end if;
            <<L110>> null;
            I := I + 1;
            if D (I) < DMNMX then
               goto L110;
            end if;
            if I < J then
               TMP   := D (I);
               D (I) := D (J);
               D (J) := TMP;
               goto L90;
            end if;
            if J - START > ENDD - J - 1 then
               STKPNT            := STKPNT + 1;
               STACK (1, STKPNT) := START;
               STACK (2, STKPNT) := J;
               STKPNT            := STKPNT + 1;
               STACK (1, STKPNT) := J + 1;
               STACK (2, STKPNT) := ENDD;
            else
               STKPNT            := STKPNT + 1;
               STACK (1, STKPNT) := J + 1;
               STACK (2, STKPNT) := ENDD;
               STKPNT            := STKPNT + 1;
               STACK (1, STKPNT) := START;
               STACK (2, STKPNT) := J;
            end if;
         end if;
      end if;
      if STKPNT > 0 then
         goto L10;
      end if;
      return;
      --
      --     End of DLASRT
      --
   end DLASRT;

   procedure DLASSQ
     (N     : Integer;
      X_adr : Address;
      INCX  : Integer;
      SCALE : in out Real;
      SUMSQ : in out Real)
   is

      X : Ftn_Real_Vector (1 .. 1 + (N - 1) * INCX);

      for X'Address use X_adr;

      pragma Import (Ada, X);

      ZERO  : constant Real := 0.0e0;
      IX    : Integer;
      ABSXI : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASSQ( N, X, INCX, SCALE, SUMSQ )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, N
   --       DOUBLE PRECISION   SCALE, SUMSQ
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   X( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASSQ  returns the values  scl  and  smsq  such that
   --
   --     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
   --
   --  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
   --  assumed to be non-negative and  scl  returns the value
   --
   --     scl = max( scale, abs( x( i ) ) ).
   --
   --  scale and sumsq must be supplied in SCALE and SUMSQ and
   --  scl and smsq are overwritten on SCALE and SUMSQ respectively.
   --
   --  The routine makes only one pass through the vector x.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The number of elements to be used from the vector X.
   --
   --  [in] X
   --           X is DOUBLE PRECISION array, dimension (N)
   --           The vector for which a scaled sum of squares is computed.
   --              x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --           The increment between successive values of the vector X.
   --           INCX > 0.
   --
   --  [in,out] SCALE
   --           SCALE is DOUBLE PRECISION
   --           On entry, the value  scale  in the equation above.
   --           On exit, SCALE is overwritten with  scl, the scaling factor
   --           for the sum of squares.
   --
   --  [in,out] SUMSQ
   --           SUMSQ is DOUBLE PRECISION
   --           On entry, the value  sumsq  in the equation above.
   --           On exit, SUMSQ is overwritten with  smsq, the basic sum of
   --           squares from which  scl  has been factored out.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N > 0 then
         IX := 1 - INCX;
         loop
            IX := IX + INCX;
            exit when IX > 1 + (N - 1) * INCX;
            if X (IX) /= ZERO then
               ABSXI := abs (X (IX));
               if SCALE < ABSXI then
                  SUMSQ := 1.0e0 + SUMSQ * (SCALE / ABSXI) ** 2;
                  SCALE := ABSXI;
               else
                  SUMSQ := SUMSQ + (ABSXI / SCALE) ** 2;
               end if;
            end if;
         end loop;
      end if;
      return;
      --
      --     End of DLASSQ
      --
   end DLASSQ;

   procedure DLASV2
     (F     : Real;
      G     : Real;
      H     : Real;
      SSMIN : in out Real;
      SSMAX : in out Real;
      SNR   : in out Real;
      CSR   : in out Real;
      SNL   : in out Real;
      CSL   : in out Real)
   is
      ZERO   : constant Real := 0.0e0;
      HALF   : constant Real := 0.5e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      FOUR   : constant Real := 4.0e0;
      GASMAL : Boolean;
      SWAP   : Boolean;
      PMAX   : Integer;
      A      : Real;
      CLT    : Real;
      CRT    : Real;
      D      : Real;
      FA     : Real;
      FT     : Real;
      GA     : Real;
      GT     : Real;
      HA     : Real;
      HT     : Real;
      L      : Real;
      M      : Real;
      MM     : Real;
      R      : Real;
      S      : Real;
      SLT    : Real;
      SRT    : Real;
      T      : Real;
      TEMP   : Real;
      TSIGN  : Real;
      TT     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASV2( F, G, H, SSMIN, SSMAX, SNR, CSR, SNL, CSL )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   CSL, CSR, F, G, H, SNL, SNR, SSMAX, SSMIN
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASV2 computes the singular value decomposition of a 2-by-2
   --  triangular matrix
   --     [  F   G  ]
   --     [  0   H  ].
   --  On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
   --  smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
   --  right singular vectors for abs(SSMAX), giving the decomposition
   --
   --     [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
   --     [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
   --
   --  Arguments:
   --  ==========
   --
   --  [in] F
   --           F is DOUBLE PRECISION
   --           The (1,1) element of the 2-by-2 matrix.
   --
   --  [in] G
   --           G is DOUBLE PRECISION
   --           The (1,2) element of the 2-by-2 matrix.
   --
   --  [in] H
   --           H is DOUBLE PRECISION
   --           The (2,2) element of the 2-by-2 matrix.
   --
   --  [out] SSMIN
   --           SSMIN is DOUBLE PRECISION
   --           abs(SSMIN) is the smaller singular value.
   --
   --  [out] SSMAX
   --           SSMAX is DOUBLE PRECISION
   --           abs(SSMAX) is the larger singular value.
   --
   --  [out] SNL
   --           SNL is DOUBLE PRECISION
   --
   --  [out] CSL
   --           CSL is DOUBLE PRECISION
   --           The vector (CSL, SNL) is a unit left singular vector for the
   --           singular value abs(SSMAX).
   --
   --  [out] SNR
   --           SNR is DOUBLE PRECISION
   --
   --  [out] CSR
   --           CSR is DOUBLE PRECISION
   --           The vector (CSR, SNR) is a unit right singular vector for the
   --           singular value abs(SSMAX).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Any input parameter may be aliased with any output parameter.
   --
   --   Barring over/underflow and assuming a guard digit in subtraction, all
   --   output quantities are correct to within a few units in the last
   --   place (ulps).
   --
   --   In IEEE arithmetic, the code works correctly if one matrix element is
   --   infinite.
   --
   --   Overflow will not occur unless the largest singular value itself
   --   overflows or is within a few ulps of overflow. (On machines with
   --   partial overflow, like the Cray, overflow may occur if the largest
   --   singular value is within a factor of 2 of overflow.)
   --
   --   Underflow is harmless if underflow is gradual. Otherwise, results
   --   may correspond to a matrix modified by perturbations of size near
   --   the underflow threshold.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --      PARAMETER          ( HALF = 0.5D0 )
   --      PARAMETER          ( ONE = 1.0D0 )
   --      PARAMETER          ( TWO = 2.0D0 )
   --      PARAMETER          ( FOUR = 4.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SIGN, SQRT
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH
   --     ..
   --     .. Executable Statements ..
   --
   begin
      FT := F;
      FA := abs (FT);
      HT := H;
      HA := abs (H);
      --
      --     PMAX points to the maximum absolute element of matrix
      --       PMAX = 1 if F largest in absolute values
      --       PMAX = 2 if G largest in absolute values
      --       PMAX = 3 if H largest in absolute values
      --
      PMAX := 1;
      SWAP := (HA > FA);
      if SWAP then
         PMAX := 3;
         TEMP := FT;
         FT   := HT;
         HT   := TEMP;
         TEMP := FA;
         FA   := HA;
         HA   := TEMP;
         --
         --        Now FA .ge. HA
         --
      end if;
      GT := G;
      GA := abs (GT);
      if GA = ZERO then
         --
         --        Diagonal matrix
         --
         SSMIN := HA;
         SSMAX := FA;
         CLT   := ONE;
         CRT   := ONE;
         SLT   := ZERO;
         SRT   := ZERO;
      else
         GASMAL := True;
         if GA > FA then
            PMAX := 2;
            if (FA / GA) < DLAMCH ('E') then
               --
               --              Case of very large GA
               --
               GASMAL := False;
               SSMAX  := GA;
               if HA > ONE 
                  then SSMIN := FA / (GA / HA);
                  else SSMIN := (FA / GA) * HA;
               end if;
               CLT := ONE;
               SLT := HT / GT;
               SRT := ONE;
               CRT := FT / GT;
            end if;
         end if;
         if GASMAL then
            --
            --           Normal case
            --
            D := FA - HA;
            if D = FA then
               --
               --              Copes with infinite F or H
               --
               L := ONE;
            else
               L := D / FA;
            end if;
            --
            --           Note that 0 .le. L .le. 1
            --
            M := GT / FT;
            --
            --           Note that abs(M) .le. 1/macheps
            --
            T := TWO - L;
            --
            --           Note that T .ge. 1
            --
            MM := M * M;
            TT := T * T;
            S  := Sqrt (TT + MM);
            --
            --           Note that 1 .le. S .le. 1 + 1/macheps
            --
            if L = ZERO 
               then R := abs (M);
               else R := Sqrt (L * L + MM);
            end if;
            --
            --           Note that 0 .le. R .le. 1 + 1/macheps
            --
            A := HALF * (S + R);
            --
            --           Note that 1 .le. A .le. 1 + abs(M)
            --
            SSMIN := HA / A;
            SSMAX := FA * A;
            if MM = ZERO then
               --
               --              Note that M is very tiny
               --
               if L = ZERO 
                  then T := sign (TWO, FT) * sign (ONE, GT);
                  else T := GT / sign (D, FT) + M / T;
               end if;
            else
               T := (M / (S + T) + M / (R + L)) * (ONE + A);
            end if;
            L   := Sqrt (T * T + FOUR);
            CRT := TWO / L;
            SRT := T / L;
            CLT := (CRT + SRT * M) / A;
            SLT := (HT / FT) * SRT / A;
         end if;
      end if;
      if SWAP then
         CSL := SRT;
         SNL := CRT;
         CSR := SLT;
         SNR := CLT;
      else
         CSL := CLT;
         SNL := SLT;
         CSR := CRT;
         SNR := SRT;
      end if;
      --
      --     Correct signs of SSMAX and SSMIN
      --
      if PMAX = 1 then
         TSIGN := sign (ONE, CSR) * sign (ONE, CSL) * sign (ONE, F);
      end if;
      if PMAX = 2 then
         TSIGN := sign (ONE, SNR) * sign (ONE, CSL) * sign (ONE, G);
      end if;
      if PMAX = 3 then
         TSIGN := sign (ONE, SNR) * sign (ONE, SNL) * sign (ONE, H);
      end if;
      SSMAX := sign (SSMAX, TSIGN);
      SSMIN := sign (SSMIN, TSIGN * sign (ONE, F) * sign (ONE, H));
      return;
      --
      --     End of DLASV2
      --
   end DLASV2;

   procedure DLASWP
     (N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      K1       : Integer;
      K2       : Integer;
      IPIV_adr : Address;
      INCX     : Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      IPIV : Ftn_Integer_Vector (1 .. K2 * abs (INCX));

      for A'Address use A_adr;
      for IPIV'Address use IPIV_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, IPIV);

      I    : Integer;
      I1   : Integer;
      I2   : Integer;
      INC  : Integer;
      IP   : Integer;
      IX   : Integer;
      IX0  : Integer;
      J    : Integer;
      K    : Integer;
      N32  : Integer;
      TEMP : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASWP( N, A, LDA, K1, K2, IPIV, INCX )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, K1, K2, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASWP performs a series of row interchanges on the matrix A.
   --  One row interchange is initiated for each of rows K1 through K2 of A.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the matrix of column dimension N to which the row
   --           interchanges will be applied.
   --           On exit, the permuted matrix.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --
   --  [in] K1
   --           K1 is INTEGER
   --           The first element of IPIV for which a row interchange will
   --           be done.
   --
   --  [in] K2
   --           K2 is INTEGER
   --           The last element of IPIV for which a row interchange will
   --           be done.
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (K2*abs(INCX))
   --           The vector of pivot indices.  Only the elements in positions
   --           K1 through K2 of IPIV are accessed.
   --           IPIV(K) = L implies rows K and L are to be interchanged.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --           The increment between successive values of IPIV.  If IPIV
   --           is negative, the pivots are applied in reverse order.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Modified by
   --    R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Interchange row I with row IPIV(I) for each of rows K1 through K2.
   --
   begin
      if INCX > 0 then
         IX0 := K1;
         I1  := K1;
         I2  := K2;
         INC := 1;
      elsif INCX < 0 then
         IX0 := 1 + (1 - K2) * INCX;
         I1  := K2;
         I2  := K1;
         INC := -1;
      else
         return;
      end if;
      --
      N32 := (N / 32) * 32;
      if N32 /= 0 then
         J := 1 - 32;
         loop
            J := J + 32;
            exit when J > N32;
            IX := IX0;
            I  := I1 - INC;
            loop
               I := I + INC;
               if INC > 0 
                  then exit when I > I2;
                  else exit when I < I2;
               end if;
               IP := IPIV (IX);
               if IP /= I then
                  K := J - 1;
                  loop
                     K := K + 1;
                     exit when K > J + 31;
                     TEMP      := A (I, K);
                     A (I, K)  := A (IP, K);
                     A (IP, K) := TEMP;
                  end loop;
               end if;
               IX := IX + INCX;
            end loop;
         end loop;
      end if;
      if N32 /= N then
         N32 := N32 + 1;
         IX  := IX0;
         I   := I1 - INC;
         loop
            I := I + INC;
            if INC > 0 
               then exit when I > I2;
               else exit when I < I2;
            end if;
            IP := IPIV (IX);
            if IP /= I then
               K := N32 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  TEMP      := A (I, K);
                  A (I, K)  := A (IP, K);
                  A (IP, K) := TEMP;
               end loop;
            end if;
            IX := IX + INCX;
         end loop;
      end if;
      --
      return;
      --
      --     End of DLASWP
      --
   end DLASWP;

   procedure DLASY2
     (LTRANL : Boolean;
      LTRANR : Boolean;
      ISGN   : Integer;
      N1     : Integer;
      N2     : Integer;
      TL_adr : Address;
      LDTL   : Integer;
      TR_adr : Address;
      LDTR   : Integer;
      B_adr  : Address;
      LDB    : Integer;
      SCALE  : in out Real;
      X_adr  : Address;
      LDX    : Integer;
      XNORM  : in out Real;
      INFO   : in out Integer)
   is

      TL : Ftn_Real_Matrix (1 .. LDTL, 1 .. 2);
      TR : Ftn_Real_Matrix (1 .. LDTR, 1 .. 2);
      B  : Ftn_Real_Matrix (1 .. LDB, 1 .. 2);
      X  : Ftn_Real_Matrix (1 .. LDX, 1 .. 2);

      for TL'Address use TL_adr;
      for TR'Address use TR_adr;
      for B'Address use B_adr;
      for X'Address use X_adr;

      pragma Import (Ada, TL);
      pragma Import (Ada, TR);
      pragma Import (Ada, B);
      pragma Import (Ada, X);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      HALF   : constant Real := 0.5e0;
      EIGHT  : constant Real := 8.0e0;
      BSWAP  : Boolean;
      XSWAP  : Boolean;
      I      : Integer;
      IP     : Integer;
      IPIV   : Integer;
      IPSV   : Integer;
      J      : Integer;
      JP     : Integer;
      JPSV   : Integer;
      K      : Integer;
      BET    : Real;
      EPS    : Real;
      GAM    : Real;
      L21    : Real;
      SGN    : Real;
      SMIN   : Real;
      SMLNUM : Real;
      TAU1   : Real;
      TEMP   : Real;
      U11    : Real;
      U12    : Real;
      U22    : Real;
      XMAX   : Real;
      BSWPIV : Ftn_Boolean_Vector (1 .. 4) := (False, True, False, True);
      XSWPIV : Ftn_Boolean_Vector (1 .. 4) := (False, False, True, True);
      JPIV   : Ftn_Integer_Vector (1 .. 4);
      LOCL21 : Ftn_Integer_Vector (1 .. 4) := (2, 1, 4, 3);
      LOCU12 : Ftn_Integer_Vector (1 .. 4) := (3, 4, 1, 2);
      LOCU22 : Ftn_Integer_Vector (1 .. 4) := (4, 3, 2, 1);
      BTMP   : Ftn_Real_Vector (1 .. 4);
      T16    : Ftn_Real_Matrix (1 .. 4, 1 .. 4);
      TMP    : Ftn_Real_Vector (1 .. 4);
      X2     : Ftn_Real_Vector (1 .. 2);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASY2( LTRANL, LTRANR, ISGN, N1, N2, TL, LDTL, TR,
   --                          LDTR, B, LDB, SCALE, X, LDX, XNORM, INFO )
   --
   --       .. Scalar Arguments ..
   --       LOGICAL            LTRANL, LTRANR
   --       INTEGER            INFO, ISGN, LDB, LDTL, LDTR, LDX, N1, N2
   --       DOUBLE PRECISION   SCALE, XNORM
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   B( LDB, * ), TL( LDTL, * ), TR( LDTR, * ),
   --      $                   X( LDX, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
   --
   --         op(TL)*X + ISGN*X*op(TR) = SCALE*B,
   --
   --  where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
   --  -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] LTRANL
   --           LTRANL is LOGICAL
   --           On entry, LTRANL specifies the op(TL):
   --              = .FALSE., op(TL) = TL,
   --              = .TRUE., op(TL) = TL**T.
   --
   --  [in] LTRANR
   --           LTRANR is LOGICAL
   --           On entry, LTRANR specifies the op(TR):
   --             = .FALSE., op(TR) = TR,
   --             = .TRUE., op(TR) = TR**T.
   --
   --  [in] ISGN
   --           ISGN is INTEGER
   --           On entry, ISGN specifies the sign of the equation
   --           as described before. ISGN may only be 1 or -1.
   --
   --  [in] N1
   --           N1 is INTEGER
   --           On entry, N1 specifies the order of matrix TL.
   --           N1 may only be 0, 1 or 2.
   --
   --  [in] N2
   --           N2 is INTEGER
   --           On entry, N2 specifies the order of matrix TR.
   --           N2 may only be 0, 1 or 2.
   --
   --  [in] TL
   --           TL is DOUBLE PRECISION array, dimension (LDTL,2)
   --           On entry, TL contains an N1 by N1 matrix.
   --
   --  [in] LDTL
   --           LDTL is INTEGER
   --           The leading dimension of the matrix TL. LDTL >= max(1,N1).
   --
   --  [in] TR
   --           TR is DOUBLE PRECISION array, dimension (LDTR,2)
   --           On entry, TR contains an N2 by N2 matrix.
   --
   --  [in] LDTR
   --           LDTR is INTEGER
   --           The leading dimension of the matrix TR. LDTR >= max(1,N2).
   --
   --  [in] B
   --           B is DOUBLE PRECISION array, dimension (LDB,2)
   --           On entry, the N1 by N2 matrix B contains the right-hand
   --           side of the equation.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the matrix B. LDB >= max(1,N1).
   --
   --  [out] SCALE
   --           SCALE is DOUBLE PRECISION
   --           On exit, SCALE contains the scale factor. SCALE is chosen
   --           less than or equal to 1 to prevent the solution overflowing.
   --
   --  [out] X
   --           X is DOUBLE PRECISION array, dimension (LDX,2)
   --           On exit, X contains the N1 by N2 solution.
   --
   --  [in] LDX
   --           LDX is INTEGER
   --           The leading dimension of the matrix X. LDX >= max(1,N1).
   --
   --  [out] XNORM
   --           XNORM is DOUBLE PRECISION
   --           On exit, XNORM is the infinity-norm of the solution.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           On exit, INFO is set to
   --              0: successful exit.
   --              1: TL and TR have too close eigenvalues, so TL or
   --                 TR is perturbed to get a nonsingular equation.
   --           NOTE: In the interests of speed, this routine does not
   --                 check the inputs for errors.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( TWO = 2.0D+0, HALF = 0.5D+0, EIGHT = 8.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      INTEGER            IDAMAX
   --      DOUBLE PRECISION   DLAMCH
   --      EXTERNAL           IDAMAX, DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX
   --     ..
   --     .. Data statements ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Do not check the input parameters for errors
   --
   begin
      INFO := 0;
      --
      --     Quick return if possible
      --
      if N1 = 0 or N2 = 0 then
         return;
      end if;
      --
      --     Set constants to control overflow
      --
      EPS    := DLAMCH ('P');
      SMLNUM := DLAMCH ('S') / EPS;
      SGN    := Real (ISGN);
      --
      K := N1 + N1 + N2 - 2;
      --      GO TO ( 10, 20, 30, 50 )K
      if K = 1 then
         goto L10;
      elsif K = 2 then
         goto L20;
      elsif K = 3 then
         goto L30;
      elsif K = 4 then
         goto L50;
      end if;
      --
      --     1 by 1: TL11*X + SGN*X*TR11 = B11
      --
      <<L10>> null;
      TAU1 := TL (1, 1) + SGN * TR (1, 1);
      BET  := abs (TAU1);
      if BET <= SMLNUM then
         TAU1 := SMLNUM;
         BET  := SMLNUM;
         INFO := 1;
      end if;
      --
      SCALE := ONE;
      GAM   := abs (B (1, 1));
      if SMLNUM * GAM > BET then
         SCALE := ONE / GAM;
      end if;
      --
      X (1, 1) := (B (1, 1) * SCALE) / TAU1;
      XNORM    := abs (X (1, 1));
      return;
      --
      --     1 by 2:
      --     TL11*[X11 X12] + ISGN*[X11 X12]*op[TR11 TR12]  = [B11 B12]
      --                                       [TR21 TR22]
      --
      <<L20>> null;
      --
      SMIN    :=
         max
           (EPS * max (abs (TL (1, 1)), abs (TR (1, 1)), abs (TR (1, 2)), abs (TR (2, 1)), abs (TR (2, 2))),
            SMLNUM);
      TMP (1) := TL (1, 1) + SGN * TR (1, 1);
      TMP (4) := TL (1, 1) + SGN * TR (2, 2);
      if LTRANR then
         TMP (2) := SGN * TR (2, 1);
         TMP (3) := SGN * TR (1, 2);
      else
         TMP (2) := SGN * TR (1, 2);
         TMP (3) := SGN * TR (2, 1);
      end if;
      BTMP (1) := B (1, 1);
      BTMP (2) := B (1, 2);
      goto L40;
      --
      --     2 by 1:
      --          op[TL11 TL12]*[X11] + ISGN* [X11]*TR11  = [B11]
      --            [TL21 TL22] [X21]         [X21]         [B21]
      --
      <<L30>> null;
      SMIN    :=
         max
           (EPS * max (abs (TR (1, 1)), abs (TL (1, 1)), abs (TL (1, 2)), abs (TL (2, 1)), abs (TL (2, 2))),
            SMLNUM);
      TMP (1) := TL (1, 1) + SGN * TR (1, 1);
      TMP (4) := TL (2, 2) + SGN * TR (1, 1);
      if LTRANL then
         TMP (2) := TL (1, 2);
         TMP (3) := TL (2, 1);
      else
         TMP (2) := TL (2, 1);
         TMP (3) := TL (1, 2);
      end if;
      BTMP (1) := B (1, 1);
      BTMP (2) := B (2, 1);
      <<L40>> null;
      --
      --     Solve 2 by 2 system using complete pivoting.
      --     Set pivots less than SMIN to SMIN.
      --
      IPIV := IDAMAX (4, TMP'Address, 1);
      U11  := TMP (IPIV);
      if abs (U11) <= SMIN then
         INFO := 1;
         U11  := SMIN;
      end if;
      U12   := TMP (LOCU12 (IPIV));
      L21   := TMP (LOCL21 (IPIV)) / U11;
      U22   := TMP (LOCU22 (IPIV)) - U12 * L21;
      XSWAP := XSWPIV (IPIV);
      BSWAP := BSWPIV (IPIV);
      if abs (U22) <= SMIN then
         INFO := 1;
         U22  := SMIN;
      end if;
      if BSWAP then
         TEMP     := BTMP (2);
         BTMP (2) := BTMP (1) - L21 * TEMP;
         BTMP (1) := TEMP;
      else
         BTMP (2) := BTMP (2) - L21 * BTMP (1);
      end if;
      SCALE := ONE;
      if (TWO * SMLNUM) * abs (BTMP (2)) > abs (U22) or (TWO * SMLNUM) * abs (BTMP (1)) > abs (U11) then
         SCALE    := HALF / max (abs (BTMP (1)), abs (BTMP (2)));
         BTMP (1) := BTMP (1) * SCALE;
         BTMP (2) := BTMP (2) * SCALE;
      end if;
      X2 (2) := BTMP (2) / U22;
      X2 (1) := BTMP (1) / U11 - (U12 / U11) * X2 (2);
      if XSWAP then
         TEMP   := X2 (2);
         X2 (2) := X2 (1);
         X2 (1) := TEMP;
      end if;
      X (1, 1) := X2 (1);
      if N1 = 1 then
         X (1, 2) := X2 (2);
         XNORM    := abs (X (1, 1)) + abs (X (1, 2));
      else
         X (2, 1) := X2 (2);
         XNORM    := max (abs (X (1, 1)), abs (X (2, 1)));
      end if;
      return;
      --
      --     2 by 2:
      --     op[TL11 TL12]*[X11 X12] +ISGN* [X11 X12]*op[TR11 TR12] = [B11 B12]
      --       [TL21 TL22] [X21 X22]        [X21 X22]   [TR21 TR22]   [B21 B22]
      --
      --     Solve equivalent 4 by 4 system using complete pivoting.
      --     Set pivots less than SMIN to SMIN.
      --
      <<L50>> null;
      SMIN     := max (abs (TR (1, 1)), abs (TR (1, 2)), abs (TR (2, 1)), abs (TR (2, 2)));
      SMIN     := max (SMIN, abs (TL (1, 1)), abs (TL (1, 2)), abs (TL (2, 1)), abs (TL (2, 2)));
      SMIN     := max (EPS * SMIN, SMLNUM);
      BTMP (1) := ZERO;
      DCOPY (16, BTMP'Address, 0, T16'Address, 1);
      T16 (1, 1) := TL (1, 1) + SGN * TR (1, 1);
      T16 (2, 2) := TL (2, 2) + SGN * TR (1, 1);
      T16 (3, 3) := TL (1, 1) + SGN * TR (2, 2);
      T16 (4, 4) := TL (2, 2) + SGN * TR (2, 2);
      if LTRANL then
         T16 (1, 2) := TL (2, 1);
         T16 (2, 1) := TL (1, 2);
         T16 (3, 4) := TL (2, 1);
         T16 (4, 3) := TL (1, 2);
      else
         T16 (1, 2) := TL (1, 2);
         T16 (2, 1) := TL (2, 1);
         T16 (3, 4) := TL (1, 2);
         T16 (4, 3) := TL (2, 1);
      end if;
      if LTRANR then
         T16 (1, 3) := SGN * TR (1, 2);
         T16 (2, 4) := SGN * TR (1, 2);
         T16 (3, 1) := SGN * TR (2, 1);
         T16 (4, 2) := SGN * TR (2, 1);
      else
         T16 (1, 3) := SGN * TR (2, 1);
         T16 (2, 4) := SGN * TR (2, 1);
         T16 (3, 1) := SGN * TR (1, 2);
         T16 (4, 2) := SGN * TR (1, 2);
      end if;
      BTMP (1) := B (1, 1);
      BTMP (2) := B (2, 1);
      BTMP (3) := B (1, 2);
      BTMP (4) := B (2, 2);
      --
      --     Perform elimination
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > 3;
         XMAX := ZERO;
         IP   := I - 1;
         loop
            IP := IP + 1;
            exit when IP > 4;
            JP := I - 1;
            loop
               JP := JP + 1;
               exit when JP > 4;
               if abs (T16 (IP, JP)) >= XMAX then
                  XMAX := abs (T16 (IP, JP));
                  IPSV := IP;
                  JPSV := JP;
               end if;
            end loop;
         end loop;
         if IPSV /= I then
            DSWAP (4, T16 (IPSV, 1)'Address, 4, T16 (I, 1)'Address, 4);
            TEMP        := BTMP (I);
            BTMP (I)    := BTMP (IPSV);
            BTMP (IPSV) := TEMP;
         end if;
         if JPSV /= I then
            DSWAP (4, T16 (1, JPSV)'Address, 1, T16 (1, I)'Address, 1);
         end if;
         JPIV (I) := JPSV;
         if abs (T16 (I, I)) < SMIN then
            INFO       := 1;
            T16 (I, I) := SMIN;
         end if;
         J := I + 1 - 1;
         loop
            J := J + 1;
            exit when J > 4;
            T16 (J, I) := T16 (J, I) / T16 (I, I);
            BTMP (J)   := BTMP (J) - T16 (J, I) * BTMP (I);
            K          := I + 1 - 1;
            loop
               K := K + 1;
               exit when K > 4;
               T16 (J, K) := T16 (J, K) - T16 (J, I) * T16 (I, K);
            end loop;
         end loop;
      end loop;
      if abs (T16 (4, 4)) < SMIN then
         T16 (4, 4) := SMIN;
      end if;
      SCALE := ONE;
      if (EIGHT * SMLNUM) * abs (BTMP (1)) > abs (T16 (1, 1)) or
         (EIGHT * SMLNUM) * abs (BTMP (2)) > abs (T16 (2, 2)) or
         (EIGHT * SMLNUM) * abs (BTMP (3)) > abs (T16 (3, 3)) or
         (EIGHT * SMLNUM) * abs (BTMP (4)) > abs (T16 (4, 4))
      then
         SCALE    := (ONE / EIGHT) / max (abs (BTMP (1)), abs (BTMP (2)), abs (BTMP (3)), abs (BTMP (4)));
         BTMP (1) := BTMP (1) * SCALE;
         BTMP (2) := BTMP (2) * SCALE;
         BTMP (3) := BTMP (3) * SCALE;
         BTMP (4) := BTMP (4) * SCALE;
      end if;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > 4;
         K       := 5 - I;
         TEMP    := ONE / T16 (K, K);
         TMP (K) := BTMP (K) * TEMP;
         J       := K + 1 - 1;
         loop
            J := J + 1;
            exit when J > 4;
            TMP (K) := TMP (K) - (TEMP * T16 (K, J)) * TMP (J);
         end loop;
      end loop;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > 3;
         if JPIV (4 - I) /= 4 - I then
            TEMP                := TMP (4 - I);
            TMP (4 - I)         := TMP (JPIV (4 - I));
            TMP (JPIV (4 - I))  := TEMP;
         end if;
      end loop;
      X (1, 1) := TMP (1);
      X (2, 1) := TMP (2);
      X (1, 2) := TMP (3);
      X (2, 2) := TMP (4);
      XNORM    := max (abs (TMP (1)) + abs (TMP (3)), abs (TMP (2)) + abs (TMP (4)));
      return;
      --
      --     End of DLASY2
      --
   end DLASY2;

   procedure DLASYF
     (UPLO     : Character;
      N        : Integer;
      NB       : Integer;
      KB       : in out Integer;
      A_adr    : Address;
      LDA      : Integer;
      IPIV_adr : Address;
      W_adr    : Address;
      LDW      : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      IPIV : Ftn_Integer_Vector (1 .. N);
      W    : Ftn_Real_Matrix (1 .. LDW, 1 .. NB);

      for A'Address use A_adr;
      for IPIV'Address use IPIV_adr;
      for W'Address use W_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, IPIV);
      pragma Import (Ada, W);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      EIGHT  : constant Real := 8.0e0;
      SEVTEN : constant Real := 17.0e0;
      IMAX   : Integer;
      J      : Integer;
      JB     : Integer;
      JJ     : Integer;
      JMAX   : Integer;
      JP     : Integer;
      K      : Integer;
      KK     : Integer;
      KKW    : Integer;
      KP     : Integer;
      KSTEP  : Integer;
      KW     : Integer;
      ABSAKK : Real;
      ALPHA  : Real;
      COLMAX : Real;
      D11    : Real;
      D21    : Real;
      D22    : Real;
      R1     : Real;
      ROWMAX : Real;
      T      : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLASYF( UPLO, N, NB, KB, A, LDA, IPIV, W, LDW, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, KB, LDA, LDW, N, NB
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), W( LDW, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLASYF computes a partial factorization of a real symmetric matrix A
   --  using the Bunch-Kaufman diagonal pivoting method. The partial
   --  factorization has the form:
   --
   --  A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
   --        ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
   --
   --  A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
   --        ( L21  I ) (  0  A22 ) (  0       I    )
   --
   --  where the order of D is at most NB. The actual order is returned in
   --  the argument KB, and is either NB or NB-1, or N if N <= NB.
   --
   --  DLASYF is an auxiliary routine called by DSYTRF. It uses blocked code
   --  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
   --  A22 (if UPLO = 'L').
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the upper or lower triangular part of the
   --           symmetric matrix A is stored:
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] NB
   --           NB is INTEGER
   --           The maximum number of columns of the matrix A that should be
   --           factored.  NB should be at least 2 to allow for 2-by-2 pivot
   --           blocks.
   --
   --  [out] KB
   --           KB is INTEGER
   --           The number of columns of A that were actually factored.
   --           KB is either NB-1 or NB, or N if N <= NB.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           n-by-n upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n-by-n lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --           On exit, A contains details of the partial factorization.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D.
   --           If UPLO = 'U', only the last KB elements of IPIV are set;
   --           if UPLO = 'L', only the first KB elements are set.
   --
   --           If IPIV(k) > 0, then rows and columns k and IPIV(k) were
   --           interchanged and D(k,k) is a 1-by-1 diagonal block.
   --           If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
   --           columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
   --           is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
   --           IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
   --           interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (LDW,NB)
   --
   --  [in] LDW
   --           LDW is INTEGER
   --           The leading dimension of the array W.  LDW >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
   --                has been completed, but the block diagonal matrix D is
   --                exactly singular.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( EIGHT = 8.0D+0, SEVTEN = 17.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, IDAMAX
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DGEMM, DGEMV, DSCAL, DSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO := 0;
      --
      --     Initialize ALPHA for use in choosing pivot block size.
      --
      ALPHA := (ONE + Sqrt (SEVTEN)) / EIGHT;
      --
      if LSAME (UPLO, 'U') then
         --
         --        Factorize the trailing columns of A using the upper triangle
         --        of A and working backwards, and compute the matrix W = U12*D
         --        for use in updating A11
         --
         --        K is the main loop index, decreasing from N in steps of 1 or 2
         --
         --        KW is the column of W which corresponds to column K of A
         --
         K := N;
         <<L10>> null;
         KW := NB + K - N;
         --
         --        Exit from loop
         --
         if (K <= N - NB + 1 and NB < N) or K < 1 then
            goto L30;
         end if;
         --
         --        Copy column K of A to column KW of W and update it
         --
         DCOPY (K, A (1, K)'Address, 1, W (1, KW)'Address, 1);
         if K < N then
            DGEMV ('N', K, N - K, -ONE, A (1, K + 1)'Address, LDA, W (K, KW + 1)'Address, LDW, ONE, W (1, KW)'Address, 1);
         end if;
         --
         KSTEP := 1;
         --
         --        Determine rows and columns to be interchanged and whether
         --        a 1-by-1 or 2-by-2 pivot block will be used
         --
         ABSAKK := abs (W (K, KW));
         --
         --        IMAX is the row-index of the largest off-diagonal element in
         --        column K, and COLMAX is its absolute value
         --
         if K > 1 then
            IMAX   := IDAMAX (K - 1, W (1, KW)'Address, 1);
            COLMAX := abs (W (IMAX, KW));
         else
            COLMAX := ZERO;
         end if;
         --
         if max (ABSAKK, COLMAX) = ZERO then
            --
            --           Column K is zero: set INFO and continue
            --
            if INFO = 0 then
               INFO := K;
            end if;
            KP := K;
         else
            if ABSAKK >= ALPHA * COLMAX then
               --
               --              no interchange, use 1-by-1 pivot block
               --
               KP := K;
            else
               --
               --              Copy column IMAX to column KW-1 of W and update it
               --
               DCOPY (IMAX, A (1, IMAX)'Address, 1, W (1, KW - 1)'Address, 1);
               DCOPY (K - IMAX, A (IMAX, IMAX + 1)'Address, LDA, W (IMAX + 1, KW - 1)'Address, 1);
               if K < N then
                  DGEMV
                    ('N',
                     K,
                     N - K,
                     -ONE,
                     A (1, K + 1)'Address,
                     LDA,
                     W (IMAX, KW + 1)'Address,
                     LDW,
                     ONE,
                     W (1, KW - 1)'Address,
                     1);
               end if;
               --
               --              JMAX is the column-index of the largest off-diagonal
               --              element in row IMAX, and ROWMAX is its absolute value
               --
               JMAX   := IMAX + IDAMAX (K - IMAX, W (IMAX + 1, KW - 1)'Address, 1);
               ROWMAX := abs (W (JMAX, KW - 1));
               if IMAX > 1 then
                  JMAX   := IDAMAX (IMAX - 1, W (1, KW - 1)'Address, 1);
                  ROWMAX := max (ROWMAX, abs (W (JMAX, KW - 1)));
               end if;
               --
               if ABSAKK >= ALPHA * COLMAX * (COLMAX / ROWMAX) then
                  --
                  --                 no interchange, use 1-by-1 pivot block
                  --
                  KP := K;
               elsif abs (W (IMAX, KW - 1)) >= ALPHA * ROWMAX then
                  --
                  --                 interchange rows and columns K and IMAX, use 1-by-1
                  --                 pivot block
                  --
                  KP := IMAX;
                  --
                  --                 copy column KW-1 of W to column KW
                  --
                  DCOPY (K, W (1, KW - 1)'Address, 1, W (1, KW)'Address, 1);
               else
                  --
                  --                 interchange rows and columns K-1 and IMAX, use 2-by-2
                  --                 pivot block
                  --
                  KP    := IMAX;
                  KSTEP := 2;
               end if;
            end if;
            --
            KK  := K - KSTEP + 1;
            KKW := NB + KK - N;
            --
            --           Updated column KP is already stored in column KKW of W
            --
            if KP /= KK then
               --
               --              Copy non-updated column KK to column KP
               --
               A (KP, K) := A (KK, K);
               DCOPY (K - 1 - KP, A (KP + 1, KK)'Address, 1, A (KP, KP + 1)'Address, LDA);
               DCOPY (KP, A (1, KK)'Address, 1, A (1, KP)'Address, 1);
               --
               --              Interchange rows KK and KP in last KK columns of A and W
               --
               DSWAP (N - KK + 1, A (KK, KK)'Address, LDA, A (KP, KK)'Address, LDA);
               DSWAP (N - KK + 1, W (KK, KKW)'Address, LDW, W (KP, KKW)'Address, LDW);
            end if;
            --
            if KSTEP = 1 then
               --
               --              1-by-1 pivot block D(k): column KW of W now holds
               --
               --              W(k) = U(k)*D(k)
               --
               --              where U(k) is the k-th column of U
               --
               --              Store U(k) in column k of A
               --
               DCOPY (K, W (1, KW)'Address, 1, A (1, K)'Address, 1);
               R1 := ONE / A (K, K);
               DSCAL (K - 1, R1, A (1, K)'Address, 1);
            else
               --
               --              2-by-2 pivot block D(k): columns KW and KW-1 of W now
               --              hold
               --
               --              ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k)
               --
               --              where U(k) and U(k-1) are the k-th and (k-1)-th columns
               --              of U
               --
               if K > 2 then
                  --
                  --                 Store U(k) and U(k-1) in columns k and k-1 of A
                  --
                  D21 := W (K - 1, KW);
                  D11 := W (K, KW) / D21;
                  D22 := W (K - 1, KW - 1) / D21;
                  T   := ONE / (D11 * D22 - ONE);
                  D21 := T / D21;
                  J   := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > K - 2;
                     A (J, K - 1) := D21 * (D11 * W (J, KW - 1) - W (J, KW));
                     A (J, K)     := D21 * (D22 * W (J, KW) - W (J, KW - 1));
                  end loop;
               end if;
               --
               --              Copy D(k) to A
               --
               A (K - 1, K - 1) := W (K - 1, KW - 1);
               A (K - 1, K)     := W (K - 1, KW);
               A (K, K)         := W (K, KW);
            end if;
         end if;
         --
         --        Store details of the interchanges in IPIV
         --
         if KSTEP = 1 then
            IPIV (K) := KP;
         else
            IPIV (K)     := -KP;
            IPIV (K - 1) := -KP;
         end if;
         --
         --        Decrease K and return to the start of the main loop
         --
         K := K - KSTEP;
         goto L10;
         --
         <<L30>> null;
         --
         --        Update the upper triangle of A11 (= A(1:k,1:k)) as
         --
         --        A11 := A11 - U12*D*U12**T = A11 - U12*W**T
         --
         --        computing blocks of NB columns at a time
         --
         J := ((K - 1) / NB) * NB + 1 + NB;
         loop
            J := J - NB;
            exit when J < 1;
            JB := min (NB, K - J + 1);
            --
            --           Update the upper triangle of the diagonal block
            --
            JJ := J - 1;
            loop
               JJ := JJ + 1;
               exit when JJ > J + JB - 1;
               DGEMV
                 ('N',
                  JJ - J + 1,
                  N - K,
                  -ONE,
                  A (J, K + 1)'Address,
                  LDA,
                  W (JJ, KW + 1)'Address,
                  LDW,
                  ONE,
                  A (J, JJ)'Address,
                  1);
            end loop;
            --
            --           Update the rectangular superdiagonal block
            --
            DGEMM
              ('N',
               'T',
               J - 1,
               JB,
               N - K,
               -ONE,
               A (1, K + 1)'Address,
               LDA,
               W (J, KW + 1)'Address,
               LDW,
               ONE,
               A (1, J)'Address,
               LDA);
         end loop;
         --
         --        Put U12 in standard form by partially undoing the interchanges
         --        in columns k+1:n
         --
         J := K + 1;
         <<L60>> null;
         JJ := J;
         JP := IPIV (J);
         if JP < 0 then
            JP := -JP;
            J  := J + 1;
         end if;
         J := J + 1;
         if JP /= JJ and J <= N then
            DSWAP (N - J + 1, A (JP, J)'Address, LDA, A (JJ, J)'Address, LDA);
         end if;
         if J <= N then
            goto L60;
         end if;
         --
         --        Set KB to the number of columns factorized
         --
         KB := N - K;
      --
      else
         --
         --        Factorize the leading columns of A using the lower triangle
         --        of A and working forwards, and compute the matrix W = L21*D
         --        for use in updating A22
         --
         --        K is the main loop index, increasing from 1 in steps of 1 or 2
         --
         K := 1;
         <<L70>> null;
         --
         --        Exit from loop
         --
         if (K >= NB and NB < N) or K > N then
            goto L90;
         end if;
         --
         --        Copy column K of A to column K of W and update it
         --
         DCOPY (N - K + 1, A (K, K)'Address, 1, W (K, K)'Address, 1);
         DGEMV ('N', N - K + 1, K - 1, -ONE, A (K, 1)'Address, LDA, W (K, 1)'Address, LDW, ONE, W (K, K)'Address, 1);
         --
         KSTEP := 1;
         --
         --        Determine rows and columns to be interchanged and whether
         --        a 1-by-1 or 2-by-2 pivot block will be used
         --
         ABSAKK := abs (W (K, K));
         --
         --        IMAX is the row-index of the largest off-diagonal element in
         --        column K, and COLMAX is its absolute value
         --
         if K < N then
            IMAX   := K + IDAMAX (N - K, W (K + 1, K)'Address, 1);
            COLMAX := abs (W (IMAX, K));
         else
            COLMAX := ZERO;
         end if;
         --
         if max (ABSAKK, COLMAX) = ZERO then
            --
            --           Column K is zero: set INFO and continue
            --
            if INFO = 0 then
               INFO := K;
            end if;
            KP := K;
         else
            if ABSAKK >= ALPHA * COLMAX then
               --
               --              no interchange, use 1-by-1 pivot block
               --
               KP := K;
            else
               --
               --              Copy column IMAX to column K+1 of W and update it
               --
               DCOPY (IMAX - K, A (IMAX, K)'Address, LDA, W (K, K + 1)'Address, 1);
               DCOPY (N - IMAX + 1, A (IMAX, IMAX)'Address, 1, W (IMAX, K + 1)'Address, 1);
               DGEMV
                 ('N',
                  N - K + 1,
                  K - 1,
                  -ONE,
                  A (K, 1)'Address,
                  LDA,
                  W (IMAX, 1)'Address,
                  LDW,
                  ONE,
                  W (K, K + 1)'Address,
                  1);
               --
               --              JMAX is the column-index of the largest off-diagonal
               --              element in row IMAX, and ROWMAX is its absolute value
               --
               JMAX   := K - 1 + IDAMAX (IMAX - K, W (K, K + 1)'Address, 1);
               ROWMAX := abs (W (JMAX, K + 1));
               if IMAX < N then
                  JMAX   := IMAX + IDAMAX (N - IMAX, W (IMAX + 1, K + 1)'Address, 1);
                  ROWMAX := max (ROWMAX, abs (W (JMAX, K + 1)));
               end if;
               --
               if ABSAKK >= ALPHA * COLMAX * (COLMAX / ROWMAX) then
                  --
                  --                 no interchange, use 1-by-1 pivot block
                  --
                  KP := K;
               elsif abs (W (IMAX, K + 1)) >= ALPHA * ROWMAX then
                  --
                  --                 interchange rows and columns K and IMAX, use 1-by-1
                  --                 pivot block
                  --
                  KP := IMAX;
                  --
                  --                 copy column K+1 of W to column K
                  --
                  DCOPY (N - K + 1, W (K, K + 1)'Address, 1, W (K, K)'Address, 1);
               else
                  --
                  --                 interchange rows and columns K+1 and IMAX, use 2-by-2
                  --                 pivot block
                  --
                  KP    := IMAX;
                  KSTEP := 2;
               end if;
            end if;
            --
            KK := K + KSTEP - 1;
            --
            --           Updated column KP is already stored in column KK of W
            --
            if KP /= KK then
               --
               --              Copy non-updated column KK to column KP
               --
               A (KP, K) := A (KK, K);
               DCOPY (KP - K - 1, A (K + 1, KK)'Address, 1, A (KP, K + 1)'Address, LDA);
               DCOPY (N - KP + 1, A (KP, KK)'Address, 1, A (KP, KP)'Address, 1);
               --
               --              Interchange rows KK and KP in first KK columns of A and W
               --
               DSWAP (KK, A (KK, 1)'Address, LDA, A (KP, 1)'Address, LDA);
               DSWAP (KK, W (KK, 1)'Address, LDW, W (KP, 1)'Address, LDW);
            end if;
            --
            if KSTEP = 1 then
               --
               --              1-by-1 pivot block D(k): column k of W now holds
               --
               --              W(k) = L(k)*D(k)
               --
               --              where L(k) is the k-th column of L
               --
               --              Store L(k) in column k of A
               --
               DCOPY (N - K + 1, W (K, K)'Address, 1, A (K, K)'Address, 1);
               if K < N then
                  R1 := ONE / A (K, K);
                  DSCAL (N - K, R1, A (K + 1, K)'Address, 1);
               end if;
            else
               --
               --              2-by-2 pivot block D(k): columns k and k+1 of W now hold
               --
               --              ( W(k) W(k+1) ) = ( L(k) L(k+1) )*D(k)
               --
               --              where L(k) and L(k+1) are the k-th and (k+1)-th columns
               --              of L
               --
               if K < N - 1 then
                  --
                  --                 Store L(k) and L(k+1) in columns k and k+1 of A
                  --
                  D21 := W (K + 1, K);
                  D11 := W (K + 1, K + 1) / D21;
                  D22 := W (K, K) / D21;
                  T   := ONE / (D11 * D22 - ONE);
                  D21 := T / D21;
                  J   := K + 2 - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     A (J, K)     := D21 * (D11 * W (J, K) - W (J, K + 1));
                     A (J, K + 1) := D21 * (D22 * W (J, K + 1) - W (J, K));
                  end loop;
               end if;
               --
               --              Copy D(k) to A
               --
               A (K, K)         := W (K, K);
               A (K + 1, K)     := W (K + 1, K);
               A (K + 1, K + 1) := W (K + 1, K + 1);
            end if;
         end if;
         --
         --        Store details of the interchanges in IPIV
         --
         if KSTEP = 1 then
            IPIV (K) := KP;
         else
            IPIV (K)     := -KP;
            IPIV (K + 1) := -KP;
         end if;
         --
         --        Increase K and return to the start of the main loop
         --
         K := K + KSTEP;
         goto L70;
         --
         <<L90>> null;
         --
         --        Update the lower triangle of A22 (= A(k:n,k:n)) as
         --
         --        A22 := A22 - L21*D*L21**T = A22 - L21*W**T
         --
         --        computing blocks of NB columns at a time
         --
         J := K - NB;
         loop
            J := J + NB;
            exit when J > N;
            JB := min (NB, N - J + 1);
            --
            --           Update the lower triangle of the diagonal block
            --
            JJ := J - 1;
            loop
               JJ := JJ + 1;
               exit when JJ > J + JB - 1;
               DGEMV
                 ('N',
                  J + JB - JJ,
                  K - 1,
                  -ONE,
                  A (JJ, 1)'Address,
                  LDA,
                  W (JJ, 1)'Address,
                  LDW,
                  ONE,
                  A (JJ, JJ)'Address,
                  1);
            end loop;
            --
            --           Update the rectangular subdiagonal block
            --
            if J + JB <= N then
               DGEMM
                 ('N',
                  'T',
                  N - J - JB + 1,
                  JB,
                  K - 1,
                  -ONE,
                  A (J + JB, 1)'Address,
                  LDA,
                  W (J, 1)'Address,
                  LDW,
                  ONE,
                  A (J + JB, J)'Address,
                  LDA);
            end if;
         end loop;
         --
         --        Put L21 in standard form by partially undoing the interchanges
         --        in columns 1:k-1
         --
         J := K - 1;
         <<L120>> null;
         JJ := J;
         JP := IPIV (J);
         if JP < 0 then
            JP := -JP;
            J  := J - 1;
         end if;
         J := J - 1;
         if JP /= JJ and J >= 1 then
            DSWAP (J, A (JP, 1)'Address, LDA, A (JJ, 1)'Address, LDA);
         end if;
         if J >= 1 then
            goto L120;
         end if;
         --
         --        Set KB to the number of columns factorized
         --
         KB := K - 1;
         --
      end if;
      return;
      --
      --     End of DLASYF
      --
   end DLASYF;

   procedure DLATRD
     (UPLO    : Character;
      N       : Integer;
      NB      : Integer;
      A_adr   : Address;
      LDA     : Integer;
      E_adr   : Address;
      TAU_adr : Address;
      W_adr   : Address;
      LDW     : Integer)
   is

      A   : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      E   : Ftn_Real_Vector (1 .. N - 1);
      TAU : Ftn_Real_Vector (1 .. N - 1);
      W   : Ftn_Real_Matrix (1 .. LDW, 1 .. NB);

      for A'Address use A_adr;
      for E'Address use E_adr;
      for TAU'Address use TAU_adr;
      for W'Address use W_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, E);
      pragma Import (Ada, TAU);
      pragma Import (Ada, W);

      ZERO  : constant Real := 0.0e0;
      ONE   : constant Real := 1.0e0;
      HALF  : constant Real := 0.5e0;
      I     : Integer;
      IW    : Integer;
      ALPHA : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            LDA, LDW, N, NB
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), E( * ), TAU( * ), W( LDW, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DLATRD reduces NB rows and columns of a real symmetric matrix A to
   --  symmetric tridiagonal form by an orthogonal similarity
   --  transformation Q**T * A * Q, and returns the matrices V and W which are
   --  needed to apply the transformation to the unreduced part of A.
   --
   --  If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
   --  matrix, of which the upper triangle is supplied;
   --  if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
   --  matrix, of which the lower triangle is supplied.
   --
   --  This is an auxiliary routine called by DSYTRD.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the upper or lower triangular part of the
   --           symmetric matrix A is stored:
   --           = 'U': Upper triangular
   --           = 'L': Lower triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.
   --
   --  [in] NB
   --           NB is INTEGER
   --           The number of rows and columns to be reduced.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           n-by-n upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n-by-n lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --           On exit:
   --           if UPLO = 'U', the last NB columns have been reduced to
   --             tridiagonal form, with the diagonal elements overwriting
   --             the diagonal elements of A; the elements above the diagonal
   --             with the array TAU, represent the orthogonal matrix Q as a
   --             product of elementary reflectors;
   --           if UPLO = 'L', the first NB columns have been reduced to
   --             tridiagonal form, with the diagonal elements overwriting
   --             the diagonal elements of A; the elements below the diagonal
   --             with the array TAU, represent the  orthogonal matrix Q as a
   --             product of elementary reflectors.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= (1,N).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
   --           elements of the last NB columns of the reduced matrix;
   --           if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
   --           the first NB columns of the reduced matrix.
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (N-1)
   --           The scalar factors of the elementary reflectors, stored in
   --           TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
   --           See Further Details.
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (LDW,NB)
   --           The n-by-nb matrix W required to update the unreduced part
   --           of A.
   --
   --  [in] LDW
   --           LDW is INTEGER
   --           The leading dimension of the array W. LDW >= max(1,N).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(n) H(n-1) . . . H(n-nb+1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
   --   and tau in TAU(i-1).
   --
   --   If UPLO = 'L', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(1) H(2) . . . H(nb).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
   --   and tau in TAU(i).
   --
   --   The elements of the vectors v together form the n-by-nb matrix V
   --   which is needed, with W, to apply the transformation to the unreduced
   --   part of the matrix, using a symmetric rank-2k update of the form:
   --   A := A - V*W**T - W*V**T.
   --
   --   The contents of A on exit are illustrated by the following examples
   --   with n = 5 and nb = 2:
   --
   --   if UPLO = 'U':                       if UPLO = 'L':
   --
   --     (  a   a   a   v4  v5 )              (  d                  )
   --     (      a   a   v4  v5 )              (  1   d              )
   --     (          a   1   v5 )              (  v1  1   a          )
   --     (              d   1  )              (  v1  v2  a   a      )
   --     (                  d  )              (  v1  v2  a   a   a  )
   --
   --   where d denotes a diagonal element of the reduced matrix, a denotes
   --   an element of the original matrix that is unchanged, and vi denotes
   --   an element of the vector defining H(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, HALF = 0.5D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DAXPY, DGEMV, DLARFG, DSCAL, DSYMV
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, DDOT
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if N <= 0 then
         return;
      end if;
      --
      if LSAME (UPLO, 'U') then
         --
         --        Reduce last NB columns of upper triangle
         --
         I := N + 1;
         loop
            I := I - 1;
            exit when I < N - NB + 1;
            IW := I - N + NB;
            if I < N then
               --
               --              Update A(1:i,i)
               --
               DGEMV
                 ('N',
                  I,
                  N - I,
                  -ONE,
                  A (1, I + 1)'Address,
                  LDA,
                  W (I, IW + 1)'Address,
                  LDW,
                  ONE,
                  A (1, I)'Address,
                  1);
               DGEMV
                 ('N',
                  I,
                  N - I,
                  -ONE,
                  W (1, IW + 1)'Address,
                  LDW,
                  A (I, I + 1)'Address,
                  LDA,
                  ONE,
                  A (1, I)'Address,
                  1);
            end if;
            if I > 1 then
               --
               --              Generate elementary reflector H(i) to annihilate
               --              A(1:i-2,i)
               --
               DLARFG (I - 1, A (I - 1, I), A (1, I)'Address, 1, TAU (I - 1));
               E (I - 1)    := A (I - 1, I);
               A (I - 1, I) := ONE;
               --
               --              Compute W(1:i-1,i)
               --
               DSYMV ('U', I - 1, ONE, A'Address, LDA, A (1, I)'Address, 1, ZERO, W (1, IW)'Address, 1);
               if I < N then
                  DGEMV
                    ('T',
                     I - 1,
                     N - I,
                     ONE,
                     W (1, IW + 1)'Address,
                     LDW,
                     A (1, I)'Address,
                     1,
                     ZERO,
                     W (I + 1, IW)'Address,
                     1);
                  DGEMV
                    ('N',
                     I - 1,
                     N - I,
                     -ONE,
                     A (1, I + 1)'Address,
                     LDA,
                     W (I + 1, IW)'Address,
                     1,
                     ONE,
                     W (1, IW)'Address,
                     1);
                  DGEMV
                    ('T',
                     I - 1,
                     N - I,
                     ONE,
                     A (1, I + 1)'Address,
                     LDA,
                     A (1, I)'Address,
                     1,
                     ZERO,
                     W (I + 1, IW)'Address,
                     1);
                  DGEMV
                    ('N',
                     I - 1,
                     N - I,
                     -ONE,
                     W (1, IW + 1)'Address,
                     LDW,
                     W (I + 1, IW)'Address,
                     1,
                     ONE,
                     W (1, IW)'Address,
                     1);
               end if;
               DSCAL (I - 1, TAU (I - 1), W (1, IW)'Address, 1);
               ALPHA := -HALF * TAU (I - 1) * DDOT (I - 1, W (1, IW)'Address, 1, A (1, I)'Address, 1);
               DAXPY (I - 1, ALPHA, A (1, I)'Address, 1, W (1, IW)'Address, 1);
            end if;
            --
         end loop;
      else
         --
         --        Reduce first NB columns of lower triangle
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > NB;
            --
            --           Update A(i:n,i)
            --
            DGEMV ('N', N - I + 1, I - 1, -ONE, A (I, 1)'Address, LDA, W (I, 1)'Address, LDW, ONE, A (I, I)'Address, 1);
            DGEMV ('N', N - I + 1, I - 1, -ONE, W (I, 1)'Address, LDW, A (I, 1)'Address, LDA, ONE, A (I, I)'Address, 1);
            if I < N then
               --
               --              Generate elementary reflector H(i) to annihilate
               --              A(i+2:n,i)
               --
               DLARFG (N - I, A (I + 1, I), A (min (I + 2, N), I)'Address, 1, TAU (I));
               E (I)        := A (I + 1, I);
               A (I + 1, I) := ONE;
               --
               --              Compute W(i+1:n,i)
               --
               DSYMV
                 ('L',
                  N - I,
                  ONE,
                  A (I + 1, I + 1)'Address,
                  LDA,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  W (I + 1, I)'Address,
                  1);
               DGEMV
                 ('T',
                  N - I,
                  I - 1,
                  ONE,
                  W (I + 1, 1)'Address,
                  LDW,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  W (1, I)'Address,
                  1);
               DGEMV
                 ('N',
                  N - I,
                  I - 1,
                  -ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  W (1, I)'Address,
                  1,
                  ONE,
                  W (I + 1, I)'Address,
                  1);
               DGEMV
                 ('T',
                  N - I,
                  I - 1,
                  ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  W (1, I)'Address,
                  1);
               DGEMV
                 ('N',
                  N - I,
                  I - 1,
                  -ONE,
                  W (I + 1, 1)'Address,
                  LDW,
                  W (1, I)'Address,
                  1,
                  ONE,
                  W (I + 1, I)'Address,
                  1);
               DSCAL (N - I, TAU (I), W (I + 1, I)'Address, 1);
               ALPHA := -HALF * TAU (I) * DDOT (N - I, W (I + 1, I)'Address, 1, A (I + 1, I)'Address, 1);
               DAXPY (N - I, ALPHA, A (I + 1, I)'Address, 1, W (I + 1, I)'Address, 1);
            end if;
            --
         end loop;
      end if;
      --
      return;
      --
      --     End of DLATRD
      --
   end DLATRD;

   procedure DORG2L
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. K);
      WORK : Ftn_Real_Vector (1 .. N);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE  : constant Real := 1.0e0;
      ZERO : constant Real := 0.0e0;
      I    : Integer;
      II   : Integer;
      J    : Integer;
      L    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORG2L( M, N, K, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORG2L generates an m by n real matrix Q with orthonormal columns,
   --  which is defined as the last n columns of a product of k elementary
   --  reflectors of order m
   --
   --        Q  =  H(k) . . . H(2) H(1)
   --
   --  as returned by DGEQLF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. M >= N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. N >= K >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the (n-k+i)-th column must contain the vector which
   --           defines the elementary reflector H(i), for i = 1,2,...,k, as
   --           returned by DGEQLF in the last k columns of its array
   --           argument A.
   --           On exit, the m by n matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEQLF.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, DSCAL, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 or N > M then
         INFO := -2;
      elsif K < 0 or K > N then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("DORG2L", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         return;
      end if;
      --
      --     Initialise columns 1:n-k to columns of the unit matrix
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N - K;
         L := 1 - 1;
         loop
            L := L + 1;
            exit when L > M;
            A (L, J) := ZERO;
         end loop;
         A (M - N + J, J) := ONE;
      end loop;
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         II := N - K + I;
         --
         --        Apply H(i) to A(1:m-k+i,1:n-k+i) from the left
         --
         A (M - N + II, II) := ONE;
         DLARF ('L', M - N + II, II - 1, A (1, II)'Address, 1, TAU (I), A'Address, LDA, WORK'Address);
         DSCAL (M - N + II - 1, -TAU (I), A (1, II)'Address, 1);
         A (M - N + II, II) := ONE - TAU (I);
         --
         --        Set A(m-k+i+1:m,n-k+i) to zero
         --
         L := M - N + II + 1 - 1;
         loop
            L := L + 1;
            exit when L > M;
            A (L, II) := ZERO;
         end loop;
      end loop;
      return;
      --
      --     End of DORG2L
      --
   end DORG2L;

   procedure DORG2R
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. K);
      WORK : Ftn_Real_Vector (1 .. N);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE  : constant Real := 1.0e0;
      ZERO : constant Real := 0.0e0;
      I    : Integer;
      J    : Integer;
      L    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORG2R( M, N, K, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORG2R generates an m by n real matrix Q with orthonormal columns,
   --  which is defined as the first n columns of a product of k elementary
   --  reflectors of order m
   --
   --        Q  =  H(1) H(2) . . . H(k)
   --
   --  as returned by DGEQRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. M >= N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. N >= K >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the i-th column must contain the vector which
   --           defines the elementary reflector H(i), for i = 1,2,...,k, as
   --           returned by DGEQRF in the first k columns of its array
   --           argument A.
   --           On exit, the m-by-n matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEQRF.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, DSCAL, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 or N > M then
         INFO := -2;
      elsif K < 0 or K > N then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("DORG2R", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         return;
      end if;
      --
      --     Initialise columns k+1:n to columns of the unit matrix
      --
      J := K + 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         L := 1 - 1;
         loop
            L := L + 1;
            exit when L > M;
            A (L, J) := ZERO;
         end loop;
         A (J, J) := ONE;
      end loop;
      --
      I := K + 1;
      loop
         I := I - 1;
         exit when I < 1;
         --
         --        Apply H(i) to A(i:m,i:n) from the left
         --
         if I < N then
            A (I, I) := ONE;
            DLARF ('L', M - I + 1, N - I, A (I, I)'Address, 1, TAU (I), A (I, I + 1)'Address, LDA, WORK'Address);
         end if;
         if I < M then
            DSCAL (M - I, -TAU (I), A (I + 1, I)'Address, 1);
         end if;
         A (I, I) := ONE - TAU (I);
         --
         --        Set A(1:i-1,i) to zero
         --
         L := 1 - 1;
         loop
            L := L + 1;
            exit when L > I - 1;
            A (L, I) := ZERO;
         end loop;
      end loop;
      return;
      --
      --     End of DORG2R
      --
   end DORG2R;

   procedure DORGBR
     (VECT     : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. max (min (M, K), min (N, K)));
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      LQUERY : Boolean;
      WANTQ  : Boolean;
      I      : Integer;
      IINFO  : Integer;
      J      : Integer;
      LWKOPT : Integer;
      MN     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORGBR( VECT, M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          VECT
   --       INTEGER            INFO, K, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORGBR generates one of the real orthogonal matrices Q or P**T
   --  determined by DGEBRD when reducing a real matrix A to bidiagonal
   --  form: A = Q * B * P**T.  Q and P**T are defined as products of
   --  elementary reflectors H(i) or G(i) respectively.
   --
   --  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
   --  is of order M:
   --  if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
   --  columns of Q, where m >= n >= k;
   --  if m < k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
   --  M-by-M matrix.
   --
   --  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
   --  is of order N:
   --  if k < n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
   --  rows of P**T, where n >= m >= k;
   --  if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
   --  an N-by-N matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] VECT
   --           VECT is CHARACTER*1
   --           Specifies whether the matrix Q or the matrix P**T is
   --           required, as defined in the transformation applied by DGEBRD:
   --           = 'Q':  generate Q;
   --           = 'P':  generate P**T.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q or P**T to be returned.
   --           M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q or P**T to be returned.
   --           N >= 0.
   --           If VECT = 'Q', M >= N >= min(M,K);
   --           if VECT = 'P', N >= M >= min(N,K).
   --
   --  [in] K
   --           K is INTEGER
   --           If VECT = 'Q', the number of columns in the original M-by-K
   --           matrix reduced by DGEBRD.
   --           If VECT = 'P', the number of rows in the original K-by-N
   --           matrix reduced by DGEBRD.
   --           K >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the vectors which define the elementary reflectors,
   --           as returned by DGEBRD.
   --           On exit, the M-by-N matrix Q or P**T.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension
   --                                 (min(M,K)) if VECT = 'Q'
   --                                 (min(N,K)) if VECT = 'P'
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i) or G(i), which determines Q or P**T, as
   --           returned by DGEBRD in its array argument TAUQ or TAUP.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,min(M,N)).
   --           For optimum performance LWORK >= min(M,N)*NB, where NB
   --           is the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DORGLQ, DORGQR, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      WANTQ  := LSAME (VECT, 'Q');
      MN     := min (M, N);
      LQUERY := (LWORK = -1);
      if not WANTQ and not LSAME (VECT, 'P') then
         INFO := -1;
      elsif M < 0 then
         INFO := -2;
      elsif N < 0 or (WANTQ and (N > M or N < min (M, K))) or (not WANTQ and (M > N or M < min (N, K))) then
         INFO := -3;
      elsif K < 0 then
         INFO := -4;
      elsif LDA < max (1, M) then
         INFO := -6;
      elsif LWORK < max (1, MN) and not LQUERY then
         INFO := -9;
      end if;
      --
      if INFO = 0 then
         WORK (1) := 1.0;
         if WANTQ then
            if M >= K then
               DORGQR (M, N, K, A'Address, LDA, TAU'Address, WORK'Address, -1, IINFO);
            else
               if M > 1 then
                  DORGQR (M - 1, M - 1, M - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, -1, IINFO);
               end if;
            end if;
         else
            if K < N then
               DORGLQ (M, N, K, A'Address, LDA, TAU'Address, WORK'Address, -1, IINFO);
            else
               if N > 1 then
                  DORGLQ (N - 1, N - 1, N - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, -1, IINFO);
               end if;
            end if;
         end if;
         LWKOPT := int (WORK (1));
         LWKOPT := max (LWKOPT, MN);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORGBR", -INFO);
         return;
      elsif LQUERY then
         WORK (1) := Real (LWKOPT);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      if WANTQ then
         --
         --        Form Q, determined by a call to DGEBRD to reduce an m-by-k
         --        matrix
         --
         if M >= K then
            --
            --           If m >= k, assume m >= n >= k
            --
            DORGQR (M, N, K, A'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
         --
         else
            --
            --           If m < k, assume m = n
            --
            --           Shift the vectors which define the elementary reflectors one
            --           column to the right, and set the first row and column of Q
            --           to those of the unit matrix
            --
            J := M + 1;
            loop
               J := J - 1;
               exit when J < 2;
               A (1, J) := ZERO;
               I        := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  A (I, J) := A (I, J - 1);
               end loop;
            end loop;
            A (1, 1) := ONE;
            I        := 2 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, 1) := ZERO;
            end loop;
            if M > 1 then
               --
               --              Form Q(2:m,2:m)
               --
               DORGQR (M - 1, M - 1, M - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
            end if;
         end if;
      else
         --
         --        Form P**T, determined by a call to DGEBRD to reduce a k-by-n
         --        matrix
         --
         if K < N then
            --
            --           If k < n, assume k <= m <= n
            --
            DORGLQ (M, N, K, A'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
         --
         else
            --
            --           If k >= n, assume m = n
            --
            --           Shift the vectors which define the elementary reflectors one
            --           row downward, and set the first row and column of P**T to
            --           those of the unit matrix
            --
            A (1, 1) := ONE;
            I        := 2 - 1;
            loop
               I := I + 1;
               exit when I > N;
               A (I, 1) := ZERO;
            end loop;
            J := 2 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := J - 1 + 1;
               loop
                  I := I - 1;
                  exit when I < 2;
                  A (I, J) := A (I - 1, J);
               end loop;
               A (1, J) := ZERO;
            end loop;
            if N > 1 then
               --
               --              Form P**T(2:n,2:n)
               --
               DORGLQ (N - 1, N - 1, N - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
            end if;
         end if;
      end if;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORGBR
      --
   end DORGBR;

   procedure DORGHR
     (N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. N - 1);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      LQUERY : Boolean;
      I      : Integer;
      IINFO  : Integer;
      J      : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NH     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORGHR( N, ILO, IHI, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORGHR generates a real orthogonal matrix Q which is defined as the
   --  product of IHI-ILO elementary reflectors of order N, as returned by
   --  DGEHRD:
   --
   --  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix Q. N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --           ILO and IHI must have the same values as in the previous call
   --           of DGEHRD. Q is equal to the unit matrix except in the
   --           submatrix Q(ilo+1:ihi,ilo+1:ihi).
   --           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the vectors which define the elementary reflectors,
   --           as returned by DGEHRD.
   --           On exit, the N-by-N orthogonal matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (N-1)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEHRD.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= IHI-ILO.
   --           For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
   --           the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DORGQR, XERBLA
   --     ..
   --     .. External Functions ..
   --      INTEGER            ILAENV
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      NH     := IHI - ILO;
      LQUERY := (LWORK = -1);
      if N < 0 then
         INFO := -1;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -2;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LWORK < max (1, NH) and not LQUERY then
         INFO := -8;
      end if;
      --
      if INFO = 0 then
         NB       := ILAENV (1, "DORGQR", " ", NH, NH, NH, -1);
         LWKOPT   := max (1, NH) * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORGHR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      --     Shift the vectors which define the elementary reflectors one
      --     column to the right, and set the first ilo and the last n-ihi
      --     rows and columns to those of the unit matrix
      --
      J := IHI + 1;
      loop
         J := J - 1;
         exit when J < ILO + 1;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > J - 1;
            A (I, J) := ZERO;
         end loop;
         I := J + 1 - 1;
         loop
            I := I + 1;
            exit when I > IHI;
            A (I, J) := A (I, J - 1);
         end loop;
         I := IHI + 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            A (I, J) := ZERO;
         end loop;
      end loop;
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > ILO;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            A (I, J) := ZERO;
         end loop;
         A (J, J) := ONE;
      end loop;
      J := IHI + 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            A (I, J) := ZERO;
         end loop;
         A (J, J) := ONE;
      end loop;
      --
      if NH > 0 then
         --
         --        Generate Q(ilo+1:ihi,ilo+1:ihi)
         --
         DORGQR (NH, NH, NH, A (ILO + 1, ILO + 1)'Address, LDA, TAU (ILO)'Address, WORK'Address, LWORK, IINFO);
      end if;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORGHR
      --
   end DORGHR;

   procedure DORGL2
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. K);
      WORK : Ftn_Real_Vector (1 .. M);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE  : constant Real := 1.0e0;
      ZERO : constant Real := 0.0e0;
      I    : Integer;
      J    : Integer;
      L    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORGL2( M, N, K, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORGL2 generates an m by n real matrix Q with orthonormal rows,
   --  which is defined as the first m rows of a product of k elementary
   --  reflectors of order n
   --
   --        Q  =  H(k) . . . H(2) H(1)
   --
   --  as returned by DGELQF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. N >= M.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. M >= K >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the i-th row must contain the vector which defines
   --           the elementary reflector H(i), for i = 1,2,...,k, as returned
   --           by DGELQF in the first k rows of its array argument A.
   --           On exit, the m-by-n matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGELQF.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (M)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, DSCAL, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < M then
         INFO := -2;
      elsif K < 0 or K > M then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("DORGL2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M <= 0 then
         return;
      end if;
      --
      if K < M then
         --
         --        Initialise rows k+1:m to rows of the unit matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            L := K + 1 - 1;
            loop
               L := L + 1;
               exit when L > M;
               A (L, J) := ZERO;
            end loop;
            if J > K and J <= M then
               A (J, J) := ONE;
            end if;
         end loop;
      end if;
      --
      I := K + 1;
      loop
         I := I - 1;
         exit when I < 1;
         --
         --        Apply H(i) to A(i:m,i:n) from the right
         --
         if I < N then
            if I < M then
               A (I, I) := ONE;
               DLARF ('R', M - I, N - I + 1, A (I, I)'Address, LDA, TAU (I), A (I + 1, I)'Address, LDA, WORK'Address);
            end if;
            DSCAL (N - I, -TAU (I), A (I, I + 1)'Address, LDA);
         end if;
         A (I, I) := ONE - TAU (I);
         --
         --        Set A(i,1:i-1) to zero
         --
         L := 1 - 1;
         loop
            L := L + 1;
            exit when L > I - 1;
            A (I, L) := ZERO;
         end loop;
      end loop;
      return;
      --
      --     End of DORGL2
      --
   end DORGL2;

   procedure DORGLQ
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. K);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      KI     : Integer;
      KK     : Integer;
      L      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORGLQ( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
   --  which is defined as the first M rows of a product of K elementary
   --  reflectors of order N
   --
   --        Q  =  H(k) . . . H(2) H(1)
   --
   --  as returned by DGELQF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. N >= M.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. M >= K >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the i-th row must contain the vector which defines
   --           the elementary reflector H(i), for i = 1,2,...,k, as returned
   --           by DGELQF in the first k rows of its array argument A.
   --           On exit, the M-by-N matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGELQF.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,M).
   --           For optimum performance LWORK >= M*NB, where NB is
   --           the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARFB, DLARFT, DORGL2, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "DORGLQ", " ", M, N, K, -1);
      LWKOPT   := max (1, M) * NB;
      WORK (1) := Real (LWKOPT);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < M then
         INFO := -2;
      elsif K < 0 or K > M then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      elsif LWORK < max (1, M) and not LQUERY then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("DORGLQ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M <= 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := M;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "DORGLQ", " ", M, N, K, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := M;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "DORGLQ", " ", M, N, K, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code after the last block.
         --        The first kk rows are handled by the block method.
         --
         KI := ((K - NX - 1) / NB) * NB;
         KK := min (K, KI + NB);
         --
         --        Set A(kk+1:m,1:kk) to zero.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > KK;
            I := KK + 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := ZERO;
            end loop;
         end loop;
      else
         KK := 0;
      end if;
      --
      --     Use unblocked code for the last or only block.
      --
      if KK < M then
         DORGL2 (M - KK, N - KK, K - KK, A (KK + 1, KK + 1)'Address, LDA, TAU (KK + 1)'Address, WORK'Address, IINFO);
      end if;
      --
      if KK > 0 then
         --
         --        Use blocked code
         --
         I := KI + 1 + NB;
         loop
            I := I - NB;
            exit when I < 1;
            IB := min (NB, K - I + 1);
            if I + IB <= M then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i) H(i+1) . . . H(i+ib-1)
               --
               DLARFT ('F', 'R', N - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, LDWORK);
               --
               --              Apply H**T to A(i+ib:m,i:n) from the right
               --
               DLARFB
                 ('R',
                  'T',
                  'F',
                  'R',
                  M - I - IB + 1,
                  N - I + 1,
                  IB,
                  A (I, I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A (I + IB, I)'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
            --
            --           Apply H**T to columns i:n of current block
            --
            DORGL2 (IB, N - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            --
            --           Set columns 1:i-1 of current block to zero
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > I - 1;
               L := I - 1;
               loop
                  L := L + 1;
                  exit when L > I + IB - 1;
                  A (L, J) := ZERO;
               end loop;
            end loop;
         end loop;
      end if;
      --
      WORK (1) := Real (IWS);
      return;
      --
      --     End of DORGLQ
      --
   end DORGLQ;

   procedure DORGQL
     (M     : Integer;
      N     : Integer;
      K     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      TAU   : Ftn_Real_Vector;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      ZERO   : constant Real := 0.0e0;
      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      KK     : Integer;
      L      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORGQL( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORGQL generates an M-by-N real matrix Q with orthonormal columns,
   --  which is defined as the last N columns of a product of K elementary
   --  reflectors of order M
   --
   --        Q  =  H(k) . . . H(2) H(1)
   --
   --  as returned by DGEQLF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. M >= N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. N >= K >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the (n-k+i)-th column must contain the vector which
   --           defines the elementary reflector H(i), for i = 1,2,...,k, as
   --           returned by DGEQLF in the last k columns of its array
   --           argument A.
   --           On exit, the M-by-N matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEQLF.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,N).
   --           For optimum performance LWORK >= N*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARFB, DLARFT, DORG2L, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 or N > M then
         INFO := -2;
      elsif K < 0 or K > N then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      end if;
      --
      if INFO = 0 then
         if N = 0 then
            LWKOPT := 1;
         else
            NB     := ILAENV (1, "DORGQL", " ", M, N, K, -1);
            LWKOPT := N * NB;
         end if;
         WORK (1) := Real (LWKOPT);
         --
         if LWORK < max (1, N) and not LQUERY then
            INFO := -8;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORGQL", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := N;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "DORGQL", " ", M, N, K, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := N;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "DORGQL", " ", M, N, K, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code after the first block.
         --        The last kk columns are handled by the block method.
         --
         KK := min (K, ((K - NX + NB - 1) / NB) * NB);
         --
         --        Set A(m-kk+1:m,1:n-kk) to zero.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N - KK;
            I := M - KK + 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := ZERO;
            end loop;
         end loop;
      else
         KK := 0;
      end if;
      --
      --     Use unblocked code for the first or only block.
      --
      DORG2L (M - KK, N - KK, K - KK, A'Address, LDA, TAU'Address, WORK'Address, IINFO);
      --
      if KK > 0 then
         --
         --        Use blocked code
         --
         I := K - KK + 1 - NB;
         loop
            I := I + NB;
            exit when I > K;
            IB := min (NB, K - I + 1);
            if N - K + I > 1 then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i+ib-1) . . . H(i+1) H(i)
               --
               DLARFT
                 ('B',
                  'C',
                  M - K + I + IB - 1,
                  IB,
                  A (1, N - K + I)'Address,
                  LDA,
                  TAU (I)'Address,
                  WORK'Address,
                  LDWORK);
               --
               --              Apply H to A(1:m-k+i+ib-1,1:n-k+i-1) from the left
               --
               DLARFB
                 ('L',
                  'N',
                  'B',
                  'C',
                  M - K + I + IB - 1,
                  N - K + I - 1,
                  IB,
                  A (1, N - K + I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
            --
            --           Apply H to rows 1:m-k+i+ib-1 of current block
            --
            DORG2L (M - K + I + IB - 1, IB, IB, A (1, N - K + I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            --
            --           Set rows m-k+i+ib:m of current block to zero
            --
            J := N - K + I - 1;
            loop
               J := J + 1;
               exit when J > N - K + I + IB - 1;
               L := M - K + I + IB - 1;
               loop
                  L := L + 1;
                  exit when L > M;
                  A (L, J) := ZERO;
               end loop;
            end loop;
         end loop;
      end if;
      --
      WORK (1) := Real (IWS);
      return;
      --
      --     End of DORGQL
      --
   end DORGQL;

   procedure DORGQR
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. K);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      KI     : Integer;
      KK     : Integer;
      L      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORGQR generates an M-by-N real matrix Q with orthonormal columns,
   --  which is defined as the first N columns of a product of K elementary
   --  reflectors of order M
   --
   --        Q  =  H(1) H(2) . . . H(k)
   --
   --  as returned by DGEQRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. M >= N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. N >= K >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the i-th column must contain the vector which
   --           defines the elementary reflector H(i), for i = 1,2,...,k, as
   --           returned by DGEQRF in the first k columns of its array
   --           argument A.
   --           On exit, the M-by-N matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEQRF.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,N).
   --           For optimum performance LWORK >= N*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARFB, DLARFT, DORG2R, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      INTEGER            ILAENV
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "DORGQR", " ", M, N, K, -1);
      LWKOPT   := max (1, N) * NB;
      WORK (1) := Real (LWKOPT);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 or N > M then
         INFO := -2;
      elsif K < 0 or K > N then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("DORGQR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := N;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "DORGQR", " ", M, N, K, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := N;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "DORGQR", " ", M, N, K, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code after the last block.
         --        The first kk columns are handled by the block method.
         --
         KI := ((K - NX - 1) / NB) * NB;
         KK := min (K, KI + NB);
         --
         --        Set A(1:kk,kk+1:n) to zero.
         --
         J := KK + 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > KK;
               A (I, J) := ZERO;
            end loop;
         end loop;
      else
         KK := 0;
      end if;
      --
      --     Use unblocked code for the last or only block.
      --
      if KK < N then
         DORG2R (M - KK, N - KK, K - KK, A (KK + 1, KK + 1)'Address, LDA, TAU (KK + 1)'Address, WORK'Address, IINFO);
      end if;
      --
      if KK > 0 then
         --
         --        Use blocked code
         --
         I := KI + 1 + NB;
         loop
            I := I - NB;
            exit when I < 1;
            IB := min (NB, K - I + 1);
            if I + IB <= N then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i) H(i+1) . . . H(i+ib-1)
               --
               DLARFT ('F', 'C', M - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, LDWORK);
               --
               --              Apply H to A(i:m,i+ib:n) from the left
               --
               DLARFB
                 ('L',
                  'N',
                  'F',
                  'C',
                  M - I + 1,
                  N - I - IB + 1,
                  IB,
                  A (I, I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A (I, I + IB)'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
            --
            --           Apply H to rows i:m of current block
            --
            DORG2R (M - I + 1, IB, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            --
            --           Set rows 1:i-1 of current block to zero
            --
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + IB - 1;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > I - 1;
                  A (L, J) := ZERO;
               end loop;
            end loop;
         end loop;
      end if;
      --
      WORK (1) := Real (IWS);
      return;
      --
      --     End of DORGQR
      --
   end DORGQR;

   procedure DORGTR
     (UPLO     : Character;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Real_Vector (1 .. N - 1);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      LQUERY : Boolean;
      UPPER  : Boolean;
      I      : Integer;
      IINFO  : Integer;
      J      : Integer;
      LWKOPT : Integer;
      NB     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORGTR( UPLO, N, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORGTR generates a real orthogonal matrix Q which is defined as the
   --  product of n-1 elementary reflectors of order N, as returned by
   --  DSYTRD:
   --
   --  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
   --
   --  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U': Upper triangle of A contains elementary reflectors
   --                  from DSYTRD;
   --           = 'L': Lower triangle of A contains elementary reflectors
   --                  from DSYTRD.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix Q. N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the vectors which define the elementary reflectors,
   --           as returned by DSYTRD.
   --           On exit, the N-by-N orthogonal matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (N-1)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DSYTRD.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,N-1).
   --           For optimum performance LWORK >= (N-1)*NB, where NB is
   --           the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DORGQL, DORGQR, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1);
      UPPER  := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      elsif LWORK < max (1, N - 1) and not LQUERY then
         INFO := -7;
      end if;
      --
      if INFO = 0 then
         if UPPER 
            then NB := ILAENV (1, "DORGQL", " ", N - 1, N - 1, N - 1, -1);
            else NB := ILAENV (1, "DORGQR", " ", N - 1, N - 1, N - 1, -1);
         end if;
         LWKOPT   := max (1, N - 1) * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORGTR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      if UPPER then
         --
         --        Q was determined by a call to DSYTRD with UPLO = 'U'
         --
         --        Shift the vectors which define the elementary reflectors one
         --        column to the left, and set the last row and column of Q to
         --        those of the unit matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N - 1;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > J - 1;
               A (I, J) := A (I, J + 1);
            end loop;
            A (N, J) := ZERO;
         end loop;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            A (I, N) := ZERO;
         end loop;
         A (N, N) := ONE;
         --
         --        Generate Q(1:n-1,1:n-1)
         --
         DORGQL (N - 1, N - 1, N - 1, A, LDA, TAU, WORK, LWORK, IINFO);
      --
      else
         --
         --        Q was determined by a call to DSYTRD with UPLO = 'L'.
         --
         --        Shift the vectors which define the elementary reflectors one
         --        column to the right, and set the first row and column of Q to
         --        those of the unit matrix
         --
         J := N + 1;
         loop
            J := J - 1;
            exit when J < 2;
            A (1, J) := ZERO;
            I        := J + 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               A (I, J) := A (I, J - 1);
            end loop;
         end loop;
         A (1, 1) := ONE;
         I        := 2 - 1;
         loop
            I := I + 1;
            exit when I > N;
            A (I, 1) := ZERO;
         end loop;
         if N > 1 then
            --
            --           Generate Q(2:n,2:n)
            --
            DORGQR (N - 1, N - 1, N - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
         end if;
      end if;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORGTR
      --
   end DORGTR;

   procedure DORM2L
     (SIDE  : Character;
      TRANS : Character;
      M     : Integer;
      N     : Integer;
      K     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      TAU   : Ftn_Real_Vector;
      C     : Ftn_Real_Matrix;
      LDC   : Integer;
      WORK  : Ftn_Real_Vector;
      INFO  : in out Integer)
   is
      ONE    : constant Real := 1.0e0;
      LEFT   : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      MI     : Integer;
      NI     : Integer;
      NQ     : Integer;
      AII    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORM2L overwrites the general real m by n matrix C with
   --
   --        Q * C  if SIDE = 'L' and TRANS = 'N', or
   --
   --        Q**T * C  if SIDE = 'L' and TRANS = 'T', or
   --
   --        C * Q  if SIDE = 'R' and TRANS = 'N', or
   --
   --        C * Q**T if SIDE = 'R' and TRANS = 'T',
   --
   --  where Q is a real orthogonal matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(k) . . . H(2) H(1)
   --
   --  as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**T from the Left
   --           = 'R': apply Q or Q**T from the Right
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply Q  (No transpose)
   --           = 'T': apply Q**T (Transpose)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,K)
   --           The i-th column must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           DGEQLF in the last k columns of its array argument A.
   --           A is modified by the routine but restored on exit.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If SIDE = 'L', LDA >= max(1,M);
   --           if SIDE = 'R', LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEQLF.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the m by n matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension
   --                                    (N) if SIDE = 'L',
   --                                    (M) if SIDE = 'R'
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      --
      --     NQ is the order of Q
      --
      if LEFT 
         then NQ := M;
         else NQ := N;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'T') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      end if;
      if INFO /= 0 then
         XERBLA ("DORM2L", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         return;
      end if;
      --
      if (LEFT and NOTRAN) or (not LEFT and not NOTRAN) then
         I1 := 1;
         I2 := K;
         I3 := 1;
      else
         I1 := K;
         I2 := 1;
         I3 := -1;
      end if;
      --
      if LEFT 
         then NI := N;
         else MI := M;
      end if;
      --
      I := I1 - I3;
      loop
         I := I + I3;
         if I3 > 0 
            then exit when I > I2;
            else exit when I < I2;
         end if;
         if LEFT then
            --
            --           H(i) is applied to C(1:m-k+i,1:n)
            --
            MI := M - K + I;
         else
            --
            --           H(i) is applied to C(1:m,1:n-k+i)
            --
            NI := N - K + I;
         end if;
         --
         --        Apply H(i)
         --
         AII               := A (NQ - K + I, I);
         A (NQ - K + I, I) := ONE;
         DLARF (SIDE, MI, NI, A (1, I)'Address, 1, TAU (I), C'Address, LDC, WORK'Address);
         A (NQ - K + I, I) := AII;
      end loop;
      return;
      --
      --     End of DORM2L
      --
   end DORM2L;

   procedure DORM2R
     (SIDE  : Character;
      TRANS : Character;
      M     : Integer;
      N     : Integer;
      K     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      TAU   : in out Ftn_Real_Vector;
      C     : in out Ftn_Real_Matrix;
      LDC   : Integer;
      WORK  : in out Ftn_Real_Vector;
      INFO  : in out Integer)
   is
      ONE    : constant Real := 1.0e0;
      LEFT   : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IC     : Integer;
      JC     : Integer;
      MI     : Integer;
      NI     : Integer;
      NQ     : Integer;
      AII    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORM2R overwrites the general real m by n matrix C with
   --
   --        Q * C  if SIDE = 'L' and TRANS = 'N', or
   --
   --        Q**T* C  if SIDE = 'L' and TRANS = 'T', or
   --
   --        C * Q  if SIDE = 'R' and TRANS = 'N', or
   --
   --        C * Q**T if SIDE = 'R' and TRANS = 'T',
   --
   --  where Q is a real orthogonal matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(1) H(2) . . . H(k)
   --
   --  as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**T from the Left
   --           = 'R': apply Q or Q**T from the Right
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply Q  (No transpose)
   --           = 'T': apply Q**T (Transpose)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,K)
   --           The i-th column must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           DGEQRF in the first k columns of its array argument A.
   --           A is modified by the routine but restored on exit.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If SIDE = 'L', LDA >= max(1,M);
   --           if SIDE = 'R', LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEQRF.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the m by n matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension
   --                                    (N) if SIDE = 'L',
   --                                    (M) if SIDE = 'R'
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      --
      --     NQ is the order of Q
      --
      if LEFT 
         then NQ := M;
         else NQ := N;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'T') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      end if;
      if INFO /= 0 then
         XERBLA ("DORM2R", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         return;
      end if;
      --
      if (LEFT and not NOTRAN) or (not LEFT and NOTRAN) then
         I1 := 1;
         I2 := K;
         I3 := 1;
      else
         I1 := K;
         I2 := 1;
         I3 := -1;
      end if;
      --
      if LEFT then
         NI := N;
         JC := 1;
      else
         MI := M;
         IC := 1;
      end if;
      --
      I := I1 - I3;
      loop
         I := I + I3;
         if I3 > 0 
            then exit when I > I2;
            else exit when I < I2;
         end if;
         if LEFT then
            --
            --           H(i) is applied to C(i:m,1:n)
            --
            MI := M - I + 1;
            IC := I;
         else
            --
            --           H(i) is applied to C(1:m,i:n)
            --
            NI := N - I + 1;
            JC := I;
         end if;
         --
         --        Apply H(i)
         --
         AII      := A (I, I);
         A (I, I) := ONE;
         DLARF (SIDE, MI, NI, A (I, I)'Address, 1, TAU (I), C (IC, JC)'Address, LDC, WORK'Address);
         A (I, I) := AII;
      end loop;
      return;
      --
      --     End of DORM2R
      --
   end DORM2R;

   procedure DORMBR
     (VECT     : Character;
      SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      the_NQ : constant Integer := max (M, N);

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. the_NQ);
      TAU  : Ftn_Real_Vector (1 .. min (the_NQ, K));
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      APPLYQ : Boolean;
      LEFT   : Boolean;
      LQUERY : Boolean;
      NOTRAN : Boolean;
      TRANST : Character;
      I1     : Integer;
      I2     : Integer;
      IINFO  : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORMBR( VECT, SIDE, TRANS, M, N, K, A, LDA, TAU, C,
   --                          LDC, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS, VECT
   --       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
   --  with
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'T':      Q**T * C       C * Q**T
   --
   --  If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
   --  with
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      P * C          C * P
   --  TRANS = 'T':      P**T * C       C * P**T
   --
   --  Here Q and P**T are the orthogonal matrices determined by DGEBRD when
   --  reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
   --  P**T are defined as products of elementary reflectors H(i) and G(i)
   --  respectively.
   --
   --  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
   --  order of the orthogonal matrix Q or P**T that is applied.
   --
   --  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
   --  if nq >= k, Q = H(1) H(2) . . . H(k);
   --  if nq < k, Q = H(1) H(2) . . . H(nq-1).
   --
   --  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
   --  if k < nq, P = G(1) G(2) . . . G(k);
   --  if k >= nq, P = G(1) G(2) . . . G(nq-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] VECT
   --           VECT is CHARACTER*1
   --           = 'Q': apply Q or Q**T;
   --           = 'P': apply P or P**T.
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q, Q**T, P or P**T from the Left;
   --           = 'R': apply Q, Q**T, P or P**T from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q  or P;
   --           = 'T':  Transpose, apply Q**T or P**T.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           If VECT = 'Q', the number of columns in the original
   --           matrix reduced by DGEBRD.
   --           If VECT = 'P', the number of rows in the original
   --           matrix reduced by DGEBRD.
   --           K >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension
   --                                 (LDA,min(nq,K)) if VECT = 'Q'
   --                                 (LDA,nq)        if VECT = 'P'
   --           The vectors which define the elementary reflectors H(i) and
   --           G(i), whose products determine the matrices Q and P, as
   --           returned by DGEBRD.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If VECT = 'Q', LDA >= max(1,nq);
   --           if VECT = 'P', LDA >= max(1,min(nq,K)).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (min(nq,K))
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i) or G(i) which determines Q or P, as returned
   --           by DGEBRD in the array argument TAUQ or TAUP.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
   --           or P*C or P**T*C or C*P or C*P**T.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DORMLQ, DORMQR, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      APPLYQ := LSAME (VECT, 'Q');
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q or P and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not APPLYQ and not LSAME (VECT, 'P') then
         INFO := -1;
      elsif not LEFT and not LSAME (SIDE, 'R') then
         INFO := -2;
      elsif not NOTRAN and not LSAME (TRANS, 'T') then
         INFO := -3;
      elsif M < 0 then
         INFO := -4;
      elsif N < 0 then
         INFO := -5;
      elsif K < 0 then
         INFO := -6;
      elsif (APPLYQ and LDA < max (1, NQ)) or (not APPLYQ and LDA < max (1, min (NQ, K))) then
         INFO := -8;
      elsif LDC < max (1, M) then
         INFO := -11;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -13;
      end if;
      --
      if INFO = 0 then
         if APPLYQ then
            if LEFT 
               then NB := ILAENV (1, "DORMQR", SIDE & TRANS, M - 1, N, M - 1, -1);
               else NB := ILAENV (1, "DORMQR", SIDE & TRANS, M, N - 1, N - 1, -1);
            end if;
         else
            if LEFT 
               then NB := ILAENV (1, "DORMQR", SIDE & TRANS, M - 1, N, M - 1, -1);
               else NB := ILAENV (1, "DORMQR", SIDE & TRANS, M, N - 1, N - 1, -1);
            end if;
         end if;
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORMBR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      WORK (1) := 1.0;
      if M = 0 or N = 0 then
         return;
      end if;
      --
      if APPLYQ then
         --
         --        Apply Q
         --
         if NQ >= K then
            --
            --           Q was determined by a call to DGEBRD with nq >= k
            --
            DORMQR (SIDE, TRANS, M, N, K, A'Address, LDA, TAU'Address, C'Address, LDC, WORK'Address, LWORK, IINFO);
         elsif NQ > 1 then
            --
            --           Q was determined by a call to DGEBRD with nq < k
            --
            if LEFT then
               MI := M - 1;
               NI := N;
               I1 := 2;
               I2 := 1;
            else
               MI := M;
               NI := N - 1;
               I1 := 1;
               I2 := 2;
            end if;
            DORMQR
              (SIDE,
               TRANS,
               MI,
               NI,
               NQ - 1,
               A (2, 1)'Address,
               LDA,
               TAU'Address,
               C (I1, I2)'Address,
               LDC,
               WORK'Address,
               LWORK,
               IINFO);
         end if;
      else
         --
         --        Apply P
         --
         if NOTRAN 
            then TRANST := 'T';
            else TRANST := 'N';
         end if;
         if NQ > K then
            --
            --           P was determined by a call to DGEBRD with nq > k
            --
            DORMLQ (SIDE, TRANST, M, N, K, A'Address, LDA, TAU'Address, C'Address, LDC, WORK'Address, LWORK, IINFO);
         elsif NQ > 1 then
            --
            --           P was determined by a call to DGEBRD with nq <= k
            --
            if LEFT then
               MI := M - 1;
               NI := N;
               I1 := 2;
               I2 := 1;
            else
               MI := M;
               NI := N - 1;
               I1 := 1;
               I2 := 2;
            end if;
            DORMLQ
              (SIDE,
               TRANST,
               MI,
               NI,
               NQ - 1,
               A (1, 2)'Address,
               LDA,
               TAU'Address,
               C (I1, I2)'Address,
               LDC,
               WORK'Address,
               LWORK,
               IINFO);
         end if;
      end if;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORMBR
      --
   end DORMBR;

   procedure DORMHR
     (SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. max (M, N));
      TAU  : Ftn_Real_Vector (1 .. max (M - 1, N - 1));
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      LEFT   : Boolean;
      LQUERY : Boolean;
      I1     : Integer;
      I2     : Integer;
      IINFO  : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NH     : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORMHR( SIDE, TRANS, M, N, ILO, IHI, A, LDA, TAU, C,
   --                          LDC, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            IHI, ILO, INFO, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORMHR overwrites the general real M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'T':      Q**T * C       C * Q**T
   --
   --  where Q is a real orthogonal matrix of order nq, with nq = m if
   --  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
   --  IHI-ILO elementary reflectors, as returned by DGEHRD:
   --
   --  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**T from the Left;
   --           = 'R': apply Q or Q**T from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'T':  Transpose, apply Q**T.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --           ILO and IHI must have the same values as in the previous call
   --           of DGEHRD. Q is equal to the unit matrix except in the
   --           submatrix Q(ilo+1:ihi,ilo+1:ihi).
   --           If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
   --           ILO = 1 and IHI = 0, if M = 0;
   --           if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
   --           ILO = 1 and IHI = 0, if N = 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension
   --                                (LDA,M) if SIDE = 'L'
   --                                (LDA,N) if SIDE = 'R'
   --           The vectors which define the elementary reflectors, as
   --           returned by DGEHRD.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension
   --                                (M-1) if SIDE = 'L'
   --                                (N-1) if SIDE = 'R'
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEHRD.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      INTEGER            ILAENV
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DORMQR, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      NH     := IHI - ILO;
      LEFT   := LSAME (SIDE, 'L');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not LSAME (TRANS, 'N') and not LSAME (TRANS, 'T') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif ILO < 1 or ILO > max (1, NQ) then
         INFO := -5;
      elsif IHI < min (ILO, NQ) or IHI > NQ then
         INFO := -6;
      elsif LDA < max (1, NQ) then
         INFO := -8;
      elsif LDC < max (1, M) then
         INFO := -11;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -13;
      end if;
      --
      if INFO = 0 then
         if LEFT 
            then NB := ILAENV (1, "DORMQR", SIDE & TRANS, NH, N, NH, -1);
            else NB := ILAENV (1, "DORMQR", SIDE & TRANS, M, NH, NH, -1);
         end if;
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORMHR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or NH = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      if LEFT then
         MI := NH;
         NI := N;
         I1 := ILO + 1;
         I2 := 1;
      else
         MI := M;
         NI := NH;
         I1 := 1;
         I2 := ILO + 1;
      end if;
      --
      DORMQR
        (SIDE,
         TRANS,
         MI,
         NI,
         NH,
         A (ILO + 1, ILO)'Address,
         LDA,
         TAU (ILO)'Address,
         C (I1, I2)'Address,
         LDC,
         WORK'Address,
         LWORK,
         IINFO);
      --
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORMHR
      --
   end DORMHR;

   procedure DORML2
     (SIDE  : Character;
      TRANS : Character;
      M     : Integer;
      N     : Integer;
      K     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      TAU   : in out Ftn_Real_Vector;
      C     : in out Ftn_Real_Matrix;
      LDC   : Integer;
      WORK  : in out Ftn_Real_Vector;
      INFO  : in out Integer)
   is
      ONE    : constant Real := 1.0e0;
      LEFT   : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IC     : Integer;
      JC     : Integer;
      MI     : Integer;
      NI     : Integer;
      NQ     : Integer;
      AII    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORML2( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORML2 overwrites the general real m by n matrix C with
   --
   --        Q * C  if SIDE = 'L' and TRANS = 'N', or
   --
   --        Q**T* C  if SIDE = 'L' and TRANS = 'T', or
   --
   --        C * Q  if SIDE = 'R' and TRANS = 'N', or
   --
   --        C * Q**T if SIDE = 'R' and TRANS = 'T',
   --
   --  where Q is a real orthogonal matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(k) . . . H(2) H(1)
   --
   --  as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**T from the Left
   --           = 'R': apply Q or Q**T from the Right
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply Q  (No transpose)
   --           = 'T': apply Q**T (Transpose)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension
   --                                (LDA,M) if SIDE = 'L',
   --                                (LDA,N) if SIDE = 'R'
   --           The i-th row must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           DGELQF in the first k rows of its array argument A.
   --           A is modified by the routine but restored on exit.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,K).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGELQF.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the m by n matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension
   --                                    (N) if SIDE = 'L',
   --                                    (M) if SIDE = 'R'
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARF, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      --
      --     NQ is the order of Q
      --
      if LEFT 
         then NQ := M;
         else NQ := N;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'T') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, K) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      end if;
      if INFO /= 0 then
         XERBLA ("DORML2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         return;
      end if;
      --
      if (LEFT and NOTRAN) or (not LEFT and not NOTRAN) then
         I1 := 1;
         I2 := K;
         I3 := 1;
      else
         I1 := K;
         I2 := 1;
         I3 := -1;
      end if;
      --
      if LEFT then
         NI := N;
         JC := 1;
      else
         MI := M;
         IC := 1;
      end if;
      --
      I := I1 - I3;
      loop
         I := I + I3;
         if I3 > 0 
            then exit when I > I2;
            else exit when I < I2;
         end if;
         if LEFT then
            --
            --           H(i) is applied to C(i:m,1:n)
            --
            MI := M - I + 1;
            IC := I;
         else
            --
            --           H(i) is applied to C(1:m,i:n)
            --
            NI := N - I + 1;
            JC := I;
         end if;
         --
         --        Apply H(i)
         --
         AII      := A (I, I);
         A (I, I) := ONE;
         DLARF (SIDE, MI, NI, A (I, I)'Address, LDA, TAU (I), C (IC, JC)'Address, LDC, WORK'Address);
         A (I, I) := AII;
      end loop;
      return;
      --
      --     End of DORML2
      --
   end DORML2;

   procedure DORMLQ
     (SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. max (M, N));
      TAU  : Ftn_Real_Vector (1 .. K);
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      NBMAX  : constant Integer := 64;
      LDT    : constant Integer := NBMAX + 1;
      LEFT   : Boolean;
      LQUERY : Boolean;
      NOTRAN : Boolean;
      TRANST : Character;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IB     : Integer;
      IC     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      JC     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
      T      : Ftn_Real_Matrix (1 .. LDT, 1 .. NBMAX);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORMLQ( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORMLQ overwrites the general real M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'T':      Q**T * C       C * Q**T
   --
   --  where Q is a real orthogonal matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(k) . . . H(2) H(1)
   --
   --  as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**T from the Left;
   --           = 'R': apply Q or Q**T from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'T':  Transpose, apply Q**T.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension
   --                                (LDA,M) if SIDE = 'L',
   --                                (LDA,N) if SIDE = 'R'
   --           The i-th row must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           DGELQF in the first k rows of its array argument A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,K).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGELQF.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARFB, DLARFT, DORML2, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'T') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, K) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -12;
      end if;
      --
      if INFO = 0 then
         --
         --        Determine the block size.  NB may be at most NBMAX, where NBMAX
         --        is used to define the local array T.
         --
         NB       := min (NBMAX, ILAENV (1, "DORMLQ", SIDE & TRANS, M, N, K, -1));
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORMLQ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := NW;
      if NB > 1 and NB < K then
         IWS := NW * NB;
         if LWORK < IWS then
            NB    := LWORK / LDWORK;
            NBMIN := max (2, ILAENV (2, "DORMLQ", SIDE & TRANS, M, N, K, -1));
         end if;
      else
         IWS := NW;
      end if;
      --
      if NB < NBMIN or NB >= K then
         --
         --        Use unblocked code
         --
         DORML2 (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, IINFO);
      else
         --
         --        Use blocked code
         --
         if (LEFT and NOTRAN) or (not LEFT and not NOTRAN) then
            I1 := 1;
            I2 := K;
            I3 := NB;
         else
            I1 := ((K - 1) / NB) * NB + 1;
            I2 := 1;
            I3 := -NB;
         end if;
         --
         if LEFT then
            NI := N;
            JC := 1;
         else
            MI := M;
            IC := 1;
         end if;
         --
         if NOTRAN 
            then TRANST := 'T';
            else TRANST := 'N';
         end if;
         --
         I := I1 - I3;
         loop
            I := I + I3;
            if I3 > 0 
               then exit when I > I2;
               else exit when I < I2;
            end if;
            IB := min (NB, K - I + 1);
            --
            --           Form the triangular factor of the block reflector
            --           H = H(i) H(i+1) . . . H(i+ib-1)
            --
            DLARFT ('F', 'R', NQ - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, T'Address, LDT);
            if LEFT then
               --
               --              H or H**T is applied to C(i:m,1:n)
               --
               MI := M - I + 1;
               IC := I;
            else
               --
               --              H or H**T is applied to C(1:m,i:n)
               --
               NI := N - I + 1;
               JC := I;
            end if;
            --
            --           Apply H or H**T
            --
            DLARFB
              (SIDE,
               TRANST,
               'F',
               'R',
               MI,
               NI,
               IB,
               A (I, I)'Address,
               LDA,
               T'Address,
               LDT,
               C (IC, JC)'Address,
               LDC,
               WORK'Address,
               LDWORK);
         end loop;
      end if;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORMLQ
      --
   end DORMLQ;

   procedure DORMQL
     (SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. K);
      TAU  : Ftn_Real_Vector (1 .. K);
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      NBMAX  : constant Integer := 64;
      LDT    : constant Integer := NBMAX + 1;
      LEFT   : Boolean;
      LQUERY : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
      T      : Ftn_Real_Matrix (1 .. LDT, 1 .. NBMAX);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORMQL overwrites the general real M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'T':      Q**T * C       C * Q**T
   --
   --  where Q is a real orthogonal matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(k) . . . H(2) H(1)
   --
   --  as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**T from the Left;
   --           = 'R': apply Q or Q**T from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'T':  Transpose, apply Q**T.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,K)
   --           The i-th column must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           DGEQLF in the last k columns of its array argument A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If SIDE = 'L', LDA >= max(1,M);
   --           if SIDE = 'R', LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEQLF.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARFB, DLARFT, DORM2L, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := max (1, N);
      else
         NQ := N;
         NW := max (1, M);
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'T') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      end if;
      --
      if INFO = 0 then
         if M = 0 or N = 0 then
            LWKOPT := 1;
         else
            --
            --           Determine the block size.  NB may be at most NBMAX, where
            --           NBMAX is used to define the local array T.
            --
            NB     := min (NBMAX, ILAENV (1, "DORMQL", SIDE & TRANS, M, N, K, -1));
            LWKOPT := NW * NB;
         end if;
         WORK (1) := Real (LWKOPT);
         --
         if LWORK < NW and not LQUERY then
            INFO := -12;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORMQL", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := NW;
      if NB > 1 and NB < K then
         IWS := NW * NB;
         if LWORK < IWS then
            NB    := LWORK / LDWORK;
            NBMIN := max (2, ILAENV (2, "DORMQL", SIDE & TRANS, M, N, K, -1));
         end if;
      else
         IWS := NW;
      end if;
      --
      if NB < NBMIN or NB >= K then
         --
         --        Use unblocked code
         --
         DORM2L (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, IINFO);
      else
         --
         --        Use blocked code
         --
         if (LEFT and NOTRAN) or (not LEFT and not NOTRAN) then
            I1 := 1;
            I2 := K;
            I3 := NB;
         else
            I1 := ((K - 1) / NB) * NB + 1;
            I2 := 1;
            I3 := -NB;
         end if;
         --
         if LEFT 
            then NI := N;
            else MI := M;
         end if;
         --
         I := I1 - I3;
         loop
            I := I + I3;
            if I3 > 0 
               then exit when I > I2;
               else exit when I < I2;
            end if;
            IB := min (NB, K - I + 1);
            --
            --           Form the triangular factor of the block reflector
            --           H = H(i+ib-1) . . . H(i+1) H(i)
            --
            DLARFT ('B', 'C', NQ - K + I + IB - 1, IB, A (1, I)'Address, LDA, TAU (I)'Address, T'Address, LDT);
            if LEFT then
               --
               --              H or H**T is applied to C(1:m-k+i+ib-1,1:n)
               --
               MI := M - K + I + IB - 1;
            else
               --
               --              H or H**T is applied to C(1:m,1:n-k+i+ib-1)
               --
               NI := N - K + I + IB - 1;
            end if;
            --
            --           Apply H or H**T
            --
            DLARFB
              (SIDE,
               TRANS,
               'B',
               'C',
               MI,
               NI,
               IB,
               A (1, I)'Address,
               LDA,
               T'Address,
               LDT,
               C'Address,
               LDC,
               WORK'Address,
               LDWORK);
         end loop;
      end if;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORMQL
      --
   end DORMQL;

   procedure DORMQR
     (SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. K);
      TAU  : Ftn_Real_Vector (1 .. K);
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      NBMAX  : constant Integer := 64;
      LDT    : constant Integer := NBMAX + 1;
      LEFT   : Boolean;
      LQUERY : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IB     : Integer;
      IC     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      JC     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
      T      : Ftn_Real_Matrix (1 .. LDT, 1 .. NBMAX);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORMQR overwrites the general real M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'T':      Q**T * C       C * Q**T
   --
   --  where Q is a real orthogonal matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(1) H(2) . . . H(k)
   --
   --  as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**T from the Left;
   --           = 'R': apply Q or Q**T from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'T':  Transpose, apply Q**T.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,K)
   --           The i-th column must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           DGEQRF in the first k columns of its array argument A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If SIDE = 'L', LDA >= max(1,M);
   --           if SIDE = 'R', LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DGEQRF.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      INTEGER            ILAENV
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARFB, DLARFT, DORM2R, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'T') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -12;
      end if;
      --
      if INFO = 0 then
         --
         --        Determine the block size.  NB may be at most NBMAX, where NBMAX
         --        is used to define the local array T.
         --
         NB       := min (NBMAX, ILAENV (1, "DORMQR", SIDE & TRANS, M, N, K, -1));
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORMQR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := NW;
      if NB > 1 and NB < K then
         IWS := NW * NB;
         if LWORK < IWS then
            NB    := LWORK / LDWORK;
            NBMIN := max (2, ILAENV (2, "DORMQR", SIDE & TRANS, M, N, K, -1));
         end if;
      else
         IWS := NW;
      end if;
      --
      if NB < NBMIN or NB >= K then
         --
         --        Use unblocked code
         --
         DORM2R (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, IINFO);
      else
         --
         --        Use blocked code
         --
         if (LEFT and not NOTRAN) or (not LEFT and NOTRAN) then
            I1 := 1;
            I2 := K;
            I3 := NB;
         else
            I1 := ((K - 1) / NB) * NB + 1;
            I2 := 1;
            I3 := -NB;
         end if;
         --
         if LEFT then
            NI := N;
            JC := 1;
         else
            MI := M;
            IC := 1;
         end if;
         --
         I := I1 - I3;
         loop
            I := I + I3;
            if I3 > 0 
               then exit when I > I2;
               else exit when I < I2;
            end if;
            IB := min (NB, K - I + 1);
            --
            --           Form the triangular factor of the block reflector
            --           H = H(i) H(i+1) . . . H(i+ib-1)
            --
            DLARFT ('F', 'C', NQ - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, T'Address, LDT);
            if LEFT then
               --
               --              H or H**T is applied to C(i:m,1:n)
               --
               MI := M - I + 1;
               IC := I;
            else
               --
               --              H or H**T is applied to C(1:m,i:n)
               --
               NI := N - I + 1;
               JC := I;
            end if;
            --
            --           Apply H or H**T
            --
            DLARFB
              (SIDE,
               TRANS,
               'F',
               'C',
               MI,
               NI,
               IB,
               A (I, I)'Address,
               LDA,
               T'Address,
               LDT,
               C (IC, JC)'Address,
               LDC,
               WORK'Address,
               LDWORK);
         end loop;
      end if;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORMQR
      --
   end DORMQR;

   procedure DORMTR
     (SIDE     : Character;
      UPLO     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. max (M, N));
      TAU  : Ftn_Real_Vector (1 .. max (M - 1, N - 1));
      C    : Ftn_Real_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      LEFT   : Boolean;
      LQUERY : Boolean;
      UPPER  : Boolean;
      I1     : Integer;
      I2     : Integer;
      IINFO  : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS, UPLO
   --       INTEGER            INFO, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DORMTR overwrites the general real M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'T':      Q**T * C       C * Q**T
   --
   --  where Q is a real orthogonal matrix of order nq, with nq = m if
   --  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
   --  nq-1 elementary reflectors, as returned by DSYTRD:
   --
   --  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
   --
   --  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**T from the Left;
   --           = 'R': apply Q or Q**T from the Right.
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U': Upper triangle of A contains elementary reflectors
   --                  from DSYTRD;
   --           = 'L': Lower triangle of A contains elementary reflectors
   --                  from DSYTRD.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'T':  Transpose, apply Q**T.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension
   --                                (LDA,M) if SIDE = 'L'
   --                                (LDA,N) if SIDE = 'R'
   --           The vectors which define the elementary reflectors, as
   --           returned by DSYTRD.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
   --
   --  [in] TAU
   --           TAU is DOUBLE PRECISION array, dimension
   --                                (M-1) if SIDE = 'L'
   --                                (N-1) if SIDE = 'R'
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by DSYTRD.
   --
   --  [in,out] C
   --           C is DOUBLE PRECISION array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DORMQL, DORMQR, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      UPPER  := LSAME (UPLO, 'U');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not UPPER and not LSAME (UPLO, 'L') then
         INFO := -2;
      elsif not LSAME (TRANS, 'N') and not LSAME (TRANS, 'T') then
         INFO := -3;
      elsif M < 0 then
         INFO := -4;
      elsif N < 0 then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -12;
      end if;
      --
      if INFO = 0 then
         if UPPER then
            if LEFT 
               then NB := ILAENV (1, "DORMQL", SIDE & TRANS, M - 1, N, M - 1, -1);
               else NB := ILAENV (1, "DORMQL", SIDE & TRANS, M, N - 1, N - 1, -1);
            end if;
         else
            if LEFT 
               then NB := ILAENV (1, "DORMQR", SIDE & TRANS, M - 1, N, M - 1, -1);
               else NB := ILAENV (1, "DORMQR", SIDE & TRANS, M, N - 1, N - 1, -1);
            end if;
         end if;
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DORMTR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or NQ = 1 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      if LEFT then
         MI := M - 1;
         NI := N;
      else
         MI := M;
         NI := N - 1;
      end if;
      --
      if UPPER then
         --
         --        Q was determined by a call to DSYTRD with UPLO = 'U'
         --
         DORMQL (SIDE, TRANS, MI, NI, NQ - 1, A (1, 2)'Address, LDA, TAU'Address, C'Address, LDC, WORK'Address, LWORK, IINFO);
      else
         --
         --        Q was determined by a call to DSYTRD with UPLO = 'L'
         --
         if LEFT then
            I1 := 2;
            I2 := 1;
         else
            I1 := 1;
            I2 := 2;
         end if;
         DORMQR
           (SIDE,
            TRANS,
            MI,
            NI,
            NQ - 1,
            A (2, 1)'Address,
            LDA,
            TAU'Address,
            C (I1, I2)'Address,
            LDC,
            WORK'Address,
            LWORK,
            IINFO);
      end if;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DORMTR
      --
   end DORMTR;

   procedure DSTEDC
     (COMPZ     : Character;
      N         : Integer;
      D_adr     : Address;
      E_adr     : Address;
      Z_adr     : Address;
      LDZ       : Integer;
      WORK_adr  : Address;
      LWORK     : Integer;
      IWORK_adr : Address;
      LIWORK    : Integer;
      INFO      : in out Integer)
   is

      D     : Ftn_Real_Vector (1 .. N);
      E     : Ftn_Real_Vector (1 .. N - 1);
      Z     : Ftn_Real_Matrix (1 .. LDZ, 1 .. N);
      WORK  : Ftn_Real_Vector (1 .. max (1, LWORK));
      IWORK : Ftn_Integer_Vector (1 .. max (1, LIWORK));

      for D'Address use D_adr;
      for E'Address use E_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);
      pragma Import (Ada, IWORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      LQUERY : Boolean;
      FINISH : Integer;
      I      : Integer;
      ICOMPZ : Integer;
      II     : Integer;
      J      : Integer;
      K      : Integer;
      LGN    : Integer;
      LIWMIN : Integer;
      LWMIN  : Integer;
      M      : Integer;
      SMLSIZ : Integer;
      START  : Integer;
      STOREZ : Integer;
      STRTRW : Integer;
      EPS    : Real;
      ORGNRM : Real;
      P      : Real;
      TINY   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSTEDC( COMPZ, N, D, E, Z, LDZ, WORK, LWORK, IWORK,
   --                          LIWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          COMPZ
   --       INTEGER            INFO, LDZ, LIWORK, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   D( * ), E( * ), WORK( * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
   --  symmetric tridiagonal matrix using the divide and conquer method.
   --  The eigenvectors of a full or band real symmetric matrix can also be
   --  found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
   --  matrix to tridiagonal form.
   --
   --  This code makes very mild assumptions about floating point
   --  arithmetic. It will work on machines with a guard digit in
   --  add/subtract, or on those binary machines without guard digits
   --  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
   --  It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.  See DLAED3 for details.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] COMPZ
   --           COMPZ is CHARACTER*1
   --           = 'N':  Compute eigenvalues only.
   --           = 'I':  Compute eigenvectors of tridiagonal matrix also.
   --           = 'V':  Compute eigenvectors of original dense symmetric
   --                   matrix also.  On entry, Z contains the orthogonal
   --                   matrix used to reduce the original matrix to
   --                   tridiagonal form.
   --
   --  [in] N
   --           N is INTEGER
   --           The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the diagonal elements of the tridiagonal matrix.
   --           On exit, if INFO = 0, the eigenvalues in ascending order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           On entry, the subdiagonal elements of the tridiagonal matrix.
   --           On exit, E has been destroyed.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension (LDZ,N)
   --           On entry, if COMPZ = 'V', then Z contains the orthogonal
   --           matrix used in the reduction to tridiagonal form.
   --           On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
   --           orthonormal eigenvectors of the original symmetric matrix,
   --           and if COMPZ = 'I', Z contains the orthonormal eigenvectors
   --           of the symmetric tridiagonal matrix.
   --           If  COMPZ = 'N', then Z is not referenced.
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --           The leading dimension of the array Z.  LDZ >= 1.
   --           If eigenvectors are desired, then LDZ >= max(1,N).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array,
   --                                          dimension (LWORK)
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If COMPZ = 'N' or N <= 1 then LWORK must be at least 1.
   --           If COMPZ = 'V' and N > 1 then LWORK must be at least
   --                          ( 1 + 3*N + 2*N*lg N + 4*N**2 ),
   --                          where lg( N ) = smallest integer k such
   --                          that 2**k >= N.
   --           If COMPZ = 'I' and N > 1 then LWORK must be at least
   --                          ( 1 + 4*N + N**2 ).
   --           Note that for COMPZ = 'I' or 'V', then if N is less than or
   --           equal to the minimum divide size, usually 25, then LWORK need
   --           only be max(1,2*(N-1)).
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (MAX(1,LIWORK))
   --           On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
   --
   --  [in] LIWORK
   --           LIWORK is INTEGER
   --           The dimension of the array IWORK.
   --           If COMPZ = 'N' or N <= 1 then LIWORK must be at least 1.
   --           If COMPZ = 'V' and N > 1 then LIWORK must be at least
   --                          ( 6 + 6*N + 5*N*lg N ).
   --           If COMPZ = 'I' and N > 1 then LIWORK must be at least
   --                          ( 3 + 5*N ).
   --           Note that for COMPZ = 'I' or 'V', then if N is less than or
   --           equal to the minimum divide size, usually 25, then LIWORK
   --           need only be 1.
   --
   --           If LIWORK = -1, then a workspace query is assumed; the
   --           routine only calculates the optimal size of the IWORK array,
   --           returns this value as the first entry of the IWORK array, and
   --           no error message related to LIWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  The algorithm failed to compute an eigenvalue while
   --                 working on the submatrix lying in rows and columns
   --                 INFO/(N+1) through mod(INFO,N+1).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA \n
   --   Modified by Francoise Tisseur, University of Tennessee
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANST
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMM, DLACPY, DLAED0, DLASCL, DLASET, DLASRT, DSTEQR, DSTERF, DSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, LOG, MAX, MOD, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1 or LIWORK = -1);
      --
      if LSAME (COMPZ, 'N') then
         ICOMPZ := 0;
      elsif LSAME (COMPZ, 'V') then
         ICOMPZ := 1;
      elsif LSAME (COMPZ, 'I') then
         ICOMPZ := 2;
      else
         ICOMPZ := -1;
      end if;
      if ICOMPZ < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif (LDZ < 1) or (ICOMPZ > 0 and LDZ < max (1, N)) then
         INFO := -6;
      end if;
      --
      if INFO = 0 then
         --
         --        Compute the workspace requirements
         --
         SMLSIZ := ILAENV (9, "DSTEDC", " ", 0, 0, 0, 0);
         if N <= 1 or ICOMPZ = 0 then
            LIWMIN := 1;
            LWMIN  := 1;
         elsif N <= SMLSIZ then
            LIWMIN := 1;
            LWMIN  := 2 * (N - 1);
         else
            LGN := int (Log (Real (N)) / Log (TWO));
            if 2 ** LGN < N then
               LGN := LGN + 1;
            end if;
            if 2 ** LGN < N then
               LGN := LGN + 1;
            end if;
            if ICOMPZ = 1 then
               LWMIN  := 1 + 3 * N + 2 * N * LGN + 4 * N ** 2;
               LIWMIN := 6 + 6 * N + 5 * N * LGN;
            elsif ICOMPZ = 2 then
               LWMIN  := 1 + 4 * N + N ** 2;
               LIWMIN := 3 + 5 * N;
            end if;
         end if;
         WORK (1)  := Real (LWMIN);
         IWORK (1) := LIWMIN;
         --
         if LWORK < LWMIN and not LQUERY then
            INFO := -8;
         elsif LIWORK < LIWMIN and not LQUERY then
            INFO := -10;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DSTEDC", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      if N = 1 then
         if ICOMPZ /= 0 then
            Z (1, 1) := ONE;
         end if;
         return;
      end if;
      --
      --     If the following conditional clause is removed, then the routine
      --     will use the Divide and Conquer routine to compute only the
      --     eigenvalues, which requires (3N + 3N**2) real workspace and
      --     (2 + 5N + 2N lg(N)) integer workspace.
      --     Since on many architectures DSTERF is much faster than any other
      --     algorithm for finding eigenvalues only, it is used here
      --     as the default. If the conditional clause is removed, then
      --     information on the size of workspace needs to be changed.
      --
      --     If COMPZ = 'N', use DSTERF to compute the eigenvalues.
      --
      if ICOMPZ = 0 then
         DSTERF (N, D'Address, E'Address, INFO);
         goto L50;
      end if;
      --
      --     If N is smaller than the minimum divide size (SMLSIZ+1), then
      --     solve the problem with another solver.
      --
      if N <= SMLSIZ then
         --
         DSTEQR (COMPZ, N, D'Address, E'Address, Z'Address, LDZ, WORK'Address, INFO);
      --
      else
         --
         --        If COMPZ = 'V', the Z matrix must be stored elsewhere for later
         --        use.
         --
         if ICOMPZ = 1 
            then STOREZ := 1 + N * N;
            else STOREZ := 1;
         end if;
         --
         if ICOMPZ = 2 then
            DLASET ('F', N, N, ZERO, ONE, Z'Address, LDZ);
         end if;
         --
         --        Scale.
         --
         ORGNRM := DLANST ('M', N, D'Address, E'Address);
         if ORGNRM = ZERO then
            goto L50;
         end if;
         --
         EPS := DLAMCH ('E');
         --
         START := 1;
         --
         --        while ( START <= N )
         --
         <<L10>> null;
         if START <= N then
            --
            --           Let FINISH be the position of the next subdiagonal entry
            --           such that E( FINISH ) <= TINY or FINISH = N if no such
            --           subdiagonal exists.  The matrix identified by the elements
            --           between START and FINISH constitutes an independent
            --           sub-problem.
            --
            FINISH := START;
            <<L20>> null;
            if FINISH < N then
               TINY := EPS * Sqrt (abs (D (FINISH))) * Sqrt (abs (D (FINISH + 1)));
               if abs (E (FINISH)) > TINY then
                  FINISH := FINISH + 1;
                  goto L20;
               end if;
            end if;
            --
            --           (Sub) Problem determined.  Compute its size and solve it.
            --
            M := FINISH - START + 1;
            if M = 1 then
               START := FINISH + 1;
               goto L10;
            end if;
            if M > SMLSIZ then
               --
               --              Scale.
               --
               ORGNRM := DLANST ('M', M, D (START)'Address, E (START)'Address);
               DLASCL ('G', 0, 0, ORGNRM, ONE, M, 1, D (START)'Address, M, INFO);
               DLASCL ('G', 0, 0, ORGNRM, ONE, M - 1, 1, E (START)'Address, M - 1, INFO);
               --
               if ICOMPZ = 1 
                  then STRTRW := 1;
                  else STRTRW := START;
               end if;
               DLAED0
                 (ICOMPZ,
                  N,
                  M,
                  D (START)'Address,
                  E (START)'Address,
                  Z (STRTRW, START)'Address,
                  LDZ,
                  WORK (1)'Address,
                  N,
                  WORK (STOREZ)'Address,
                  IWORK'Address,
                  INFO);
               if INFO /= 0 then
                  INFO := (INFO / (M + 1) + START - 1) * (N + 1) + "mod" (INFO, (M + 1)) + START - 1;
                  goto L50;
               end if;
               --
               --              Scale back.
               --
               DLASCL ('G', 0, 0, ONE, ORGNRM, M, 1, D (START)'Address, M, INFO);
            --
            else
               if ICOMPZ = 1 then
                  --
                  --                 Since QR won't update a Z matrix which is larger than
                  --                 the length of D, we must solve the sub-problem in a
                  --                 workspace and then multiply back into Z.
                  --
                  DSTEQR ('I', M, D (START)'Address, E (START)'Address, WORK'Address, M, WORK (M * M + 1)'Address, INFO);
                  DLACPY ('A', N, M, Z (1, START)'Address, LDZ, WORK (STOREZ)'Address, N);
                  DGEMM ('N', 'N', N, M, M, ONE, WORK (STOREZ)'Address, N, WORK'Address, M, ZERO, Z (1, START)'Address, LDZ);
               elsif ICOMPZ = 2 then
                  DSTEQR ('I', M, D (START)'Address, E (START)'Address, Z (START, START)'Address, LDZ, WORK'Address, INFO);
               else
                  DSTERF (M, D (START)'Address, E (START)'Address, INFO);
               end if;
               if INFO /= 0 then
                  INFO := START * (N + 1) + FINISH;
                  goto L50;
               end if;
            end if;
            --
            START := FINISH + 1;
            goto L10;
         end if;
         --
         --        endwhile
         --
         --        If the problem split any number of times, then the eigenvalues
         --        will not be properly ordered.  Here we permute the eigenvalues
         --        (and the associated eigenvectors) into ascending order.
         --
         if M /= N then
            if ICOMPZ = 0 then
               --
               --              Use Quick Sort
               --
               DLASRT ('I', N, D, INFO);
            --
            else
               --
               --              Use Selection Sort to minimize swaps of eigenvectors
               --
               II := 2 - 1;
               loop
                  II := II + 1;
                  exit when II > N;
                  I := II - 1;
                  K := I;
                  P := D (I);
                  J := II - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     if D (J) < P then
                        K := J;
                        P := D (J);
                     end if;
                  end loop;
                  if K /= I then
                     D (K) := D (I);
                     D (I) := P;
                     DSWAP (N, Z (1, I)'Address, 1, Z (1, K)'Address, 1);
                  end if;
               end loop;
            end if;
         end if;
      end if;
      --
      <<L50>> null;
      WORK (1)  := Real (LWMIN);
      IWORK (1) := LIWMIN;
      --
      return;
      --
      --     End of DSTEDC
      --
   end DSTEDC;

   procedure DSTEQR
     (COMPZ    : Character;
      N        : Integer;
      D_adr    : Address;
      E_adr    : Address;
      Z_adr    : Address;
      LDZ      : Integer;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      D    : Ftn_Real_Vector (1 .. N);
      E    : Ftn_Real_Vector (1 .. N - 1);
      Z    : Ftn_Real_Matrix (1 .. LDZ, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, 2 * N - 2));

      for D'Address use D_adr;
      for E'Address use E_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);

      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      TWO    : constant Real    := 2.0e0;
      THREE  : constant Real    := 3.0e0;
      MAXIT  : constant Integer := 30;
      I      : Integer;
      ICOMPZ : Integer;
      II     : Integer;
      ISCALE : Integer;
      J      : Integer;
      JTOT   : Integer;
      K      : Integer;
      L      : Integer;
      L1     : Integer;
      LEND   : Integer;
      LENDM1 : Integer;
      LENDP1 : Integer;
      LENDSV : Integer;
      LM1    : Integer;
      LSV    : Integer;
      M      : Integer;
      MM     : Integer;
      MM1    : Integer;
      NM1    : Integer;
      NMAXIT : Integer;
      ANORM  : Real;
      B      : Real;
      C      : Real;
      EPS    : Real;
      EPS2   : Real;
      F      : Real;
      G      : Real;
      P      : Real;
      R      : Real;
      RT1    : Real;
      RT2    : Real;
      S      : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SSFMAX : Real;
      SSFMIN : Real;
      TST    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSTEQR( COMPZ, N, D, E, Z, LDZ, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          COMPZ
   --       INTEGER            INFO, LDZ, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * ), WORK( * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
   --  symmetric tridiagonal matrix using the implicit QL or QR method.
   --  The eigenvectors of a full or band symmetric matrix can also be found
   --  if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
   --  tridiagonal form.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] COMPZ
   --           COMPZ is CHARACTER*1
   --           = 'N':  Compute eigenvalues only.
   --           = 'V':  Compute eigenvalues and eigenvectors of the original
   --                   symmetric matrix.  On entry, Z must contain the
   --                   orthogonal matrix used to reduce the original matrix
   --                   to tridiagonal form.
   --           = 'I':  Compute eigenvalues and eigenvectors of the
   --                   tridiagonal matrix.  Z is initialized to the identity
   --                   matrix.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the diagonal elements of the tridiagonal matrix.
   --           On exit, if INFO = 0, the eigenvalues in ascending order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           On entry, the (n-1) subdiagonal elements of the tridiagonal
   --           matrix.
   --           On exit, E has been destroyed.
   --
   --  [in,out] Z
   --           Z is DOUBLE PRECISION array, dimension (LDZ, N)
   --           On entry, if  COMPZ = 'V', then Z contains the orthogonal
   --           matrix used in the reduction to tridiagonal form.
   --           On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
   --           orthonormal eigenvectors of the original symmetric matrix,
   --           and if COMPZ = 'I', Z contains the orthonormal eigenvectors
   --           of the symmetric tridiagonal matrix.
   --           If COMPZ = 'N', then Z is not referenced.
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --           The leading dimension of the array Z.  LDZ >= 1, and if
   --           eigenvectors are desired, then  LDZ >= max(1,N).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (max(1,2*N-2))
   --           If COMPZ = 'N', then WORK is not referenced.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  the algorithm has failed to find all the eigenvalues in
   --                 a total of 30*N iterations; if INFO = i, then i
   --                 elements of E have not converged to zero; on exit, D
   --                 and E contain the elements of a symmetric tridiagonal
   --                 matrix which is orthogonally similar to the original
   --                 matrix.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, THREE = 3.0D0 )
   --      PARAMETER          ( MAXIT = 30 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, DLAMCH, DLANST, DLAPY2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLAE2, DLAEV2, DLARTG, DLASCL, DLASET, DLASR, DLASRT, DSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if LSAME (COMPZ, 'N') then
         ICOMPZ := 0;
      elsif LSAME (COMPZ, 'V') then
         ICOMPZ := 1;
      elsif LSAME (COMPZ, 'I') then
         ICOMPZ := 2;
      else
         ICOMPZ := -1;
      end if;
      if ICOMPZ < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif (LDZ < 1) or (ICOMPZ > 0 and LDZ < max (1, N)) then
         INFO := -6;
      end if;
      if INFO /= 0 then
         XERBLA ("DSTEQR", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      if N = 1 then
         if ICOMPZ = 2 then
            Z (1, 1) := ONE;
         end if;
         return;
      end if;
      --
      --     Determine the unit roundoff and over/underflow thresholds.
      --
      EPS    := DLAMCH ('E');
      EPS2   := EPS ** 2;
      SAFMIN := DLAMCH ('S');
      SAFMAX := ONE / SAFMIN;
      SSFMAX := Sqrt (SAFMAX) / THREE;
      SSFMIN := Sqrt (SAFMIN) / EPS2;
      --
      --     Compute the eigenvalues and eigenvectors of the tridiagonal
      --     matrix.
      --
      if ICOMPZ = 2 then
         DLASET ('F', N, N, ZERO, ONE, Z'Address, LDZ);
      end if;
      --
      NMAXIT := N * MAXIT;
      JTOT   := 0;
      --
      --     Determine where the matrix splits and choose QL or QR iteration
      --     for each block, according to whether top or bottom diagonal
      --     element is smaller.
      --
      L1  := 1;
      NM1 := N - 1;
      --
      <<L10>> null;
      if L1 > N then
         goto L160;
      end if;
      if L1 > 1 then
         E (L1 - 1) := ZERO;
      end if;
      if L1 <= NM1 then
         M := L1 - 1;
         loop
            M := M + 1;
            exit when M > NM1;
            TST := abs (E (M));
            if TST = ZERO then
               goto L30;
            end if;
            if TST <= (Sqrt (abs (D (M))) * Sqrt (abs (D (M + 1)))) * EPS then
               E (M) := ZERO;
               goto L30;
            end if;
         end loop;
      end if;
      M := N;
      --
      <<L30>> null;
      L      := L1;
      LSV    := L;
      LEND   := M;
      LENDSV := LEND;
      L1     := M + 1;
      if LEND = L then
         goto L10;
      end if;
      --
      --     Scale submatrix in rows and columns L to LEND
      --
      ANORM  := DLANST ('M', LEND - L + 1, D (L)'Address, E (L)'Address);
      ISCALE := 0;
      if ANORM = ZERO then
         goto L10;
      end if;
      if ANORM > SSFMAX then
         ISCALE := 1;
         DLASCL ('G', 0, 0, ANORM, SSFMAX, LEND - L + 1, 1, D (L)'Address, N, INFO);
         DLASCL ('G', 0, 0, ANORM, SSFMAX, LEND - L, 1, E (L)'Address, N, INFO);
      elsif ANORM < SSFMIN then
         ISCALE := 2;
         DLASCL ('G', 0, 0, ANORM, SSFMIN, LEND - L + 1, 1, D (L)'Address, N, INFO);
         DLASCL ('G', 0, 0, ANORM, SSFMIN, LEND - L, 1, E (L)'Address, N, INFO);
      end if;
      --
      --     Choose between QL and QR iteration
      --
      if abs (D (LEND)) < abs (D (L)) then
         LEND := LSV;
         L    := LENDSV;
      end if;
      --
      if LEND > L then
         --
         --        QL Iteration
         --
         --        Look for small subdiagonal element.
         --
         <<L40>> null;
         if L /= LEND then
            LENDM1 := LEND - 1;
            M      := L - 1;
            loop
               M := M + 1;
               exit when M > LENDM1;
               TST := abs (E (M)) * abs (E (M));
               if TST <= (EPS2 * abs (D (M))) * abs (D (M + 1)) + SAFMIN then
                  goto L60;
               end if;
            end loop;
         end if;
         --
         M := LEND;
         --
         <<L60>> null;
         if M < LEND then
            E (M) := ZERO;
         end if;
         P := D (L);
         if M = L then
            goto L80;
         end if;
         --
         --        If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
         --        to compute its eigensystem.
         --
         if M = L + 1 then
            if ICOMPZ > 0 then
               DLAEV2 (D (L), E (L), D (L + 1), RT1, RT2, C, S);
               WORK (L)         := C;
               WORK (N - 1 + L) := S;
               DLASR ('R', 'V', 'B', N, 2, WORK (L)'Address, WORK (N - 1 + L)'Address, Z (1, L)'Address, LDZ);
            else
               DLAE2 (D (L), E (L), D (L + 1), RT1, RT2);
            end if;
            D (L)     := RT1;
            D (L + 1) := RT2;
            E (L)     := ZERO;
            L         := L + 2;
            if L <= LEND then
               goto L40;
            end if;
            goto L140;
         end if;
         --
         if JTOT = NMAXIT then
            goto L140;
         end if;
         JTOT := JTOT + 1;
         --
         --        Form shift.
         --
         G := (D (L + 1) - P) / (TWO * E (L));
         R := DLAPY2 (G, ONE);
         G := D (M) - P + (E (L) / (G + sign (R, G)));
         --
         S := ONE;
         C := ONE;
         P := ZERO;
         --
         --        Inner loop
         --
         MM1 := M - 1;
         I   := MM1 + 1;
         loop
            I := I - 1;
            exit when I < L;
            F := S * E (I);
            B := C * E (I);
            DLARTG (G, F, C, S, R);
            if I /= M - 1 then
               E (I + 1) := R;
            end if;
            G         := D (I + 1) - P;
            R         := (D (I) - G) * S + TWO * C * B;
            P         := S * R;
            D (I + 1) := G + P;
            G         := C * R - B;
            --
            --           If eigenvectors are desired, then save rotations.
            --
            if ICOMPZ > 0 then
               WORK (I)         := C;
               WORK (N - 1 + I) := -S;
            end if;
            --
         end loop;
         --
         --        If eigenvectors are desired, then apply saved rotations.
         --
         if ICOMPZ > 0 then
            MM := M - L + 1;
            DLASR ('R', 'V', 'B', N, MM, WORK (L)'Address, WORK (N - 1 + L)'Address, Z (1, L)'Address, LDZ);
         end if;
         --
         D (L) := D (L) - P;
         E (L) := G;
         goto L40;
         --
         --        Eigenvalue found.
         --
         <<L80>> null;
         D (L) := P;
         --
         L := L + 1;
         if L <= LEND then
            goto L40;
         end if;
         goto L140;
      --
      else
         --
         --        QR Iteration
         --
         --        Look for small superdiagonal element.
         --
         <<L90>> null;
         if L /= LEND then
            LENDP1 := LEND + 1;
            M      := L + 1;
            loop
               M := M - 1;
               exit when M < LENDP1;
               TST := abs (E (M - 1)) * abs (E (M - 1));
               if TST <= (EPS2 * abs (D (M))) * abs (D (M - 1)) + SAFMIN then
                  goto L110;
               end if;
            end loop;
         end if;
         --
         M := LEND;
         --
         <<L110>> null;
         if M > LEND then
            E (M - 1) := ZERO;
         end if;
         P := D (L);
         if M = L then
            goto L130;
         end if;
         --
         --        If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
         --        to compute its eigensystem.
         --
         if M = L - 1 then
            if ICOMPZ > 0 then
               DLAEV2 (D (L - 1), E (L - 1), D (L), RT1, RT2, C, S);
               WORK (M)         := C;
               WORK (N - 1 + M) := S;
               DLASR ('R', 'V', 'F', N, 2, WORK (M)'Address, WORK (N - 1 + M)'Address, Z (1, L - 1)'Address, LDZ);
            else
               DLAE2 (D (L - 1), E (L - 1), D (L), RT1, RT2);
            end if;
            D (L - 1) := RT1;
            D (L)     := RT2;
            E (L - 1) := ZERO;
            L         := L - 2;
            if L >= LEND then
               goto L90;
            end if;
            goto L140;
         end if;
         --
         if JTOT = NMAXIT then
            goto L140;
         end if;
         JTOT := JTOT + 1;
         --
         --        Form shift.
         --
         G := (D (L - 1) - P) / (TWO * E (L - 1));
         R := DLAPY2 (G, ONE);
         G := D (M) - P + (E (L - 1) / (G + sign (R, G)));
         --
         S := ONE;
         C := ONE;
         P := ZERO;
         --
         --        Inner loop
         --
         LM1 := L - 1;
         I   := M - 1;
         loop
            I := I + 1;
            exit when I > LM1;
            F := S * E (I);
            B := C * E (I);
            DLARTG (G, F, C, S, R);
            if I /= M then
               E (I - 1) := R;
            end if;
            G     := D (I) - P;
            R     := (D (I + 1) - G) * S + TWO * C * B;
            P     := S * R;
            D (I) := G + P;
            G     := C * R - B;
            --
            --           If eigenvectors are desired, then save rotations.
            --
            if ICOMPZ > 0 then
               WORK (I)         := C;
               WORK (N - 1 + I) := S;
            end if;
            --
         end loop;
         --
         --        If eigenvectors are desired, then apply saved rotations.
         --
         if ICOMPZ > 0 then
            MM := L - M + 1;
            DLASR ('R', 'V', 'F', N, MM, WORK (M)'Address, WORK (N - 1 + M)'Address, Z (1, M)'Address, LDZ);
         end if;
         --
         D (L)   := D (L) - P;
         E (LM1) := G;
         goto L90;
         --
         --        Eigenvalue found.
         --
         <<L130>> null;
         D (L) := P;
         --
         L := L - 1;
         if L >= LEND then
            goto L90;
         end if;
         goto L140;
         --
      end if;
      --
      --     Undo scaling if necessary
      --
      <<L140>> null;
      if ISCALE = 1 then
         DLASCL ('G', 0, 0, SSFMAX, ANORM, LENDSV - LSV + 1, 1, D (LSV)'Address, N, INFO);
         DLASCL ('G', 0, 0, SSFMAX, ANORM, LENDSV - LSV, 1, E (LSV)'Address, N, INFO);
      elsif ISCALE = 2 then
         DLASCL ('G', 0, 0, SSFMIN, ANORM, LENDSV - LSV + 1, 1, D (LSV)'Address, N, INFO);
         DLASCL ('G', 0, 0, SSFMIN, ANORM, LENDSV - LSV, 1, E (LSV)'Address, N, INFO);
      end if;
      --
      --     Check for no convergence to an eigenvalue after a total
      --     of N*MAXIT iterations.
      --
      if JTOT < NMAXIT then
         goto L10;
      end if;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         if E (I) /= ZERO then
            INFO := INFO + 1;
         end if;
      end loop;
      goto L190;
      --
      --     Order eigenvalues and eigenvectors.
      --
      <<L160>> null;
      if ICOMPZ = 0 then
         --
         --        Use Quick Sort
         --
         DLASRT ('I', N, D, INFO);
      --
      else
         --
         --        Use Selection Sort to minimize swaps of eigenvectors
         --
         II := 2 - 1;
         loop
            II := II + 1;
            exit when II > N;
            I := II - 1;
            K := I;
            P := D (I);
            J := II - 1;
            loop
               J := J + 1;
               exit when J > N;
               if D (J) < P then
                  K := J;
                  P := D (J);
               end if;
            end loop;
            if K /= I then
               D (K) := D (I);
               D (I) := P;
               DSWAP (N, Z (1, I)'Address, 1, Z (1, K)'Address, 1);
            end if;
         end loop;
      end if;
      --
      <<L190>> null;
      return;
      --
      --     End of DSTEQR
      --
   end DSTEQR;

   procedure DSTERF
     (N     : Integer;
      D_adr : Address;
      E_adr : Address;
      INFO  : in out Integer)
   is

      D : Ftn_Real_Vector (1 .. N);
      E : Ftn_Real_Vector (1 .. N - 1);

      for D'Address use D_adr;
      for E'Address use E_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);

      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      TWO    : constant Real    := 2.0e0;
      THREE  : constant Real    := 3.0e0;
      MAXIT  : constant Integer := 30;
      I      : Integer;
      ISCALE : Integer;
      JTOT   : Integer;
      L      : Integer;
      L1     : Integer;
      LEND   : Integer;
      LENDSV : Integer;
      LSV    : Integer;
      M      : Integer;
      NMAXIT : Integer;
      ALPHA  : Real;
      ANORM  : Real;
      BB     : Real;
      C      : Real;
      EPS    : Real;
      EPS2   : Real;
      GAMMA  : Real;
      OLDC   : Real;
      OLDGAM : Real;
      P      : Real;
      R      : Real;
      RT1    : Real;
      RT2    : Real;
      RTE    : Real;
      S      : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SIGMA  : Real;
      SSFMAX : Real;
      SSFMIN : Real;
      RMAX   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSTERF( N, D, E, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
   --  using the Pal-Walker-Kahan variant of the QL or QR algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the n diagonal elements of the tridiagonal matrix.
   --           On exit, if INFO = 0, the eigenvalues in ascending order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           On entry, the (n-1) subdiagonal elements of the tridiagonal
   --           matrix.
   --           On exit, E has been destroyed.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  the algorithm failed to find all of the eigenvalues in
   --                 a total of 30*N iterations; if INFO = i, then i
   --                 elements of E have not converged to zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, THREE = 3.0D0 )
   --      PARAMETER          ( MAXIT = 30 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DLAMCH, DLANST, DLAPY2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLAE2, DLASCL, DLASRT, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      --     Quick return if possible
      --
      if N < 0 then
         INFO := -1;
         XERBLA ("DSTERF", -INFO);
         return;
      end if;
      if N <= 1 then
         return;
      end if;
      --
      --     Determine the unit roundoff for this environment.
      --
      EPS    := DLAMCH ('E');
      EPS2   := EPS ** 2;
      SAFMIN := DLAMCH ('S');
      SAFMAX := ONE / SAFMIN;
      SSFMAX := Sqrt (SAFMAX) / THREE;
      SSFMIN := Sqrt (SAFMIN) / EPS2;
      RMAX   := DLAMCH ('O');
      --
      --     Compute the eigenvalues of the tridiagonal matrix.
      --
      NMAXIT := N * MAXIT;
      SIGMA  := ZERO;
      JTOT   := 0;
      --
      --     Determine where the matrix splits and choose QL or QR iteration
      --     for each block, according to whether top or bottom diagonal
      --     element is smaller.
      --
      L1 := 1;
      --
      <<L10>> null;
      if L1 > N then
         goto L170;
      end if;
      if L1 > 1 then
         E (L1 - 1) := ZERO;
      end if;
      M := L1 - 1;
      loop
         M := M + 1;
         exit when M > N - 1;
         if abs (E (M)) <= (Sqrt (abs (D (M))) * Sqrt (abs (D (M + 1)))) * EPS then
            E (M) := ZERO;
            goto L30;
         end if;
      end loop;
      M := N;
      --
      <<L30>> null;
      L      := L1;
      LSV    := L;
      LEND   := M;
      LENDSV := LEND;
      L1     := M + 1;
      if LEND = L then
         goto L10;
      end if;
      --
      --     Scale submatrix in rows and columns L to LEND
      --
      ANORM  := DLANST ('M', LEND - L + 1, D (L)'Address, E (L)'Address);
      ISCALE := 0;
      if ANORM = ZERO then
         goto L10;
      end if;
      if (ANORM > SSFMAX) then
         ISCALE := 1;
         DLASCL ('G', 0, 0, ANORM, SSFMAX, LEND - L + 1, 1, D (L)'Address, N, INFO);
         DLASCL ('G', 0, 0, ANORM, SSFMAX, LEND - L, 1, E (L)'Address, N, INFO);
      elsif ANORM < SSFMIN then
         ISCALE := 2;
         DLASCL ('G', 0, 0, ANORM, SSFMIN, LEND - L + 1, 1, D (L)'Address, N, INFO);
         DLASCL ('G', 0, 0, ANORM, SSFMIN, LEND - L, 1, E (L)'Address, N, INFO);
      end if;
      --
      I := L - 1;
      loop
         I := I + 1;
         exit when I > LEND - 1;
         E (I) := E (I) ** 2;
      end loop;
      --
      --     Choose between QL and QR iteration
      --
      if abs (D (LEND)) < abs (D (L)) then
         LEND := LSV;
         L    := LENDSV;
      end if;
      --
      if LEND >= L then
         --
         --        QL Iteration
         --
         --        Look for small subdiagonal element.
         --
         <<L50>> null;
         if L /= LEND then
            M := L - 1;
            loop
               M := M + 1;
               exit when M > LEND - 1;
               if abs (E (M)) <= EPS2 * abs (D (M) * D (M + 1)) then
                  goto L70;
               end if;
            end loop;
         end if;
         M := LEND;
         --
         <<L70>> null;
         if M < LEND then
            E (M) := ZERO;
         end if;
         P := D (L);
         if M = L then
            goto L90;
         end if;
         --
         --        If remaining matrix is 2 by 2, use DLAE2 to compute its
         --        eigenvalues.
         --
         if M = L + 1 then
            RTE := Sqrt (E (L));
            DLAE2 (D (L), RTE, D (L + 1), RT1, RT2);
            D (L)     := RT1;
            D (L + 1) := RT2;
            E (L)     := ZERO;
            L         := L + 2;
            if L <= LEND then
               goto L50;
            end if;
            goto L150;
         end if;
         --
         if JTOT = NMAXIT then
            goto L150;
         end if;
         JTOT := JTOT + 1;
         --
         --        Form shift.
         --
         RTE   := Sqrt (E (L));
         SIGMA := (D (L + 1) - P) / (TWO * RTE);
         R     := DLAPY2 (SIGMA, ONE);
         SIGMA := P - (RTE / (SIGMA + sign (R, SIGMA)));
         --
         C     := ONE;
         S     := ZERO;
         GAMMA := D (M) - SIGMA;
         P     := GAMMA * GAMMA;
         --
         --        Inner loop
         --
         I := M - 1 + 1;
         loop
            I := I - 1;
            exit when I < L;
            BB := E (I);
            R  := P + BB;
            if I /= M - 1 then
               E (I + 1) := S * R;
            end if;
            OLDC      := C;
            C         := P / R;
            S         := BB / R;
            OLDGAM    := GAMMA;
            ALPHA     := D (I);
            GAMMA     := C * (ALPHA - SIGMA) - S * OLDGAM;
            D (I + 1) := OLDGAM + (ALPHA - GAMMA);
            if C /= ZERO 
               then P := (GAMMA * GAMMA) / C;
               else P := OLDC * BB;
            end if;
         end loop;
         --
         E (L) := S * P;
         D (L) := SIGMA + GAMMA;
         goto L50;
         --
         --        Eigenvalue found.
         --
         <<L90>> null;
         D (L) := P;
         --
         L := L + 1;
         if L <= LEND then
            goto L50;
         end if;
         goto L150;
      --
      else
         --
         --        QR Iteration
         --
         --        Look for small superdiagonal element.
         --
         <<L100>> null;
         M := L + 1;
         loop
            M := M - 1;
            exit when M < LEND + 1;
            if abs (E (M - 1)) <= EPS2 * abs (D (M) * D (M - 1)) then
               goto L120;
            end if;
         end loop;
         M := LEND;
         --
         <<L120>> null;
         if M > LEND then
            E (M - 1) := ZERO;
         end if;
         P := D (L);
         if M = L then
            goto L140;
         end if;
         --
         --        If remaining matrix is 2 by 2, use DLAE2 to compute its
         --        eigenvalues.
         --
         if M = L - 1 then
            RTE := Sqrt (E (L - 1));
            DLAE2 (D (L), RTE, D (L - 1), RT1, RT2);
            D (L)     := RT1;
            D (L - 1) := RT2;
            E (L - 1) := ZERO;
            L         := L - 2;
            if L >= LEND then
               goto L100;
            end if;
            goto L150;
         end if;
         --
         if JTOT = NMAXIT then
            goto L150;
         end if;
         JTOT := JTOT + 1;
         --
         --        Form shift.
         --
         RTE   := Sqrt (E (L - 1));
         SIGMA := (D (L - 1) - P) / (TWO * RTE);
         R     := DLAPY2 (SIGMA, ONE);
         SIGMA := P - (RTE / (SIGMA + sign (R, SIGMA)));
         --
         C     := ONE;
         S     := ZERO;
         GAMMA := D (M) - SIGMA;
         P     := GAMMA * GAMMA;
         --
         --        Inner loop
         --
         I := M - 1;
         loop
            I := I + 1;
            exit when I > L - 1;
            BB := E (I);
            R  := P + BB;
            if I /= M then
               E (I - 1) := S * R;
            end if;
            OLDC   := C;
            C      := P / R;
            S      := BB / R;
            OLDGAM := GAMMA;
            ALPHA  := D (I + 1);
            GAMMA  := C * (ALPHA - SIGMA) - S * OLDGAM;
            D (I)  := OLDGAM + (ALPHA - GAMMA);
            if C /= ZERO 
               then P := (GAMMA * GAMMA) / C;
               else P := OLDC * BB;
            end if;
         end loop;
         --
         E (L - 1) := S * P;
         D (L)     := SIGMA + GAMMA;
         goto L100;
         --
         --        Eigenvalue found.
         --
         <<L140>> null;
         D (L) := P;
         --
         L := L - 1;
         if L >= LEND then
            goto L100;
         end if;
         goto L150;
         --
      end if;
      --
      --     Undo scaling if necessary
      --
      <<L150>> null;
      if ISCALE = 1 then
         DLASCL ('G', 0, 0, SSFMAX, ANORM, LENDSV - LSV + 1, 1, D (LSV)'Address, N, INFO);
      end if;
      if ISCALE = 2 then
         DLASCL ('G', 0, 0, SSFMIN, ANORM, LENDSV - LSV + 1, 1, D (LSV)'Address, N, INFO);
      end if;
      --
      --     Check for no convergence to an eigenvalue after a total
      --     of N*MAXIT iterations.
      --
      if JTOT < NMAXIT then
         goto L10;
      end if;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         if E (I) /= ZERO then
            INFO := INFO + 1;
         end if;
      end loop;
      goto L180;
      --
      --     Sort eigenvalues in increasing order.
      --
      <<L170>> null;
      DLASRT ('I', N, D, INFO);
      --
      <<L180>> null;
      return;
      --
      --     End of DSTERF
      --
   end DSTERF;

   procedure DSYCONV
     (UPLO : Character;
      WAY  : Character;
      N    : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer;
      IPIV : Ftn_Integer_Vector;
      WORK : in out Ftn_Real_Vector;
      INFO : in out Integer)
   is
      ZERO    : constant Real := 0.0e0;
      UPPER   : Boolean;
      CONVERT : Boolean;
      I       : Integer;
      IP      : Integer;
      J       : Integer;
      TEMP    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYCONV( UPLO, WAY, N, A, LDA, IPIV, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO, WAY
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYCONV convert A given by TRF into L and D and vice-versa.
   --  Get Non-diag elements of D (returned in workspace) and
   --  apply or reverse permutation done in TRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the details of the factorization are stored
   --           as an upper or lower triangular matrix.
   --           = 'U':  Upper triangular, form is A = U*D*U**T;
   --           = 'L':  Lower triangular, form is A = L*D*L**T.
   --
   --  [in] WAY
   --           WAY is CHARACTER*1
   --           = 'C': Convert
   --           = 'R': Revert
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The block diagonal matrix D and the multipliers used to
   --           obtain the factor U or L as computed by DSYTRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D
   --           as determined by DSYTRF.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0 )
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO    := 0;
      UPPER   := LSAME (UPLO, 'U');
      CONVERT := LSAME (WAY, 'C');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif not CONVERT and not LSAME (WAY, 'R') then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYCONV", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      if UPPER then
         --
         --      A is UPPER
         --
         --      Convert A (A is upper)
         --
         --        Convert VALUE
         --
         if CONVERT then
            I        := N;
            WORK (1) := ZERO;
            while I > 1 loop
               if IPIV (I) < 0 then
                  WORK (I)     := A (I - 1, I);
                  A (I - 1, I) := ZERO;
                  I            := I - 1;
               else
                  WORK (I) := ZERO;
               end if;
               I := I - 1;
            end loop;
            --
            --        Convert PERMUTATIONS
            --
            I := N;
            while I >= 1 loop
               if IPIV (I) > 0 then
                  IP := IPIV (I);
                  if I < N then
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > N;
                        TEMP      := A (IP, J);
                        A (IP, J) := A (I, J);
                        A (I, J)  := TEMP;
                     end loop;
                  end if;
               else
                  IP := -IPIV (I);
                  if I < N then
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > N;
                        TEMP         := A (IP, J);
                        A (IP, J)    := A (I - 1, J);
                        A (I - 1, J) := TEMP;
                     end loop;
                  end if;
                  I := I - 1;
               end if;
               I := I - 1;
            end loop;
         else
            --
            --      Revert A (A is upper)
            --
            --
            --        Revert PERMUTATIONS
            --
            I := 1;
            while I <= N loop
               if IPIV (I) > 0 then
                  IP := IPIV (I);
                  if I < N then
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > N;
                        TEMP      := A (IP, J);
                        A (IP, J) := A (I, J);
                        A (I, J)  := TEMP;
                     end loop;
                  end if;
               else
                  IP := -IPIV (I);
                  I  := I + 1;
                  if I < N then
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > N;
                        TEMP         := A (IP, J);
                        A (IP, J)    := A (I - 1, J);
                        A (I - 1, J) := TEMP;
                     end loop;
                  end if;
               end if;
               I := I + 1;
            end loop;
            --
            --        Revert VALUE
            --
            I := N;
            while I > 1 loop
               if IPIV (I) < 0 then
                  A (I - 1, I) := WORK (I);
                  I            := I - 1;
               end if;
               I := I - 1;
            end loop;
         end if;
      else
         --
         --      A is LOWER
         --
         if CONVERT then
            --
            --      Convert A (A is lower)
            --
            --
            --        Convert VALUE
            --
            I        := 1;
            WORK (N) := ZERO;
            while I <= N loop
               if I < N and IPIV (I) < 0 then
                  WORK (I)     := A (I + 1, I);
                  A (I + 1, I) := ZERO;
                  I            := I + 1;
               else
                  WORK (I) := ZERO;
               end if;
               I := I + 1;
            end loop;
            --
            --        Convert PERMUTATIONS
            --
            I := 1;
            while I <= N loop
               if IPIV (I) > 0 then
                  IP := IPIV (I);
                  if I > 1 then
                     J := 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > I - 1;
                        TEMP      := A (IP, J);
                        A (IP, J) := A (I, J);
                        A (I, J)  := TEMP;
                     end loop;
                  end if;
               else
                  IP := -IPIV (I);
                  if I > 1 then
                     J := 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > I - 1;
                        TEMP         := A (IP, J);
                        A (IP, J)    := A (I + 1, J);
                        A (I + 1, J) := TEMP;
                     end loop;
                  end if;
                  I := I + 1;
               end if;
               I := I + 1;
            end loop;
         else
            --
            --      Revert A (A is lower)
            --
            --
            --        Revert PERMUTATIONS
            --
            I := N;
            while I >= 1 loop
               if IPIV (I) > 0 then
                  IP := IPIV (I);
                  if I > 1 then
                     J := 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > I - 1;
                        TEMP      := A (I, J);
                        A (I, J)  := A (IP, J);
                        A (IP, J) := TEMP;
                     end loop;
                  end if;
               else
                  IP := -IPIV (I);
                  I  := I - 1;
                  if I > 1 then
                     J := 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > I - 1;
                        TEMP         := A (I + 1, J);
                        A (I + 1, J) := A (IP, J);
                        A (IP, J)    := TEMP;
                     end loop;
                  end if;
               end if;
               I := I - 1;
            end loop;
            --
            --        Revert VALUE
            --
            I := 1;
            while I <= N - 1 loop
               if IPIV (I) < 0 then
                  A (I + 1, I) := WORK (I);
                  I            := I + 1;
               end if;
               I := I + 1;
            end loop;
         end if;
      end if;
      return;
      --
      --     End of DSYCONV
      --
   end DSYCONV;

   procedure DSYEV
     (JOBZ  : Character;
      UPLO  : Character;
      N     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      W     : in out Ftn_Real_Vector;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      LOWER  : Boolean;
      LQUERY : Boolean;
      WANTZ  : Boolean;
      IINFO  : Integer;
      IMAX   : Integer;
      INDE   : Integer;
      INDTAU : Integer;
      INDWRK : Integer;
      ISCALE : Integer;
      LLWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      ANRM   : Real;
      BIGNUM : Real;
      EPS    : Real;
      RMAX   : Real;
      RMIN   : Real;
      SAFMIN : Real;
      SIGMA  : Real;
      SMLNUM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBZ, UPLO
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYEV computes all eigenvalues and, optionally, eigenvectors of a
   --  real symmetric matrix A.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBZ
   --           JOBZ is CHARACTER*1
   --           = 'N':  Compute eigenvalues only;
   --           = 'V':  Compute eigenvalues and eigenvectors.
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA, N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the
   --           leading N-by-N upper triangular part of A contains the
   --           upper triangular part of the matrix A.  If UPLO = 'L',
   --           the leading N-by-N lower triangular part of A contains
   --           the lower triangular part of the matrix A.
   --           On exit, if JOBZ = 'V', then if INFO = 0, A contains the
   --           orthonormal eigenvectors of the matrix A.
   --           If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
   --           or the upper triangle (if UPLO='U') of A, including the
   --           diagonal, is destroyed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (N)
   --           If INFO = 0, the eigenvalues in ascending order.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of the array WORK.  LWORK >= max(1,3*N-1).
   --           For optimal efficiency, LWORK >= (NB+2)*N,
   --           where NB is the blocksize for DSYTRD returned by ILAENV.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, the algorithm failed to converge; i
   --                 off-diagonal elements of an intermediate tridiagonal
   --                 form did not converge to zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANSY
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASCL, DORGTR, DSCAL, DSTEQR, DSTERF, DSYTRD, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      WANTZ  := LSAME (JOBZ, 'V');
      LOWER  := LSAME (UPLO, 'L');
      LQUERY := (LWORK = -1);
      --
      INFO := 0;
      if not (WANTZ or LSAME (JOBZ, 'N')) then
         INFO := -1;
      elsif not (LOWER or LSAME (UPLO, 'U')) then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      --
      if INFO = 0 then
         declare
            str_UPLO : String (1 .. 1);
         begin
            str_UPLO (1) := UPLO;
            NB           := ILAENV (1, "DSYTRD", str_UPLO, N, -1, -1, -1);
         end;
         LWKOPT   := max (1, (NB + 2) * N);
         WORK (1) := Real (LWKOPT);
         --
         if LWORK < max (1, 3 * N - 1) and not LQUERY then
            INFO := -8;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DSYEV ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      if N = 1 then
         W (1)    := A (1, 1);
         WORK (1) := 2.0;
         if WANTZ then
            A (1, 1) := ONE;
         end if;
         return;
      end if;
      --
      --     Get machine constants.
      --
      SAFMIN := DLAMCH ('S');
      EPS    := DLAMCH ('P');
      SMLNUM := SAFMIN / EPS;
      BIGNUM := ONE / SMLNUM;
      RMIN   := Sqrt (SMLNUM);
      RMAX   := Sqrt (BIGNUM);
      --
      --     Scale matrix to allowable range, if necessary.
      --
      ANRM   := DLANSY ('M', UPLO, N, A, LDA, WORK);
      ISCALE := 0;
      if ANRM > ZERO and ANRM < RMIN then
         ISCALE := 1;
         SIGMA  := RMIN / ANRM;
      elsif ANRM > RMAX then
         ISCALE := 1;
         SIGMA  := RMAX / ANRM;
      end if;
      if ISCALE = 1 then
         DLASCL (UPLO, 0, 0, ONE, SIGMA, N, N, A'Address, LDA, INFO);
      end if;
      --
      --     Call DSYTRD to reduce symmetric matrix to tridiagonal form.
      --
      INDE   := 1;
      INDTAU := INDE + N;
      INDWRK := INDTAU + N;
      LLWORK := LWORK - INDWRK + 1;
      DSYTRD
        (UPLO,
         N,
         A'Address,
         LDA,
         W'Address,
         WORK (INDE)'Address,
         WORK (INDTAU)'Address,
         WORK (INDWRK)'Address,
         LLWORK,
         IINFO);
      --
      --     For eigenvalues only, call DSTERF.  For eigenvectors, first call
      --     DORGTR to generate the orthogonal matrix, then call DSTEQR.
      --
      if not WANTZ then
         DSTERF (N, W'Address, WORK (INDE)'Address, INFO);
      else
         DORGTR (UPLO, N, A'Address, LDA, WORK (INDTAU)'Address, WORK (INDWRK)'Address, LLWORK, IINFO);
         DSTEQR (JOBZ, N, W'Address, WORK (INDE)'Address, A'Address, LDA, WORK (INDTAU)'Address, INFO);
      end if;
      --
      --     If matrix was scaled, then rescale eigenvalues appropriately.
      --
      if ISCALE = 1 then
         if INFO = 0 
            then IMAX := N;
            else IMAX := INFO - 1;
         end if;
         DSCAL (IMAX, ONE / SIGMA, W'Address, 1);
      end if;
      --
      --     Set WORK(1) to optimal workspace size.
      --
      WORK (1) := Real (LWKOPT);
      --
      return;
      --
      --     End of DSYEV
      --
   end DSYEV;

   procedure DSYEVD
     (JOBZ   : Character;
      UPLO   : Character;
      N      : Integer;
      A      : in out Ftn_Real_Matrix;
      LDA    : Integer;
      W      : in out Ftn_Real_Vector;
      WORK   : in out Ftn_Real_Vector;
      LWORK  : Integer;
      IWORK  : in out Ftn_Integer_Vector;
      LIWORK : Integer;
      INFO   : in out Integer)
   is
      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      LOWER  : Boolean;
      LQUERY : Boolean;
      WANTZ  : Boolean;
      IINFO  : Integer;
      INDE   : Integer;
      INDTAU : Integer;
      INDWK2 : Integer;
      INDWRK : Integer;
      ISCALE : Integer;
      LIOPT  : Integer;
      LIWMIN : Integer;
      LLWORK : Integer;
      LLWRK2 : Integer;
      LOPT   : Integer;
      LWMIN  : Integer;
      ANRM   : Real;
      BIGNUM : Real;
      EPS    : Real;
      RMAX   : Real;
      RMIN   : Real;
      SAFMIN : Real;
      SIGMA  : Real;
      SMLNUM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, IWORK,
   --                          LIWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBZ, UPLO
   --       INTEGER            INFO, LDA, LIWORK, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYEVD computes all eigenvalues and, optionally, eigenvectors of a
   --  real symmetric matrix A. If eigenvectors are desired, it uses a
   --  divide and conquer algorithm.
   --
   --  The divide and conquer algorithm makes very mild assumptions about
   --  floating point arithmetic. It will work on machines with a guard
   --  digit in add/subtract, or on those binary machines without guard
   --  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
   --  Cray-2. It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.
   --
   --  Because of large use of BLAS of level 3, DSYEVD needs N**2 more
   --  workspace than DSYEVX.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBZ
   --           JOBZ is CHARACTER*1
   --           = 'N':  Compute eigenvalues only;
   --           = 'V':  Compute eigenvalues and eigenvectors.
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA, N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the
   --           leading N-by-N upper triangular part of A contains the
   --           upper triangular part of the matrix A.  If UPLO = 'L',
   --           the leading N-by-N lower triangular part of A contains
   --           the lower triangular part of the matrix A.
   --           On exit, if JOBZ = 'V', then if INFO = 0, A contains the
   --           orthonormal eigenvectors of the matrix A.
   --           If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
   --           or the upper triangle (if UPLO='U') of A, including the
   --           diagonal, is destroyed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (N)
   --           If INFO = 0, the eigenvalues in ascending order.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array,
   --                                          dimension (LWORK)
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If N <= 1,               LWORK must be at least 1.
   --           If JOBZ = 'N' and N > 1, LWORK must be at least 2*N+1.
   --           If JOBZ = 'V' and N > 1, LWORK must be at least
   --                                                 1 + 6*N + 2*N**2.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal sizes of the WORK and IWORK
   --           arrays, returns these values as the first entries of the WORK
   --           and IWORK arrays, and no error message related to LWORK or
   --           LIWORK is issued by XERBLA.
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (MAX(1,LIWORK))
   --           On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
   --
   --  [in] LIWORK
   --           LIWORK is INTEGER
   --           The dimension of the array IWORK.
   --           If N <= 1,                LIWORK must be at least 1.
   --           If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
   --           If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
   --
   --           If LIWORK = -1, then a workspace query is assumed; the
   --           routine only calculates the optimal sizes of the WORK and
   --           IWORK arrays, returns these values as the first entries of
   --           the WORK and IWORK arrays, and no error message related to
   --           LWORK or LIWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
   --                 to converge; i off-diagonal elements of an intermediate
   --                 tridiagonal form did not converge to zero;
   --                 if INFO = i and JOBZ = 'V', then the algorithm failed
   --                 to compute an eigenvalue while working on the submatrix
   --                 lying in rows and columns INFO/(N+1) through
   --                 mod(INFO,N+1).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA \n
   --   Modified by Francoise Tisseur, University of Tennessee \n
   --   Modified description of INFO. Sven, 16 Feb 05. \n
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, DLAMCH, DLANSY, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLACPY, DLASCL, DORMTR, DSCAL, DSTEDC, DSTERF, DSYTRD, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      WANTZ  := LSAME (JOBZ, 'V');
      LOWER  := LSAME (UPLO, 'L');
      LQUERY := (LWORK = -1 or LIWORK = -1);
      --
      INFO := 0;
      if not (WANTZ or LSAME (JOBZ, 'N')) then
         INFO := -1;
      elsif not (LOWER or LSAME (UPLO, 'U')) then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      --
      if INFO = 0 then
         if N <= 1 then
            LIWMIN := 1;
            LWMIN  := 1;
            LOPT   := LWMIN;
            LIOPT  := LIWMIN;
         else
            if WANTZ then
               LIWMIN := 3 + 5 * N;
               LWMIN  := 1 + 6 * N + 2 * N ** 2;
            else
               LIWMIN := 1;
               LWMIN  := 2 * N + 1;
            end if;
            declare
               str_UPLO : String (1 .. 1);
            begin
               str_UPLO (1) := UPLO;
               LOPT         := max (LWMIN, 2 * N + ILAENV (1, "DSYTRD", str_UPLO, N, -1, -1, -1));
            end;
            LIOPT := LIWMIN;
         end if;
         WORK (1)  := Real (LOPT);
         IWORK (1) := LIOPT;
         --
         if LWORK < LWMIN and not LQUERY then
            INFO := -8;
         elsif LIWORK < LIWMIN and not LQUERY then
            INFO := -10;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DSYEVD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      if N = 1 then
         W (1) := A (1, 1);
         if WANTZ then
            A (1, 1) := ONE;
         end if;
         return;
      end if;
      --
      --     Get machine constants.
      --
      SAFMIN := DLAMCH ('S');
      EPS    := DLAMCH ('P');
      SMLNUM := SAFMIN / EPS;
      BIGNUM := ONE / SMLNUM;
      RMIN   := Sqrt (SMLNUM);
      RMAX   := Sqrt (BIGNUM);
      --
      --     Scale matrix to allowable range, if necessary.
      --
      ANRM   := DLANSY ('M', UPLO, N, A, LDA, WORK);
      ISCALE := 0;
      if ANRM > ZERO and ANRM < RMIN then
         ISCALE := 1;
         SIGMA  := RMIN / ANRM;
      elsif ANRM > RMAX then
         ISCALE := 1;
         SIGMA  := RMAX / ANRM;
      end if;
      if ISCALE = 1 then
         DLASCL (UPLO, 0, 0, ONE, SIGMA, N, N, A'Address, LDA, INFO);
      end if;
      --
      --     Call DSYTRD to reduce symmetric matrix to tridiagonal form.
      --
      INDE   := 1;
      INDTAU := INDE + N;
      INDWRK := INDTAU + N;
      LLWORK := LWORK - INDWRK + 1;
      INDWK2 := INDWRK + N * N;
      LLWRK2 := LWORK - INDWK2 + 1;
      --
      DSYTRD
        (UPLO,
         N,
         A'Address,
         LDA,
         W'Address,
         WORK (INDE)'Address,
         WORK (INDTAU)'Address,
         WORK (INDWRK)'Address,
         LLWORK,
         IINFO);
      LOPT := 2 * N + Integer (WORK (INDWRK));
      --
      --     For eigenvalues only, call DSTERF.  For eigenvectors, first call
      --     DSTEDC to generate the eigenvector matrix, WORK(INDWRK), of the
      --     tridiagonal matrix, then call DORMTR to multiply it by the
      --     Householder transformations stored in A.
      --
      if not WANTZ then
         DSTERF (N, W'Address, WORK (INDE)'Address, INFO);
      else
         DSTEDC
           ('I',
            N,
            W'Address,
            WORK (INDE)'Address,
            WORK (INDWRK)'Address,
            N,
            WORK (INDWK2)'Address,
            LLWRK2,
            IWORK'Address,
            LIWORK,
            INFO);
         DORMTR
           ('L',
            UPLO,
            'N',
            N,
            N,
            A'Address,
            LDA,
            WORK (INDTAU)'Address,
            WORK (INDWRK)'Address,
            N,
            WORK (INDWK2)'Address,
            LLWRK2,
            IINFO);
         DLACPY ('A', N, N, WORK (INDWRK)'Address, N, A'Address, LDA);
         LOPT := max (LOPT, 1 + 6 * N + 2 * N ** 2);
      end if;
      --
      --     If matrix was scaled, then rescale eigenvalues appropriately.
      --
      if ISCALE = 1 then
         DSCAL (N, ONE / SIGMA, W'Address, 1);
      end if;
      --
      WORK (1)  := Real (LOPT);
      IWORK (1) := LIOPT;
      --
      return;
      --
      --     End of DSYEVD
      --
   end DSYEVD;

   procedure DSYSV
     (UPLO  : Character;
      N     : Integer;
      NRHS  : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      IPIV  : out Ftn_Integer_Vector;
      B     : in out Ftn_Real_Matrix;
      LDB   : Integer;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      LQUERY : Boolean;
      LWKOPT : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,
   --                         LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LDB, LWORK, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYSV computes the solution to a real system of linear equations
   --     A * X = B,
   --  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
   --  matrices.
   --
   --  The diagonal pivoting method is used to factor A as
   --     A = U * D * U**T,  if UPLO = 'U', or
   --     A = L * D * L**T,  if UPLO = 'L',
   --  where U (or L) is a product of permutation and unit upper (lower)
   --  triangular matrices, and D is symmetric and block diagonal with
   --  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
   --  used to solve the system of equations A * X = B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of linear equations, i.e., the order of the
   --           matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           N-by-N upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading N-by-N lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --
   --           On exit, if INFO = 0, the block diagonal matrix D and the
   --           multipliers used to obtain the factor U or L from the
   --           factorization A = U*D*U**T or A = L*D*L**T as computed by
   --           DSYTRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D, as
   --           determined by DSYTRF.  If IPIV(k) > 0, then rows and columns
   --           k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
   --           diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
   --           then rows and columns k-1 and -IPIV(k) were interchanged and
   --           D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
   --           IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
   --           -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
   --           diagonal block.
   --
   --  [in,out] B
   --           B is DOUBLE PRECISION array, dimension (LDB,NRHS)
   --           On entry, the N-by-NRHS right hand side matrix B.
   --           On exit, if INFO = 0, the N-by-NRHS solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of WORK.  LWORK >= 1, and for best performance
   --           LWORK >= max(1,N*NB), where NB is the optimal blocksize for
   --           DSYTRF.
   --           for LWORK < N, TRS will be done with Level BLAS 2
   --           for LWORK >= N, TRS will be done with Level BLAS 3
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --           > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
   --                has been completed, but the block diagonal matrix D is
   --                exactly singular, so the solution could not be computed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, DSYTRF, DSYTRS, DSYTRS2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1);
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NRHS < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDB < max (1, N) then
         INFO := -8;
      elsif LWORK < 1 and not LQUERY then
         INFO := -10;
      end if;
      --
      if INFO = 0 then
         if N = 0 then
            LWKOPT := 1;
         else
            DSYTRF (UPLO, N, A, LDA, IPIV, WORK, -1, INFO);
            LWKOPT := Integer (WORK (1));
         end if;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DSYSV ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Compute the factorization A = U*D*U**T or A = L*D*L**T.
      --
      DSYTRF (UPLO, N, A, LDA, IPIV, WORK, LWORK, INFO);
      if INFO = 0 then
         --
         --        Solve the system A*X = B, overwriting B with X.
         --
         if LWORK < N then
            --
            --        Solve with TRS ( Use Level BLAS 2)
            --
            DSYTRS (UPLO, N, NRHS, A, LDA, IPIV, B, LDB, INFO);
         --
         else
            --
            --        Solve with TRS2 ( Use Level BLAS 3)
            --
            DSYTRS2 (UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK, INFO);
            --
         end if;
         --
      end if;
      --
      WORK (1) := Real (LWKOPT);
      --
      return;
      --
      --     End of DSYSV
      --
   end DSYSV;

   procedure DSYTD2
     (UPLO    : Character;
      N       : Integer;
      A_adr   : Address;
      LDA     : Integer;
      D_adr   : Address;
      E_adr   : Address;
      TAU_adr : Address;
      INFO    : in out Integer)
   is

      A   : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      D   : Ftn_Real_Vector (1 .. N);
      E   : Ftn_Real_Vector (1 .. N - 1);
      TAU : Ftn_Real_Vector (1 .. N - 1);

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAU'Address use TAU_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAU);

      ONE   : constant Real := 1.0e0;
      ZERO  : constant Real := 0.0e0;
      HALF  : constant Real := 0.5e0;
      UPPER : Boolean;
      I     : Integer;
      ALPHA : Real;
      TAUI  : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYTD2( UPLO, N, A, LDA, D, E, TAU, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAU( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
   --  form T by an orthogonal similarity transformation: Q**T * A * Q = T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the upper or lower triangular part of the
   --           symmetric matrix A is stored:
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           n-by-n upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n-by-n lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --           On exit, if UPLO = 'U', the diagonal and first superdiagonal
   --           of A are overwritten by the corresponding elements of the
   --           tridiagonal matrix T, and the elements above the first
   --           superdiagonal, with the array TAU, represent the orthogonal
   --           matrix Q as a product of elementary reflectors; if UPLO
   --           = 'L', the diagonal and first subdiagonal of A are over-
   --           written by the corresponding elements of the tridiagonal
   --           matrix T, and the elements below the first subdiagonal, with
   --           the array TAU, represent the orthogonal matrix Q as a product
   --           of elementary reflectors. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           The diagonal elements of the tridiagonal matrix T:
   --           D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           The off-diagonal elements of the tridiagonal matrix T:
   --           E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (N-1)
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(n-1) . . . H(2) H(1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
   --   A(1:i-1,i+1), and tau in TAU(i).
   --
   --   If UPLO = 'L', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(1) H(2) . . . H(n-1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
   --   and tau in TAU(i).
   --
   --   The contents of A on exit are illustrated by the following examples
   --   with n = 5:
   --
   --   if UPLO = 'U':                       if UPLO = 'L':
   --
   --     (  d   e   v2  v3  v4 )              (  d                  )
   --     (      d   e   v3  v4 )              (  e   d              )
   --     (          d   e   v4 )              (  v1  e   d          )
   --     (              d   e  )              (  v1  v2  e   d      )
   --     (                  d  )              (  v1  v2  v3  e   d  )
   --
   --   where d and e denote diagonal and off-diagonal elements of T, and vi
   --   denotes an element of the vector defining H(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D0, ZERO = 0.0D0, HALF = 1.0D0 / 2.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DAXPY, DLARFG, DSYMV, DSYR2, XERBLA
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, DDOT
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO  := 0;
      UPPER := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYTD2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         return;
      end if;
      --
      if UPPER then
         --
         --        Reduce the upper triangle of A
         --
         I := N - 1 + 1;
         loop
            I := I - 1;
            exit when I < 1;
            --
            --           Generate elementary reflector H(i) = I - tau * v * v**T
            --           to annihilate A(1:i-1,i+1)
            --
            DLARFG (I, A (I, I + 1), A (1, I + 1)'Address, 1, TAUI);
            E (I) := A (I, I + 1);
            --
            if TAUI /= ZERO then
               --
               --              Apply H(i) from both sides to A(1:i,1:i)
               --
               A (I, I + 1) := ONE;
               --
               --              Compute  x := tau * A * v  storing x in TAU(1:i)
               --
               DSYMV (UPLO, I, TAUI, A'Address, LDA, A (1, I + 1)'Address, 1, ZERO, TAU'Address, 1);
               --
               --              Compute  w := x - 1/2 * tau * (x**T * v) * v
               --
               ALPHA := -HALF * TAUI * DDOT (I, TAU'Address, 1, A (1, I + 1)'Address, 1);
               DAXPY (I, ALPHA, A (1, I + 1)'Address, 1, TAU'Address, 1);
               --
               --              Apply the transformation as a rank-2 update:
               --                 A := A - v * w**T - w * v**T
               --
               DSYR2 (UPLO, I, -ONE, A (1, I + 1)'Address, 1, TAU'Address, 1, A'Address, LDA);
               --
               A (I, I + 1) := E (I);
            end if;
            D (I + 1) := A (I + 1, I + 1);
            TAU (I)   := TAUI;
         end loop;
         D (1) := A (1, 1);
      else
         --
         --        Reduce the lower triangle of A
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            --
            --           Generate elementary reflector H(i) = I - tau * v * v**T
            --           to annihilate A(i+2:n,i)
            --
            DLARFG (N - I, A (I + 1, I), A (min (I + 2, N), I)'Address, 1, TAUI);
            E (I) := A (I + 1, I);
            --
            if TAUI /= ZERO then
               --
               --              Apply H(i) from both sides to A(i+1:n,i+1:n)
               --
               A (I + 1, I) := ONE;
               --
               --              Compute  x := tau * A * v  storing y in TAU(i:n-1)
               --
               DSYMV (UPLO, N - I, TAUI, A (I + 1, I + 1)'Address, LDA, A (I + 1, I)'Address, 1, ZERO, TAU (I)'Address, 1);
               --
               --              Compute  w := x - 1/2 * tau * (x**T * v) * v
               --
               ALPHA := -HALF * TAUI * DDOT (N - I, TAU (I)'Address, 1, A (I + 1, I)'Address, 1);
               DAXPY (N - I, ALPHA, A (I + 1, I)'Address, 1, TAU (I)'Address, 1);
               --
               --              Apply the transformation as a rank-2 update:
               --                 A := A - v * w**T - w * v**T
               --
               DSYR2 (UPLO, N - I, -ONE, A (I + 1, I)'Address, 1, TAU (I)'Address, 1, A (I + 1, I + 1)'Address, LDA);
               --
               A (I + 1, I) := E (I);
            end if;
            D (I)   := A (I, I);
            TAU (I) := TAUI;
         end loop;
         D (N) := A (N, N);
      end if;
      --
      return;
      --
      --     End of DSYTD2
      --
   end DSYTD2;

   procedure DSYTF2
     (UPLO     : Character;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      IPIV_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      IPIV : Ftn_Integer_Vector (1 .. N);

      for A'Address use A_adr;
      for IPIV'Address use IPIV_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, IPIV);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      EIGHT  : constant Real := 8.0e0;
      SEVTEN : constant Real := 17.0e0;
      UPPER  : Boolean;
      I      : Integer;
      IMAX   : Integer;
      J      : Integer;
      JMAX   : Integer;
      K      : Integer;
      KK     : Integer;
      KP     : Integer;
      KSTEP  : Integer;
      ABSAKK : Real;
      ALPHA  : Real;
      COLMAX : Real;
      D11    : Real;
      D12    : Real;
      D21    : Real;
      D22    : Real;
      R1     : Real;
      ROWMAX : Real;
      T      : Real;
      WK     : Real;
      WKM1   : Real;
      WKP1   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYTF2( UPLO, N, A, LDA, IPIV, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYTF2 computes the factorization of a real symmetric matrix A using
   --  the Bunch-Kaufman diagonal pivoting method:
   --
   --     A = U*D*U**T  or  A = L*D*L**T
   --
   --  where U (or L) is a product of permutation and unit upper (lower)
   --  triangular matrices, U**T is the transpose of U, and D is symmetric and
   --  block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
   --
   --  This is the unblocked version of the algorithm, calling Level 2 BLAS.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the upper or lower triangular part of the
   --           symmetric matrix A is stored:
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           n-by-n upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n-by-n lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --
   --           On exit, the block diagonal matrix D and the multipliers used
   --           to obtain the factor U or L (see below for further details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D.
   --           If IPIV(k) > 0, then rows and columns k and IPIV(k) were
   --           interchanged and D(k,k) is a 1-by-1 diagonal block.
   --           If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
   --           columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
   --           is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
   --           IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
   --           interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -k, the k-th argument had an illegal value
   --           > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
   --                has been completed, but the block diagonal matrix D is
   --                exactly singular, and division by zero will occur if it
   --                is used to solve a system of equations.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', then A = U*D*U**T, where
   --      U = P(n)*U(n)* ... *P(k)U(k)* ...,
   --   i.e., U is a product of terms P(k)*U(k), where k decreases from n to
   --   1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
   --   and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
   --   defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
   --   that if the diagonal block D(k) is of order s (s = 1 or 2), then
   --
   --              (   I    v    0   )   k-s
   --      U(k) =  (   0    I    0   )   s
   --              (   0    0    I   )   n-k
   --                 k-s   s   n-k
   --
   --   If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
   --   If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
   --   and A(k,k), and v overwrites A(1:k-2,k-1:k).
   --
   --   If UPLO = 'L', then A = L*D*L**T, where
   --      L = P(1)*L(1)* ... *P(k)*L(k)* ...,
   --   i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
   --   n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
   --   and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
   --   defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
   --   that if the diagonal block D(k) is of order s (s = 1 or 2), then
   --
   --              (   I    0     0   )  k-1
   --      L(k) =  (   0    I     0   )  s
   --              (   0    v     I   )  n-k-s+1
   --                 k-1   s  n-k-s+1
   --
   --   If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
   --   If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
   --   and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
   --
   --  Contributors:
   --  ==================
   --
   --
   --   09-29-06 - patch from
   --     Bobby Cheng, MathWorks
   --
   --     Replace l.204 and l.372
   --          IF( MAX( ABSAKK, COLMAX ).EQ.ZERO ) THEN
   --     by
   --          IF( (MAX( ABSAKK, COLMAX ).EQ.ZERO) .OR. DISNAN(ABSAKK) ) THEN
   --
   --   01-01-96 - Based on modifications by
   --     J. Lewis, Boeing Computer Services Company
   --     A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
   --   1-96 - Based on modifications by J. Lewis, Boeing Computer Services
   --          Company
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( EIGHT = 8.0D+0, SEVTEN = 17.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, IDAMAX, DISNAN
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DSCAL, DSWAP, DSYR, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO  := 0;
      UPPER := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYTF2", -INFO);
         return;
      end if;
      --
      --     Initialize ALPHA for use in choosing pivot block size.
      --
      ALPHA := (ONE + Sqrt (SEVTEN)) / EIGHT;
      --
      if UPPER then
         --
         --        Factorize A as U*D*U**T using the upper triangle of A
         --
         --        K is the main loop index, decreasing from N to 1 in steps of
         --        1 or 2
         --
         K := N;
         <<L10>> null;
         --
         --        If K < 1, exit from loop
         --
         if K < 1 then
            goto L70;
         end if;
         KSTEP := 1;
         --
         --        Determine rows and columns to be interchanged and whether
         --        a 1-by-1 or 2-by-2 pivot block will be used
         --
         ABSAKK := abs (A (K, K));
         --
         --        IMAX is the row-index of the largest off-diagonal element in
         --        column K, and COLMAX is its absolute value
         --
         if K > 1 then
            IMAX   := IDAMAX (K - 1, A (1, K)'Address, 1);
            COLMAX := abs (A (IMAX, K));
         else
            COLMAX := ZERO;
         end if;
         --
         if (max (ABSAKK, COLMAX) = ZERO) or DISNAN (ABSAKK) then
            --
            --           Column K is zero or contains a NaN: set INFO and continue
            --
            if INFO = 0 then
               INFO := K;
            end if;
            KP := K;
         else
            if ABSAKK >= ALPHA * COLMAX then
               --
               --              no interchange, use 1-by-1 pivot block
               --
               KP := K;
            else
               --
               --              JMAX is the column-index of the largest off-diagonal
               --              element in row IMAX, and ROWMAX is its absolute value
               --
               JMAX   := IMAX + IDAMAX (K - IMAX, A (IMAX, IMAX + 1)'Address, LDA);
               ROWMAX := abs (A (IMAX, JMAX));
               if IMAX > 1 then
                  JMAX   := IDAMAX (IMAX - 1, A (1, IMAX)'Address, 1);
                  ROWMAX := max (ROWMAX, abs (A (JMAX, IMAX)));
               end if;
               --
               if ABSAKK >= ALPHA * COLMAX * (COLMAX / ROWMAX) then
                  --
                  --                 no interchange, use 1-by-1 pivot block
                  --
                  KP := K;
               elsif abs (A (IMAX, IMAX)) >= ALPHA * ROWMAX then
                  --
                  --                 interchange rows and columns K and IMAX, use 1-by-1
                  --                 pivot block
                  --
                  KP := IMAX;
               else
                  --
                  --                 interchange rows and columns K-1 and IMAX, use 2-by-2
                  --                 pivot block
                  --
                  KP    := IMAX;
                  KSTEP := 2;
               end if;
            end if;
            --
            KK := K - KSTEP + 1;
            if KP /= KK then
               --
               --              Interchange rows and columns KK and KP in the leading
               --              submatrix A(1:k,1:k)
               --
               DSWAP (KP - 1, A (1, KK)'Address, 1, A (1, KP)'Address, 1);
               DSWAP (KK - KP - 1, A (KP + 1, KK)'Address, 1, A (KP, KP + 1)'Address, LDA);
               T          := A (KK, KK);
               A (KK, KK) := A (KP, KP);
               A (KP, KP) := T;
               if KSTEP = 2 then
                  T            := A (K - 1, K);
                  A (K - 1, K) := A (KP, K);
                  A (KP, K)    := T;
               end if;
            end if;
            --
            --           Update the leading submatrix
            --
            if KSTEP = 1 then
               --
               --              1-by-1 pivot block D(k): column k now holds
               --
               --              W(k) = U(k)*D(k)
               --
               --              where U(k) is the k-th column of U
               --
               --              Perform a rank-1 update of A(1:k-1,1:k-1) as
               --
               --              A := A - U(k)*D(k)*U(k)**T = A - W(k)*1/D(k)*W(k)**T
               --
               R1 := ONE / A (K, K);
               DSYR (UPLO, K - 1, -R1, A (1, K)'Address, 1, A'Address, LDA);
               --
               --              Store U(k) in column k
               --
               DSCAL (K - 1, R1, A (1, K)'Address, 1);
            else
               --
               --              2-by-2 pivot block D(k): columns k and k-1 now hold
               --
               --              ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k)
               --
               --              where U(k) and U(k-1) are the k-th and (k-1)-th columns
               --              of U
               --
               --              Perform a rank-2 update of A(1:k-2,1:k-2) as
               --
               --              A := A - ( U(k-1) U(k) )*D(k)*( U(k-1) U(k) )**T
               --                 = A - ( W(k-1) W(k) )*inv(D(k))*( W(k-1) W(k) )**T
               --
               if K > 2 then
                  --
                  D12 := A (K - 1, K);
                  D22 := A (K - 1, K - 1) / D12;
                  D11 := A (K, K) / D12;
                  T   := ONE / (D11 * D22 - ONE);
                  D12 := T / D12;
                  --
                  J := K - 2 + 1;
                  loop
                     J := J - 1;
                     exit when J < 1;
                     WKM1 := D12 * (D11 * A (J, K - 1) - A (J, K));
                     WK   := D12 * (D22 * A (J, K) - A (J, K - 1));
                     I    := J + 1;
                     loop
                        I := I - 1;
                        exit when I < 1;
                        A (I, J) := A (I, J) - A (I, K) * WK - A (I, K - 1) * WKM1;
                     end loop;
                     A (J, K)     := WK;
                     A (J, K - 1) := WKM1;
                  end loop;
                  --
               end if;
               --
            end if;
         end if;
         --
         --        Store details of the interchanges in IPIV
         --
         if KSTEP = 1 then
            IPIV (K) := KP;
         else
            IPIV (K)     := -KP;
            IPIV (K - 1) := -KP;
         end if;
         --
         --        Decrease K and return to the start of the main loop
         --
         K := K - KSTEP;
         goto L10;
      --
      else
         --
         --        Factorize A as L*D*L**T using the lower triangle of A
         --
         --        K is the main loop index, increasing from 1 to N in steps of
         --        1 or 2
         --
         K := 1;
         <<L40>> null;
         --
         --        If K > N, exit from loop
         --
         if K > N then
            goto L70;
         end if;
         KSTEP := 1;
         --
         --        Determine rows and columns to be interchanged and whether
         --        a 1-by-1 or 2-by-2 pivot block will be used
         --
         ABSAKK := abs (A (K, K));
         --
         --        IMAX is the row-index of the largest off-diagonal element in
         --        column K, and COLMAX is its absolute value
         --
         if K < N then
            IMAX   := K + IDAMAX (N - K, A (K + 1, K)'Address, 1);
            COLMAX := abs (A (IMAX, K));
         else
            COLMAX := ZERO;
         end if;
         --
         if (max (ABSAKK, COLMAX) = ZERO) or DISNAN (ABSAKK) then
            --
            --           Column K is zero or contains a NaN: set INFO and continue
            --
            if INFO = 0 then
               INFO := K;
            end if;
            KP := K;
         else
            if ABSAKK >= ALPHA * COLMAX then
               --
               --              no interchange, use 1-by-1 pivot block
               --
               KP := K;
            else
               --
               --              JMAX is the column-index of the largest off-diagonal
               --              element in row IMAX, and ROWMAX is its absolute value
               --
               JMAX   := K - 1 + IDAMAX (IMAX - K, A (IMAX, K)'Address, LDA);
               ROWMAX := abs (A (IMAX, JMAX));
               if IMAX < N then
                  JMAX   := IMAX + IDAMAX (N - IMAX, A (IMAX + 1, IMAX)'Address, 1);
                  ROWMAX := max (ROWMAX, abs (A (JMAX, IMAX)));
               end if;
               --
               if ABSAKK >= ALPHA * COLMAX * (COLMAX / ROWMAX) then
                  --
                  --                 no interchange, use 1-by-1 pivot block
                  --
                  KP := K;
               elsif abs (A (IMAX, IMAX)) >= ALPHA * ROWMAX then
                  --
                  --                 interchange rows and columns K and IMAX, use 1-by-1
                  --                 pivot block
                  --
                  KP := IMAX;
               else
                  --
                  --                 interchange rows and columns K+1 and IMAX, use 2-by-2
                  --                 pivot block
                  --
                  KP    := IMAX;
                  KSTEP := 2;
               end if;
            end if;
            --
            KK := K + KSTEP - 1;
            if KP /= KK then
               --
               --              Interchange rows and columns KK and KP in the trailing
               --              submatrix A(k:n,k:n)
               --
               if KP < N then
                  DSWAP (N - KP, A (KP + 1, KK)'Address, 1, A (KP + 1, KP)'Address, 1);
               end if;
               DSWAP (KP - KK - 1, A (KK + 1, KK)'Address, 1, A (KP, KK + 1)'Address, LDA);
               T          := A (KK, KK);
               A (KK, KK) := A (KP, KP);
               A (KP, KP) := T;
               if KSTEP = 2 then
                  T            := A (K + 1, K);
                  A (K + 1, K) := A (KP, K);
                  A (KP, K)    := T;
               end if;
            end if;
            --
            --           Update the trailing submatrix
            --
            if KSTEP = 1 then
               --
               --              1-by-1 pivot block D(k): column k now holds
               --
               --              W(k) = L(k)*D(k)
               --
               --              where L(k) is the k-th column of L
               --
               if K < N then
                  --
                  --                 Perform a rank-1 update of A(k+1:n,k+1:n) as
                  --
                  --                 A := A - L(k)*D(k)*L(k)**T = A - W(k)*(1/D(k))*W(k)**T
                  --
                  D11 := ONE / A (K, K);
                  DSYR (UPLO, N - K, -D11, A (K + 1, K)'Address, 1, A (K + 1, K + 1)'Address, LDA);
                  --
                  --                 Store L(k) in column K
                  --
                  DSCAL (N - K, D11, A (K + 1, K)'Address, 1);
               end if;
            else
               --
               --              2-by-2 pivot block D(k)
               --
               if K < N - 1 then
                  --
                  --                 Perform a rank-2 update of A(k+2:n,k+2:n) as
                  --
                  --                 A := A - ( (A(k) A(k+1))*D(k)**(-1) ) * (A(k) A(k+1))**T
                  --
                  --                 where L(k) and L(k+1) are the k-th and (k+1)-th
                  --                 columns of L
                  --
                  D21 := A (K + 1, K);
                  D11 := A (K + 1, K + 1) / D21;
                  D22 := A (K, K) / D21;
                  T   := ONE / (D11 * D22 - ONE);
                  D21 := T / D21;
                  --
                  J := K + 2 - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     --
                     WK   := D21 * (D11 * A (J, K) - A (J, K + 1));
                     WKP1 := D21 * (D22 * A (J, K + 1) - A (J, K));
                     --
                     I := J - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        A (I, J) := A (I, J) - A (I, K) * WK - A (I, K + 1) * WKP1;
                     end loop;
                     --
                     A (J, K)     := WK;
                     A (J, K + 1) := WKP1;
                     --
                  end loop;
               end if;
            end if;
         end if;
         --
         --        Store details of the interchanges in IPIV
         --
         if KSTEP = 1 then
            IPIV (K) := KP;
         else
            IPIV (K)     := -KP;
            IPIV (K + 1) := -KP;
         end if;
         --
         --        Increase K and return to the start of the main loop
         --
         K := K + KSTEP;
         goto L40;
         --
      end if;
      --
      <<L70>> null;
      --
      return;
      --
      --     End of DSYTF2
      --
   end DSYTF2;

   procedure DSYTRD
     (UPLO     : Character;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      D    : Ftn_Real_Vector (1 .. N);
      E    : Ftn_Real_Vector (1 .. N - 1);
      TAU  : Ftn_Real_Vector (1 .. N - 1);
      WORK : Ftn_Real_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE    : constant Real := 1.0e0;
      LQUERY : Boolean;
      UPPER  : Boolean;
      I      : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      KK     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYTRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), D( * ), E( * ), TAU( * ),
   --      $                   WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYTRD reduces a real symmetric matrix A to real symmetric
   --  tridiagonal form T by an orthogonal similarity transformation:
   --  Q**T * A * Q = T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           N-by-N upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading N-by-N lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --           On exit, if UPLO = 'U', the diagonal and first superdiagonal
   --           of A are overwritten by the corresponding elements of the
   --           tridiagonal matrix T, and the elements above the first
   --           superdiagonal, with the array TAU, represent the orthogonal
   --           matrix Q as a product of elementary reflectors; if UPLO
   --           = 'L', the diagonal and first subdiagonal of A are over-
   --           written by the corresponding elements of the tridiagonal
   --           matrix T, and the elements below the first subdiagonal, with
   --           the array TAU, represent the orthogonal matrix Q as a product
   --           of elementary reflectors. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           The diagonal elements of the tridiagonal matrix T:
   --           D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           The off-diagonal elements of the tridiagonal matrix T:
   --           E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
   --
   --  [out] TAU
   --           TAU is DOUBLE PRECISION array, dimension (N-1)
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= 1.
   --           For optimum performance LWORK >= N*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(n-1) . . . H(2) H(1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
   --   A(1:i-1,i+1), and tau in TAU(i).
   --
   --   If UPLO = 'L', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(1) H(2) . . . H(n-1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**T
   --
   --   where tau is a real scalar, and v is a real vector with
   --   v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
   --   and tau in TAU(i).
   --
   --   The contents of A on exit are illustrated by the following examples
   --   with n = 5:
   --
   --   if UPLO = 'U':                       if UPLO = 'L':
   --
   --     (  d   e   v2  v3  v4 )              (  d                  )
   --     (      d   e   v3  v4 )              (  e   d              )
   --     (          d   e   v4 )              (  v1  e   d          )
   --     (              d   e  )              (  v1  v2  e   d      )
   --     (                  d  )              (  v1  v2  v3  e   d  )
   --
   --   where d and e denote diagonal and off-diagonal elements of T, and vi
   --   denotes an element of the vector defining H(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLATRD, DSYR2K, DSYTD2, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      LQUERY := (LWORK = -1);
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      elsif LWORK < 1 and not LQUERY then
         INFO := -9;
      end if;
      --
      if INFO = 0 then
         --
         --        Determine the block size.
         --
         declare
            str_UPLO : String (1 .. 1);
         begin
            str_UPLO (1) := UPLO;
            NB           := ILAENV (1, "DSYTRD", str_UPLO, N, -1, -1, -1);
         end;
         LWKOPT   := N * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DSYTRD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         WORK (1) := 1.0;
         return;
      end if;
      --
      NX  := N;
      IWS := 1;
      if NB > 1 and NB < N then
         --
         --        Determine when to cross over from blocked to unblocked code
         --        (last block is always handled by unblocked code).
         --
         declare
            str_UPLO : String (1 .. 1);
         begin
            str_UPLO (1) := UPLO;
            NX           := max (NB, ILAENV (3, "DSYTRD", str_UPLO, N, -1, -1, -1));
         end;
         if NX < N then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := N;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  determine the
               --              minimum value of NB, and reduce NB or force use of
               --              unblocked code by setting NX = N.
               --
               NB := max (LWORK / LDWORK, 1);
               declare
                  str_UPLO : String (1 .. 1);
               begin
                  str_UPLO (1) := UPLO;
                  NBMIN        := ILAENV (2, "DSYTRD", str_UPLO, N, -1, -1, -1);
               end;
               if NB < NBMIN then
                  NX := N;
               end if;
            end if;
         else
            NX := N;
         end if;
      else
         NB := 1;
      end if;
      --
      if UPPER then
         --
         --        Reduce the upper triangle of A.
         --        Columns 1:kk are handled by the unblocked method.
         --
         KK := N - ((N - NX + NB - 1) / NB) * NB;
         I  := N - NB + 1 + NB;
         loop
            I := I - NB;
            exit when I < KK + 1;
            --
            --           Reduce columns i:i+nb-1 to tridiagonal form and form the
            --           matrix W which is needed to update the unreduced part of
            --           the matrix
            --
            DLATRD (UPLO, I + NB - 1, NB, A'Address, LDA, E'Address, TAU'Address, WORK'Address, LDWORK);
            --
            --           Update the unreduced submatrix A(1:i-1,1:i-1), using an
            --           update of the form:  A := A - V*W**T - W*V**T
            --
            DSYR2K (UPLO, 'N', I - 1, NB, -ONE, A (1, I)'Address, LDA, WORK'Address, LDWORK, ONE, A'Address, LDA);
            --
            --           Copy superdiagonal elements back into A, and diagonal
            --           elements into D
            --
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + NB - 1;
               A (J - 1, J) := E (J - 1);
               D (J)        := A (J, J);
            end loop;
         end loop;
         --
         --        Use unblocked code to reduce the last or only block
         --
         DSYTD2 (UPLO, KK, A'Address, LDA, D'Address, E'Address, TAU'Address, IINFO);
      else
         --
         --        Reduce the lower triangle of A
         --
         I := 1 - NB;
         loop
            I := I + NB;
            exit when I > N - NX;
            --
            --           Reduce columns i:i+nb-1 to tridiagonal form and form the
            --           matrix W which is needed to update the unreduced part of
            --           the matrix
            --
            DLATRD (UPLO, N - I + 1, NB, A (I, I)'Address, LDA, E (I)'Address, TAU (I)'Address, WORK'Address, LDWORK);
            --
            --           Update the unreduced submatrix A(i+ib:n,i+ib:n), using
            --           an update of the form:  A := A - V*W**T - W*V**T
            --
            DSYR2K
              (UPLO,
               'N',
               N - I - NB + 1,
               NB,
               -ONE,
               A (I + NB, I)'Address,
               LDA,
               WORK (NB + 1)'Address,
               LDWORK,
               ONE,
               A (I + NB, I + NB)'Address,
               LDA);
            --
            --           Copy subdiagonal elements back into A, and diagonal
            --           elements into D
            --
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + NB - 1;
               A (J + 1, J) := E (J);
               D (J)        := A (J, J);
            end loop;
         end loop;
         --
         --        Use unblocked code to reduce the last or only block
         --
         DSYTD2 (UPLO, N - I + 1, A (I, I)'Address, LDA, D (I)'Address, E (I)'Address, TAU (I)'Address, IINFO);
      end if;
      --
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DSYTRD
      --
   end DSYTRD;

   procedure DSYTRF
     (UPLO  : Character;
      N     : Integer;
      A     : in out Ftn_Real_Matrix;
      LDA   : Integer;
      IPIV  : in out Ftn_Integer_Vector;
      WORK  : in out Ftn_Real_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      LQUERY : Boolean;
      UPPER  : Boolean;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      K      : Integer;
      KB     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYTRF( UPLO, N, A, LDA, IPIV, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYTRF computes the factorization of a real symmetric matrix A using
   --  the Bunch-Kaufman diagonal pivoting method.  The form of the
   --  factorization is
   --
   --     A = U*D*U**T  or  A = L*D*L**T
   --
   --  where U (or L) is a product of permutation and unit upper (lower)
   --  triangular matrices, and D is symmetric and block diagonal with
   --  1-by-1 and 2-by-2 diagonal blocks.
   --
   --  This is the blocked version of the algorithm, calling Level 3 BLAS.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           N-by-N upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading N-by-N lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --
   --           On exit, the block diagonal matrix D and the multipliers used
   --           to obtain the factor U or L (see below for further details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D.
   --           If IPIV(k) > 0, then rows and columns k and IPIV(k) were
   --           interchanged and D(k,k) is a 1-by-1 diagonal block.
   --           If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
   --           columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
   --           is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
   --           IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
   --           interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of WORK.  LWORK >=1.  For best performance
   --           LWORK >= N*NB, where NB is the block size returned by ILAENV.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
   --                 has been completed, but the block diagonal matrix D is
   --                 exactly singular, and division by zero will occur if it
   --                 is used to solve a system of equations.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', then A = U*D*U**T, where
   --      U = P(n)*U(n)* ... *P(k)U(k)* ...,
   --   i.e., U is a product of terms P(k)*U(k), where k decreases from n to
   --   1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
   --   and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
   --   defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
   --   that if the diagonal block D(k) is of order s (s = 1 or 2), then
   --
   --              (   I    v    0   )   k-s
   --      U(k) =  (   0    I    0   )   s
   --              (   0    0    I   )   n-k
   --                 k-s   s   n-k
   --
   --   If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
   --   If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
   --   and A(k,k), and v overwrites A(1:k-2,k-1:k).
   --
   --   If UPLO = 'L', then A = L*D*L**T, where
   --      L = P(1)*L(1)* ... *P(k)*L(k)* ...,
   --   i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
   --   n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
   --   and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
   --   defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
   --   that if the diagonal block D(k) is of order s (s = 1 or 2), then
   --
   --              (   I    0     0   )  k-1
   --      L(k) =  (   0    I     0   )  s
   --              (   0    v     I   )  n-k-s+1
   --                 k-1   s  n-k-s+1
   --
   --   If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
   --   If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
   --   and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASYF, DSYTF2, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      LQUERY := (LWORK = -1);
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      elsif LWORK < 1 and not LQUERY then
         INFO := -7;
      end if;
      --
      if INFO = 0 then
         --
         --        Determine the block size
         --
         declare
            str_UPLO : String (1 .. 1);
         begin
            str_UPLO (1) := UPLO;
            NB           := ILAENV (1, "DSYTRF", str_UPLO, N, -1, -1, -1);
         end;
         LWKOPT   := N * NB;
         WORK (1) := Real (LWKOPT);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("DSYTRF", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := N;
      if NB > 1 and NB < N then
         IWS := LDWORK * NB;
         if LWORK < IWS then
            NB := max (LWORK / LDWORK, 1);
            declare
               str_UPLO : String (1 .. 1);
            begin
               str_UPLO (1) := UPLO;
               NBMIN        := max (2, ILAENV (2, "DSYTRF", str_UPLO, N, -1, -1, -1));
            end;
         end if;
      else
         IWS := 1;
      end if;
      if NB < NBMIN then
         NB := N;
      end if;
      --
      if UPPER then
         --
         --        Factorize A as U*D*U**T using the upper triangle of A
         --
         --        K is the main loop index, decreasing from N to 1 in steps of
         --        KB, where KB is the number of columns factorized by DLASYF;
         --        KB is either NB or NB-1, or K for the last block
         --
         K := N;
         <<L10>> null;
         --
         --        If K < 1, exit from loop
         --
         if K < 1 then
            goto L40;
         end if;
         --
         if K > NB then
            --
            --           Factorize columns k-kb+1:k of A and use blocked code to
            --           update columns 1:k-kb
            --
            DLASYF (UPLO, K, NB, KB, A'Address, LDA, IPIV'Address, WORK'Address, LDWORK, IINFO);
         else
            --
            --           Use unblocked code to factorize columns 1:k of A
            --
            DSYTF2 (UPLO, K, A'Address, LDA, IPIV'Address, IINFO);
            KB := K;
         end if;
         --
         --        Set INFO on the first occurrence of a zero pivot
         --
         if INFO = 0 and IINFO > 0 then
            INFO := IINFO;
         end if;
         --
         --        Decrease K and return to the start of the main loop
         --
         K := K - KB;
         goto L10;
      --
      else
         --
         --        Factorize A as L*D*L**T using the lower triangle of A
         --
         --        K is the main loop index, increasing from 1 to N in steps of
         --        KB, where KB is the number of columns factorized by DLASYF;
         --        KB is either NB or NB-1, or N-K+1 for the last block
         --
         K := 1;
         <<L20>> null;
         --
         --        If K > N, exit from loop
         --
         if K > N then
            goto L40;
         end if;
         --
         if K <= N - NB then
            --
            --           Factorize columns k:k+kb-1 of A and use blocked code to
            --           update columns k+kb:n
            --
            DLASYF (UPLO, N - K + 1, NB, KB, A (K, K)'Address, LDA, IPIV (K)'Address, WORK'Address, LDWORK, IINFO);
         else
            --
            --           Use unblocked code to factorize columns k:n of A
            --
            DSYTF2 (UPLO, N - K + 1, A (K, K)'Address, LDA, IPIV (K)'Address, IINFO);
            KB := N - K + 1;
         end if;
         --
         --        Set INFO on the first occurrence of a zero pivot
         --
         if INFO = 0 and IINFO > 0 then
            INFO := IINFO + K - 1;
         end if;
         --
         --        Adjust IPIV
         --
         J := K - 1;
         loop
            J := J + 1;
            exit when J > K + KB - 1;
            if IPIV (J) > 0 
               then IPIV (J) := IPIV (J) + K - 1;
               else IPIV (J) := IPIV (J) - K + 1;
            end if;
         end loop;
         --
         --        Increase K and return to the start of the main loop
         --
         K := K + KB;
         goto L20;
         --
      end if;
      --
      <<L40>> null;
      WORK (1) := Real (LWKOPT);
      return;
      --
      --     End of DSYTRF
      --
   end DSYTRF;

   procedure DSYTRS
     (UPLO : Character;
      N    : Integer;
      NRHS : Integer;
      A    : Ftn_Real_Matrix;
      LDA  : Integer;
      IPIV : Ftn_Integer_Vector;
      B    : in out Ftn_Real_Matrix;
      LDB  : Integer;
      INFO : in out Integer)
   is
      ONE   : constant Real := 1.0e0;
      UPPER : Boolean;
      J     : Integer;
      K     : Integer;
      KP    : Integer;
      AK    : Real;
      AKM1  : Real;
      AKM1K : Real;
      BK    : Real;
      BKM1  : Real;
      DENOM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYTRS( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LDB, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYTRS solves a system of linear equations A*X = B with a real
   --  symmetric matrix A using the factorization A = U*D*U**T or
   --  A = L*D*L**T computed by DSYTRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the details of the factorization are stored
   --           as an upper or lower triangular matrix.
   --           = 'U':  Upper triangular, form is A = U*D*U**T;
   --           = 'L':  Lower triangular, form is A = L*D*L**T.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The block diagonal matrix D and the multipliers used to
   --           obtain the factor U or L as computed by DSYTRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D
   --           as determined by DSYTRF.
   --
   --  [in,out] B
   --           B is DOUBLE PRECISION array, dimension (LDB,NRHS)
   --           On entry, the right hand side matrix B.
   --           On exit, the solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMV, DGER, DSCAL, DSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO  := 0;
      UPPER := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NRHS < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDB < max (1, N) then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYTRS", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 or NRHS = 0 then
         return;
      end if;
      --
      if UPPER then
         --
         --        Solve A*X = B, where A = U*D*U**T.
         --
         --        First solve U*D*X = B, overwriting B with X.
         --
         --        K is the main loop index, decreasing from N to 1 in steps of
         --        1 or 2, depending on the size of the diagonal blocks.
         --
         K := N;
         <<L10>> null;
         --
         --        If K < 1, exit from loop.
         --
         if K < 1 then
            goto L30;
         end if;
         --
         if IPIV (K) > 0 then
            --
            --           1 x 1 diagonal block
            --
            --           Interchange rows K and IPIV(K).
            --
            KP := IPIV (K);
            if KP /= K then
               DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            --
            --           Multiply by inv(U(K)), where U(K) is the transformation
            --           stored in column K of A.
            --
            DGER (K - 1, NRHS, -ONE, A (1, K)'Address, 1, B (K, 1)'Address, LDB, B (1, 1)'Address, LDB);
            --
            --           Multiply by the inverse of the diagonal block.
            --
            DSCAL (NRHS, ONE / A (K, K), B (K, 1)'Address, LDB);
            K := K - 1;
         else
            --
            --           2 x 2 diagonal block
            --
            --           Interchange rows K-1 and -IPIV(K).
            --
            KP := -IPIV (K);
            if KP /= K - 1 then
               DSWAP (NRHS, B (K - 1, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            --
            --           Multiply by inv(U(K)), where U(K) is the transformation
            --           stored in columns K-1 and K of A.
            --
            DGER (K - 2, NRHS, -ONE, A (1, K)'Address, 1, B (K, 1)'Address, LDB, B (1, 1)'Address, LDB);
            DGER (K - 2, NRHS, -ONE, A (1, K - 1)'Address, 1, B (K - 1, 1)'Address, LDB, B (1, 1)'Address, LDB);
            --
            --           Multiply by the inverse of the diagonal block.
            --
            AKM1K := A (K - 1, K);
            AKM1  := A (K - 1, K - 1) / AKM1K;
            AK    := A (K, K) / AKM1K;
            DENOM := AKM1 * AK - ONE;
            J     := 1 - 1;
            loop
               J := J + 1;
               exit when J > NRHS;
               BKM1         := B (K - 1, J) / AKM1K;
               BK           := B (K, J) / AKM1K;
               B (K - 1, J) := (AK * BKM1 - BK) / DENOM;
               B (K, J)     := (AKM1 * BK - BKM1) / DENOM;
            end loop;
            K := K - 2;
         end if;
         --
         goto L10;
         <<L30>> null;
         --
         --        Next solve U**T *X = B, overwriting B with X.
         --
         --        K is the main loop index, increasing from 1 to N in steps of
         --        1 or 2, depending on the size of the diagonal blocks.
         --
         K := 1;
         <<L40>> null;
         --
         --        If K > N, exit from loop.
         --
         if K > N then
            goto L50;
         end if;
         --
         if IPIV (K) > 0 then
            --
            --           1 x 1 diagonal block
            --
            --           Multiply by inv(U**T(K)), where U(K) is the transformation
            --           stored in column K of A.
            --
            DGEMV ('T', K - 1, NRHS, -ONE, B'Address, LDB, A (1, K)'Address, 1, ONE, B (K, 1)'Address, LDB);
            --
            --           Interchange rows K and IPIV(K).
            --
            KP := IPIV (K);
            if KP /= K then
               DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            K := K + 1;
         else
            --
            --           2 x 2 diagonal block
            --
            --           Multiply by inv(U**T(K+1)), where U(K+1) is the transformation
            --           stored in columns K and K+1 of A.
            --
            DGEMV ('T', K - 1, NRHS, -ONE, B'Address, LDB, A (1, K)'Address, 1, ONE, B (K, 1)'Address, LDB);
            DGEMV ('T', K - 1, NRHS, -ONE, B'Address, LDB, A (1, K + 1)'Address, 1, ONE, B (K + 1, 1)'Address, LDB);
            --
            --           Interchange rows K and -IPIV(K).
            --
            KP := -IPIV (K);
            if KP /= K then
               DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            K := K + 2;
         end if;
         --
         goto L40;
         <<L50>> null;
      --
      else
         --
         --        Solve A*X = B, where A = L*D*L**T.
         --
         --        First solve L*D*X = B, overwriting B with X.
         --
         --        K is the main loop index, increasing from 1 to N in steps of
         --        1 or 2, depending on the size of the diagonal blocks.
         --
         K := 1;
         <<L60>> null;
         --
         --        If K > N, exit from loop.
         --
         if K > N then
            goto L80;
         end if;
         --
         if IPIV (K) > 0 then
            --
            --           1 x 1 diagonal block
            --
            --           Interchange rows K and IPIV(K).
            --
            KP := IPIV (K);
            if KP /= K then
               DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            --
            --           Multiply by inv(L(K)), where L(K) is the transformation
            --           stored in column K of A.
            --
            if K < N then
               DGER (N - K, NRHS, -ONE, A (K + 1, K)'Address, 1, B (K, 1)'Address, LDB, B (K + 1, 1)'Address, LDB);
            end if;
            --
            --           Multiply by the inverse of the diagonal block.
            --
            DSCAL (NRHS, ONE / A (K, K), B (K, 1)'Address, LDB);
            K := K + 1;
         else
            --
            --           2 x 2 diagonal block
            --
            --           Interchange rows K+1 and -IPIV(K).
            --
            KP := -IPIV (K);
            if KP /= K + 1 then
               DSWAP (NRHS, B (K + 1, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            --
            --           Multiply by inv(L(K)), where L(K) is the transformation
            --           stored in columns K and K+1 of A.
            --
            if K < N - 1 then
               DGER (N - K - 1, NRHS, -ONE, A (K + 2, K)'Address, 1, B (K, 1)'Address, LDB, B (K + 2, 1)'Address, LDB);
               DGER
                 (N - K - 1,
                  NRHS,
                  -ONE,
                  A (K + 2, K + 1)'Address,
                  1,
                  B (K + 1, 1)'Address,
                  LDB,
                  B (K + 2, 1)'Address,
                  LDB);
            end if;
            --
            --           Multiply by the inverse of the diagonal block.
            --
            AKM1K := A (K + 1, K);
            AKM1  := A (K, K) / AKM1K;
            AK    := A (K + 1, K + 1) / AKM1K;
            DENOM := AKM1 * AK - ONE;
            J     := 1 - 1;
            loop
               J := J + 1;
               exit when J > NRHS;
               BKM1         := B (K, J) / AKM1K;
               BK           := B (K + 1, J) / AKM1K;
               B (K, J)     := (AK * BKM1 - BK) / DENOM;
               B (K + 1, J) := (AKM1 * BK - BKM1) / DENOM;
            end loop;
            K := K + 2;
         end if;
         --
         goto L60;
         <<L80>> null;
         --
         --        Next solve L**T *X = B, overwriting B with X.
         --
         --        K is the main loop index, decreasing from N to 1 in steps of
         --        1 or 2, depending on the size of the diagonal blocks.
         --
         K := N;
         <<L90>> null;
         --
         --        If K < 1, exit from loop.
         --
         if K < 1 then
            goto L100;
         end if;
         --
         if IPIV (K) > 0 then
            --
            --           1 x 1 diagonal block
            --
            --           Multiply by inv(L**T(K)), where L(K) is the transformation
            --           stored in column K of A.
            --
            if K < N then
               DGEMV
                 ('T',
                  N - K,
                  NRHS,
                  -ONE,
                  B (K + 1, 1)'Address,
                  LDB,
                  A (K + 1, K)'Address,
                  1,
                  ONE,
                  B (K, 1)'Address,
                  LDB);
            end if;
            --
            --           Interchange rows K and IPIV(K).
            --
            KP := IPIV (K);
            if KP /= K then
               DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            K := K - 1;
         else
            --
            --           2 x 2 diagonal block
            --
            --           Multiply by inv(L**T(K-1)), where L(K-1) is the transformation
            --           stored in columns K-1 and K of A.
            --
            if K < N then
               DGEMV
                 ('T',
                  N - K,
                  NRHS,
                  -ONE,
                  B (K + 1, 1)'Address,
                  LDB,
                  A (K + 1, K)'Address,
                  1,
                  ONE,
                  B (K, 1)'Address,
                  LDB);
               DGEMV
                 ('T',
                  N - K,
                  NRHS,
                  -ONE,
                  B (K + 1, 1)'Address,
                  LDB,
                  A (K + 1, K - 1)'Address,
                  1,
                  ONE,
                  B (K - 1, 1)'Address,
                  LDB);
            end if;
            --
            --           Interchange rows K and -IPIV(K).
            --
            KP := -IPIV (K);
            if KP /= K then
               DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            K := K - 2;
         end if;
         --
         goto L90;
         <<L100>> null;
      end if;
      --
      return;
      --
      --     End of DSYTRS
      --
   end DSYTRS;

   procedure DSYTRS2
     (UPLO : Character;
      N    : Integer;
      NRHS : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer;
      IPIV : Ftn_Integer_Vector;
      B    : in out Ftn_Real_Matrix;
      LDB  : Integer;
      WORK : out Ftn_Real_Vector;
      INFO : in out Integer)
   is
      ONE   : constant Real := 1.0e0;
      UPPER : Boolean;
      I     : Integer;
      IINFO : Integer;
      J     : Integer;
      K     : Integer;
      KP    : Integer;
      AK    : Real;
      AKM1  : Real;
      AKM1K : Real;
      BK    : Real;
      BKM1  : Real;
      DENOM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DSYTRS2( UPLO, N, NRHS, A, LDA, IPIV, B, LDB,
   --                           WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LDB, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DSYTRS2 solves a system of linear equations A*X = B with a real
   --  symmetric matrix A using the factorization A = U*D*U**T or
   --  A = L*D*L**T computed by DSYTRF and converted by DSYCONV.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the details of the factorization are stored
   --           as an upper or lower triangular matrix.
   --           = 'U':  Upper triangular, form is A = U*D*U**T;
   --           = 'L':  Lower triangular, form is A = L*D*L**T.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The block diagonal matrix D and the multipliers used to
   --           obtain the factor U or L as computed by DSYTRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D
   --           as determined by DSYTRF.
   --
   --  [in,out] B
   --           B is DOUBLE PRECISION array, dimension (LDB,NRHS)
   --           On entry, the right hand side matrix B.
   --           On exit, the solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] WORK
   --           WORK is REAL array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DSCAL, DSYCONV, DSWAP, DTRSM, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO  := 0;
      UPPER := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NRHS < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDB < max (1, N) then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("DSYTRS2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 or NRHS = 0 then
         return;
      end if;
      --
      --     Convert A
      --
      DSYCONV (UPLO, 'C', N, A, LDA, IPIV, WORK, IINFO);
      --
      if UPPER then
         --
         --        Solve A*X = B, where A = U*D*U**T.
         --
         --       P**T * B
         K := N;
         while K >= 1 loop
            if IPIV (K) > 0 then
               --           1 x 1 diagonal block
               --           Interchange rows K and IPIV(K).
               KP := IPIV (K);
               if KP /= K then
                  DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K - 1;
            else
               --           2 x 2 diagonal block
               --           Interchange rows K-1 and -IPIV(K).
               KP := -IPIV (K);
               if KP = -IPIV (K - 1) then
                  DSWAP (NRHS, B (K - 1, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K - 2;
            end if;
         end loop;
         --
         --  Compute (U \P**T * B) -> B    [ (U \P**T * B) ]
         --
         DTRSM ('L', 'U', 'N', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --  Compute D \ B -> B   [ D \ (U \P**T * B) ]
         --
         I := N;
         while I >= 1 loop
            if IPIV (I) > 0 then
               DSCAL (NRHS, ONE / A (I, I), B (I, 1)'Address, LDB);
            elsif I > 1 then
               if IPIV (I - 1) = IPIV (I) then
                  AKM1K := WORK (I);
                  AKM1  := A (I - 1, I - 1) / AKM1K;
                  AK    := A (I, I) / AKM1K;
                  DENOM := AKM1 * AK - ONE;
                  J     := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > NRHS;
                     BKM1         := B (I - 1, J) / AKM1K;
                     BK           := B (I, J) / AKM1K;
                     B (I - 1, J) := (AK * BKM1 - BK) / DENOM;
                     B (I, J)     := (AKM1 * BK - BKM1) / DENOM;
                  end loop;
                  I := I - 1;
               end if;
            end if;
            I := I - 1;
         end loop;
         --
         --      Compute (U**T \ B) -> B   [ U**T \ (D \ (U \P**T * B) ) ]
         --
         DTRSM ('L', 'U', 'T', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --       P * B  [ P * (U**T \ (D \ (U \P**T * B) )) ]
         --
         K := 1;
         while K <= N loop
            if IPIV (K) > 0 then
               --           1 x 1 diagonal block
               --           Interchange rows K and IPIV(K).
               KP := IPIV (K);
               if KP /= K then
                  DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K + 1;
            else
               --           2 x 2 diagonal block
               --           Interchange rows K-1 and -IPIV(K).
               KP := -IPIV (K);
               if K < N and KP = -IPIV (K + 1) then
                  DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K + 2;
            end if;
         end loop;
      --
      else
         --
         --        Solve A*X = B, where A = L*D*L**T.
         --
         --       P**T * B
         K := 1;
         while K <= N loop
            if IPIV (K) > 0 then
               --           1 x 1 diagonal block
               --           Interchange rows K and IPIV(K).
               KP := IPIV (K);
               if KP /= K then
                  DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K + 1;
            else
               --           2 x 2 diagonal block
               --           Interchange rows K and -IPIV(K+1).
               KP := -IPIV (K + 1);
               if KP = -IPIV (K) then
                  DSWAP (NRHS, B (K + 1, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K + 2;
            end if;
         end loop;
         --
         --  Compute (L \P**T * B) -> B    [ (L \P**T * B) ]
         --
         DTRSM ('L', 'L', 'N', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --  Compute D \ B -> B   [ D \ (L \P**T * B) ]
         --
         I := 1;
         while I <= N loop
            if IPIV (I) > 0 then
               DSCAL (NRHS, ONE / A (I, I), B (I, 1)'Address, LDB);
            else
               AKM1K := WORK (I);
               AKM1  := A (I, I) / AKM1K;
               AK    := A (I + 1, I + 1) / AKM1K;
               DENOM := AKM1 * AK - ONE;
               J     := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > NRHS;
                  BKM1         := B (I, J) / AKM1K;
                  BK           := B (I + 1, J) / AKM1K;
                  B (I, J)     := (AK * BKM1 - BK) / DENOM;
                  B (I + 1, J) := (AKM1 * BK - BKM1) / DENOM;
               end loop;
               I := I + 1;
            end if;
            I := I + 1;
         end loop;
         --
         --  Compute (L**T \ B) -> B   [ L**T \ (D \ (L \P**T * B) ) ]
         --
         DTRSM ('L', 'L', 'T', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --       P * B  [ P * (L**T \ (D \ (L \P**T * B) )) ]
         --
         K := N;
         while K >= 1 loop
            if IPIV (K) > 0 then
               --           1 x 1 diagonal block
               --           Interchange rows K and IPIV(K).
               KP := IPIV (K);
               if KP /= K then
                  DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K - 1;
            else
               --           2 x 2 diagonal block
               --           Interchange rows K-1 and -IPIV(K).
               KP := -IPIV (K);
               if K > 1 and KP = -IPIV (K - 1) then
                  DSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K - 2;
            end if;
         end loop;
         --
      end if;
      --
      --     Revert A
      --
      DSYCONV (UPLO, 'R', N, A, LDA, IPIV, WORK, IINFO);
      --
      return;
      --
      --     End of DSYTRS2
      --
   end DSYTRS2;

   procedure DTREVC
     (SIDE           : Character;
      HOWMNY         : Character;
      the_SELECT_adr : Address;
      N              : Integer;
      T_adr          : Address;
      LDT            : Integer;
      VL_adr         : Address;
      LDVL           : Integer;
      VR_adr         : Address;
      LDVR           : Integer;
      MM             : Integer;
      M              : in out Integer;
      WORK_adr       : Address;
      INFO           : in out Integer)
   is

      the_SELECT : Ftn_Boolean_Vector (1 .. N);
      T          : Ftn_Real_Matrix (1 .. LDT, 1 .. N);
      VL         : Ftn_Real_Matrix (1 .. LDVL, 1 .. MM);
      VR         : Ftn_Real_Matrix (1 .. LDVR, 1 .. MM);
      WORK       : Ftn_Real_Vector (1 .. 3 * N);

      for the_SELECT'Address use the_SELECT_adr;
      for T'Address use T_adr;
      for VL'Address use VL_adr;
      for VR'Address use VR_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, the_SELECT);
      pragma Import (Ada, T);
      pragma Import (Ada, VL);
      pragma Import (Ada, VR);
      pragma Import (Ada, WORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      ALLV   : Boolean;
      BOTHV  : Boolean;
      LEFTV  : Boolean;
      OVER   : Boolean;
      PAIR   : Boolean;
      RIGHTV : Boolean;
      SOMEV  : Boolean;
      I      : Integer;
      IERR   : Integer;
      II     : Integer;
      IP     : Integer;
      the_IS : Integer;
      J      : Integer;
      J1     : Integer;
      J2     : Integer;
      JNXT   : Integer;
      K      : Integer;
      KI     : Integer;
      N2     : Integer;
      BETA   : Real;
      BIGNUM : Real;
      EMAX   : Real;
      OVFL   : Real;
      REC    : Real;
      REMAX  : Real;
      SCALE  : Real;
      SMIN   : Real;
      SMLNUM : Real;
      ULP    : Real;
      UNFL   : Real;
      VCRIT  : Real;
      VMAX   : Real;
      WI     : Real;
      WR     : Real;
      XNORM  : Real;
      X      : Ftn_Real_Matrix (1 .. 2, 1 .. 2);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DTREVC( SIDE, HOWMNY, SELECT, N, T, LDT, VL, LDVL, VR,
   --                          LDVR, MM, M, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          HOWMNY, SIDE
   --       INTEGER            INFO, LDT, LDVL, LDVR, M, MM, N
   --       ..
   --       .. Array Arguments ..
   --       LOGICAL            SELECT( * )
   --       DOUBLE PRECISION   T( LDT, * ), VL( LDVL, * ), VR( LDVR, * ),
   --      $                   WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DTREVC computes some or all of the right and/or left eigenvectors of
   --  a real upper quasi-triangular matrix T.
   --  Matrices of this type are produced by the Schur factorization of
   --  a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
   --
   --  The right eigenvector x and the left eigenvector y of T corresponding
   --  to an eigenvalue w are defined by:
   --
   --     T*x = w*x,     (y**T)*T = w*(y**T)
   --
   --  where y**T denotes the transpose of y.
   --  The eigenvalues are not input to this routine, but are read directly
   --  from the diagonal blocks of T.
   --
   --  This routine returns the matrices X and/or Y of right and left
   --  eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
   --  input matrix.  If Q is the orthogonal factor that reduces a matrix
   --  A to Schur form T, then Q*X and Q*Y are the matrices of right and
   --  left eigenvectors of A.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'R':  compute right eigenvectors only;
   --           = 'L':  compute left eigenvectors only;
   --           = 'B':  compute both right and left eigenvectors.
   --
   --  [in] HOWMNY
   --           HOWMNY is CHARACTER*1
   --           = 'A':  compute all right and/or left eigenvectors;
   --           = 'B':  compute all right and/or left eigenvectors,
   --                   backtransformed by the matrices in VR and/or VL;
   --           = 'S':  compute selected right and/or left eigenvectors,
   --                   as indicated by the LOGICAL array SELECT.
   --
   --  [in,out] SELECT
   --           SELECT is LOGICAL array, dimension (N)
   --           If HOWMNY = 'S', SELECT specifies the eigenvectors to be
   --           computed.
   --           If w(j) is a real eigenvalue, the corresponding real
   --           eigenvector is computed if SELECT(j) is .TRUE..
   --           If w(j) and w(j+1) are the real and imaginary parts of a
   --           complex eigenvalue, the corresponding complex eigenvector is
   --           computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
   --           on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
   --           .FALSE..
   --           Not referenced if HOWMNY = 'A' or 'B'.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix T. N >= 0.
   --
   --  [in] T
   --           T is DOUBLE PRECISION array, dimension (LDT,N)
   --           The upper quasi-triangular matrix T in Schur canonical form.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= max(1,N).
   --
   --  [in,out] VL
   --           VL is DOUBLE PRECISION array, dimension (LDVL,MM)
   --           On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
   --           contain an N-by-N matrix Q (usually the orthogonal matrix Q
   --           of Schur vectors returned by DHSEQR).
   --           On exit, if SIDE = 'L' or 'B', VL contains:
   --           if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
   --           if HOWMNY = 'B', the matrix Q*Y;
   --           if HOWMNY = 'S', the left eigenvectors of T specified by
   --                            SELECT, stored consecutively in the columns
   --                            of VL, in the same order as their
   --                            eigenvalues.
   --           A complex eigenvector corresponding to a complex eigenvalue
   --           is stored in two consecutive columns, the first holding the
   --           real part, and the second the imaginary part.
   --           Not referenced if SIDE = 'R'.
   --
   --  [in] LDVL
   --           LDVL is INTEGER
   --           The leading dimension of the array VL.  LDVL >= 1, and if
   --           SIDE = 'L' or 'B', LDVL >= N.
   --
   --  [in,out] VR
   --           VR is DOUBLE PRECISION array, dimension (LDVR,MM)
   --           On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
   --           contain an N-by-N matrix Q (usually the orthogonal matrix Q
   --           of Schur vectors returned by DHSEQR).
   --           On exit, if SIDE = 'R' or 'B', VR contains:
   --           if HOWMNY = 'A', the matrix X of right eigenvectors of T;
   --           if HOWMNY = 'B', the matrix Q*X;
   --           if HOWMNY = 'S', the right eigenvectors of T specified by
   --                            SELECT, stored consecutively in the columns
   --                            of VR, in the same order as their
   --                            eigenvalues.
   --           A complex eigenvector corresponding to a complex eigenvalue
   --           is stored in two consecutive columns, the first holding the
   --           real part and the second the imaginary part.
   --           Not referenced if SIDE = 'L'.
   --
   --  [in] LDVR
   --           LDVR is INTEGER
   --           The leading dimension of the array VR.  LDVR >= 1, and if
   --           SIDE = 'R' or 'B', LDVR >= N.
   --
   --  [in] MM
   --           MM is INTEGER
   --           The number of columns in the arrays VL and/or VR. MM >= M.
   --
   --  [out] M
   --           M is INTEGER
   --           The number of columns in the arrays VL and/or VR actually
   --           used to store the eigenvectors.
   --           If HOWMNY = 'A' or 'B', M is set to N.
   --           Each selected real eigenvector occupies one column and each
   --           selected complex eigenvector occupies two columns.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (3*N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The algorithm used in this program is basically backward (forward)
   --   substitution, with scaling to make the the code robust against
   --   possible overflow.
   --
   --   Each eigenvector is normalized so that the element of largest
   --   magnitude has magnitude 1; here the magnitude of a complex number
   --   (x,y) is taken to be |x| + |y|.
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME, IDAMAX, DDOT, DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DAXPY, DCOPY, DGEMV, DLALN2, DSCAL, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, SQRT
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Decode and test the input parameters
   --
   begin
      BOTHV  := LSAME (SIDE, 'B');
      RIGHTV := LSAME (SIDE, 'R') or BOTHV;
      LEFTV  := LSAME (SIDE, 'L') or BOTHV;
      --
      ALLV  := LSAME (HOWMNY, 'A');
      OVER  := LSAME (HOWMNY, 'B');
      SOMEV := LSAME (HOWMNY, 'S');
      --
      INFO := 0;
      if not RIGHTV and not LEFTV then
         INFO := -1;
      elsif not ALLV and not OVER and not SOMEV then
         INFO := -2;
      elsif N < 0 then
         INFO := -4;
      elsif LDT < max (1, N) then
         INFO := -6;
      elsif LDVL < 1 or (LEFTV and LDVL < N) then
         INFO := -8;
      elsif LDVR < 1 or (RIGHTV and LDVR < N) then
         INFO := -10;
      else
         --
         --        Set M to the number of columns required to store the selected
         --        eigenvectors, standardize the array SELECT if necessary, and
         --        test MM.
         --
         if SOMEV then
            M    := 0;
            PAIR := False;
            J    := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if PAIR then
                  PAIR           := False;
                  the_SELECT (J) := False;
               else
                  if J < N then
                     if T (J + 1, J) = ZERO then
                        if the_SELECT (J) then
                           M := M + 1;
                        end if;
                     else
                        PAIR := True;
                        if the_SELECT (J) or the_SELECT (J + 1) then
                           the_SELECT (J) := True;
                           M              := M + 2;
                        end if;
                     end if;
                  else
                     if the_SELECT (N) then
                        M := M + 1;
                     end if;
                  end if;
               end if;
            end loop;
         else
            M := N;
         end if;
         --
         if MM < M then
            INFO := -11;
         end if;
      end if;
      if INFO /= 0 then
         XERBLA ("DTREVC", -INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if N = 0 then
         return;
      end if;
      --
      --     Set the constants to control overflow.
      --
      UNFL := DLAMCH ('S');
      OVFL := ONE / UNFL;
      DLABAD (UNFL, OVFL);
      ULP    := DLAMCH ('P');
      SMLNUM := UNFL * (Real (N) / ULP);
      BIGNUM := (ONE - ULP) / SMLNUM;
      --
      --     Compute 1-norm of each column of strictly upper triangular
      --     part of T to control overflow in triangular solver.
      --
      WORK (1) := ZERO;
      J        := 2 - 1;
      loop
         J := J + 1;
         exit when J > N;
         WORK (J) := ZERO;
         I        := 1 - 1;
         loop
            I := I + 1;
            exit when I > J - 1;
            WORK (J) := WORK (J) + abs (T (I, J));
         end loop;
      end loop;
      --
      --     Index IP is used to specify the real or complex eigenvalue:
      --       IP = 0, real eigenvalue,
      --            1, first of conjugate complex pair: (wr,wi)
      --           -1, second of conjugate complex pair: (wr,wi)
      --
      N2 := 2 * N;
      --
      if RIGHTV then
         --
         --        Compute right eigenvectors.
         --
         IP     := 0;
         the_IS := M;
         KI     := N + 1;
         loop
            KI := KI - 1;
            exit when KI < 1;
            --
            if IP = 1 then
               goto L130;
            end if;
            if KI = 1 then
               goto L40;
            end if;
            if T (KI, KI - 1) = ZERO then
               goto L40;
            end if;
            IP := -1;
            --
            <<L40>> null;
            if SOMEV then
               if IP = 0 then
                  if not the_SELECT (KI) then
                     goto L130;
                  end if;
               else
                  if not the_SELECT (KI - 1) then
                     goto L130;
                  end if;
               end if;
            end if;
            --
            --           Compute the KI-th eigenvalue (WR,WI).
            --
            WR := T (KI, KI);
            WI := ZERO;
            if IP /= 0 then
               WI := Sqrt (abs (T (KI, KI - 1))) * Sqrt (abs (T (KI - 1, KI)));
            end if;
            SMIN := max (ULP * (abs (WR) + abs (WI)), SMLNUM);
            --
            if IP = 0 then
               --
               --              Real right eigenvector
               --
               WORK (KI + N) := ONE;
               --
               --              Form right-hand side
               --
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > KI - 1;
                  WORK (K + N) := -T (K, KI);
               end loop;
               --
               --              Solve the upper quasi-triangular system:
               --                 (T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK.
               --
               JNXT := KI - 1;
               J    := KI - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if J > JNXT then
                     goto L60;
                  end if;
                  J1   := J;
                  J2   := J;
                  JNXT := J - 1;
                  if J > 1 then
                     if T (J, J - 1) /= ZERO then
                        J1   := J - 1;
                        JNXT := J - 2;
                     end if;
                  end if;
                  --
                  if J1 = J2 then
                     --
                     --                    1-by-1 diagonal block
                     --
                     DLALN2
                       (False,
                        1,
                        1,
                        SMIN,
                        ONE,
                        T (J, J)'Address,
                        LDT,
                        ONE,
                        ONE,
                        WORK (J + N)'Address,
                        N,
                        WR,
                        ZERO,
                        X'Address,
                        2,
                        SCALE,
                        XNORM,
                        IERR);
                     --
                     --                    Scale X(1,1) to avoid overflow when updating
                     --                    the right-hand side.
                     --
                     if XNORM > ONE then
                        if WORK (J) > BIGNUM / XNORM then
                           X (1, 1) := X (1, 1) / XNORM;
                           SCALE    := SCALE / XNORM;
                        end if;
                     end if;
                     --
                     --                    Scale if necessary
                     --
                     if SCALE /= ONE then
                        DSCAL (KI, SCALE, WORK (1 + N)'Address, 1);
                     end if;
                     WORK (J + N) := X (1, 1);
                     --
                     --                    Update right-hand side
                     --
                     DAXPY (J - 1, -X (1, 1), T (1, J)'Address, 1, WORK (1 + N)'Address, 1);
                  --
                  else
                     --
                     --                    2-by-2 diagonal block
                     --
                     DLALN2
                       (False,
                        2,
                        1,
                        SMIN,
                        ONE,
                        T (J - 1, J - 1)'Address,
                        LDT,
                        ONE,
                        ONE,
                        WORK (J - 1 + N)'Address,
                        N,
                        WR,
                        ZERO,
                        X'Address,
                        2,
                        SCALE,
                        XNORM,
                        IERR);
                     --
                     --                    Scale X(1,1) and X(2,1) to avoid overflow when
                     --                    updating the right-hand side.
                     --
                     if XNORM > ONE then
                        BETA := max (WORK (J - 1), WORK (J));
                        if BETA > BIGNUM / XNORM then
                           X (1, 1) := X (1, 1) / XNORM;
                           X (2, 1) := X (2, 1) / XNORM;
                           SCALE    := SCALE / XNORM;
                        end if;
                     end if;
                     --
                     --                    Scale if necessary
                     --
                     if SCALE /= ONE then
                        DSCAL (KI, SCALE, WORK (1 + N)'Address, 1);
                     end if;
                     WORK (J - 1 + N) := X (1, 1);
                     WORK (J + N)     := X (2, 1);
                     --
                     --                    Update right-hand side
                     --
                     DAXPY (J - 2, -X (1, 1), T (1, J - 1)'Address, 1, WORK (1 + N)'Address, 1);
                     DAXPY (J - 2, -X (2, 1), T (1, J)'Address, 1, WORK (1 + N)'Address, 1);
                  end if;
                  <<L60>> null;
               end loop;
               --
               --              Copy the vector x or Q*x to VR and normalize.
               --
               if not OVER then
                  DCOPY (KI, WORK (1 + N)'Address, 1, VR (1, the_IS)'Address, 1);
                  --
                  II    := IDAMAX (KI, VR (1, the_IS)'Address, 1);
                  REMAX := ONE / abs (VR (II, the_IS));
                  DSCAL (KI, REMAX, VR (1, the_IS)'Address, 1);
                  --
                  K := KI + 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     VR (K, the_IS) := ZERO;
                  end loop;
               else
                  if KI > 1 then
                     DGEMV
                       ('N',
                        N,
                        KI - 1,
                        ONE,
                        VR'Address,
                        LDVR,
                        WORK (1 + N)'Address,
                        1,
                        WORK (KI + N),
                        VR (1, KI)'Address,
                        1);
                  end if;
                  --
                  II    := IDAMAX (N, VR (1, KI)'Address, 1);
                  REMAX := ONE / abs (VR (II, KI));
                  DSCAL (N, REMAX, VR (1, KI)'Address, 1);
               end if;
            --
            else
               --
               --              Complex right eigenvector.
               --
               --              Initial solve
               --                [ (T(KI-1,KI-1) T(KI-1,KI) ) - (WR + I* WI)]*X = 0.
               --                [ (T(KI,KI-1)   T(KI,KI)   )               ]
               --
               if abs (T (KI - 1, KI)) >= abs (T (KI, KI - 1)) then
                  WORK (KI - 1 + N) := ONE;
                  WORK (KI + N2)    := WI / T (KI - 1, KI);
               else
                  WORK (KI - 1 + N) := -WI / T (KI, KI - 1);
                  WORK (KI + N2)    := ONE;
               end if;
               WORK (KI + N)      := ZERO;
               WORK (KI - 1 + N2) := ZERO;
               --
               --              Form right-hand side
               --
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > KI - 2;
                  WORK (K + N)  := -WORK (KI - 1 + N) * T (K, KI - 1);
                  WORK (K + N2) := -WORK (KI + N2) * T (K, KI);
               end loop;
               --
               --              Solve upper quasi-triangular system:
               --              (T(1:KI-2,1:KI-2) - (WR+i*WI))*X = SCALE*(WORK+i*WORK2)
               --
               JNXT := KI - 2;
               J    := KI - 2 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  if J > JNXT then
                     goto L90;
                  end if;
                  J1   := J;
                  J2   := J;
                  JNXT := J - 1;
                  if J > 1 then
                     if T (J, J - 1) /= ZERO then
                        J1   := J - 1;
                        JNXT := J - 2;
                     end if;
                  end if;
                  --
                  if J1 = J2 then
                     --
                     --                    1-by-1 diagonal block
                     --
                     DLALN2
                       (False,
                        1,
                        2,
                        SMIN,
                        ONE,
                        T (J, J)'Address,
                        LDT,
                        ONE,
                        ONE,
                        WORK (J + N)'Address,
                        N,
                        WR,
                        WI,
                        X'Address,
                        2,
                        SCALE,
                        XNORM,
                        IERR);
                     --
                     --                    Scale X(1,1) and X(1,2) to avoid overflow when
                     --                    updating the right-hand side.
                     --
                     if XNORM > ONE then
                        if WORK (J) > BIGNUM / XNORM then
                           X (1, 1) := X (1, 1) / XNORM;
                           X (1, 2) := X (1, 2) / XNORM;
                           SCALE    := SCALE / XNORM;
                        end if;
                     end if;
                     --
                     --                    Scale if necessary
                     --
                     if SCALE /= ONE then
                        DSCAL (KI, SCALE, WORK (1 + N)'Address, 1);
                        DSCAL (KI, SCALE, WORK (1 + N2)'Address, 1);
                     end if;
                     WORK (J + N)  := X (1, 1);
                     WORK (J + N2) := X (1, 2);
                     --
                     --                    Update the right-hand side
                     --
                     DAXPY (J - 1, -X (1, 1), T (1, J)'Address, 1, WORK (1 + N)'Address, 1);
                     DAXPY (J - 1, -X (1, 2), T (1, J)'Address, 1, WORK (1 + N2)'Address, 1);
                  --
                  else
                     --
                     --                    2-by-2 diagonal block
                     --
                     DLALN2
                       (False,
                        2,
                        2,
                        SMIN,
                        ONE,
                        T (J - 1, J - 1)'Address,
                        LDT,
                        ONE,
                        ONE,
                        WORK (J - 1 + N)'Address,
                        N,
                        WR,
                        WI,
                        X'Address,
                        2,
                        SCALE,
                        XNORM,
                        IERR);
                     --
                     --                    Scale X to avoid overflow when updating
                     --                    the right-hand side.
                     --
                     if XNORM > ONE then
                        BETA := max (WORK (J - 1), WORK (J));
                        if BETA > BIGNUM / XNORM then
                           REC      := ONE / XNORM;
                           X (1, 1) := X (1, 1) * REC;
                           X (1, 2) := X (1, 2) * REC;
                           X (2, 1) := X (2, 1) * REC;
                           X (2, 2) := X (2, 2) * REC;
                           SCALE    := SCALE * REC;
                        end if;
                     end if;
                     --
                     --                    Scale if necessary
                     --
                     if SCALE /= ONE then
                        DSCAL (KI, SCALE, WORK (1 + N)'Address, 1);
                        DSCAL (KI, SCALE, WORK (1 + N2)'Address, 1);
                     end if;
                     WORK (J - 1 + N)  := X (1, 1);
                     WORK (J + N)      := X (2, 1);
                     WORK (J - 1 + N2) := X (1, 2);
                     WORK (J + N2)     := X (2, 2);
                     --
                     --                    Update the right-hand side
                     --
                     DAXPY (J - 2, -X (1, 1), T (1, J - 1)'Address, 1, WORK (1 + N)'Address, 1);
                     DAXPY (J - 2, -X (2, 1), T (1, J)'Address, 1, WORK (1 + N)'Address, 1);
                     DAXPY (J - 2, -X (1, 2), T (1, J - 1)'Address, 1, WORK (1 + N2)'Address, 1);
                     DAXPY (J - 2, -X (2, 2), T (1, J)'Address, 1, WORK (1 + N2)'Address, 1);
                  end if;
                  <<L90>> null;
               end loop;
               --
               --              Copy the vector x or Q*x to VR and normalize.
               --
               if not OVER then
                  DCOPY (KI, WORK (1 + N)'Address, 1, VR (1, the_IS - 1)'Address, 1);
                  DCOPY (KI, WORK (1 + N2)'Address, 1, VR (1, the_IS)'Address, 1);
                  --
                  EMAX := ZERO;
                  K    := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > KI;
                     EMAX := max (EMAX, abs (VR (K, the_IS - 1)) + abs (VR (K, the_IS)));
                  end loop;
                  --
                  REMAX := ONE / EMAX;
                  DSCAL (KI, REMAX, VR (1, the_IS - 1)'Address, 1);
                  DSCAL (KI, REMAX, VR (1, the_IS)'Address, 1);
                  --
                  K := KI + 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     VR (K, the_IS - 1) := ZERO;
                     VR (K, the_IS)     := ZERO;
                  end loop;
               --
               else
                  --
                  if KI > 2 then
                     DGEMV
                       ('N',
                        N,
                        KI - 2,
                        ONE,
                        VR'Address,
                        LDVR,
                        WORK (1 + N)'Address,
                        1,
                        WORK (KI - 1 + N),
                        VR (1, KI - 1)'Address,
                        1);
                     DGEMV
                       ('N',
                        N,
                        KI - 2,
                        ONE,
                        VR'Address,
                        LDVR,
                        WORK (1 + N2)'Address,
                        1,
                        WORK (KI + N2),
                        VR (1, KI)'Address,
                        1);
                  else
                     DSCAL (N, WORK (KI - 1 + N), VR (1, KI - 1)'Address, 1);
                     DSCAL (N, WORK (KI + N2), VR (1, KI)'Address, 1);
                  end if;
                  --
                  EMAX := ZERO;
                  K    := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     EMAX := max (EMAX, abs (VR (K, KI - 1)) + abs (VR (K, KI)));
                  end loop;
                  REMAX := ONE / EMAX;
                  DSCAL (N, REMAX, VR (1, KI - 1)'Address, 1);
                  DSCAL (N, REMAX, VR (1, KI)'Address, 1);
               end if;
            end if;
            --
            the_IS := the_IS - 1;
            if IP /= 0 then
               the_IS := the_IS - 1;
            end if;
            <<L130>> null;
            if IP = 1 then
               IP := 0;
            end if;
            if IP = -1 then
               IP := 1;
            end if;
         end loop;
      end if;
      --
      if LEFTV then
         --
         --        Compute left eigenvectors.
         --
         IP     := 0;
         the_IS := 1;
         KI     := 1 - 1;
         loop
            KI := KI + 1;
            exit when KI > N;
            --
            if IP = -1 then
               goto L250;
            end if;
            if KI = N then
               goto L150;
            end if;
            if T (KI + 1, KI) = ZERO then
               goto L150;
            end if;
            IP := 1;
            --
            <<L150>> null;
            if SOMEV then
               if not the_SELECT (KI) then
                  goto L250;
               end if;
            end if;
            --
            --           Compute the KI-th eigenvalue (WR,WI).
            --
            WR := T (KI, KI);
            WI := ZERO;
            if IP /= 0 then
               WI := Sqrt (abs (T (KI, KI + 1))) * Sqrt (abs (T (KI + 1, KI)));
            end if;
            SMIN := max (ULP * (abs (WR) + abs (WI)), SMLNUM);
            --
            if IP = 0 then
               --
               --              Real left eigenvector.
               --
               WORK (KI + N) := ONE;
               --
               --              Form right-hand side
               --
               K := KI + 1 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  WORK (K + N) := -T (KI, K);
               end loop;
               --
               --              Solve the quasi-triangular system:
               --                 (T(KI+1:N,KI+1:N) - WR)**T*X = SCALE*WORK
               --
               VMAX  := ONE;
               VCRIT := BIGNUM;
               --
               JNXT := KI + 1;
               J    := KI + 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if J < JNXT then
                     goto L170;
                  end if;
                  J1   := J;
                  J2   := J;
                  JNXT := J + 1;
                  if J < N then
                     if T (J + 1, J) /= ZERO then
                        J2   := J + 1;
                        JNXT := J + 2;
                     end if;
                  end if;
                  --
                  if J1 = J2 then
                     --
                     --                    1-by-1 diagonal block
                     --
                     --                    Scale if necessary to avoid overflow when forming
                     --                    the right-hand side.
                     --
                     if WORK (J) > VCRIT then
                        REC := ONE / VMAX;
                        DSCAL (N - KI + 1, REC, WORK (KI + N)'Address, 1);
                        VMAX  := ONE;
                        VCRIT := BIGNUM;
                     end if;
                     --
                     WORK (J + N) := WORK (J + N) -
                                     DDOT (J - KI - 1, T (KI + 1, J)'Address, 1, WORK (KI + 1 + N)'Address, 1);
                     --
                     --                    Solve (T(J,J)-WR)**T*X = WORK
                     --
                     DLALN2
                       (False,
                        1,
                        1,
                        SMIN,
                        ONE,
                        T (J, J)'Address,
                        LDT,
                        ONE,
                        ONE,
                        WORK (J + N)'Address,
                        N,
                        WR,
                        ZERO,
                        X'Address,
                        2,
                        SCALE,
                        XNORM,
                        IERR);
                     --
                     --                    Scale if necessary
                     --
                     if SCALE /= ONE then
                        DSCAL (N - KI + 1, SCALE, WORK (KI + N)'Address, 1);
                     end if;
                     WORK (J + N) := X (1, 1);
                     VMAX         := max (abs (WORK (J + N)), VMAX);
                     VCRIT        := BIGNUM / VMAX;
                  --
                  else
                     --
                     --                    2-by-2 diagonal block
                     --
                     --                    Scale if necessary to avoid overflow when forming
                     --                    the right-hand side.
                     --
                     BETA := max (WORK (J), WORK (J + 1));
                     if BETA > VCRIT then
                        REC := ONE / VMAX;
                        DSCAL (N - KI + 1, REC, WORK (KI + N)'Address, 1);
                        VMAX  := ONE;
                        VCRIT := BIGNUM;
                     end if;
                     --
                     WORK (J + N) := WORK (J + N) -
                                     DDOT (J - KI - 1, T (KI + 1, J)'Address, 1, WORK (KI + 1 + N)'Address, 1);
                     --
                     WORK (J + 1 + N) := WORK (J + 1 + N) -
                                         DDOT (J - KI - 1, T (KI + 1, J + 1)'Address, 1, WORK (KI + 1 + N)'Address, 1);
                     --
                     --                    Solve
                     --                      [T(J,J)-WR   T(J,J+1)     ]**T * X = SCALE*( WORK1 )
                     --                      [T(J+1,J)    T(J+1,J+1)-WR]                ( WORK2 )
                     --
                     DLALN2
                       (True,
                        2,
                        1,
                        SMIN,
                        ONE,
                        T (J, J)'Address,
                        LDT,
                        ONE,
                        ONE,
                        WORK (J + N)'Address,
                        N,
                        WR,
                        ZERO,
                        X'Address,
                        2,
                        SCALE,
                        XNORM,
                        IERR);
                     --
                     --                    Scale if necessary
                     --
                     if SCALE /= ONE then
                        DSCAL (N - KI + 1, SCALE, WORK (KI + N)'Address, 1);
                     end if;
                     WORK (J + N)     := X (1, 1);
                     WORK (J + 1 + N) := X (2, 1);
                     --
                     VMAX  := max (abs (WORK (J + N)), abs (WORK (J + 1 + N)), VMAX);
                     VCRIT := BIGNUM / VMAX;
                     --
                  end if;
                  <<L170>> null;
               end loop;
               --
               --              Copy the vector x or Q*x to VL and normalize.
               --
               if not OVER then
                  DCOPY (N - KI + 1, WORK (KI + N)'Address, 1, VL (KI, the_IS)'Address, 1);
                  --
                  II    := IDAMAX (N - KI + 1, VL (KI, the_IS)'Address, 1) + KI - 1;
                  REMAX := ONE / abs (VL (II, the_IS));
                  DSCAL (N - KI + 1, REMAX, VL (KI, the_IS)'Address, 1);
                  --
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > KI - 1;
                     VL (K, the_IS) := ZERO;
                  end loop;
               --
               else
                  --
                  if KI < N then
                     DGEMV
                       ('N',
                        N,
                        N - KI,
                        ONE,
                        VL (1, KI + 1)'Address,
                        LDVL,
                        WORK (KI + 1 + N)'Address,
                        1,
                        WORK (KI + N),
                        VL (1, KI)'Address,
                        1);
                  end if;
                  --
                  II    := IDAMAX (N, VL (1, KI)'Address, 1);
                  REMAX := ONE / abs (VL (II, KI));
                  DSCAL (N, REMAX, VL (1, KI)'Address, 1);
                  --
               end if;
            --
            else
               --
               --              Complex left eigenvector.
               --
               --               Initial solve:
               --                 ((T(KI,KI)    T(KI,KI+1) )**T - (WR - I* WI))*X = 0.
               --                 ((T(KI+1,KI) T(KI+1,KI+1))                )
               --
               if abs (T (KI, KI + 1)) >= abs (T (KI + 1, KI)) then
                  WORK (KI + N)      := WI / T (KI, KI + 1);
                  WORK (KI + 1 + N2) := ONE;
               else
                  WORK (KI + N)      := ONE;
                  WORK (KI + 1 + N2) := -WI / T (KI + 1, KI);
               end if;
               WORK (KI + 1 + N) := ZERO;
               WORK (KI + N2)    := ZERO;
               --
               --              Form right-hand side
               --
               K := KI + 2 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  WORK (K + N)  := -WORK (KI + N) * T (KI, K);
                  WORK (K + N2) := -WORK (KI + 1 + N2) * T (KI + 1, K);
               end loop;
               --
               --              Solve complex quasi-triangular system:
               --              ( T(KI+2,N:KI+2,N) - (WR-i*WI) )*X = WORK1+i*WORK2
               --
               VMAX  := ONE;
               VCRIT := BIGNUM;
               --
               JNXT := KI + 2;
               J    := KI + 2 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if J < JNXT then
                     goto L200;
                  end if;
                  J1   := J;
                  J2   := J;
                  JNXT := J + 1;
                  if J < N then
                     if T (J + 1, J) /= ZERO then
                        J2   := J + 1;
                        JNXT := J + 2;
                     end if;
                  end if;
                  --
                  if J1 = J2 then
                     --
                     --                    1-by-1 diagonal block
                     --
                     --                    Scale if necessary to avoid overflow when
                     --                    forming the right-hand side elements.
                     --
                     if WORK (J) > VCRIT then
                        REC := ONE / VMAX;
                        DSCAL (N - KI + 1, REC, WORK (KI + N)'Address, 1);
                        DSCAL (N - KI + 1, REC, WORK (KI + N2)'Address, 1);
                        VMAX  := ONE;
                        VCRIT := BIGNUM;
                     end if;
                     --
                     WORK (J + N)  := WORK (J + N) -
                                      DDOT (J - KI - 2, T (KI + 2, J)'Address, 1, WORK (KI + 2 + N)'Address, 1);
                     WORK (J + N2) := WORK (J + N2) -
                                      DDOT (J - KI - 2, T (KI + 2, J)'Address, 1, WORK (KI + 2 + N2)'Address, 1);
                     --
                     --                    Solve (T(J,J)-(WR-i*WI))*(X11+i*X12)= WK+I*WK2
                     --
                     DLALN2
                       (False,
                        1,
                        2,
                        SMIN,
                        ONE,
                        T (J, J)'Address,
                        LDT,
                        ONE,
                        ONE,
                        WORK (J + N)'Address,
                        N,
                        WR,
                        -WI,
                        X'Address,
                        2,
                        SCALE,
                        XNORM,
                        IERR);
                     --
                     --                    Scale if necessary
                     --
                     if SCALE /= ONE then
                        DSCAL (N - KI + 1, SCALE, WORK (KI + N)'Address, 1);
                        DSCAL (N - KI + 1, SCALE, WORK (KI + N2)'Address, 1);
                     end if;
                     WORK (J + N)  := X (1, 1);
                     WORK (J + N2) := X (1, 2);
                     VMAX          := max (abs (WORK (J + N)), abs (WORK (J + N2)), VMAX);
                     VCRIT         := BIGNUM / VMAX;
                  --
                  else
                     --
                     --                    2-by-2 diagonal block
                     --
                     --                    Scale if necessary to avoid overflow when forming
                     --                    the right-hand side elements.
                     --
                     BETA := max (WORK (J), WORK (J + 1));
                     if BETA > VCRIT then
                        REC := ONE / VMAX;
                        DSCAL (N - KI + 1, REC, WORK (KI + N)'Address, 1);
                        DSCAL (N - KI + 1, REC, WORK (KI + N2)'Address, 1);
                        VMAX  := ONE;
                        VCRIT := BIGNUM;
                     end if;
                     --
                     WORK (J + N) := WORK (J + N) -
                                     DDOT (J - KI - 2, T (KI + 2, J)'Address, 1, WORK (KI + 2 + N)'Address, 1);
                     --
                     WORK (J + N2) := WORK (J + N2) -
                                      DDOT (J - KI - 2, T (KI + 2, J)'Address, 1, WORK (KI + 2 + N2)'Address, 1);
                     --
                     WORK (J + 1 + N) := WORK (J + 1 + N) -
                                         DDOT (J - KI - 2, T (KI + 2, J + 1)'Address, 1, WORK (KI + 2 + N)'Address, 1);
                     --
                     WORK (J + 1 + N2) := WORK (J + 1 + N2) -
                                          DDOT (J - KI - 2, T (KI + 2, J + 1)'Address, 1, WORK (KI + 2 + N2)'Address, 1);
                     --
                     --                    Solve 2-by-2 complex linear equation
                     --                      ([T(j,j)   T(j,j+1)  ]**T-(wr-i*wi)*I)*X = SCALE*B
                     --                      ([T(j+1,j) T(j+1,j+1)]               )
                     --
                     DLALN2
                       (True,
                        2,
                        2,
                        SMIN,
                        ONE,
                        T (J, J)'Address,
                        LDT,
                        ONE,
                        ONE,
                        WORK (J + N)'Address,
                        N,
                        WR,
                        -WI,
                        X'Address,
                        2,
                        SCALE,
                        XNORM,
                        IERR);
                     --
                     --                    Scale if necessary
                     --
                     if SCALE /= ONE then
                        DSCAL (N - KI + 1, SCALE, WORK (KI + N)'Address, 1);
                        DSCAL (N - KI + 1, SCALE, WORK (KI + N2)'Address, 1);
                     end if;
                     WORK (J + N)      := X (1, 1);
                     WORK (J + N2)     := X (1, 2);
                     WORK (J + 1 + N)  := X (2, 1);
                     WORK (J + 1 + N2) := X (2, 2);
                     VMAX              := max (abs (X (1, 1)), abs (X (1, 2)), abs (X (2, 1)), abs (X (2, 2)), VMAX);
                     VCRIT             := BIGNUM / VMAX;
                     --
                  end if;
                  <<L200>> null;
               end loop;
               --
               --              Copy the vector x or Q*x to VL and normalize.
               --
               if not OVER then
                  DCOPY (N - KI + 1, WORK (KI + N)'Address, 1, VL (KI, the_IS)'Address, 1);
                  DCOPY (N - KI + 1, WORK (KI + N2)'Address, 1, VL (KI, the_IS + 1)'Address, 1);
                  --
                  EMAX := ZERO;
                  K    := KI - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     EMAX := max (EMAX, abs (VL (K, the_IS)) + abs (VL (K, the_IS + 1)));
                  end loop;
                  REMAX := ONE / EMAX;
                  DSCAL (N - KI + 1, REMAX, VL (KI, the_IS)'Address, 1);
                  DSCAL (N - KI + 1, REMAX, VL (KI, the_IS + 1)'Address, 1);
                  --
                  K := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > KI - 1;
                     VL (K, the_IS)     := ZERO;
                     VL (K, the_IS + 1) := ZERO;
                  end loop;
               else
                  if KI < N - 1 then
                     DGEMV
                       ('N',
                        N,
                        N - KI - 1,
                        ONE,
                        VL (1, KI + 2)'Address,
                        LDVL,
                        WORK (KI + 2 + N)'Address,
                        1,
                        WORK (KI + N),
                        VL (1, KI)'Address,
                        1);
                     DGEMV
                       ('N',
                        N,
                        N - KI - 1,
                        ONE,
                        VL (1, KI + 2)'Address,
                        LDVL,
                        WORK (KI + 2 + N2)'Address,
                        1,
                        WORK (KI + 1 + N2),
                        VL (1, KI + 1)'Address,
                        1);
                  else
                     DSCAL (N, WORK (KI + N), VL (1, KI)'Address, 1);
                     DSCAL (N, WORK (KI + 1 + N2), VL (1, KI + 1)'Address, 1);
                  end if;
                  --
                  EMAX := ZERO;
                  K    := 1 - 1;
                  loop
                     K := K + 1;
                     exit when K > N;
                     EMAX := max (EMAX, abs (VL (K, KI)) + abs (VL (K, KI + 1)));
                  end loop;
                  REMAX := ONE / EMAX;
                  DSCAL (N, REMAX, VL (1, KI)'Address, 1);
                  DSCAL (N, REMAX, VL (1, KI + 1)'Address, 1);
                  --
               end if;
               --
            end if;
            --
            the_IS := the_IS + 1;
            if IP /= 0 then
               the_IS := the_IS + 1;
            end if;
            <<L250>> null;
            if IP = -1 then
               IP := 0;
            end if;
            if IP = 1 then
               IP := -1;
            end if;
            --
         end loop;
         --
      end if;
      --
      return;
      --
      --     End of DTREVC
      --
   end DTREVC;

   procedure DTREXC
     (COMPQ : Character;
      N     : Integer;
      T     : in out Ftn_Real_Matrix;
      LDT   : Integer;
      Q     : in out Ftn_Real_Matrix;
      LDQ   : Integer;
      IFST  : in out Integer;
      ILST  : in out Integer;
      WORK  : in out Ftn_Real_Vector;
      INFO  : in out Integer)
   is
      ZERO   : constant Real := 0.0e0;
      WANTQ  : Boolean;
      HERE   : Integer;
      NBF    : Integer;
      NBL    : Integer;
      NBNEXT : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DTREXC( COMPQ, N, T, LDT, Q, LDQ, IFST, ILST, WORK,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          COMPQ
   --       INTEGER            IFST, ILST, INFO, LDQ, LDT, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   Q( LDQ, * ), T( LDT, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DTREXC reorders the real Schur factorization of a real matrix
   --  A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
   --  moved to row ILST.
   --
   --  The real Schur form T is reordered by an orthogonal similarity
   --  transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
   --  is updated by postmultiplying it with Z.
   --
   --  T must be in Schur canonical form (as returned by DHSEQR), that is,
   --  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
   --  2-by-2 diagonal block has its diagonal elements equal and its
   --  off-diagonal elements of opposite sign.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] COMPQ
   --           COMPQ is CHARACTER*1
   --           = 'V':  update the matrix Q of Schur vectors;
   --           = 'N':  do not update Q.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix T. N >= 0.
   --
   --  [in,out] T
   --           T is DOUBLE PRECISION array, dimension (LDT,N)
   --           On entry, the upper quasi-triangular matrix T, in Schur
   --           Schur canonical form.
   --           On exit, the reordered upper quasi-triangular matrix, again
   --           in Schur canonical form.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= max(1,N).
   --
   --  [in,out] Q
   --           Q is DOUBLE PRECISION array, dimension (LDQ,N)
   --           On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
   --           On exit, if COMPQ = 'V', Q has been postmultiplied by the
   --           orthogonal transformation matrix Z which reorders T.
   --           If COMPQ = 'N', Q is not referenced.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --           The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [in,out] IFST
   --           IFST is INTEGER
   --
   --  [in,out] ILST
   --           ILST is INTEGER
   --
   --           Specify the reordering of the diagonal blocks of T.
   --           The block with row index IFST is moved to row ILST, by a
   --           sequence of transpositions between adjacent blocks.
   --           On exit, if IFST pointed on entry to the second row of a
   --           2-by-2 block, it is changed to point to the first row; ILST
   --           always points to the first row of the block in its final
   --           position (which may differ from its input value by +1 or -1).
   --           1 <= IFST <= N; 1 <= ILST <= N.
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           = 1:  two adjacent blocks were too close to swap (the problem
   --                 is very ill-conditioned); T may have been partially
   --                 reordered, and ILST points to the first row of the
   --                 current position of the block being moved.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLAEXC, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Decode and test the input arguments.
   --
   begin
      INFO  := 0;
      WANTQ := LSAME (COMPQ, 'V');
      if not WANTQ and not LSAME (COMPQ, 'N') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDT < max (1, N) then
         INFO := -4;
      elsif LDQ < 1 or (WANTQ and LDQ < max (1, N)) then
         INFO := -6;
      elsif IFST < 1 or IFST > N then
         INFO := -7;
      elsif ILST < 1 or ILST > N then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("DTREXC", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 1 then
         return;
      end if;
      --
      --     Determine the first row of specified block
      --     and find out it is 1 by 1 or 2 by 2.
      --
      if IFST > 1 then
         if T (IFST, IFST - 1) /= ZERO then
            IFST := IFST - 1;
         end if;
      end if;
      NBF := 1;
      if IFST < N then
         if T (IFST + 1, IFST) /= ZERO then
            NBF := 2;
         end if;
      end if;
      --
      --     Determine the first row of the final block
      --     and find out it is 1 by 1 or 2 by 2.
      --
      if ILST > 1 then
         if T (ILST, ILST - 1) /= ZERO then
            ILST := ILST - 1;
         end if;
      end if;
      NBL := 1;
      if ILST < N then
         if T (ILST + 1, ILST) /= ZERO then
            NBL := 2;
         end if;
      end if;
      --
      if IFST = ILST then
         return;
      end if;
      --
      if IFST < ILST then
         --
         --        Update ILST
         --
         if NBF = 2 and NBL = 1 then
            ILST := ILST - 1;
         end if;
         if NBF = 1 and NBL = 2 then
            ILST := ILST + 1;
         end if;
         --
         HERE := IFST;
         --
         <<L10>> null;
         --
         --        Swap block with next one below
         --
         if NBF = 1 or NBF = 2 then
            --
            --           Current block either 1 by 1 or 2 by 2
            --
            NBNEXT := 1;
            if HERE + NBF + 1 <= N then
               if T (HERE + NBF + 1, HERE + NBF) /= ZERO then
                  NBNEXT := 2;
               end if;
            end if;
            DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE, NBF, NBNEXT, WORK, INFO);
            if INFO /= 0 then
               ILST := HERE;
               return;
            end if;
            HERE := HERE + NBNEXT;
            --
            --           Test if 2 by 2 block breaks into two 1 by 1 blocks
            --
            if NBF = 2 then
               if T (HERE + 1, HERE) = ZERO then
                  NBF := 3;
               end if;
            end if;
         --
         else
            --
            --           Current block consists of two 1 by 1 blocks each of which
            --           must be swapped individually
            --
            NBNEXT := 1;
            if HERE + 3 <= N then
               if T (HERE + 3, HERE + 2) /= ZERO then
                  NBNEXT := 2;
               end if;
            end if;
            DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE + 1, 1, NBNEXT, WORK, INFO);
            if INFO /= 0 then
               ILST := HERE;
               return;
            end if;
            if NBNEXT = 1 then
               --
               --              Swap two 1 by 1 blocks, no problems possible
               --
               DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE, 1, NBNEXT, WORK, INFO);
               HERE := HERE + 1;
            else
               --
               --              Recompute NBNEXT in case 2 by 2 split
               --
               if T (HERE + 2, HERE + 1) = ZERO then
                  NBNEXT := 1;
               end if;
               if NBNEXT = 2 then
                  --
                  --                 2 by 2 Block did not split
                  --
                  DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE, 1, NBNEXT, WORK, INFO);
                  if INFO /= 0 then
                     ILST := HERE;
                     return;
                  end if;
                  HERE := HERE + 2;
               else
                  --
                  --                 2 by 2 Block did split
                  --
                  DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE, 1, 1, WORK, INFO);
                  DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE + 1, 1, 1, WORK, INFO);
                  HERE := HERE + 2;
               end if;
            end if;
         end if;
         if HERE < ILST then
            goto L10;
         end if;
      --
      else
         --
         HERE := IFST;
         <<L20>> null;
         --
         --        Swap block with next one above
         --
         if NBF = 1 or NBF = 2 then
            --
            --           Current block either 1 by 1 or 2 by 2
            --
            NBNEXT := 1;
            if HERE >= 3 then
               if T (HERE - 1, HERE - 2) /= ZERO then
                  NBNEXT := 2;
               end if;
            end if;
            DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE - NBNEXT, NBNEXT, NBF, WORK, INFO);
            if INFO /= 0 then
               ILST := HERE;
               return;
            end if;
            HERE := HERE - NBNEXT;
            --
            --           Test if 2 by 2 block breaks into two 1 by 1 blocks
            --
            if NBF = 2 then
               if T (HERE + 1, HERE) = ZERO then
                  NBF := 3;
               end if;
            end if;
         --
         else
            --
            --           Current block consists of two 1 by 1 blocks each of which
            --           must be swapped individually
            --
            NBNEXT := 1;
            if HERE >= 3 then
               if T (HERE - 1, HERE - 2) /= ZERO then
                  NBNEXT := 2;
               end if;
            end if;
            DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE - NBNEXT, NBNEXT, 1, WORK, INFO);
            if INFO /= 0 then
               ILST := HERE;
               return;
            end if;
            if NBNEXT = 1 then
               --
               --              Swap two 1 by 1 blocks, no problems possible
               --
               DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE, NBNEXT, 1, WORK, INFO);
               HERE := HERE - 1;
            else
               --
               --              Recompute NBNEXT in case 2 by 2 split
               --
               if T (HERE, HERE - 1) = ZERO then
                  NBNEXT := 1;
               end if;
               if NBNEXT = 2 then
                  --
                  --                 2 by 2 Block did not split
                  --
                  DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE - 1, 2, 1, WORK, INFO);
                  if INFO /= 0 then
                     ILST := HERE;
                     return;
                  end if;
                  HERE := HERE - 2;
               else
                  --
                  --                 2 by 2 Block did split
                  --
                  DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE, 1, 1, WORK, INFO);
                  DLAEXC (WANTQ, N, T, LDT, Q, LDQ, HERE - 1, 1, 1, WORK, INFO);
                  HERE := HERE - 2;
               end if;
            end if;
         end if;
         if HERE > ILST then
            goto L20;
         end if;
      end if;
      ILST := HERE;
      --
      return;
      --
      --     End of DTREXC
      --
   end DTREXC;

   procedure DTRTI2
     (UPLO  : Character;
      DIAG  : Character;
      N     : Integer;
      A_adr : Address;
      LDA   : Integer;
      INFO  : in out Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);

      for A'Address use A_adr;

      pragma Import (Ada, A);

      ONE    : constant Real := 1.0e0;
      NOUNIT : Boolean;
      UPPER  : Boolean;
      J      : Integer;
      AJJ    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DTRTI2( UPLO, DIAG, N, A, LDA, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIAG, UPLO
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DTRTI2 computes the inverse of a real upper or lower triangular
   --  matrix.
   --
   --  This is the Level 2 BLAS version of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the matrix A is upper or lower triangular.
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --           Specifies whether or not the matrix A is unit triangular.
   --           = 'N':  Non-unit triangular
   --           = 'U':  Unit triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the triangular matrix A.  If UPLO = 'U', the
   --           leading n by n upper triangular part of the array A contains
   --           the upper triangular matrix, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n by n lower triangular part of the array A contains
   --           the lower triangular matrix, and the strictly upper
   --           triangular part of A is not referenced.  If DIAG = 'U', the
   --           diagonal elements of A are also not referenced and are
   --           assumed to be 1.
   --
   --           On exit, the (triangular) inverse of the original matrix, in
   --           the same storage format.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -k, the k-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DSCAL, DTRMV, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      NOUNIT := LSAME (DIAG, 'N');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif not NOUNIT and not LSAME (DIAG, 'U') then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("DTRTI2", -INFO);
         return;
      end if;
      --
      if UPPER then
         --
         --        Compute inverse of upper triangular matrix.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if NOUNIT then
               A (J, J) := ONE / A (J, J);
               AJJ      := -A (J, J);
            else
               AJJ := -ONE;
            end if;
            --
            --           Compute elements 1:j-1 of j-th column.
            --
            DTRMV ('U', 'N', DIAG, J - 1, A'Address, LDA, A (1, J)'Address, 1);
            DSCAL (J - 1, AJJ, A (1, J)'Address, 1);
         end loop;
      else
         --
         --        Compute inverse of lower triangular matrix.
         --
         J := N + 1;
         loop
            J := J - 1;
            exit when J < 1;
            if NOUNIT then
               A (J, J) := ONE / A (J, J);
               AJJ      := -A (J, J);
            else
               AJJ := -ONE;
            end if;
            if J < N then
               --
               --              Compute elements j+1:n of j-th column.
               --
               DTRMV ('L', 'N', DIAG, N - J, A (J + 1, J + 1)'Address, LDA, A (J + 1, J)'Address, 1);
               DSCAL (N - J, AJJ, A (J + 1, J)'Address, 1);
            end if;
         end loop;
      end if;
      --
      return;
      --
      --     End of DTRTI2
      --
   end DTRTI2;

   procedure DTRTRI
     (UPLO : Character;
      DIAG : Character;
      N    : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer;
      INFO : in out Integer)
   is
      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
      NOUNIT : Boolean;
      UPPER  : Boolean;
      J      : Integer;
      JB     : Integer;
      NB     : Integer;
      NN     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE DTRTRI( UPLO, DIAG, N, A, LDA, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIAG, UPLO
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  DTRTRI computes the inverse of a real upper or lower triangular
   --  matrix A.
   --
   --  This is the Level 3 BLAS version of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  A is upper triangular;
   --           = 'L':  A is lower triangular.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --           = 'N':  A is non-unit triangular;
   --           = 'U':  A is unit triangular.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           On entry, the triangular matrix A.  If UPLO = 'U', the
   --           leading N-by-N upper triangular part of the array A contains
   --           the upper triangular matrix, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading N-by-N lower triangular part of the array A contains
   --           the lower triangular matrix, and the strictly upper
   --           triangular part of A is not referenced.  If DIAG = 'U', the
   --           diagonal elements of A are also not referenced and are
   --           assumed to be 1.
   --           On exit, the (triangular) inverse of the original matrix, in
   --           the same storage format.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --           > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
   --                matrix is singular and its inverse can not be computed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DTRMM, DTRSM, DTRTI2, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      NOUNIT := LSAME (DIAG, 'N');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif not NOUNIT and not LSAME (DIAG, 'U') then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("DTRTRI", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     Check for singularity if non-unit.
      --
      if NOUNIT then
         INFO := 1 - 1;
         loop
            INFO := INFO + 1;
            exit when INFO > N;
            if A (INFO, INFO) = ZERO then
               return;
            end if;
         end loop;
         INFO := 0;
      end if;
      --
      --     Determine the block size for this environment.
      --
      NB := ILAENV (1, "DTRTRI", UPLO & DIAG, N, -1, -1, -1);
      if NB <= 1 or NB >= N then
         --
         --        Use unblocked code
         --
         DTRTI2 (UPLO, DIAG, N, A'Address, LDA, INFO);
      else
         --
         --        Use blocked code
         --
         if UPPER then
            --
            --           Compute inverse of upper triangular matrix
            --
            J := 1 - NB;
            loop
               J := J + NB;
               exit when J > N;
               JB := min (NB, N - J + 1);
               --
               --              Compute rows 1:j-1 of current block column
               --
               DTRMM ('L', 'U', 'N', DIAG, J - 1, JB, ONE, A'Address, LDA, A (1, J)'Address, LDA);
               DTRSM ('R', 'U', 'N', DIAG, J - 1, JB, -ONE, A (J, J)'Address, LDA, A (1, J)'Address, LDA);
               --
               --              Compute inverse of current diagonal block
               --
               DTRTI2 ('U', DIAG, JB, A (J, J)'Address, LDA, INFO);
            end loop;
         else
            --
            --           Compute inverse of lower triangular matrix
            --
            NN := ((N - 1) / NB) * NB + 1;
            J  := NN + NB;
            loop
               J := J - NB;
               exit when J < 1;
               JB := min (NB, N - J + 1);
               if J + JB <= N then
                  --
                  --                 Compute rows j+jb:n of current block column
                  --
                  DTRMM
                    ('L',
                     'L',
                     'N',
                     DIAG,
                     N - J - JB + 1,
                     JB,
                     ONE,
                     A (J + JB, J + JB)'Address,
                     LDA,
                     A (J + JB, J)'Address,
                     LDA);
                  DTRSM ('R', 'L', 'N', DIAG, N - J - JB + 1, JB, -ONE, A (J, J)'Address, LDA, A (J + JB, J)'Address, LDA);
               end if;
               --
               --              Compute inverse of current diagonal block
               --
               DTRTI2 ('L', DIAG, JB, A (J, J)'Address, LDA, INFO);
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of DTRTRI
      --
   end DTRTRI;

   function IEEECK
     (ISPEC : Integer;
      ZERO  : Real;
      ONE   : Real)
      return  Integer
   is
      NAN1          : Real;
      NAN2          : Real;
      NAN3          : Real;
      NAN4          : Real;
      NAN5          : Real;
      NAN6          : Real;
      NEGINF        : Real;
      NEGZRO        : Real;
      NEWZRO        : Real;
      POSINF        : Real;
      IEEECK_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER          FUNCTION IEEECK( ISPEC, ZERO, ONE )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            ISPEC
   --       REAL               ONE, ZERO
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  IEEECK is called from the ILAENV to verify that Infinity and
   --  possibly NaN arithmetic is safe (i.e. will not trap).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ISPEC
   --           ISPEC is INTEGER
   --           Specifies whether to test just for inifinity arithmetic
   --           or whether to test for infinity and NaN arithmetic.
   --           = 0: Verify infinity arithmetic only.
   --           = 1: Verify infinity and NaN arithmetic.
   --
   --  [in] ZERO
   --           ZERO is REAL
   --           Must contain the value 0.0
   --           This is passed to prevent the compiler from optimizing
   --           away this code.
   --
   --  [in] ONE
   --           ONE is REAL
   --           Must contain the value 1.0
   --           This is passed to prevent the compiler from optimizing
   --           away this code.
   --
   --   RETURN VALUE:  INTEGER
   --           = 0:  Arithmetic failed to produce the correct answers
   --           = 1:  Arithmetic produced the correct answers
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   begin
      IEEECK_Result := 1;
      --
      POSINF := ONE / ZERO;
      if POSINF <= ONE then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      NEGINF := -ONE / ZERO;
      if NEGINF >= ZERO then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      NEGZRO := ONE / (NEGINF + ONE);
      if NEGZRO /= ZERO then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      NEGINF := ONE / NEGZRO;
      if NEGINF >= ZERO then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      NEWZRO := NEGZRO + ZERO;
      if NEWZRO /= ZERO then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      POSINF := ONE / NEWZRO;
      if POSINF <= ONE then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      NEGINF := NEGINF * POSINF;
      if NEGINF >= ZERO then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      POSINF := POSINF * POSINF;
      if POSINF <= ONE then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      --
      --
      --
      --     Return if we were only asked to check infinity arithmetic
      --
      if ISPEC = 0 then
         return IEEECK_Result;
      end if;
      --
      NAN1 := POSINF + NEGINF;
      --
      NAN2 := POSINF / NEGINF;
      --
      NAN3 := POSINF / POSINF;
      --
      NAN4 := POSINF * ZERO;
      --
      NAN5 := NEGINF * NEGZRO;
      --
      NAN6 := NAN5 * ZERO;
      --
      if NAN1 = NAN1 then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      if NAN2 = NAN2 then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      if NAN3 = NAN3 then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      if NAN4 = NAN4 then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      if NAN5 = NAN5 then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      if NAN6 = NAN6 then
         IEEECK_Result := 0;
         return IEEECK_Result;
      end if;
      --
      return IEEECK_Result;
   end IEEECK;

   function ILADLC
     (M    : Integer;
      N    : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer)
      return Integer
   is
      ZERO          : constant Real := 0.0e0;
      I             : Integer;
      ILADLC_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER FUNCTION ILADLC( M, N, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            M, N, LDA
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ILADLC scans A for its last non-zero column.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The m by n matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick test for the common case where one corner is non-zero.
   begin
      if N = 0 then
         ILADLC_Result := N;
      elsif A (1, N) /= ZERO or A (M, N) /= ZERO then
         ILADLC_Result := N;
      else
         --     Now scan each column from the end, returning with the first non-zero.
         ILADLC_Result := N + 1;
         loop
            ILADLC_Result := ILADLC_Result - 1;
            exit when ILADLC_Result < 1;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               if A (I, ILADLC_Result) /= ZERO then
                  return ILADLC_Result;
               end if;
            end loop;
         end loop;
      end if;
      return ILADLC_Result;
   end ILADLC;

   function ILADLR
     (M    : Integer;
      N    : Integer;
      A    : in out Ftn_Real_Matrix;
      LDA  : Integer)
      return Integer
   is
      ZERO          : constant Real := 0.0e0;
      I             : Integer;
      J             : Integer;
      ILADLR_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER FUNCTION ILADLR( M, N, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            M, N, LDA
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ILADLR scans A for its last non-zero row.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The m by n matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick test for the common case where one corner is non-zero.
   begin
      if M = 0 then
         ILADLR_Result := M;
      elsif A (M, 1) /= ZERO or A (M, N) /= ZERO then
         ILADLR_Result := M;
      else
         --     Scan up each column tracking the last zero row seen.
         ILADLR_Result := 0;
         J             := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := M;
            while (A (max (I, 1), J) = ZERO) and (I >= 1) loop
               I := I - 1;
            end loop;
            ILADLR_Result := max (ILADLR_Result, I);
         end loop;
      end if;
      return ILADLR_Result;
   end ILADLR;

   function ILAENV
     (ISPEC : Integer;
      NAME  : String;
      OPTS  : String;
      N1    : Integer;
      N2    : Integer;
      N3    : Integer;
      N4    : Integer)
      return  Integer
   is
      I             : Integer;
      IC            : Integer;
      IZ            : Integer;
      NB            : Integer;
      NBMIN         : Integer;
      NX            : Integer;
      CNAME         : Boolean;
      SNAME         : Boolean;
      C1            : Character;
      C2            : String (1 .. 2);
      C4            : String (1 .. 2);
      C3            : String (1 .. 3);
      SUBNAM        : String (1 .. 6);
      ILAENV_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER*( * )    NAME, OPTS
   --       INTEGER            ISPEC, N1, N2, N3, N4
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ILAENV is called from the LAPACK routines to choose problem-dependent
   --  parameters for the local environment.  See ISPEC for a description of
   --  the parameters.
   --
   --  ILAENV returns an INTEGER
   --  if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC
   --  if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal value.
   --
   --  This version provides a set of parameters which should give good,
   --  but not optimal, performance on many of the currently available
   --  computers.  Users are encouraged to modify this subroutine to set
   --  the tuning parameters for their particular machine using the option
   --  and problem size information in the arguments.
   --
   --  This routine will not function correctly if it is converted to all
   --  lower case.  Converting it to all upper case is allowed.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ISPEC
   --           ISPEC is INTEGER
   --           Specifies the parameter to be returned as the value of
   --           ILAENV.
   --           = 1: the optimal blocksize; if this value is 1, an unblocked
   --                algorithm will give the best performance.
   --           = 2: the minimum block size for which the block routine
   --                should be used; if the usable block size is less than
   --                this value, an unblocked routine should be used.
   --           = 3: the crossover point (in a block routine, for N less
   --                than this value, an unblocked routine should be used)
   --           = 4: the number of shifts, used in the nonsymmetric
   --                eigenvalue routines (DEPRECATED)
   --           = 5: the minimum column dimension for blocking to be used;
   --                rectangular blocks must have dimension at least k by m,
   --                where k is given by ILAENV(2,...) and m by ILAENV(5,...)
   --           = 6: the crossover point for the SVD (when reducing an m by n
   --                matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
   --                this value, a QR factorization is used first to reduce
   --                the matrix to a triangular form.)
   --           = 7: the number of processors
   --           = 8: the crossover point for the multishift QR method
   --                for nonsymmetric eigenvalue problems (DEPRECATED)
   --           = 9: maximum size of the subproblems at the bottom of the
   --                computation tree in the divide-and-conquer algorithm
   --                (used by xGELSD and xGESDD)
   --           =10: ieee NaN arithmetic can be trusted not to trap
   --           =11: infinity arithmetic can be trusted not to trap
   --           12 <= ISPEC <= 16:
   --                xHSEQR or one of its subroutines,
   --                see IPARMQ for detailed explanation
   --
   --  [in] NAME
   --           NAME is CHARACTER*(*)
   --           The name of the calling subroutine, in either upper case or
   --           lower case.
   --
   --  [in] OPTS
   --           OPTS is CHARACTER*(*)
   --           The character options to the subroutine NAME, concatenated
   --           into a single character string.  For example, UPLO = 'U',
   --           TRANS = 'T', and DIAG = 'N' for a triangular routine would
   --           be specified as OPTS = 'UTN'.
   --
   --  [in] N1
   --           N1 is INTEGER
   --
   --  [in] N2
   --           N2 is INTEGER
   --
   --  [in] N3
   --           N3 is INTEGER
   --
   --  [in] N4
   --           N4 is INTEGER
   --           Problem dimensions for the subroutine NAME; these may not all
   --           be required.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The following conventions have been used when calling ILAENV from the
   --   LAPACK routines:
   --   (1)  OPTS is a concatenation of all of the character options to
   --        subroutine NAME, in the same order that they appear in the
   --        argument list for NAME, even if they are not used in determining
   --        the value of the parameter specified by ISPEC.
   --   (2)  The problem dimensions N1, N2, N3, N4 are specified in the order
   --        that they appear in the argument list for NAME.  N1 is used
   --        first, N2 second, and so on, and unused problem dimensions are
   --        passed a value of -1.
   --   (3)  The parameter value returned by ILAENV is checked for validity in
   --        the calling subroutine.  For example, ILAENV is used to retrieve
   --        the optimal blocksize for STRTRI as follows:
   --
   --       NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
   --       IF( NB.LE.1 ) NB = MAX( 1, N )
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          CHAR, ICHAR, INT, MIN, REAL
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           IEEECK, IPARMQ
   --     ..
   --     .. Executable Statements ..
   --
   --
   --     Invalid value for ISPEC
   --
   begin
      if ISPEC = 1 or ISPEC = 2 or ISPEC = 3 then
         goto L10;
      elsif ISPEC = 4 then
         goto L80;
      elsif ISPEC = 5 then
         goto L90;
      elsif ISPEC = 6 then
         goto L100;
      elsif ISPEC = 7 then
         goto L110;
      elsif ISPEC = 8 then
         goto L120;
      elsif ISPEC = 9 then
         goto L130;
      elsif ISPEC = 10 then
         goto L140;
      elsif ISPEC = 11 then
         goto L150;
      elsif ISPEC = 12 or ISPEC = 13 or ISPEC = 14 or ISPEC = 15 or ISPEC = 16 then
         goto L160;
      end if;
      --
      --     Invalid value for ISPEC
      --
      ILAENV_Result := -1;
      return ILAENV_Result;
      --
      <<L10>> null;
      --
      --     Convert NAME to upper case if the first character is lower case.
      --
      ILAENV_Result := 1;
      SUBNAM        := NAME;
      IC            := ichar (SUBNAM (1));
      IZ            := ichar ('Z');
      if IZ = 90 or IZ = 122 then
         --
         --        ASCII character set
         --
         if IC >= 97 and IC <= 122 then
            SUBNAM (1) := char (IC - 32);
            I          := 2 - 1;
            loop
               I := I + 1;
               exit when I > 6;
               IC := ichar (SUBNAM (I));
               if IC >= 97 and IC <= 122 then
                  SUBNAM (I) := char (IC - 32);
               end if;
            end loop;
         end if;
      --
      elsif IZ = 233 or IZ = 169 then
         --
         --        EBCDIC character set
         --
         if (IC >= 129 and IC <= 137) or (IC >= 145 and IC <= 153) or (IC >= 162 and IC <= 169) then
            SUBNAM (1) := char (IC + 64);
            I          := 2 - 1;
            loop
               I := I + 1;
               exit when I > 6;
               IC := ichar (SUBNAM (I));
               if (IC >= 129 and IC <= 137) or (IC >= 145 and IC <= 153) or (IC >= 162 and IC <= 169) then
                  SUBNAM (I) := char (IC + 64);
               end if;
            end loop;
         end if;
      --
      elsif IZ = 218 or IZ = 250 then
         --
         --        Prime machines:  ASCII+128
         --
         if IC >= 225 and IC <= 250 then
            SUBNAM (1) := char (IC - 32);
            I          := 2 - 1;
            loop
               I := I + 1;
               exit when I > 6;
               IC := ichar (SUBNAM (I));
               if IC >= 225 and IC <= 250 then
                  SUBNAM (I) := char (IC - 32);
               end if;
            end loop;
         end if;
      end if;
      --
      C1    := SUBNAM (1);
      SNAME := (C1 = 'S' or C1 = 'D');
      CNAME := (C1 = 'C' or C1 = 'Z');
      if not (CNAME or SNAME) then
         return ILAENV_Result;
      end if;
      C2 := SUBNAM (2 .. 3);
      C3 := SUBNAM (4 .. 6);
      C4 := C3 (2 .. 3);
      --
      --       GO TO ( 50, 60, 70 )ISPEC
      if ISPEC = 1 then
         goto L50;
      elsif ISPEC = 2 then
         goto L60;
      elsif ISPEC = 3 then
         goto L70;
      end if;
      --
      <<L50>> null;
      --
      --     ISPEC = 1:  block size
      --
      --     In these examples, separate code is provided for setting NB for
      --     real and complex.  We assume that NB will take the same value in
      --     single or Real precision.
      --
      NB := 1;
      --
      if C2 = "GE" then
         if C3 = "TRF" then
            if SNAME 
               then NB := 64;
               else NB := 64;
            end if;
         elsif C3 = "QRF" or C3 = "RQF" or C3 = "LQF" or C3 = "QLF" then
            if SNAME 
               then NB := 32;
               else NB := 32;
            end if;
         elsif C3 = "HRD" then
            if SNAME 
               then NB := 32;
               else NB := 32;
            end if;
         elsif C3 = "BRD" then
            if SNAME 
               then NB := 32;
               else NB := 32;
            end if;
         elsif C3 = "TRI" then
            if SNAME 
               then NB := 64;
               else NB := 64;
            end if;
         end if;
      elsif C2 = "PO" then
         if C3 = "TRF" then
            if SNAME 
               then NB := 64;
               else NB := 64;
            end if;
         end if;
      elsif C2 = "SY" then
         if C3 = "TRF" then
            if SNAME 
               then NB := 64;
               else NB := 64;
            end if;
         elsif SNAME and C3 = "TRD" then
            NB := 32;
         elsif SNAME and C3 = "GST" then
            NB := 64;
         end if;
      elsif CNAME and C2 = "HE" then
         if C3 = "TRF" then
            NB := 64;
         elsif C3 = "TRD" then
            NB := 32;
         elsif C3 = "GST" then
            NB := 64;
         end if;
      elsif SNAME and C2 = "OR" then
         if C3 (1) = 'G' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NB := 32;
            end if;
         elsif C3 (1) = 'M' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NB := 32;
            end if;
         end if;
      elsif CNAME and C2 = "UN" then
         if C3 (1) = 'G' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NB := 32;
            end if;
         elsif C3 (1) = 'M' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NB := 32;
            end if;
         end if;
      elsif C2 = "GB" then
         if C3 = "TRF" then
            if SNAME then
               if N4 <= 64 
                  then NB := 1;
                  else NB := 32;
               end if;
            else
               if N4 <= 64 
                  then NB := 1;
                  else NB := 32;
               end if;
            end if;
         end if;
      elsif C2 = "PB" then
         if C3 = "TRF" then
            if SNAME then
               if N2 <= 64 
                  then NB := 1;
                  else NB := 32;
               end if;
            else
               if N2 <= 64 
                  then NB := 1;
                  else NB := 32;
               end if;
            end if;
         end if;
      elsif C2 = "TR" then
         if C3 = "TRI" then
            if SNAME 
               then NB := 64;
               else NB := 64;
            end if;
         end if;
      elsif C2 = "LA" then
         if C3 = "UUM" then
            if SNAME 
               then NB := 64;
               else NB := 64;
            end if;
         end if;
      elsif SNAME and C2 = "ST" then
         if C3 = "EBZ" then
            NB := 1;
         end if;
      end if;
      ILAENV_Result := NB;
      return ILAENV_Result;
      --
      <<L60>> null;
      --
      --     ISPEC = 2:  minimum block size
      --
      NBMIN := 2;
      if C2 = "GE" then
         if C3 = "QRF" or C3 = "RQF" or C3 = "LQF" or C3 = "QLF" then
            if SNAME 
               then NBMIN := 2;
               else NBMIN := 2;
            end if;
         elsif C3 = "HRD" then
            if SNAME 
               then NBMIN := 2;
               else NBMIN := 2;
            end if;
         elsif C3 = "BRD" then
            if SNAME 
               then NBMIN := 2;
               else NBMIN := 2;
            end if;
         elsif C3 = "TRI" then
            if SNAME 
               then NBMIN := 2;
               else NBMIN := 2;
            end if;
         end if;
      elsif C2 = "SY" then
         if C3 = "TRF" then
            if SNAME 
               then NBMIN := 8;
               else NBMIN := 8;
            end if;
         elsif SNAME and C3 = "TRD" then
            NBMIN := 2;
         end if;
      elsif CNAME and C2 = "HE" then
         if C3 = "TRD" then
            NBMIN := 2;
         end if;
      elsif SNAME and C2 = "OR" then
         if C3 (1) = 'G' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NBMIN := 2;
            end if;
         elsif C3 (1) = 'M' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NBMIN := 2;
            end if;
         end if;
      elsif CNAME and C2 = "UN" then
         if C3 (1) = 'G' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NBMIN := 2;
            end if;
         elsif C3 (1) = 'M' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NBMIN := 2;
            end if;
         end if;
      end if;
      ILAENV_Result := NBMIN;
      return ILAENV_Result;
      --
      <<L70>> null;
      --
      --     ISPEC = 3:  crossover point
      --
      NX := 0;
      if C2 = "GE" then
         if C3 = "QRF" or C3 = "RQF" or C3 = "LQF" or C3 = "QLF" then
            if SNAME 
               then NX := 128;
               else NX := 128;
            end if;
         elsif C3 = "HRD" then
            if SNAME 
               then NX := 128;
               else NX := 128;
            end if;
         elsif C3 = "BRD" then
            if SNAME 
               then NX := 128;
               else NX := 128;
            end if;
         end if;
      elsif C2 = "SY" then
         if SNAME and C3 = "TRD" then
            NX := 32;
         end if;
      elsif CNAME and C2 = "HE" then
         if C3 = "TRD" then
            NX := 32;
         end if;
      elsif SNAME and C2 = "OR" then
         if C3 (1) = 'G' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NX := 128;
            end if;
         end if;
      elsif CNAME and C2 = "UN" then
         if C3 (1) = 'G' then
            if C4 = "QR" or C4 = "RQ" or C4 = "LQ" or C4 = "QL" or C4 = "HR" or C4 = "TR" or C4 = "BR" then
               NX := 128;
            end if;
         end if;
      end if;
      ILAENV_Result := NX;
      return ILAENV_Result;
      --
      <<L80>> null;
      --
      --     ISPEC = 4:  number of shifts (used by xHSEQR)
      --
      ILAENV_Result := 6;
      return ILAENV_Result;
      --
      <<L90>> null;
      --
      --     ISPEC = 5:  minimum column dimension (not used)
      --
      ILAENV_Result := 2;
      return ILAENV_Result;
      --
      <<L100>> null;
      --
      --     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)
      --
      ILAENV_Result := int (Real (min (N1, N2)) * 1.6e0);
      return ILAENV_Result;
      --
      <<L110>> null;
      --
      --     ISPEC = 7:  number of processors (not used)
      --
      ILAENV_Result := 1;
      return ILAENV_Result;
      --
      <<L120>> null;
      --
      --     ISPEC = 8:  crossover point for multishift (used by xHSEQR)
      --
      ILAENV_Result := 50;
      return ILAENV_Result;
      --
      <<L130>> null;
      --
      --     ISPEC = 9:  maximum size of the subproblems at the bottom of the
      --                 computation tree in the divide-and-conquer algorithm
      --                 (used by xGELSD and xGESDD)
      --
      ILAENV_Result := 25;
      return ILAENV_Result;
      --
      <<L140>> null;
      --
      --     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap
      --
      --     ILAENV = 0
      ILAENV_Result := 1;
      if ILAENV_Result = 1 then
         ILAENV_Result := IEEECK (1, 0.0, 1.0);
      end if;
      return ILAENV_Result;
      --
      <<L150>> null;
      --
      --     ISPEC = 11: infinity arithmetic can be trusted not to trap
      --
      --     ILAENV = 0
      ILAENV_Result := 1;
      if ILAENV_Result = 1 then
         ILAENV_Result := IEEECK (0, 0.0, 1.0);
      end if;
      return ILAENV_Result;
      --
      <<L160>> null;
      --
      --     12 <= ISPEC <= 16: xHSEQR or one of its subroutines.
      --
      ILAENV_Result := IPARMQ (ISPEC, NAME, OPTS, N1, N2, N3, N4);
      return ILAENV_Result;
      --
      --     End of ILAENV
      --
   end ILAENV;

   function ILAZLC
     (M    : Integer;
      N    : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer)
      return Integer
   is
      ZERO          : constant Complex := (0.0e0, 0.0e0);
      I, J          : Integer;
      ILAZLC_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER FUNCTION ILAZLC( M, N, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            M, N, LDA
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ILAZLC scans A for its last non-zero column.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The m by n matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER ( ZERO = (0.0D+0, 0.0D+0) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick test for the common case where one corner is non-zero.
   begin
      if N = 0 then
         ILAZLC_Result := N;
      elsif A (1, N) /= ZERO or A (M, N) /= ZERO then
         ILAZLC_Result := N;
      else
         --     Now scan each column from the end, returning with the first non-zero.
         J := N + 1;
         loop
            J := J - 1;
            exit when J < 1;
            ILAZLC_Result := J;
            I             := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               if A (I, J) /= ZERO then
                  return ILAZLC_Result;
               end if;
            end loop;
         end loop;
      end if;
      return ILAZLC_Result;
   end ILAZLC;

   function ILAZLR
     (M    : Integer;
      N    : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer)
      return Integer
   is
      ZERO          : constant Complex := (0.0e0, 0.0e0);
      I             : Integer;
      J             : Integer;
      ILAZLR_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER FUNCTION ILAZLR( M, N, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            M, N, LDA
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ILAZLR scans A for its last non-zero row.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The m by n matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER ( ZERO = (0.0D+0, 0.0D+0) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick test for the common case where one corner is non-zero.
   begin
      if M = 0 then
         ILAZLR_Result := M;
      elsif A (M, 1) /= ZERO or A (M, N) /= ZERO then
         ILAZLR_Result := M;
      else
         --     Scan up each column tracking the last zero row seen.
         ILAZLR_Result := 0;
         J             := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := M;
            while (A (max (I, 1), J) = ZERO) and (I >= 1) loop
               I := I - 1;
            end loop;
            ILAZLR_Result := max (ILAZLR_Result, I);
         end loop;
      end if;
      return ILAZLR_Result;
   end ILAZLR;

   function IPARMQ
     (ISPEC : Integer;
      NAME  : String;
      OPTS  : String;
      N     : Integer;
      ILO   : Integer;
      IHI   : Integer;
      LWORK : Integer)
      return  Integer
   is
      INMIN         : constant Integer := 12;
      INWIN         : constant Integer := 13;
      INIBL         : constant Integer := 14;
      ISHFTS        : constant Integer := 15;
      IACC22        : constant Integer := 16;
      NMIN          : constant Integer := 75;
      K22MIN        : constant Integer := 14;
      KACMIN        : constant Integer := 14;
      NIBBLE        : constant Integer := 14;
      KNWSWP        : constant Integer := 500;
      TWO           : constant Real    := 2.0e0;
      NH            : Integer;
      NS            : Integer;
      IPARMQ_Result : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       INTEGER FUNCTION IPARMQ( ISPEC, NAME, OPTS, N, ILO, IHI, LWORK )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, ISPEC, LWORK, N
   --       CHARACTER          NAME*( * ), OPTS*( * )
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --       This program sets problem and machine dependent parameters
   --       useful for xHSEQR and its subroutines. It is called whenever
   --       ILAENV is called with 12 <= ISPEC <= 16
   --
   --  Arguments:
   --  ==========
   --
   --  [in] ISPEC
   --           ISPEC is integer scalar
   --               ISPEC specifies which tunable parameter IPARMQ should
   --               return.
   --
   --               ISPEC=12: (INMIN)  Matrices of order nmin or less
   --                         are sent directly to xLAHQR, the implicit
   --                         Real shift QR algorithm.  NMIN must be
   --                         at least 11.
   --
   --               ISPEC=13: (INWIN)  Size of the deflation window.
   --                         This is best set greater than or equal to
   --                         the number of simultaneous shifts NS.
   --                         Larger matrices benefit from larger deflation
   --                         windows.
   --
   --               ISPEC=14: (INIBL) Determines when to stop nibbling and
   --                         invest in an (expensive) multi-shift QR sweep.
   --                         If the aggressive early deflation subroutine
   --                         finds LD converged eigenvalues from an order
   --                         NW deflation window and LD.GT.(NW*NIBBLE)/100,
   --                         then the next QR sweep is skipped and early
   --                         deflation is applied immediately to the
   --                         remaining active diagonal block.  Setting
   --                         IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a
   --                         multi-shift QR sweep whenever early deflation
   --                         finds a converged eigenvalue.  Setting
   --                         IPARMQ(ISPEC=14) greater than or equal to 100
   --                         prevents TTQRE from skipping a multi-shift
   --                         QR sweep.
   --
   --               ISPEC=15: (NSHFTS) The number of simultaneous shifts in
   --                         a multi-shift QR iteration.
   --
   --               ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the
   --                         following meanings.
   --                         0:  During the multi-shift QR sweep,
   --                             xLAQR5 does not accumulate reflections and
   --                             does not use matrix-matrix multiply to
   --                             update the far-from-diagonal matrix
   --                             entries.
   --                         1:  During the multi-shift QR sweep,
   --                             xLAQR5 and/or xLAQRaccumulates reflections and uses
   --                             matrix-matrix multiply to update the
   --                             far-from-diagonal matrix entries.
   --                         2:  During the multi-shift QR sweep.
   --                             xLAQR5 accumulates reflections and takes
   --                             advantage of 2-by-2 block structure during
   --                             matrix-matrix multiplies.
   --                         (If xTRMM is slower than xGEMM, then
   --                         IPARMQ(ISPEC=16)=1 may be more efficient than
   --                         IPARMQ(ISPEC=16)=2 despite the greater level of
   --                         arithmetic work implied by the latter choice.)
   --
   --  [in] NAME
   --           NAME is character string
   --                Name of the calling subroutine
   --
   --  [in] OPTS
   --           OPTS is character string
   --                This is a concatenation of the string arguments to
   --                TTQRE.
   --
   --  [in] N
   --           N is integer scalar
   --                N is the order of the Hessenberg matrix H.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --                It is assumed that H is already upper triangular
   --                in rows and columns 1:ILO-1 and IHI+1:N.
   --
   --  [in] LWORK
   --           LWORK is integer scalar
   --                The amount of workspace available.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --        Little is known about how best to choose these parameters.
   --        It is possible to use different values of the parameters
   --        for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR.
   --
   --        It is probably best to choose different parameters for
   --        different matrices and different parameters at different
   --        times during the iteration, but this has not been
   --        implemented --- yet.
   --
   --
   --        The best choices of most of the parameters depend
   --        in an ill-understood way on the relative execution
   --        rate of xLAQR3 and xLAQR5 and on the nature of each
   --        particular eigenvalue problem.  Experiment may be the
   --        only practical way to determine which choices are most
   --        effective.
   --
   --        Following is a list of default values supplied by IPARMQ.
   --        These defaults may be adjusted in order to attain better
   --        performance in any particular computational environment.
   --
   --        IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point.
   --                         Default: 75. (Must be at least 11.)
   --
   --        IPARMQ(ISPEC=13) Recommended deflation window size.
   --                         This depends on ILO, IHI and NS, the
   --                         number of simultaneous shifts returned
   --                         by IPARMQ(ISPEC=15).  The default for
   --                         (IHI-ILO+1).LE.500 is NS.  The default
   --                         for (IHI-ILO+1).GT.500 is 3*NS/2.
   --
   --        IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14.
   --
   --        IPARMQ(ISPEC=15) Number of simultaneous shifts, NS.
   --                         a multi-shift QR iteration.
   --
   --                         If IHI-ILO+1 is ...
   --
   --                         greater than      ...but less    ... the
   --                         or equal to ...      than        default is
   --
   --                                 0               30       NS =   2+
   --                                30               60       NS =   4+
   --                                60              150       NS =  10
   --                               150              590       NS =  **
   --                               590             3000       NS =  64
   --                              3000             6000       NS = 128
   --                              6000             infinity   NS = 256
   --
   --                     (+)  By default matrices of this order are
   --                          passed to the implicit Real shift routine
   --                          xLAHQR.  See IPARMQ(ISPEC=12) above.   These
   --                          values of NS are used only in case of a rare
   --                          xLAHQR failure.
   --
   --                     (**) The asterisks (**) indicate an ad-hoc
   --                          function increasing from 10 to 64.
   --
   --        IPARMQ(ISPEC=16) Select structured matrix multiply.
   --                         (See ISPEC=16 above for details.)
   --                         Default: 3.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --
   --  ================================================================
   --     .. Parameters ..
   --      PARAMETER          ( INMIN = 12, INWIN = 13, INIBL = 14, ISHFTS = 15, IACC22 = 16 )
   --      PARAMETER          ( NMIN = 75, K22MIN = 14, KACMIN = 14, NIBBLE = 14, KNWSWP = 500 )
   --      PARAMETER          ( TWO = 2.0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          LOG, MAX, MOD, NINT, REAL
   --     ..
   --     .. Executable Statements ..
   begin
      if (ISPEC = ISHFTS) or (ISPEC = INWIN) or (ISPEC = IACC22) then
         --
         --        ==== Set the number simultaneous shifts ====
         --
         NH := IHI - ILO + 1;
         NS := 2;
         if NH >= 30 then
            NS := 4;
         end if;
         if NH >= 60 then
            NS := 10;
         end if;
         if NH >= 150 then
            NS := max (10, NH / nint (Log (Real (NH)) / Log (TWO)));
         end if;
         if NH >= 590 then
            NS := 64;
         end if;
         if NH >= 3000 then
            NS := 128;
         end if;
         if NH >= 6000 then
            NS := 256;
         end if;
         NS := max (2, NS - "mod" (NS, 2));
      end if;
      --
      if ISPEC = INMIN then
         --
         --
         --        ===== Matrices of order smaller than NMIN get sent
         --        .     to xLAHQR, the classic Real shift algorithm.
         --        .     This must be at least 11. ====
         --
         IPARMQ_Result := NMIN;
      --
      elsif ISPEC = INIBL then
         --
         --        ==== INIBL: skip a multi-shift qr iteration and
         --        .    whenever aggressive early deflation finds
         --        .    at least (NIBBLE*(window size)/100) deflations. ====
         --
         IPARMQ_Result := NIBBLE;
      --
      elsif ISPEC = ISHFTS then
         --
         --        ==== NSHFTS: The number of simultaneous shifts =====
         --
         IPARMQ_Result := NS;
      --
      elsif ISPEC = INWIN then
         --
         --        ==== NW: deflation window size.  ====
         --
         if NH <= KNWSWP 
            then IPARMQ_Result := NS;
            else IPARMQ_Result := 3 * NS / 2;
         end if;
      --
      elsif ISPEC = IACC22 then
         --
         --        ==== IACC22: Whether to accumulate reflections
         --        .     before updating the far-from-diagonal elements
         --        .     and whether to use 2-by-2 block structure while
         --        .     doing it.  A small amount of work could be saved
         --        .     by making this choice dependent also upon the
         --        .     NH=IHI-ILO+1.
         --
         IPARMQ_Result := 0;
         if NS >= KACMIN then
            IPARMQ_Result := 1;
         end if;
         if NS >= K22MIN then
            IPARMQ_Result := 2;
         end if;
      --
      else
         --        ===== invalid value of ispec =====
         IPARMQ_Result := -1;
         --
      end if;
      --
      --     ==== End of IPARMQ ====
      --
      return IPARMQ_Result;
   end IPARMQ;

   function LSAME (CA : Character; CB : Character) return Boolean is
      INTA         : Integer;
      INTB         : Integer;
      ZCODE        : Integer;
      LSAME_Result : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --  Definition:
   --  ===========
   --
   --      LOGICAL FUNCTION LSAME( CA, CB )
   --
   --     .. Scalar Arguments ..
   --      CHARACTER          CA, CB
   --     ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  LSAME returns .TRUE. if CA is the same letter as CB regardless of
   --  case.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] CA
   --
   --  [in] CB
   --           CA and CB specify the single characters to be compared.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ICHAR
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Test if the characters are equal
   --
   begin
      LSAME_Result := CA = CB;
      if LSAME_Result then
         return LSAME_Result;
      end if;
      --
      --     Now test for equivalence if both characters are alphabetic.
      --
      ZCODE := ichar ('Z');
      --
      --     Use 'Z' rather than 'A' so that ASCII can be detected on Prime
      --     machines, on which ICHAR returns a value with bit 8 set.
      --     ICHAR('A') on Prime machines returns 193 which is the same as
      --     ICHAR('A') on an EBCDIC machine.
      --
      INTA := ichar (CA);
      INTB := ichar (CB);
      --
      if ZCODE = 90 or ZCODE = 122 then
         --
         --        ASCII is assumed - ZCODE is the ASCII code of either lower or
         --        upper case 'Z'.
         --
         if INTA >= 97 and INTA <= 122 then
            INTA := INTA - 32;
         end if;
         if INTB >= 97 and INTB <= 122 then
            INTB := INTB - 32;
         end if;
      --
      elsif ZCODE = 233 or ZCODE = 169 then
         --
         --        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
         --        upper case 'Z'.
         --
         if (INTA >= 129 and INTA <= 137) or (INTA >= 145 and INTA <= 153) or (INTA >= 162 and INTA <= 169) then
            INTA := INTA + 64;
         end if;
         if (INTB >= 129 and INTB <= 137) or (INTB >= 145 and INTB <= 153) or (INTB >= 162 and INTB <= 169) then
            INTB := INTB + 64;
         end if;
      --
      elsif ZCODE = 218 or ZCODE = 250 then
         --
         --        ASCII is assumed, on Prime machines - ZCODE is the ASCII code
         --        plus 128 of either lower or upper case 'Z'.
         --
         if INTA >= 225 and INTA <= 250 then
            INTA := INTA - 32;
         end if;
         if INTB >= 225 and INTB <= 250 then
            INTB := INTB - 32;
         end if;
      end if;
      LSAME_Result := INTA = INTB;
      --
      --     RETURN
      --
      --     End of LSAME
      --
      return LSAME_Result;
   end LSAME;

   procedure XERBLA (SRNAME : String; INFO : Integer) is

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE XERBLA( SRNAME, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER*(*)      SRNAME
   --       INTEGER            INFO
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  XERBLA  is an error handler for the LAPACK routines.
   --  It is called by an LAPACK routine if an input parameter has an
   --  invalid value.  A message is printed and execution stops.
   --
   --  Installers may consider modifying the STOP statement in order to
   --  call system-specific exception-handling facilities.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SRNAME
   --           SRNAME is CHARACTER*(*)
   --           The name of the routine which called XERBLA.
   --
   --  [in] INFO
   --           INFO is INTEGER
   --           The position of the invalid parameter in the parameter list
   --           of the calling routine.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Intrinsic Functions ..
   --      INTRINSIC          LEN_TRIM
   --     ..
   --     .. Executable Statements ..
   --
   begin
      --
      Put (" ** On entry to " & SRNAME & " parameter number ");
      Put (Integer'Image (INFO));
      Put_Line (" had an illegal value.");
      --
      --     End of XERBLA
      --
   end XERBLA;

   procedure ZBDSQR
     (UPLO      : Character;
      N         : Integer;
      NCVT      : Integer;
      NRU       : Integer;
      NCC       : Integer;
      D_adr     : Address;
      E_adr     : Address;
      VT_adr    : Address;
      LDVT      : Integer;
      U_adr     : Address;
      LDU       : Integer;
      C_adr     : Address;
      LDC       : Integer;
      RWORK_adr : Address;
      INFO      : in out Integer)
   is

      D     : Ftn_Real_Vector (1 .. N);
      E     : Ftn_Real_Vector (1 .. N - 1);
      VT    : Ftn_Complex_Matrix (1 .. LDVT, 1 .. NCVT);
      U     : Ftn_Complex_Matrix (1 .. LDU, 1 .. N);
      C     : Ftn_Complex_Matrix (1 .. LDC, 1 .. NCC);
      RWORK : Ftn_Real_Vector (1 .. max (1, max (2 * N, 4 * N - 4)));

      for D'Address use D_adr;
      for E'Address use E_adr;
      for VT'Address use VT_adr;
      for U'Address use U_adr;
      for C'Address use C_adr;
      for RWORK'Address use RWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, VT);
      pragma Import (Ada, U);
      pragma Import (Ada, C);
      pragma Import (Ada, RWORK);

      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      NEGONE : constant Real    := -1.0e0;
      HNDRTH : constant Real    := 0.01e0;
      TEN    : constant Real    := 10.0e0;
      HNDRD  : constant Real    := 100.0e0;
      MEIGTH : constant Real    := -0.125e0;
      MAXITR : constant Integer := 6;
      LOWER  : Boolean;
      ROTATE : Boolean;
      I      : Integer;
      IDIR   : Integer;
      ISUB   : Integer;
      ITER   : Integer;
      J      : Integer;
      LL     : Integer;
      LLL    : Integer;
      M      : Integer;
      MAXIT  : Integer;
      NM1    : Integer;
      NM12   : Integer;
      NM13   : Integer;
      OLDLL  : Integer;
      OLDM   : Integer;
      ABSE   : Real;
      ABSS   : Real;
      COSL   : Real;
      COSR   : Real;
      CS     : Real;
      EPS    : Real;
      F      : Real;
      G      : Real;
      H      : Real;
      MU     : Real;
      OLDCS  : Real;
      OLDSN  : Real;
      R      : Real;
      SHIFT  : Real;
      SIGMN  : Real;
      SIGMX  : Real;
      SINL   : Real;
      SINR   : Real;
      SLL    : Real;
      SMAX   : Real;
      SMIN   : Real;
      SMINL  : Real;
      SMINOA : Real;
      SN     : Real;
      THRESH : Real;
      TOL    : Real;
      TOLMUL : Real;
      UNFL   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZBDSQR( UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U,
   --                          LDU, C, LDC, RWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDC, LDU, LDVT, N, NCC, NCVT, NRU
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * ), RWORK( * )
   --       COMPLEX*16         C( LDC, * ), U( LDU, * ), VT( LDVT, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZBDSQR computes the singular values and, optionally, the right and/or
   --  left singular vectors from the singular value decomposition (SVD) of
   --  a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
   --  zero-shift QR algorithm.  The SVD of B has the form
   --
   --     B = Q * S * P**H
   --
   --  where S is the diagonal matrix of singular values, Q is an orthogonal
   --  matrix of left singular vectors, and P is an orthogonal matrix of
   --  right singular vectors.  If left singular vectors are requested, this
   --  subroutine actually returns U*Q instead of Q, and, if right singular
   --  vectors are requested, this subroutine returns P**H*VT instead of
   --  P**H, for given complex input matrices U and VT.  When U and VT are
   --  the unitary matrices that reduce a general matrix A to bidiagonal
   --  form: A = U*B*VT, as computed by ZGEBRD, then
   --
   --     A = (U*Q) * S * (P**H*VT)
   --
   --  is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
   --  for a given complex input matrix C.
   --
   --  See "Computing  Small Singular Values of Bidiagonal Matrices With
   --  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
   --  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
   --  no. 5, pp. 873-912, Sept 1990) and
   --  "Accurate singular values and differential qd algorithms," by
   --  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
   --  Department, University of California at Berkeley, July 1992
   --  for a detailed description of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  B is upper bidiagonal;
   --           = 'L':  B is lower bidiagonal.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix B.  N >= 0.
   --
   --  [in] NCVT
   --           NCVT is INTEGER
   --           The number of columns of the matrix VT. NCVT >= 0.
   --
   --  [in] NRU
   --           NRU is INTEGER
   --           The number of rows of the matrix U. NRU >= 0.
   --
   --  [in] NCC
   --           NCC is INTEGER
   --           The number of columns of the matrix C. NCC >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the n diagonal elements of the bidiagonal matrix B.
   --           On exit, if INFO=0, the singular values of B in decreasing
   --           order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           On entry, the N-1 offdiagonal elements of the bidiagonal
   --           matrix B.
   --           On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
   --           will contain the diagonal and superdiagonal elements of a
   --           bidiagonal matrix orthogonally equivalent to the one given
   --           as input.
   --
   --  [in,out] VT
   --           VT is COMPLEX*16 array, dimension (LDVT, NCVT)
   --           On entry, an N-by-NCVT matrix VT.
   --           On exit, VT is overwritten by P**H * VT.
   --           Not referenced if NCVT = 0.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --           The leading dimension of the array VT.
   --           LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
   --
   --  [in,out] U
   --           U is COMPLEX*16 array, dimension (LDU, N)
   --           On entry, an NRU-by-N matrix U.
   --           On exit, U is overwritten by U * Q.
   --           Not referenced if NRU = 0.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --           The leading dimension of the array U.  LDU >= max(1,NRU).
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC, NCC)
   --           On entry, an N-by-NCC matrix C.
   --           On exit, C is overwritten by Q**H * C.
   --           Not referenced if NCC = 0.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C.
   --           LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array, dimension (2*N)
   --           if NCVT = NRU = NCC = 0, (max(1, 4*N-4)) otherwise
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  If INFO = -i, the i-th argument had an illegal value
   --           > 0:  the algorithm did not converge; D and E contain the
   --                 elements of a bidiagonal matrix which is orthogonally
   --                 similar to the input matrix B;  if INFO = i, i
   --                 elements of E have not converged to zero.
   --
   --  Internal Parameters:
   --  =========================
   --
   --   TOLMUL  DOUBLE PRECISION, default = max(10,min(100,EPS**(-1/8)))
   --           TOLMUL controls the convergence criterion of the QR loop.
   --           If it is positive, TOLMUL*EPS is the desired relative
   --              precision in the computed singular values.
   --           If it is negative, abs(TOLMUL*EPS*sigma_max) is the
   --              desired absolute accuracy in the computed singular
   --              values (corresponds to relative accuracy
   --              abs(TOLMUL*EPS)) in the largest singular value.
   --           abs(TOLMUL) should be between 1 and 1/EPS, and preferably
   --              between 10 (for fast convergence) and .1/EPS
   --              (for there to be some accuracy in the results).
   --           Default is to lose at either one eighth or 2 of the
   --              available decimal digits in each computed singular value
   --              (whichever is smaller).
   --
   --   MAXITR  INTEGER, default = 6
   --           MAXITR controls the maximum number of passes of the
   --           algorithm through its inner loop. The algorithms stops
   --           (and so fails to converge) if the number of passes
   --           through the inner loop exceeds MAXITR*N**2.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0 )
   --      PARAMETER          ( ONE = 1.0D0 )
   --      PARAMETER          ( NEGONE = -1.0D0 )
   --      PARAMETER          ( HNDRTH = 0.01D0 )
   --      PARAMETER          ( TEN = 10.0D0 )
   --      PARAMETER          ( HNDRD = 100.0D0 )
   --      PARAMETER          ( MEIGTH = -0.125D0 )
   --      PARAMETER          ( MAXITR = 6 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, DLAMCH
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLARTG, DLAS2, DLASQ1, DLASV2, XERBLA, ZDROT, ZDSCAL, ZLASR, ZSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, MAX, MIN, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO  := 0;
      LOWER := LSAME (UPLO, 'L');
      if not LSAME (UPLO, 'U') and not LOWER then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NCVT < 0 then
         INFO := -3;
      elsif NRU < 0 then
         INFO := -4;
      elsif NCC < 0 then
         INFO := -5;
      elsif (NCVT = 0 and LDVT < 1) or (NCVT > 0 and LDVT < max (1, N)) then
         INFO := -9;
      elsif LDU < max (1, NRU) then
         INFO := -11;
      elsif (NCC = 0 and LDC < 1) or (NCC > 0 and LDC < max (1, N)) then
         INFO := -13;
      end if;
      if INFO /= 0 then
         XERBLA ("ZBDSQR", -INFO);
         return;
      end if;
      if N = 0 then
         return;
      end if;
      if N = 1 then
         goto L160;
      end if;
      --
      --     ROTATE is true if any singular vectors desired, false otherwise
      --
      ROTATE := (NCVT > 0) or (NRU > 0) or (NCC > 0);
      --
      --     If no singular vectors desired, use qd algorithm
      --
      if not ROTATE then
         DLASQ1 (N, D, E, RWORK, INFO);
         --
         --     If INFO equals 2, dqds didn't finish, try to finish
         --
         if INFO /= 2 then
            return;
         end if;
         INFO := 0;
      end if;
      --
      NM1  := N - 1;
      NM12 := NM1 + NM1;
      NM13 := NM12 + NM1;
      IDIR := 0;
      --
      --     Get machine constants
      --
      EPS  := DLAMCH ('E');
      UNFL := DLAMCH ('S');
      --
      --     If matrix lower bidiagonal, rotate to be upper bidiagonal
      --     by applying Givens rotations on the left
      --
      if LOWER then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            DLARTG (D (I), E (I), CS, SN, R);
            D (I)           := R;
            E (I)           := SN * D (I + 1);
            D (I + 1)       := CS * D (I + 1);
            RWORK (I)       := CS;
            RWORK (NM1 + I) := SN;
         end loop;
         --
         --        Update singular vectors if desired
         --
         if NRU > 0 then
            ZLASR ('R', 'V', 'F', NRU, N, RWORK (1)'Address, RWORK (N)'Address, U'Address, LDU);
         end if;
         if NCC > 0 then
            ZLASR ('L', 'V', 'F', N, NCC, RWORK (1)'Address, RWORK (N)'Address, C'Address, LDC);
         end if;
      end if;
      --
      --     Compute singular values to relative accuracy TOL
      --     (By setting TOL to be negative, algorithm will compute
      --     singular values to absolute accuracy ABS(TOL)*norm(input matrix))
      --
      TOLMUL := max (TEN, min (HNDRD, EPS ** MEIGTH));
      TOL    := TOLMUL * EPS;
      --
      --     Compute approximate maximum, minimum singular values
      --
      SMAX := ZERO;
      I    := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         SMAX := max (SMAX, abs (D (I)));
      end loop;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         SMAX := max (SMAX, abs (E (I)));
      end loop;
      SMINL := ZERO;
      if TOL >= ZERO then
         --
         --        Relative accuracy desired
         --
         SMINOA := abs (D (1));
         if SMINOA = ZERO then
            goto L50;
         end if;
         MU := SMINOA;
         I  := 2 - 1;
         loop
            I := I + 1;
            exit when I > N;
            MU     := abs (D (I)) * (MU / (MU + abs (E (I - 1))));
            SMINOA := min (SMINOA, MU);
            if SMINOA = ZERO then
               goto L50;
            end if;
         end loop;
         <<L50>> null;
         SMINOA := SMINOA / Sqrt (Real (N));
         THRESH := max (TOL * SMINOA, Real (MAXITR * N * N) * UNFL);
      else
         --
         --        Absolute accuracy desired
         --
         THRESH := max (abs (TOL) * SMAX, Real (MAXITR * N * N) * UNFL);
      end if;
      --
      --     Prepare for main iteration loop for the singular values
      --     (MAXIT is the maximum number of passes through the inner
      --     loop permitted before nonconvergence signalled.)
      --
      MAXIT := MAXITR * N * N;
      ITER  := 0;
      OLDLL := -1;
      OLDM  := -1;
      --
      --     M points to last element of unconverged part of matrix
      --
      M := N;
      --
      --     Begin main iteration loop
      --
      <<L60>> null;
      --
      --     Check for convergence or exceeding iteration count
      --
      if M <= 1 then
         goto L160;
      end if;
      if ITER > MAXIT then
         goto L200;
      end if;
      --
      --     Find diagonal block of matrix to work on
      --
      if TOL < ZERO and abs (D (M)) <= THRESH then
         D (M) := ZERO;
      end if;
      SMAX := abs (D (M));
      SMIN := SMAX;
      LLL  := 1 - 1;
      loop
         LLL := LLL + 1;
         exit when LLL > M - 1;
         LL   := M - LLL;
         ABSS := abs (D (LL));
         ABSE := abs (E (LL));
         if TOL < ZERO and ABSS <= THRESH then
            D (LL) := ZERO;
         end if;
         if ABSE <= THRESH then
            goto L80;
         end if;
         SMIN := min (SMIN, ABSS);
         SMAX := max (SMAX, ABSS, ABSE);
      end loop;
      LL := 0;
      goto L90;
      <<L80>> null;
      E (LL) := ZERO;
      --
      --     Matrix splits since E(LL) = 0
      --
      if LL = M - 1 then
         --
         --        Convergence of bottom singular value, return to top of loop
         --
         M := M - 1;
         goto L60;
      end if;
      <<L90>> null;
      LL := LL + 1;
      --
      --     E(LL) through E(M-1) are nonzero, E(LL-1) is zero
      --
      if LL = M - 1 then
         --
         --        2 by 2 block, handle separately
         --
         DLASV2 (D (M - 1), E (M - 1), D (M), SIGMN, SIGMX, SINR, COSR, SINL, COSL);
         D (M - 1) := SIGMX;
         E (M - 1) := ZERO;
         D (M)     := SIGMN;
         --
         --        Compute singular vectors, if desired
         --
         if NCVT > 0 then
            ZDROT (NCVT, VT (M - 1, 1)'Address, LDVT, VT (M, 1)'Address, LDVT, COSR, SINR);
         end if;
         if NRU > 0 then
            ZDROT (NRU, U (1, M - 1)'Address, 1, U (1, M)'Address, 1, COSL, SINL);
         end if;
         if NCC > 0 then
            ZDROT (NCC, C (M - 1, 1)'Address, LDC, C (M, 1)'Address, LDC, COSL, SINL);
         end if;
         M := M - 2;
         goto L60;
      end if;
      --
      --     If working on new submatrix, choose shift direction
      --     (from larger end diagonal element towards smaller)
      --
      if LL > OLDM or M < OLDLL then
         if abs (D (LL)) >= abs (D (M)) then
            --
            --           Chase bulge from top (big end) to bottom (small end)
            --
            IDIR := 1;
         else
            --
            --           Chase bulge from bottom (big end) to top (small end)
            --
            IDIR := 2;
         end if;
      end if;
      --
      --     Apply convergence tests
      --
      if IDIR = 1 then
         --
         --        Run convergence test in forward direction
         --        First apply standard test to bottom of matrix
         --
         if abs (E (M - 1)) <= abs (TOL) * abs (D (M)) or (TOL < ZERO and abs (E (M - 1)) <= THRESH) then
            E (M - 1) := ZERO;
            goto L60;
         end if;
         --
         if TOL >= ZERO then
            --
            --           If relative accuracy desired,
            --           apply convergence criterion forward
            --
            MU    := abs (D (LL));
            SMINL := MU;
            LLL   := LL - 1;
            loop
               LLL := LLL + 1;
               exit when LLL > M - 1;
               if abs (E (LLL)) <= TOL * MU then
                  E (LLL) := ZERO;
                  goto L60;
               end if;
               MU    := abs (D (LLL + 1)) * (MU / (MU + abs (E (LLL))));
               SMINL := min (SMINL, MU);
            end loop;
         end if;
      --
      else
         --
         --        Run convergence test in backward direction
         --        First apply standard test to top of matrix
         --
         if abs (E (LL)) <= abs (TOL) * abs (D (LL)) or (TOL < ZERO and abs (E (LL)) <= THRESH) then
            E (LL) := ZERO;
            goto L60;
         end if;
         --
         if TOL >= ZERO then
            --
            --           If relative accuracy desired,
            --           apply convergence criterion backward
            --
            MU    := abs (D (M));
            SMINL := MU;
            LLL   := M - 1 + 1;
            loop
               LLL := LLL - 1;
               exit when LLL < LL;
               if abs (E (LLL)) <= TOL * MU then
                  E (LLL) := ZERO;
                  goto L60;
               end if;
               MU    := abs (D (LLL)) * (MU / (MU + abs (E (LLL))));
               SMINL := min (SMINL, MU);
            end loop;
         end if;
      end if;
      OLDLL := LL;
      OLDM  := M;
      --
      --     Compute shift.  First, test if shifting would ruin relative
      --     accuracy, and if so set the shift to zero.
      --
      if TOL >= ZERO and Real (N) * TOL * (SMINL / SMAX) <= max (EPS, HNDRTH * TOL) then
         --
         --        Use a zero shift to avoid loss of relative accuracy
         --
         SHIFT := ZERO;
      else
         --
         --        Compute the shift from 2-by-2 block at end of matrix
         --
         if IDIR = 1 then
            SLL := abs (D (LL));
            DLAS2 (D (M - 1), E (M - 1), D (M), SHIFT, R);
         else
            SLL := abs (D (M));
            DLAS2 (D (LL), E (LL), D (LL + 1), SHIFT, R);
         end if;
         --
         --        Test if shift negligible, and if so set to zero
         --
         if SLL > ZERO then
            if (SHIFT / SLL) ** 2 < EPS then
               SHIFT := ZERO;
            end if;
         end if;
      end if;
      --
      --     Increment iteration count
      --
      ITER := ITER + M - LL;
      --
      --     If SHIFT = 0, do simplified QR iteration
      --
      if SHIFT = ZERO then
         if IDIR = 1 then
            --
            --           Chase bulge from top to bottom
            --           Save cosines and sines for later singular vector updates
            --
            CS    := ONE;
            OLDCS := ONE;
            I     := LL - 1;
            loop
               I := I + 1;
               exit when I > M - 1;
               DLARTG (D (I) * CS, E (I), CS, SN, R);
               if I > LL then
                  E (I - 1) := OLDSN * R;
               end if;
               DLARTG (OLDCS * R, D (I + 1) * SN, OLDCS, OLDSN, D (I));
               RWORK (I - LL + 1)        := CS;
               RWORK (I - LL + 1 + NM1)  := SN;
               RWORK (I - LL + 1 + NM12) := OLDCS;
               RWORK (I - LL + 1 + NM13) := OLDSN;
            end loop;
            H         := D (M) * CS;
            D (M)     := H * OLDCS;
            E (M - 1) := H * OLDSN;
            --
            --           Update singular vectors
            --
            if NCVT > 0 then
               ZLASR ('L', 'V', 'F', M - LL + 1, NCVT, RWORK (1)'Address, RWORK (N)'Address, VT (LL, 1)'Address, LDVT);
            end if;
            if NRU > 0 then
               ZLASR
                 ('R',
                  'V',
                  'F',
                  NRU,
                  M - LL + 1,
                  RWORK (NM12 + 1)'Address,
                  RWORK (NM13 + 1)'Address,
                  U (1, LL)'Address,
                  LDU);
            end if;
            if NCC > 0 then
               ZLASR
                 ('L',
                  'V',
                  'F',
                  M - LL + 1,
                  NCC,
                  RWORK (NM12 + 1)'Address,
                  RWORK (NM13 + 1)'Address,
                  C (LL, 1)'Address,
                  LDC);
            end if;
            --
            --           Test convergence
            --
            if abs (E (M - 1)) <= THRESH then
               E (M - 1) := ZERO;
            end if;
         --
         else
            --
            --           Chase bulge from bottom to top
            --           Save cosines and sines for later singular vector updates
            --
            CS    := ONE;
            OLDCS := ONE;
            I     := M + 1;
            loop
               I := I - 1;
               exit when I < LL + 1;
               DLARTG (D (I) * CS, E (I - 1), CS, SN, R);
               if I < M then
                  E (I) := OLDSN * R;
               end if;
               DLARTG (OLDCS * R, D (I - 1) * SN, OLDCS, OLDSN, D (I));
               RWORK (I - LL)        := CS;
               RWORK (I - LL + NM1)  := -SN;
               RWORK (I - LL + NM12) := OLDCS;
               RWORK (I - LL + NM13) := -OLDSN;
            end loop;
            H      := D (LL) * CS;
            D (LL) := H * OLDCS;
            E (LL) := H * OLDSN;
            --
            --           Update singular vectors
            --
            if NCVT > 0 then
               ZLASR
                 ('L',
                  'V',
                  'B',
                  M - LL + 1,
                  NCVT,
                  RWORK (NM12 + 1)'Address,
                  RWORK (NM13 + 1)'Address,
                  VT (LL, 1)'Address,
                  LDVT);
            end if;
            if NRU > 0 then
               ZLASR ('R', 'V', 'B', NRU, M - LL + 1, RWORK (1)'Address, RWORK (N)'Address, U (1, LL)'Address, LDU);
            end if;
            if NCC > 0 then
               ZLASR ('L', 'V', 'B', M - LL + 1, NCC, RWORK (1)'Address, RWORK (N)'Address, C (LL, 1)'Address, LDC);
            end if;
            --
            --           Test convergence
            --
            if abs (E (LL)) <= THRESH then
               E (LL) := ZERO;
            end if;
         end if;
      else
         --
         --        Use nonzero shift
         --
         if IDIR = 1 then
            --
            --           Chase bulge from top to bottom
            --           Save cosines and sines for later singular vector updates
            --
            F := (abs (D (LL)) - SHIFT) * (sign (ONE, D (LL)) + SHIFT / D (LL));
            G := E (LL);
            I := LL - 1;
            loop
               I := I + 1;
               exit when I > M - 1;
               DLARTG (F, G, COSR, SINR, R);
               if I > LL then
                  E (I - 1) := R;
               end if;
               F         := COSR * D (I) + SINR * E (I);
               E (I)     := COSR * E (I) - SINR * D (I);
               G         := SINR * D (I + 1);
               D (I + 1) := COSR * D (I + 1);
               DLARTG (F, G, COSL, SINL, R);
               D (I)     := R;
               F         := COSL * E (I) + SINL * D (I + 1);
               D (I + 1) := COSL * D (I + 1) - SINL * E (I);
               if I < M - 1 then
                  G         := SINL * E (I + 1);
                  E (I + 1) := COSL * E (I + 1);
               end if;
               RWORK (I - LL + 1)        := COSR;
               RWORK (I - LL + 1 + NM1)  := SINR;
               RWORK (I - LL + 1 + NM12) := COSL;
               RWORK (I - LL + 1 + NM13) := SINL;
            end loop;
            E (M - 1) := F;
            --
            --           Update singular vectors
            --
            if NCVT > 0 then
               ZLASR ('L', 'V', 'F', M - LL + 1, NCVT, RWORK (1)'Address, RWORK (N)'Address, VT (LL, 1)'Address, LDVT);
            end if;
            if NRU > 0 then
               ZLASR
                 ('R',
                  'V',
                  'F',
                  NRU,
                  M - LL + 1,
                  RWORK (NM12 + 1)'Address,
                  RWORK (NM13 + 1)'Address,
                  U (1, LL)'Address,
                  LDU);
            end if;
            if NCC > 0 then
               ZLASR
                 ('L',
                  'V',
                  'F',
                  M - LL + 1,
                  NCC,
                  RWORK (NM12 + 1)'Address,
                  RWORK (NM13 + 1)'Address,
                  C (LL, 1)'Address,
                  LDC);
            end if;
            --
            --           Test convergence
            --
            if abs (E (M - 1)) <= THRESH then
               E (M - 1) := ZERO;
            end if;
         --
         else
            --
            --           Chase bulge from bottom to top
            --           Save cosines and sines for later singular vector updates
            --
            F := (abs (D (M)) - SHIFT) * (sign (ONE, D (M)) + SHIFT / D (M));
            G := E (M - 1);
            I := M + 1;
            loop
               I := I - 1;
               exit when I < LL + 1;
               DLARTG (F, G, COSR, SINR, R);
               if I < M then
                  E (I) := R;
               end if;
               F         := COSR * D (I) + SINR * E (I - 1);
               E (I - 1) := COSR * E (I - 1) - SINR * D (I);
               G         := SINR * D (I - 1);
               D (I - 1) := COSR * D (I - 1);
               DLARTG (F, G, COSL, SINL, R);
               D (I)     := R;
               F         := COSL * E (I - 1) + SINL * D (I - 1);
               D (I - 1) := COSL * D (I - 1) - SINL * E (I - 1);
               if I > LL + 1 then
                  G         := SINL * E (I - 2);
                  E (I - 2) := COSL * E (I - 2);
               end if;
               RWORK (I - LL)        := COSR;
               RWORK (I - LL + NM1)  := -SINR;
               RWORK (I - LL + NM12) := COSL;
               RWORK (I - LL + NM13) := -SINL;
            end loop;
            E (LL) := F;
            --
            --           Test convergence
            --
            if abs (E (LL)) <= THRESH then
               E (LL) := ZERO;
            end if;
            --
            --           Update singular vectors if desired
            --
            if NCVT > 0 then
               ZLASR
                 ('L',
                  'V',
                  'B',
                  M - LL + 1,
                  NCVT,
                  RWORK (NM12 + 1)'Address,
                  RWORK (NM13 + 1)'Address,
                  VT (LL, 1)'Address,
                  LDVT);
            end if;
            if NRU > 0 then
               ZLASR ('R', 'V', 'B', NRU, M - LL + 1, RWORK (1)'Address, RWORK (N)'Address, U (1, LL)'Address, LDU);
            end if;
            if NCC > 0 then
               ZLASR ('L', 'V', 'B', M - LL + 1, NCC, RWORK (1)'Address, RWORK (N)'Address, C (LL, 1)'Address, LDC);
            end if;
         end if;
      end if;
      --
      --     QR iteration finished, go back and check convergence
      --
      goto L60;
      --
      --     All singular values converged, so make them positive
      --
      <<L160>> null;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         if D (I) < ZERO then
            D (I) := -D (I);
            --
            --           Change sign of singular vectors, if desired
            --
            if NCVT > 0 then
               ZDSCAL (NCVT, NEGONE, VT (I, 1)'Address, LDVT);
            end if;
         end if;
      end loop;
      --
      --     Sort the singular values into decreasing order (insertion sort on
      --     singular values, but only one transposition per singular vector)
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         --
         --        Scan for smallest D(I)
         --
         ISUB := 1;
         SMIN := D (1);
         J    := 2 - 1;
         loop
            J := J + 1;
            exit when J > N + 1 - I;
            if D (J) <= SMIN then
               ISUB := J;
               SMIN := D (J);
            end if;
         end loop;
         if ISUB /= N + 1 - I then
            --
            --           Swap singular values and vectors
            --
            D (ISUB)      := D (N + 1 - I);
            D (N + 1 - I) := SMIN;
            if NCVT > 0 then
               ZSWAP (NCVT, VT (ISUB, 1)'Address, LDVT, VT (N + 1 - I, 1)'Address, LDVT);
            end if;
            if NRU > 0 then
               ZSWAP (NRU, U (1, ISUB)'Address, 1, U (1, N + 1 - I)'Address, 1);
            end if;
            if NCC > 0 then
               ZSWAP (NCC, C (ISUB, 1)'Address, LDC, C (N + 1 - I, 1)'Address, LDC);
            end if;
         end if;
      end loop;
      goto L220;
      --
      --     Maximum number of iterations exceeded, failure to converge
      --
      <<L200>> null;
      INFO := 0;
      I    := 1 - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         if E (I) /= ZERO then
            INFO := INFO + 1;
         end if;
      end loop;
      <<L220>> null;
      return;
      --
      --     End of ZBDSQR
      --
   end ZBDSQR;

   procedure ZGEBAK
     (JOB       : Character;
      SIDE      : Character;
      N         : Integer;
      ILO       : Integer;
      IHI       : Integer;
      SCALE_adr : Address;
      M         : Integer;
      V_adr     : Address;
      LDV       : Integer;
      INFO      : in out Integer)
   is

      SCALE : Ftn_Real_Vector (1 .. N);
      V     : Ftn_Complex_Matrix (1 .. LDV, 1 .. M);

      for SCALE'Address use SCALE_adr;
      for V'Address use V_adr;

      pragma Import (Ada, SCALE);
      pragma Import (Ada, V);

      ONE    : constant Real := 1.0e0;
      LEFTV  : Boolean;
      RIGHTV : Boolean;
      I      : Integer;
      II     : Integer;
      K      : Integer;
      S      : Real;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEBAK( JOB, SIDE, N, ILO, IHI, SCALE, M, V, LDV,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOB, SIDE
   --       INTEGER            IHI, ILO, INFO, LDV, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   SCALE( * )
   --       COMPLEX*16         V( LDV, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEBAK forms the right or left eigenvectors of a complex general
   --  matrix by backward transformation on the computed eigenvectors of the
   --  balanced matrix output by ZGEBAL.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOB
   --           JOB is CHARACTER*1
   --           Specifies the type of backward transformation required:
   --           = 'N', do nothing, return immediately;
   --           = 'P', do backward transformation for permutation only;
   --           = 'S', do backward transformation for scaling only;
   --           = 'B', do backward transformations for both permutation and
   --                  scaling.
   --           JOB must be the same as the argument JOB supplied to ZGEBAL.
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'R':  V contains right eigenvectors;
   --           = 'L':  V contains left eigenvectors.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of rows of the matrix V.  N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --           The integers ILO and IHI determined by ZGEBAL.
   --           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
   --
   --  [in] SCALE
   --           SCALE is DOUBLE PRECISION array, dimension (N)
   --           Details of the permutation and scaling factors, as returned
   --           by ZGEBAL.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of columns of the matrix V.  M >= 0.
   --
   --  [in,out] V
   --           V is COMPLEX*16 array, dimension (LDV,M)
   --           On entry, the matrix of right or left eigenvectors to be
   --           transformed, as returned by ZHSEIN or ZTREVC.
   --           On exit, V is overwritten by the transformed eigenvectors.
   --
   --  [in] LDV
   --           LDV is INTEGER
   --           The leading dimension of the array V. LDV >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZDSCAL, ZSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Decode and Test the input parameters
   --
   begin
      RIGHTV := LSAME (SIDE, 'R');
      LEFTV  := LSAME (SIDE, 'L');
      --
      INFO := 0;
      if not LSAME (JOB, 'N') and not LSAME (JOB, 'P') and not LSAME (JOB, 'S') and not LSAME (JOB, 'B') then
         INFO := -1;
      elsif not RIGHTV and not LEFTV then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -4;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -5;
      elsif M < 0 then
         INFO := -7;
      elsif LDV < max (1, N) then
         INFO := -9;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGEBAK", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      if M = 0 then
         return;
      end if;
      if LSAME (JOB, 'N') then
         return;
      end if;
      --
      if ILO = IHI then
         goto L30;
      end if;
      --
      --     Backward balance
      --
      if LSAME (JOB, 'S') or LSAME (JOB, 'B') then
         --
         if RIGHTV then
            I := ILO - 1;
            loop
               I := I + 1;
               exit when I > IHI;
               S := SCALE (I);
               ZDSCAL (M, S, V (I, 1)'Address, LDV);
            end loop;
         end if;
         --
         if LEFTV then
            I := ILO - 1;
            loop
               I := I + 1;
               exit when I > IHI;
               S := ONE / SCALE (I);
               ZDSCAL (M, S, V (I, 1)'Address, LDV);
            end loop;
         end if;
         --
      end if;
      --
      --     Backward permutation
      --
      --     For  I = ILO-1 step -1 until 1,
      --              IHI+1 step 1 until N do --
      --
      <<L30>> null;
      if LSAME (JOB, 'P') or LSAME (JOB, 'B') then
         if RIGHTV then
            II := 1 - 1;
            loop
               II := II + 1;
               exit when II > N;
               I := II;
               if I >= ILO and I <= IHI then
                  goto L40;
               end if;
               if I < ILO then
                  I := ILO - II;
               end if;
               K := int (SCALE (I));
               if K = I then
                  goto L40;
               end if;
               ZSWAP (M, V (I, 1)'Address, LDV, V (K, 1)'Address, LDV);
               <<L40>> null;
            end loop;
         end if;
         --
         if LEFTV then
            II := 1 - 1;
            loop
               II := II + 1;
               exit when II > N;
               I := II;
               if I >= ILO and I <= IHI then
                  goto L50;
               end if;
               if I < ILO then
                  I := ILO - II;
               end if;
               K := int (SCALE (I));
               if K = I then
                  goto L50;
               end if;
               ZSWAP (M, V (I, 1)'Address, LDV, V (K, 1)'Address, LDV);
               <<L50>> null;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZGEBAK
      --
   end ZGEBAK;

   procedure ZGEBAL
     (JOB       : Character;
      N         : Integer;
      A_adr     : Address;
      LDA       : Integer;
      ILO       : in out Integer;
      IHI       : in out Integer;
      SCALE_adr : Address;
      INFO      : in out Integer)
   is

      A     : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      SCALE : Ftn_Real_Vector (1 .. N);

      for A'Address use A_adr;
      for SCALE'Address use SCALE_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, SCALE);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      SCLFAC : constant Real := 2.0e0;
      FACTOR : constant Real := 0.95e0;
      NOCONV : Boolean;
      I      : Integer;
      ICA    : Integer;
      IEXC   : Integer;
      IRA    : Integer;
      J      : Integer;
      K      : Integer;
      L      : Integer;
      M      : Integer;
      C      : Real;
      CA     : Real;
      F      : Real;
      G      : Real;
      R      : Real;
      RA     : Real;
      S      : Real;
      SFMAX1 : Real;
      SFMAX2 : Real;
      SFMIN1 : Real;
      SFMIN2 : Real;
      CDUM   : Complex;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEBAL( JOB, N, A, LDA, ILO, IHI, SCALE, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOB
   --       INTEGER            IHI, ILO, INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   SCALE( * )
   --       COMPLEX*16         A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEBAL balances a general complex matrix A.  This involves, first,
   --  permuting A by a similarity transformation to isolate eigenvalues
   --  in the first 1 to ILO-1 and last IHI+1 to N elements on the
   --  diagonal; and second, applying a diagonal similarity transformation
   --  to rows and columns ILO to IHI to make the rows and columns as
   --  close in norm as possible.  Both steps are optional.
   --
   --  Balancing may reduce the 1-norm of the matrix, and improve the
   --  accuracy of the computed eigenvalues and/or eigenvectors.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOB
   --           JOB is CHARACTER*1
   --           Specifies the operations to be performed on A:
   --           = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
   --                   for i = 1,...,N;
   --           = 'P':  permute only;
   --           = 'S':  scale only;
   --           = 'B':  both permute and scale.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the input matrix A.
   --           On exit,  A is overwritten by the balanced matrix.
   --           If JOB = 'N', A is not referenced.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] ILO
   --
   --  [out] IHI
   --           ILO and IHI are set to INTEGER such that on exit
   --           A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
   --           If JOB = 'N' or 'S', ILO = 1 and IHI = N.
   --
   --  [out] SCALE
   --           SCALE is DOUBLE PRECISION array, dimension (N)
   --           Details of the permutations and scaling factors applied to
   --           A.  If P(j) is the index of the row and column interchanged
   --           with row and column j and D(j) is the scaling factor
   --           applied to row and column j, then
   --           SCALE(j) = P(j)    for j = 1,...,ILO-1
   --                    = D(j)    for j = ILO,...,IHI
   --                    = P(j)    for j = IHI+1,...,N.
   --           The order in which the interchanges are made is N to IHI+1,
   --           then 1 to ILO-1.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The permutations consist of row and column interchanges which put
   --   the matrix in the form
   --
   --              ( T1   X   Y  )
   --      P A P = (  0   B   Z  )
   --              (  0   0   T2 )
   --
   --   where T1 and T2 are upper triangular matrices whose eigenvalues lie
   --   along the diagonal.  The column indices ILO and IHI mark the starting
   --   and ending columns of the submatrix B. Balancing consists of applying
   --   a diagonal similarity transformation inv(D) * B * D to make the
   --   1-norms of each row of B and its corresponding column nearly equal.
   --   The output matrix is
   --
   --      ( T1     X*D          Y    )
   --      (  0  inv(D)*B*D  inv(D)*Z ).
   --      (  0      0           T2   )
   --
   --   Information about the permutations P and the diagonal matrix D is
   --   returned in the vector SCALE.
   --
   --   This subroutine is based on the EISPACK routine CBAL.
   --
   --   Modified by Tzu-Yi Chen, Computer Science Division, University of
   --     California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( SCLFAC = 2.0D+0 )
   --      PARAMETER          ( FACTOR = 0.95D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            DISNAN, LSAME
   --       INTEGER            IZAMAX
   --       DOUBLE PRECISION   DLAMCH
   --       EXTERNAL           DISNAN, LSAME, IZAMAX, DLAMCH
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZDSCAL, ZSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DIMAG, MAX, MIN
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      --
      --     Test the input parameters
      --
      INFO := 0;
      if not LSAME (JOB, 'N') and not LSAME (JOB, 'P') and not LSAME (JOB, 'S') and not LSAME (JOB, 'B') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGEBAL", -INFO);
         return;
      end if;
      --
      K := 1;
      L := N;
      --
      if N = 0 then
         goto L210;
      end if;
      --
      if LSAME (JOB, 'N') then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            SCALE (I) := ONE;
         end loop;
         goto L210;
      end if;
      --
      if LSAME (JOB, 'S') then
         goto L120;
      end if;
      --
      --     Permutation to isolate eigenvalues if possible
      --
      goto L50;
      --
      --     Row and column exchange.
      --
      <<L20>> null;
      SCALE (M) := Real (J);
      if J = M then
         goto L30;
      end if;
      --
      ZSWAP (L, A (1, J)'Address, 1, A (1, M)'Address, 1);
      ZSWAP (N - K + 1, A (J, K)'Address, LDA, A (M, K)'Address, LDA);
      --
      <<L30>> null;
      --       GO TO ( 40, 80 )IEXC
      if IEXC = 1 then
         goto L40;
      elsif IEXC = 2 then
         goto L80;
      end if;
      --
      --     Search for rows isolating an eigenvalue and push them down.
      --
      <<L40>> null;
      if L = 1 then
         goto L210;
      end if;
      L := L - 1;
      --
      <<L50>> null;
      J := L + 1;
      loop
         J := J - 1;
         exit when J < 1;
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > L;
            if I = J then
               goto L60;
            end if;
            if dble (A (J, I)) /= ZERO or dimag (A (J, I)) /= ZERO then
               goto L70;
            end if;
            <<L60>> null;
         end loop;
         --
         M    := L;
         IEXC := 1;
         goto L20;
         <<L70>> null;
      end loop;
      --
      goto L90;
      --
      --     Search for columns isolating an eigenvalue and push them left.
      --
      <<L80>> null;
      K := K + 1;
      --
      <<L90>> null;
      J := K - 1;
      loop
         J := J + 1;
         exit when J > L;
         --
         I := K - 1;
         loop
            I := I + 1;
            exit when I > L;
            if I = J then
               goto L100;
            end if;
            if dble (A (I, J)) /= ZERO or dimag (A (I, J)) /= ZERO then
               goto L110;
            end if;
            <<L100>> null;
         end loop;
         --
         M    := K;
         IEXC := 2;
         goto L20;
         <<L110>> null;
      end loop;
      --
      <<L120>> null;
      I := K - 1;
      loop
         I := I + 1;
         exit when I > L;
         SCALE (I) := ONE;
      end loop;
      --
      if LSAME (JOB, 'P') then
         goto L210;
      end if;
      --
      --     Balance the submatrix in rows K to L.
      --
      --     Iterative loop for norm reduction
      --
      SFMIN1 := DLAMCH ('S') / DLAMCH ('P');
      SFMAX1 := ONE / SFMIN1;
      SFMIN2 := SFMIN1 * SCLFAC;
      SFMAX2 := ONE / SFMIN2;
      <<L140>> null;
      NOCONV := False;
      --
      I := K - 1;
      loop
         I := I + 1;
         exit when I > L;
         C := ZERO;
         R := ZERO;
         --
         J := K - 1;
         loop
            J := J + 1;
            exit when J > L;
            if J = I then
               goto L150;
            end if;
            C := C + CABS1 (A (J, I));
            R := R + CABS1 (A (I, J));
            <<L150>> null;
         end loop;
         ICA := IZAMAX (L, A (1, I)'Address, 1);
         CA  := abs (A (ICA, I));
         IRA := IZAMAX (N - K + 1, A (I, K)'Address, LDA);
         RA  := abs (A (I, IRA + K - 1));
         --
         --        Guard against zero C or R due to underflow.
         --
         if C = ZERO or R = ZERO then
            goto L200;
         end if;
         G := R / SCLFAC;
         F := ONE;
         S := C + R;
         <<L160>> null;
         if C >= G or max (F, C, CA) >= SFMAX2 or min (R, G, RA) <= SFMIN2 then
            -- ?? ---------------------------
            goto L170;
            -- ?? ---------------------------
         end if;
         if DISNAN (C + F + CA + R + G + RA) then
            --
            --           Exit if NaN to avoid infinite loop
            --
            INFO := -3;
            XERBLA ("ZGEBAL", -INFO);
            return;
         end if;
         F  := F * SCLFAC;
         C  := C * SCLFAC;
         CA := CA * SCLFAC;
         R  := R / SCLFAC;
         G  := G / SCLFAC;
         RA := RA / SCLFAC;
         -- ?? ---------------------------
         goto L160;
         -- ?? ---------------------------
         --
         <<L170>> null;
         G := C / SCLFAC;
         <<L180>> null;
         if G < R or max (R, RA) >= SFMAX2 or min (F, C, G, CA) <= SFMIN2 then
            -- ?? ---------------------------
            goto L190;
            -- ?? ---------------------------
         end if;
         F  := F / SCLFAC;
         C  := C / SCLFAC;
         G  := G / SCLFAC;
         CA := CA / SCLFAC;
         R  := R * SCLFAC;
         RA := RA * SCLFAC;
         -- ?? ---------------------------
         goto L180;
         -- ?? ---------------------------
         --
         --        Now balance.
         --
         <<L190>> null;
         if (C + R) >= FACTOR * S then
            goto L200;
         end if;
         if F < ONE and SCALE (I) < ONE then
            if F * SCALE (I) <= SFMIN1 then
               goto L200;
            end if;
         end if;
         if F > ONE and SCALE (I) > ONE then
            if SCALE (I) >= SFMAX1 / F then
               goto L200;
            end if;
         end if;
         G         := ONE / F;
         SCALE (I) := SCALE (I) * F;
         NOCONV    := True;
         --
         ZDSCAL (N - K + 1, G, A (I, K)'Address, LDA);
         ZDSCAL (L, F, A (1, I)'Address, 1);
         --
         <<L200>> null;
      end loop;
      --
      if NOCONV then
         goto L140;
      end if;
      --
      <<L210>> null;
      ILO := K;
      IHI := L;
      --
      return;
      --
      --     End of ZGEBAL
      --
   end ZGEBAL;

   procedure ZGEBD2
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      TAUQ_adr : Address;
      TAUP_adr : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      D    : Ftn_Real_Vector (1 .. min (M, N));
      E    : Ftn_Real_Vector (1 .. min (M, N) - 1);
      TAUQ : Ftn_Complex_Vector (1 .. min (M, N));
      TAUP : Ftn_Complex_Vector (1 .. min (M, N));
      WORK : Ftn_Complex_Vector (1 .. max (M, N));

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAUQ'Address use TAUQ_adr;
      for TAUP'Address use TAUP_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAUQ);
      pragma Import (Ada, TAUP);
      pragma Import (Ada, WORK);

      ZERO  : constant Complex := (0.0e0, 0.0e0);
      ONE   : constant Complex := (1.0e0, 0.0e0);
      I     : Integer;
      ALPHA : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEBD2( M, N, A, LDA, D, E, TAUQ, TAUP, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * )
   --       COMPLEX*16         A( LDA, * ), TAUP( * ), TAUQ( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEBD2 reduces a complex general m by n matrix A to upper or lower
   --  real bidiagonal form B by a unitary transformation: Q**H * A * P = B.
   --
   --  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows in the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns in the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the m by n general matrix to be reduced.
   --           On exit,
   --           if m >= n, the diagonal and the first superdiagonal are
   --             overwritten with the upper bidiagonal matrix B; the
   --             elements below the diagonal, with the array TAUQ, represent
   --             the unitary matrix Q as a product of elementary
   --             reflectors, and the elements above the first superdiagonal,
   --             with the array TAUP, represent the unitary matrix P as
   --             a product of elementary reflectors;
   --           if m < n, the diagonal and the first subdiagonal are
   --             overwritten with the lower bidiagonal matrix B; the
   --             elements below the first subdiagonal, with the array TAUQ,
   --             represent the unitary matrix Q as a product of
   --             elementary reflectors, and the elements above the diagonal,
   --             with the array TAUP, represent the unitary matrix P as
   --             a product of elementary reflectors.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (min(M,N))
   --           The diagonal elements of the bidiagonal matrix B:
   --           D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (min(M,N)-1)
   --           The off-diagonal elements of the bidiagonal matrix B:
   --           if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
   --           if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
   --
   --  [out] TAUQ
   --           TAUQ is COMPLEX*16 array dimension (min(M,N))
   --           The scalar factors of the elementary reflectors which
   --           represent the unitary matrix Q. See Further Details.
   --
   --  [out] TAUP
   --           TAUP is COMPLEX*16 array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors which
   --           represent the unitary matrix P. See Further Details.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (max(M,N))
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrices Q and P are represented as products of elementary
   --   reflectors:
   --
   --   If m >= n,
   --
   --      Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
   --
   --   where tauq and taup are complex scalars, and v and u are complex
   --   vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
   --   A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
   --   A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   If m < n,
   --
   --      Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
   --
   --   where tauq and taup are complex scalars, v and u are complex vectors;
   --   v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
   --   u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
   --   tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   The contents of A on exit are illustrated by the following examples:
   --
   --   m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
   --
   --     (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
   --     (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
   --     (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
   --     (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
   --     (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
   --     (  v1  v2  v3  v4  v5 )
   --
   --   where d and e denote diagonal and off-diagonal elements of B, vi
   --   denotes an element of the vector defining H(i), and ui an element of
   --   the vector defining G(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ), ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLACGV, ZLARF, ZLARFG
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG, MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO < 0 then
         XERBLA ("ZGEBD2", -INFO);
         return;
      end if;
      --
      if M >= N then
         --
         --        Reduce to upper bidiagonal form
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            --
            --           Generate elementary reflector H(i) to annihilate A(i+1:m,i)
            --
            ALPHA := A (I, I);
            ZLARFG (M - I + 1, ALPHA, A (min (I + 1, M), I)'Address, 1, TAUQ (I));
            D (I)    := real_part (ALPHA);
            A (I, I) := ONE;
            --
            --           Apply H(i)**H to A(i:m,i+1:n) from the left
            --
            if I < N then
               ZLARF
                 ('L',
                  M - I + 1,
                  N - I,
                  A (I, I)'Address,
                  1,
                  dconjg (TAUQ (I)),
                  A (I, I + 1)'Address,
                  LDA,
                  WORK'Address);
            end if;
            A (I, I) := Complex'(D (I), 0.0e0);
            --
            if I < N then
               --
               --              Generate elementary reflector G(i) to annihilate
               --              A(i,i+2:n)
               --
               ZLACGV (N - I, A (I, I + 1)'Address, LDA);
               ALPHA := A (I, I + 1);
               ZLARFG (N - I, ALPHA, A (I, min (I + 2, N))'Address, LDA, TAUP (I));
               E (I)        := real_part (ALPHA);
               A (I, I + 1) := ONE;
               --
               --              Apply G(i) to A(i+1:m,i+1:n) from the right
               --
               ZLARF ('R', M - I, N - I, A (I, I + 1)'Address, LDA, TAUP (I), A (I + 1, I + 1)'Address, LDA, WORK'Address);
               ZLACGV (N - I, A (I, I + 1)'Address, LDA);
               A (I, I + 1) := Complex'(E (I), 0.0e0);
            else
               TAUP (I) := ZERO;
            end if;
         end loop;
      else
         --
         --        Reduce to lower bidiagonal form
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            --
            --           Generate elementary reflector G(i) to annihilate A(i,i+1:n)
            --
            ZLACGV (N - I + 1, A (I, I)'Address, LDA);
            ALPHA := A (I, I);
            ZLARFG (N - I + 1, ALPHA, A (I, min (I + 1, N))'Address, LDA, TAUP (I));
            D (I)    := real_part (ALPHA);
            A (I, I) := ONE;
            --
            --           Apply G(i) to A(i+1:m,i:n) from the right
            --
            if I < M then
               ZLARF ('R', M - I, N - I + 1, A (I, I)'Address, LDA, TAUP (I), A (I + 1, I)'Address, LDA, WORK'Address);
            end if;
            ZLACGV (N - I + 1, A (I, I)'Address, LDA);
            A (I, I) := Complex'(D (I), 0.0e0);
            --
            if I < M then
               --
               --              Generate elementary reflector H(i) to annihilate
               --              A(i+2:m,i)
               --
               ALPHA := A (I + 1, I);
               ZLARFG (M - I, ALPHA, A (min (I + 2, M), I)'Address, 1, TAUQ (I));
               E (I)        := real_part (ALPHA);
               A (I + 1, I) := ONE;
               --
               --              Apply H(i)**H to A(i+1:m,i+1:n) from the left
               --
               ZLARF
                 ('L',
                  M - I,
                  N - I,
                  A (I + 1, I)'Address,
                  1,
                  dconjg (TAUQ (I)),
                  A (I + 1, I + 1)'Address,
                  LDA,
                  WORK'Address);
               A (I + 1, I) := Complex'(E (I), 0.0e0);
            else
               TAUQ (I) := ZERO;
            end if;
         end loop;
      end if;
      return;
      --
      --     End of ZGEBD2
      --
   end ZGEBD2;

   procedure ZGEBRD
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      TAUQ_adr : Address;
      TAUP_adr : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      D    : Ftn_Real_Vector (1 .. min (M, N));
      E    : Ftn_Real_Vector (1 .. min (M, N) - 1);
      TAUQ : Ftn_Complex_Vector (1 .. min (M, N));
      TAUP : Ftn_Complex_Vector (1 .. min (M, N));
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAUQ'Address use TAUQ_adr;
      for TAUP'Address use TAUP_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAUQ);
      pragma Import (Ada, TAUP);
      pragma Import (Ada, WORK);

      ONE    : constant Complex := (1.0e0, 0.0e0);
      LQUERY : Boolean;
      I      : Integer;
      IINFO  : Integer;
      J      : Integer;
      LDWRKX : Integer;
      LDWRKY : Integer;
      LWKOPT : Integer;
      MINMN  : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
      WS     : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEBRD( M, N, A, LDA, D, E, TAUQ, TAUP, WORK, LWORK,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * )
   --       COMPLEX*16         A( LDA, * ), TAUP( * ), TAUQ( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEBRD reduces a general complex M-by-N matrix A to upper or lower
   --  bidiagonal form B by a unitary transformation: Q**H * A * P = B.
   --
   --  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows in the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns in the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the M-by-N general matrix to be reduced.
   --           On exit,
   --           if m >= n, the diagonal and the first superdiagonal are
   --             overwritten with the upper bidiagonal matrix B; the
   --             elements below the diagonal, with the array TAUQ, represent
   --             the unitary matrix Q as a product of elementary
   --             reflectors, and the elements above the first superdiagonal,
   --             with the array TAUP, represent the unitary matrix P as
   --             a product of elementary reflectors;
   --           if m < n, the diagonal and the first subdiagonal are
   --             overwritten with the lower bidiagonal matrix B; the
   --             elements below the first subdiagonal, with the array TAUQ,
   --             represent the unitary matrix Q as a product of
   --             elementary reflectors, and the elements above the diagonal,
   --             with the array TAUP, represent the unitary matrix P as
   --             a product of elementary reflectors.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (min(M,N))
   --           The diagonal elements of the bidiagonal matrix B:
   --           D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (min(M,N)-1)
   --           The off-diagonal elements of the bidiagonal matrix B:
   --           if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
   --           if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
   --
   --  [out] TAUQ
   --           TAUQ is COMPLEX*16 array dimension (min(M,N))
   --           The scalar factors of the elementary reflectors which
   --           represent the unitary matrix Q. See Further Details.
   --
   --  [out] TAUP
   --           TAUP is COMPLEX*16 array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors which
   --           represent the unitary matrix P. See Further Details.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of the array WORK.  LWORK >= max(1,M,N).
   --           For optimum performance LWORK >= (M+N)*NB, where NB
   --           is the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrices Q and P are represented as products of elementary
   --   reflectors:
   --
   --   If m >= n,
   --
   --      Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
   --
   --   where tauq and taup are complex scalars, and v and u are complex
   --   vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
   --   A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
   --   A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   If m < n,
   --
   --      Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
   --
   --   where tauq and taup are complex scalars, and v and u are complex
   --   vectors; v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in
   --   A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in
   --   A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   The contents of A on exit are illustrated by the following examples:
   --
   --   m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
   --
   --     (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
   --     (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
   --     (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
   --     (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
   --     (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
   --     (  v1  v2  v3  v4  v5 )
   --
   --   where d and e denote diagonal and off-diagonal elements of B, vi
   --   denotes an element of the vector defining H(i), and ui an element of
   --   the vector defining G(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZGEBD2, ZGEMM, ZLABRD
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO     := 0;
      NB       := max (1, ILAENV (1, "ZGEBRD", "   ", M, N, -1, -1));
      LWKOPT   := (M + N) * NB;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      elsif LWORK < max (1, M, N) and not LQUERY then
         INFO := -10;
      end if;
      if INFO < 0 then
         XERBLA ("ZGEBRD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      MINMN := min (M, N);
      if MINMN = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      WS     := Real (max (M, N));
      LDWRKX := M;
      LDWRKY := N;
      --
      if NB > 1 and NB < MINMN then
         --
         --        Set the crossover point NX.
         --
         NX := max (NB, ILAENV (3, "ZGEBRD", "   ", M, N, -1, -1));
         --
         --        Determine when to switch from blocked to unblocked code.
         --
         if NX < MINMN then
            WS := Real ((M + N) * NB);
            if Real (LWORK) < WS then
               --
               --              Not enough work space for the optimal NB, consider using
               --              a smaller block size.
               --
               NBMIN := ILAENV (2, "ZGEBRD", "   ", M, N, -1, -1);
               if LWORK >= (M + N) * NBMIN then
                  NB := LWORK / (M + N);
               else
                  NB := 1;
                  NX := MINMN;
               end if;
            end if;
         end if;
      else
         NX := MINMN;
      end if;
      --
      I := 1 - NB;
      loop
         I := I + NB;
         exit when I > MINMN - NX;
         --
         --        Reduce rows and columns i:i+ib-1 to bidiagonal form and return
         --        the matrices X and Y which are needed to update the unreduced
         --        part of the matrix
         --
         ZLABRD
           (M - I + 1,
            N - I + 1,
            NB,
            A (I, I)'Address,
            LDA,
            D (I)'Address,
            E (I)'Address,
            TAUQ (I)'Address,
            TAUP (I)'Address,
            WORK'Address,
            LDWRKX,
            WORK (LDWRKX * NB + 1)'Address,
            LDWRKY);
         --
         --        Update the trailing submatrix A(i+ib:m,i+ib:n), using
         --        an update of the form  A := A - V*Y**H - X*U**H
         --
         ZGEMM
           ('N',
            'C',
            M - I - NB + 1,
            N - I - NB + 1,
            NB,
            -ONE,
            A (I + NB, I)'Address,
            LDA,
            WORK (LDWRKX * NB + NB + 1)'Address,
            LDWRKY,
            ONE,
            A (I + NB, I + NB)'Address,
            LDA);
         ZGEMM
           ('N',
            'N',
            M - I - NB + 1,
            N - I - NB + 1,
            NB,
            -ONE,
            WORK (NB + 1)'Address,
            LDWRKX,
            A (I, I + NB)'Address,
            LDA,
            ONE,
            A (I + NB, I + NB)'Address,
            LDA);
         --
         --        Copy diagonal and off-diagonal elements of B back into A
         --
         if M >= N then
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + NB - 1;
               A (J, J)     := Complex'(D (J), 0.0e0);
               A (J, J + 1) := Complex'(E (J), 0.0e0);
            end loop;
         else
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + NB - 1;
               A (J, J)     := Complex'(D (J), 0.0e0);
               A (J + 1, J) := Complex'(E (J), 0.0e0);
            end loop;
         end if;
      end loop;
      --
      --     Use unblocked code to reduce the remainder of the matrix
      --
      ZGEBD2
        (M - I + 1,
         N - I + 1,
         A (I, I)'Address,
         LDA,
         D (I)'Address,
         E (I)'Address,
         TAUQ (I)'Address,
         TAUP (I)'Address,
         WORK'Address,
         IINFO);
      WORK (1) := Complex'(WS, 0.0e0);
      return;
      --
      --     End of ZGEBRD
      --
   end ZGEBRD;

   procedure ZGEEV
     (JOBVL : Character;
      JOBVR : Character;
      N     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      W     : in out Ftn_Complex_Vector;
      VL    : in out Ftn_Complex_Matrix;
      LDVL  : Integer;
      VR    : in out Ftn_Complex_Matrix;
      LDVR  : Integer;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      RWORK : in out Ftn_Real_Vector;
      INFO  : in out Integer)
   is
      ZERO       : constant Real := 0.0e0;
      ONE        : constant Real := 1.0e0;
      LQUERY     : Boolean;
      SCALEA     : Boolean;
      WANTVL     : Boolean;
      WANTVR     : Boolean;
      SIDE       : Character;
      HSWORK     : Integer;
      I          : Integer;
      IBAL       : Integer;
      IERR       : Integer;
      IHI        : Integer;
      ILO        : Integer;
      IRWORK     : Integer;
      ITAU       : Integer;
      IWRK       : Integer;
      K          : Integer;
      MAXWRK     : Integer;
      MINWRK     : Integer;
      NOUT       : Integer;
      ANRM       : Real;
      BIGNUM     : Real;
      CSCALE     : Real;
      EPS        : Real;
      SCL        : Real;
      SMLNUM     : Real;
      TMP        : Complex;
      the_SELECT : Ftn_Boolean_Vector (1 .. 1);
      DUM        : Ftn_Real_Vector (1 .. 1);

   --  ZGEEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEEV( JOBVL, JOBVR, N, A, LDA, W, VL, LDVL, VR, LDVR,
   --                         WORK, LWORK, RWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBVL, JOBVR
   --       INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   RWORK( * )
   --       COMPLEX*16         A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),
   --      $                   W( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEEV computes for an N-by-N complex nonsymmetric matrix A, the
   --  eigenvalues and, optionally, the left and/or right eigenvectors.
   --
   --  The right eigenvector v(j) of A satisfies
   --                   A * v(j) = lambda(j) * v(j)
   --  where lambda(j) is its eigenvalue.
   --  The left eigenvector u(j) of A satisfies
   --                u(j)**H * A = lambda(j) * u(j)**H
   --  where u(j)**H denotes the conjugate transpose of u(j).
   --
   --  The computed eigenvectors are normalized to have Euclidean norm
   --  equal to 1 and largest component real.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBVL
   --           JOBVL is CHARACTER*1
   --           = 'N': left eigenvectors of A are not computed;
   --           = 'V': left eigenvectors of are computed.
   --
   --  [in] JOBVR
   --           JOBVR is CHARACTER*1
   --           = 'N': right eigenvectors of A are not computed;
   --           = 'V': right eigenvectors of A are computed.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A. N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the N-by-N matrix A.
   --           On exit, A has been overwritten.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] W
   --           W is COMPLEX*16 array, dimension (N)
   --           W contains the computed eigenvalues.
   --
   --  [out] VL
   --           VL is COMPLEX*16 array, dimension (LDVL,N)
   --           If JOBVL = 'V', the left eigenvectors u(j) are stored one
   --           after another in the columns of VL, in the same order
   --           as their eigenvalues.
   --           If JOBVL = 'N', VL is not referenced.
   --           u(j) = VL(:,j), the j-th column of VL.
   --
   --  [in] LDVL
   --           LDVL is INTEGER
   --           The leading dimension of the array VL.  LDVL >= 1; if
   --           JOBVL = 'V', LDVL >= N.
   --
   --  [out] VR
   --           VR is COMPLEX*16 array, dimension (LDVR,N)
   --           If JOBVR = 'V', the right eigenvectors v(j) are stored one
   --           after another in the columns of VR, in the same order
   --           as their eigenvalues.
   --           If JOBVR = 'N', VR is not referenced.
   --           v(j) = VR(:,j), the j-th column of VR.
   --
   --  [in] LDVR
   --           LDVR is INTEGER
   --           The leading dimension of the array VR.  LDVR >= 1; if
   --           JOBVR = 'V', LDVR >= N.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= max(1,2*N).
   --           For good performance, LWORK must generally be larger.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array, dimension (2*N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = i, the QR algorithm failed to compute all the
   --                 eigenvalues, and no eigenvectors have been computed;
   --                 elements and i+1:N of W contain eigenvalues which have
   --                 converged.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           DLABAD, XERBLA, ZDSCAL, ZGEBAK, ZGEBAL, ZGEHRD,
   --      $                   ZHSEQR, ZLACPY, ZLASCL, ZSCAL, ZTREVC, ZUNGHR
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       INTEGER            IDAMAX, ILAENV
   --       DOUBLE PRECISION   DLAMCH, DZNRM2, ZLANGE
   --       EXTERNAL           LSAME, IDAMAX, ILAENV, DLAMCH, DZNRM2, ZLANGE
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, DCMPLX, DCONJG, DIMAG, MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1);
      WANTVL := LSAME (JOBVL, 'V');
      WANTVR := LSAME (JOBVR, 'V');
      if (not WANTVL) and (not LSAME (JOBVL, 'N')) then
         INFO := -1;
      elsif (not WANTVR) and (not LSAME (JOBVR, 'N')) then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDVL < 1 or (WANTVL and LDVL < N) then
         INFO := -8;
      elsif LDVR < 1 or (WANTVR and LDVR < N) then
         INFO := -10;
      end if;
      --
      --     Compute workspace
      --      (Note: Comments in the code beginning "Workspace:" describe the
      --       minimal amount of workspace needed at that point in the code,
      --       as well as the preferred amount for good performance.
      --       CWorkspace refers to complex workspace, and RWorkspace to real
      --       workspace. NB refers to the optimal block size for the
      --       immediately following subroutine, as returned by ILAENV.
      --       HSWORK refers to the workspace preferred by ZHSEQR, as
      --       calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
      --       the worst case.)
      --
      if INFO = 0 then
         if N = 0 then
            MINWRK := 1;
            MAXWRK := 1;
         else
            MAXWRK := N + N * ILAENV (1, "ZGEHRD", " ", N, 1, N, 0);
            MINWRK := 2 * N;
            if WANTVL then
               MAXWRK := max (MAXWRK, N + (N - 1) * ILAENV (1, "ZUNGHR", " ", N, 1, N, -1));
               ZHSEQR ('S', 'V', N, 1, N, A'Address, LDA, W'Address, VL'Address, LDVL, WORK'Address, -1, INFO);
            elsif WANTVR then
               MAXWRK := max (MAXWRK, N + (N - 1) * ILAENV (1, "ZUNGHR", " ", N, 1, N, -1));
               ZHSEQR ('S', 'V', N, 1, N, A'Address, LDA, W'Address, VR'Address, LDVR, WORK'Address, -1, INFO);
            else
               ZHSEQR ('E', 'N', N, 1, N, A'Address, LDA, W'Address, VR'Address, LDVR, WORK'Address, -1, INFO);
            end if;
            HSWORK := int (dble (WORK (1)));
            MAXWRK := max (MAXWRK, HSWORK, MINWRK);
         end if;
         WORK (1) := Complex'(Real (MAXWRK), 0.0e0);
         --
         if LWORK < MINWRK and not LQUERY then
            INFO := -12;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZGEEV ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     Get machine constants
      --
      EPS    := DLAMCH ('P');
      SMLNUM := DLAMCH ('S');
      BIGNUM := ONE / SMLNUM;
      DLABAD (SMLNUM, BIGNUM);
      SMLNUM := Sqrt (SMLNUM) / EPS;
      BIGNUM := ONE / SMLNUM;
      --
      --     Scale A if max element outside range [SMLNUM,BIGNUM]
      --
      ANRM   := ZLANGE ('M', N, N, A, LDA, DUM);
      SCALEA := False;
      if ANRM > ZERO and ANRM < SMLNUM then
         SCALEA := True;
         CSCALE := SMLNUM;
      elsif ANRM > BIGNUM then
         SCALEA := True;
         CSCALE := BIGNUM;
      end if;
      if SCALEA then
         ZLASCL ('G', 0, 0, ANRM, CSCALE, N, N, A'Address, LDA, IERR);
      end if;
      --
      --     Balance the matrix
      --     (CWorkspace: none)
      --     (RWorkspace: need N)
      --
      IBAL := 1;
      ZGEBAL ('B', N, A'Address, LDA, ILO, IHI, RWORK (IBAL)'Address, IERR);
      --
      --     Reduce to upper Hessenberg form
      --     (CWorkspace: need 2*N, prefer N+N*NB)
      --     (RWorkspace: none)
      --
      ITAU := 1;
      IWRK := ITAU + N;
      ZGEHRD (N, ILO, IHI, A'Address, LDA, WORK (ITAU)'Address, WORK (IWRK)'Address, LWORK - IWRK + 1, IERR);
      --
      if WANTVL then
         --
         --        Want left eigenvectors
         --        Copy Householder vectors to VL
         --
         SIDE := 'L';
         ZLACPY ('L', N, N, A'Address, LDA, VL'Address, LDVL);
         --
         --        Generate unitary matrix in VL
         --        (CWorkspace: need 2*N-1, prefer N+(N-1)*NB)
         --        (RWorkspace: none)
         --
         ZUNGHR (N, ILO, IHI, VL'Address, LDVL, WORK (ITAU)'Address, WORK (IWRK)'Address, LWORK - IWRK + 1, IERR);
         --
         --        Perform QR iteration, accumulating Schur vectors in VL
         --        (CWorkspace: need 1, prefer HSWORK (see comments) )
         --        (RWorkspace: none)
         --
         IWRK := ITAU;
         ZHSEQR
           ('S',
            'V',
            N,
            ILO,
            IHI,
            A'Address,
            LDA,
            W'Address,
            VL'Address,
            LDVL,
            WORK (IWRK)'Address,
            LWORK - IWRK + 1,
            INFO);
         --
         if WANTVR then
            --
            --           Want left and right eigenvectors
            --           Copy Schur vectors to VR
            --
            SIDE := 'B';
            ZLACPY ('F', N, N, VL'Address, LDVL, VR'Address, LDVR);
         end if;
      --
      elsif WANTVR then
         --
         --        Want right eigenvectors
         --        Copy Householder vectors to VR
         --
         SIDE := 'R';
         ZLACPY ('L', N, N, A'Address, LDA, VR'Address, LDVR);
         --
         --        Generate unitary matrix in VR
         --        (CWorkspace: need 2*N-1, prefer N+(N-1)*NB)
         --        (RWorkspace: none)
         --
         ZUNGHR (N, ILO, IHI, VR'Address, LDVR, WORK (ITAU)'Address, WORK (IWRK)'Address, LWORK - IWRK + 1, IERR);
         --
         --        Perform QR iteration, accumulating Schur vectors in VR
         --        (CWorkspace: need 1, prefer HSWORK (see comments) )
         --        (RWorkspace: none)
         --
         IWRK := ITAU;
         ZHSEQR
           ('S',
            'V',
            N,
            ILO,
            IHI,
            A'Address,
            LDA,
            W'Address,
            VR'Address,
            LDVR,
            WORK (IWRK)'Address,
            LWORK - IWRK + 1,
            INFO);
      --
      else
         --
         --        Compute eigenvalues only
         --        (CWorkspace: need 1, prefer HSWORK (see comments) )
         --        (RWorkspace: none)
         --
         IWRK := ITAU;
         ZHSEQR
           ('E',
            'N',
            N,
            ILO,
            IHI,
            A'Address,
            LDA,
            W'Address,
            VR'Address,
            LDVR,
            WORK (IWRK)'Address,
            LWORK - IWRK + 1,
            INFO);
      end if;
      --
      --     If INFO > 0 from ZHSEQR, then quit
      --
      if INFO > 0 then
         goto L50;
      end if;
      --
      if WANTVL or WANTVR then
         --
         --        Compute left and/or right eigenvectors
         --        (CWorkspace: need 2*N)
         --        (RWorkspace: need 2*N)
         --
         IRWORK := IBAL + N;
         ZTREVC
           (SIDE,
            'B',
            the_SELECT'Address,
            N,
            A'Address,
            LDA,
            VL'Address,
            LDVL,
            VR'Address,
            LDVR,
            N,
            NOUT,
            WORK (IWRK)'Address,
            RWORK (IRWORK)'Address,
            IERR);
      end if;
      --
      if WANTVL then
         --
         --        Undo balancing of left eigenvectors
         --        (CWorkspace: none)
         --        (RWorkspace: need N)
         --
         ZGEBAK ('B', 'L', N, ILO, IHI, RWORK (IBAL)'Address, N, VL'Address, LDVL, IERR);
         --
         --        Normalize left eigenvectors and make largest component real
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            SCL := ONE / DZNRM2 (N, VL (1, I)'Address, 1);
            ZDSCAL (N, SCL, VL (1, I)'Address, 1);
            K := 1 - 1;
            loop
               K := K + 1;
               exit when K > N;
               RWORK (IRWORK + K - 1) := dble (VL (K, I)) ** 2 + dimag (VL (K, I)) ** 2;
            end loop;
            K   := IDAMAX (N, RWORK (IRWORK)'Address, 1);
            TMP := dconjg (VL (K, I)) / Sqrt (RWORK (IRWORK + K - 1));
            ZSCAL (N, TMP, VL (1, I)'Address, 1);
            VL (K, I) := dcmplx (dble (VL (K, I)), ZERO);
         end loop;
      end if;
      --
      if WANTVR then
         --
         --        Undo balancing of right eigenvectors
         --        (CWorkspace: none)
         --        (RWorkspace: need N)
         --
         ZGEBAK ('B', 'R', N, ILO, IHI, RWORK (IBAL)'Address, N, VR'Address, LDVR, IERR);
         --
         --        Normalize right eigenvectors and make largest component real
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            SCL := ONE / DZNRM2 (N, VR (1, I)'Address, 1);
            ZDSCAL (N, SCL, VR (1, I)'Address, 1);
            K := 1 - 1;
            loop
               K := K + 1;
               exit when K > N;
               RWORK (IRWORK + K - 1) := dble (VR (K, I)) ** 2 + dimag (VR (K, I)) ** 2;
            end loop;
            K   := IDAMAX (N, RWORK (IRWORK)'Address, 1);
            TMP := dconjg (VR (K, I)) / Sqrt (RWORK (IRWORK + K - 1));
            ZSCAL (N, TMP, VR (1, I)'Address, 1);
            VR (K, I) := dcmplx (dble (VR (K, I)), ZERO);
         end loop;
      end if;
      --
      --     Undo scaling if necessary
      --
      <<L50>> null;
      if SCALEA then
         ZLASCL ('G', 0, 0, CSCALE, ANRM, N - INFO, 1, W (INFO + 1)'Address, max (N - INFO, 1), IERR);
         if INFO > 0 then
            ZLASCL ('G', 0, 0, CSCALE, ANRM, ILO - 1, 1, W'Address, N, IERR);
         end if;
      end if;
      --
      WORK (1) := Complex'(Real (MAXWRK), 0.0e0);
      return;
      --
      --     End of ZGEEV
      --
   end ZGEEV;

   procedure ZGEHD2
     (N    : Integer;
      ILO  : Integer;
      IHI  : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer;
      TAU  : in out Ftn_Complex_Vector;
      WORK : in out Ftn_Complex_Vector;
      INFO : in out Integer)
   is
      ONE   : constant Complex := (1.0e0, 0.0e0);
      I     : Integer;
      ALPHA : Complex;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEHD2( N, ILO, IHI, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEHD2 reduces a complex general matrix A to upper Hessenberg form H
   --  by a unitary similarity transformation:  Q**H * A * Q = H .
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --           It is assumed that A is already upper triangular in rows
   --           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
   --           set by a previous call to ZGEBAL; otherwise they should be
   --           set to 1 and N respectively. See Further Details.
   --           1 <= ILO <= IHI <= max(1,N).
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the n by n general matrix to be reduced.
   --           On exit, the upper triangle and the first subdiagonal of A
   --           are overwritten with the upper Hessenberg matrix H, and the
   --           elements below the first subdiagonal, with the array TAU,
   --           represent the unitary matrix Q as a product of elementary
   --           reflectors. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (N-1)
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of (ihi-ilo) elementary
   --   reflectors
   --
   --      Q = H(ilo) H(ilo+1) . . . H(ihi-1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
   --   exit in A(i+2:ihi,i), and tau in TAU(i).
   --
   --   The contents of A are illustrated by the following example, with
   --   n = 7, ilo = 2 and ihi = 6:
   --
   --   on entry,                        on exit,
   --
   --   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
   --   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
   --   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
   --   (                         a )    (                          a )
   --
   --   where a denotes an element of the original matrix A, h denotes a
   --   modified element of the upper Hessenberg matrix H, and vi denotes an
   --   element of the vector defining H(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZLARF, ZLARFG
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG, MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO := 0;
      if N < 0 then
         INFO := -1;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -2;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGEHD2", -INFO);
         return;
      end if;
      --
      I := ILO - 1;
      loop
         I := I + 1;
         exit when I > IHI - 1;
         --
         --        Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
         --
         ALPHA := A (I + 1, I);
         ZLARFG (IHI - I, ALPHA, A (min (I + 2, N), I)'Address, 1, TAU (I));
         A (I + 1, I) := ONE;
         --
         --        Apply H(i) to A(1:ihi,i+1:ihi) from the right
         --
         ZLARF ('R', IHI, IHI - I, A (I + 1, I)'Address, 1, TAU (I), A (1, I + 1)'Address, LDA, WORK'Address);
         --
         --        Apply H(i)**H to A(i+1:ihi,i+1:n) from the left
         --
         ZLARF
           ('L',
            IHI - I,
            N - I,
            A (I + 1, I)'Address,
            1,
            dconjg (TAU (I)),
            A (I + 1, I + 1)'Address,
            LDA,
            WORK'Address);
         --
         A (I + 1, I) := ALPHA;
      end loop;
      --
      return;
      --
      --     End of ZGEHD2
      --
   end ZGEHD2;

   procedure ZGEHRD
     (N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. N - 1);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      NBMAX  : constant Integer := 64;
      LDT    : constant Integer := NBMAX + 1;
      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NH     : Integer;
      NX     : Integer;
      EI     : Complex;
      T      : Ftn_Complex_Matrix (1 .. LDT, 1 .. NBMAX);

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEHRD( N, ILO, IHI, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16        A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEHRD reduces a complex general matrix A to upper Hessenberg form H by
   --  an unitary similarity transformation:  Q**H * A * Q = H .
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --           It is assumed that A is already upper triangular in rows
   --           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
   --           set by a previous call to ZGEBAL; otherwise they should be
   --           set to 1 and N respectively. See Further Details.
   --           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the N-by-N general matrix to be reduced.
   --           On exit, the upper triangle and the first subdiagonal of A
   --           are overwritten with the upper Hessenberg matrix H, and the
   --           elements below the first subdiagonal, with the array TAU,
   --           represent the unitary matrix Q as a product of elementary
   --           reflectors. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (N-1)
   --           The scalar factors of the elementary reflectors (see Further
   --           Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
   --           zero.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (LWORK)
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of the array WORK.  LWORK >= max(1,N).
   --           For optimum performance LWORK >= N*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of (ihi-ilo) elementary
   --   reflectors
   --
   --      Q = H(ilo) H(ilo+1) . . . H(ihi-1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
   --   exit in A(i+2:ihi,i), and tau in TAU(i).
   --
   --   The contents of A are illustrated by the following example, with
   --   n = 7, ilo = 2 and ihi = 6:
   --
   --   on entry,                        on exit,
   --
   --   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
   --   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
   --   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
   --   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
   --   (                         a )    (                          a )
   --
   --   where a denotes an element of the original matrix A, h denotes a
   --   modified element of the upper Hessenberg matrix H, and vi denotes an
   --   element of the vector defining H(i).
   --
   --   This file is a slight modification of LAPACK-3.0's DGEHRD
   --   subroutine incorporating improvements proposed by Quintana-Orti and
   --   Van de Geijn (2006). (See DLAHR2.)
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ),  ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           ZAXPY, ZGEHD2, ZGEMM, ZLAHR2, ZLARFB, ZTRMM,
   --      $                   XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --       INTEGER            ILAENV
   --       EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO     := 0;
      NB       := min (NBMAX, ILAENV (1, "ZGEHRD", " ", N, ILO, IHI, -1));
      LWKOPT   := N * NB;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      LQUERY   := (LWORK = -1);
      if N < 0 then
         INFO := -1;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -2;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGEHRD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Set elements 1:ILO-1 and IHI:N-1 of TAU to zero
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > ILO - 1;
         TAU (I) := ZERO;
      end loop;
      I := max (1, IHI) - 1;
      loop
         I := I + 1;
         exit when I > N - 1;
         TAU (I) := ZERO;
      end loop;
      --
      --     Quick return if possible
      --
      NH := IHI - ILO + 1;
      if NH <= 1 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      --     Determine the block size
      --
      NB    := min (NBMAX, ILAENV (1, "ZGEHRD", " ", N, ILO, IHI, -1));
      NBMIN := 2;
      IWS   := 1;
      if NB > 1 and NB < NH then
         --
         --        Determine when to cross over from blocked to unblocked code
         --        (last block is always handled by unblocked code)
         --
         NX := max (NB, ILAENV (3, "ZGEHRD", " ", N, ILO, IHI, -1));
         if NX < NH then
            --
            --           Determine if workspace is large enough for blocked code
            --
            IWS := N * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  determine the
               --              minimum value of NB, and reduce NB or force use of
               --              unblocked code
               --
               NBMIN := max (2, ILAENV (2, "ZGEHRD", " ", N, ILO, IHI, -1));
               if LWORK >= N * NBMIN 
                  then NB := LWORK / N;
                  else NB := 1;
               end if;
            end if;
         end if;
      end if;
      LDWORK := N;
      --
      if NB < NBMIN or NB >= NH then
         --
         --        Use unblocked code below
         --
         I := ILO;
      --
      else
         --
         --        Use blocked code
         --
         I := ILO - NB;
         loop
            I := I + NB;
            exit when I > IHI - 1 - NX;
            IB := min (NB, IHI - I);
            --
            --           Reduce columns i:i+ib-1 to Hessenberg form, returning the
            --           matrices V and T of the block reflector H = I - V*T*V**H
            --           which performs the reduction, and also the matrix Y = A*V*T
            --
            ZLAHR2 (IHI, I, IB, A (1, I)'Address, LDA, TAU (I)'Address, T'Address, LDT, WORK'Address, LDWORK);
            --
            --           Apply the block reflector H to A(1:ihi,i+ib:ihi) from the
            --           right, computing  A := A - Y * V**H. V(i+ib,ib-1) must be set
            --           to 1
            --
            EI                     := A (I + IB, I + IB - 1);
            A (I + IB, I + IB - 1) := ONE;
            ZGEMM
              ('N',
               'C',
               IHI,
               IHI - I - IB + 1,
               IB,
               -ONE,
               WORK'Address,
               LDWORK,
               A (I + IB, I)'Address,
               LDA,
               ONE,
               A (1, I + IB)'Address,
               LDA);
            A (I + IB, I + IB - 1) := EI;
            --
            --           Apply the block reflector H to A(1:i,i+1:i+ib-1) from the
            --           right
            --
            ZTRMM ('R', 'L', 'C', 'U', I, IB - 1, ONE, A (I + 1, I)'Address, LDA, WORK'Address, LDWORK);
            J := 0 - 1;
            loop
               J := J + 1;
               exit when J > IB - 2;
               ZAXPY (I, -ONE, WORK (LDWORK * J + 1)'Address, 1, A (1, I + J + 1)'Address, 1);
            end loop;
            --
            --           Apply the block reflector H to A(i+1:ihi,i+ib:n) from the
            --           left
            --
            ZLARFB
              ('L',
               'C',
               'F',
               'C',
               IHI - I,
               N - I - IB + 1,
               IB,
               A (I + 1, I)'Address,
               LDA,
               T'Address,
               LDT,
               A (I + 1, I + IB)'Address,
               LDA,
               WORK'Address,
               LDWORK);
         end loop;
      end if;
      --
      --     Use unblocked code to reduce the rest of the matrix
      --
      ZGEHD2 (N, I, IHI, A, LDA, TAU, WORK, IINFO);
      WORK (1) := Complex'(Real (IWS), 0.0e0);
      --
      return;
      --
      --     End of ZGEHRD
      --
   end ZGEHRD;

   procedure ZGELQ2
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. min (M, N));
      WORK : Ftn_Complex_Vector (1 .. M);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE   : constant Complex := (1.0e0, 0.0e0);
      I     : Integer;
      K     : Integer;
      ALPHA : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGELQ2( M, N, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGELQ2 computes an LQ factorization of a complex m by n matrix A:
   --  A = L * Q.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the m by n matrix A.
   --           On exit, the elements on and below the diagonal of the array
   --           contain the m by min(m,n) lower trapezoidal matrix L (L is
   --           lower triangular if m <= n); the elements above the diagonal,
   --           with the array TAU, represent the unitary matrix Q as a
   --           product of elementary reflectors (see Further Details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (M)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of elementary reflectors
   --
   --      Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
   --   A(i,i+1:n), and tau in TAU(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLACGV, ZLARF, ZLARFG
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGELQ2", -INFO);
         return;
      end if;
      --
      K := min (M, N);
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         --
         --        Generate elementary reflector H(i) to annihilate A(i,i+1:n)
         --
         ZLACGV (N - I + 1, A (I, I)'Address, LDA);
         ALPHA := A (I, I);
         ZLARFG (N - I + 1, ALPHA, A (I, min (I + 1, N))'Address, LDA, TAU (I));
         if I < M then
            --
            --           Apply H(i) to A(i+1:m,i:n) from the right
            --
            A (I, I) := ONE;
            ZLARF ('R', M - I, N - I + 1, A (I, I)'Address, LDA, TAU (I), A (I + 1, I)'Address, LDA, WORK'Address);
         end if;
         A (I, I) := ALPHA;
         ZLACGV (N - I + 1, A (I, I)'Address, LDA);
      end loop;
      return;
      --
      --     End of ZGELQ2
      --
   end ZGELQ2;

   procedure ZGELQF
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. min (M, N));
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      K      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGELQF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGELQF computes an LQ factorization of a complex M-by-N matrix A:
   --  A = L * Q.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the M-by-N matrix A.
   --           On exit, the elements on and below the diagonal of the array
   --           contain the m-by-min(m,n) lower trapezoidal matrix L (L is
   --           lower triangular if m <= n); the elements above the diagonal,
   --           with the array TAU, represent the unitary matrix Q as a
   --           product of elementary reflectors (see Further Details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= max(1,M).
   --           For optimum performance LWORK >= M*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of elementary reflectors
   --
   --      Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
   --   A(i,i+1:n), and tau in TAU(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZGELQ2, ZLARFB, ZLARFT
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "ZGELQF", "   ", M, N, -1, -1);
      LWKOPT   := M * NB;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      elsif LWORK < max (1, M) and not LQUERY then
         INFO := -7;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGELQF", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      K := min (M, N);
      if K = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := M;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "ZGELQF", "   ", M, N, -1, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := M;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "ZGELQF", "   ", M, N, -1, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code initially
         --
         I := 1 - NB;
         loop
            I := I + NB;
            exit when I > K - NX;
            IB := min (K - I + 1, NB);
            --
            --           Compute the LQ factorization of the current block
            --           A(i:i+ib-1,i:n)
            --
            ZGELQ2 (IB, N - I + 1, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            if I + IB <= M then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i) H(i+1) . . . H(i+ib-1)
               --
               ZLARFT ('F', 'R', N - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, LDWORK);
               --
               --              Apply H to A(i+ib:m,i:n) from the right
               --
               ZLARFB
                 ('R',
                  'N',
                  'F',
                  'R',
                  M - I - IB + 1,
                  N - I + 1,
                  IB,
                  A (I, I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A (I + IB, I)'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
         end loop;
      else
         I := 1;
      end if;
      --
      --     Use unblocked code to factor the last or only block.
      --
      if I <= K then
         ZGELQ2 (M - I + 1, N - I + 1, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
      end if;
      --
      WORK (1) := Complex'(Real (IWS), 0.0e0);
      return;
      --
      --     End of ZGELQF
      --
   end ZGELQF;

   procedure ZGEQR2
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. min (M, N));
      WORK : Ftn_Complex_Vector (1 .. N);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE   : constant Complex := (1.0e0, 0.0e0);
      I     : Integer;
      K     : Integer;
      ALPHA : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEQR2( M, N, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEQR2 computes a QR factorization of a complex m by n matrix A:
   --  A = Q * R.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the m by n matrix A.
   --           On exit, the elements on and above the diagonal of the array
   --           contain the min(m,n) by n upper trapezoidal matrix R (R is
   --           upper triangular if m >= n); the elements below the diagonal,
   --           with the array TAU, represent the unitary matrix Q as a
   --           product of elementary reflectors (see Further Details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of elementary reflectors
   --
   --      Q = H(1) H(2) . . . H(k), where k = min(m,n).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
   --   and tau in TAU(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLARF, ZLARFG
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG, MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGEQR2", -INFO);
         return;
      end if;
      --
      K := min (M, N);
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         --
         --        Generate elementary reflector H(i) to annihilate A(i+1:m,i)
         --
         ZLARFG (M - I + 1, A (I, I), A (min (I + 1, M), I)'Address, 1, TAU (I));
         if I < N then
            --
            --           Apply H(i)**H to A(i:m,i+1:n) from the left
            --
            ALPHA    := A (I, I);
            A (I, I) := ONE;
            ZLARF ('L', M - I + 1, N - I, A (I, I)'Address, 1, dconjg (TAU (I)), A (I, I + 1)'Address, LDA, WORK'Address);
            A (I, I) := ALPHA;
         end if;
      end loop;
      return;
      --
      --     End of ZGEQR2
      --
   end ZGEQR2;

   procedure ZGEQRF
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. min (M, N));
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      K      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGEQRF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGEQRF computes a QR factorization of a complex M-by-N matrix A:
   --  A = Q * R.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the M-by-N matrix A.
   --           On exit, the elements on and above the diagonal of the array
   --           contain the min(M,N)-by-N upper trapezoidal matrix R (R is
   --           upper triangular if m >= n); the elements below the diagonal,
   --           with the array TAU, represent the unitary matrix Q as a
   --           product of min(m,n) elementary reflectors (see Further
   --           Details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (min(M,N))
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= max(1,N).
   --           For optimum performance LWORK >= N*NB, where NB is
   --           the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of elementary reflectors
   --
   --      Q = H(1) H(2) . . . H(k), where k = min(m,n).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
   --   and tau in TAU(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZGEQR2, ZLARFB, ZLARFT
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "ZGEQRF", "   ", M, N, -1, -1);
      LWKOPT   := N * NB;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -7;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGEQRF", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      K := min (M, N);
      if K = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := N;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "ZGEQRF", "   ", M, N, -1, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := N;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "ZGEQRF", "   ", M, N, -1, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code initially
         --
         I := 1 - NB;
         loop
            I := I + NB;
            exit when I > K - NX;
            IB := min (K - I + 1, NB);
            --
            --           Compute the QR factorization of the current block
            --           A(i:m,i:i+ib-1)
            --
            ZGEQR2 (M - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            if I + IB <= N then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i) H(i+1) . . . H(i+ib-1)
               --
               ZLARFT ('F', 'C', M - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, LDWORK);
               --
               --              Apply H**H to A(i:m,i+ib:n) from the left
               --
               ZLARFB
                 ('L',
                  'C',
                  'F',
                  'C',
                  M - I + 1,
                  N - I - IB + 1,
                  IB,
                  A (I, I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A (I, I + IB)'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
         end loop;
      else
         I := 1;
      end if;
      --
      --     Use unblocked code to factor the last or only block.
      --
      if I <= K then
         ZGEQR2 (M - I + 1, N - I + 1, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
      end if;
      --
      WORK (1) := Complex'(Real (IWS), 0.0e0);
      return;
      --
      --     End of ZGEQRF
      --
   end ZGEQRF;

   procedure ZGESDD
     (JOBZ  : Character;
      M     : Integer;
      N     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      S     : in out Ftn_Real_Vector;
      U     : in out Ftn_Complex_Matrix;
      LDU   : Integer;
      VT    : in out Ftn_Complex_Matrix;
      LDVT  : Integer;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      RWORK : in out Ftn_Real_Vector;
      IWORK : in out Ftn_Integer_Vector;
      INFO  : in out Integer)
   is
      LQUERV : constant Integer := -1;
      CZERO  : constant Complex := (0.0e0, 0.0e0);
      CONE   : constant Complex := (1.0e0, 0.0e0);
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      WNTQA  : Boolean;
      WNTQAS : Boolean;
      WNTQN  : Boolean;
      WNTQO  : Boolean;
      WNTQS  : Boolean;
      BLK    : Integer;
      CHUNK  : Integer;
      I      : Integer;
      IE     : Integer;
      IERR   : Integer;
      IL     : Integer;
      IR     : Integer;
      IRU    : Integer;
      IRVT   : Integer;
      ISCL   : Integer;
      ITAU   : Integer;
      ITAUP  : Integer;
      ITAUQ  : Integer;
      IU     : Integer;
      IVT    : Integer;
      LDWKVT : Integer;
      LDWRKL : Integer;
      LDWRKR : Integer;
      LDWRKU : Integer;
      MAXWRK : Integer;
      MINMN  : Integer;
      MINWRK : Integer;
      MNTHR1 : Integer;
      MNTHR2 : Integer;
      NRWORK : Integer;
      NWORK  : Integer;
      WRKBL  : Integer;
      ANRM   : Real;
      BIGNUM : Real;
      EPS    : Real;
      SMLNUM : Real;
      IDUM   : Ftn_Integer_Vector (1 .. 1);
      DUM    : Ftn_Real_Vector (1 .. 1);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGESDD( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK,
   --                          LWORK, RWORK, IWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBZ
   --       INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   RWORK( * ), S( * )
   --       COMPLEX*16         A( LDA, * ), U( LDU, * ), VT( LDVT, * ),
   --      $                   WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGESDD computes the singular value decomposition (SVD) of a complex
   --  M-by-N matrix A, optionally computing the left and/or right singular
   --  vectors, by using divide-and-conquer method. The SVD is written
   --
   --       A = U * SIGMA * conjugate-transpose(V)
   --
   --  where SIGMA is an M-by-N matrix which is zero except for its
   --  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
   --  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
   --  are the singular values of A; they are real and non-negative, and
   --  are returned in descending order.  The first min(m,n) columns of
   --  U and V are the left and right singular vectors of A.
   --
   --  Note that the routine returns VT = V**H, not V.
   --
   --  The divide and conquer algorithm makes very mild assumptions about
   --  floating point arithmetic. It will work on machines with a guard
   --  digit in add/subtract, or on those binary machines without guard
   --  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
   --  Cray-2. It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBZ
   --           JOBZ is CHARACTER*1
   --           Specifies options for computing all or part of the matrix U:
   --           = 'A':  all M columns of U and all N rows of V**H are
   --                   returned in the arrays U and VT;
   --           = 'S':  the first min(M,N) columns of U and the first
   --                   min(M,N) rows of V**H are returned in the arrays U
   --                   and VT;
   --           = 'O':  If M >= N, the first N columns of U are overwritten
   --                   in the array A and all rows of V**H are returned in
   --                   the array VT;
   --                   otherwise, all columns of U are returned in the
   --                   array U and the first M rows of V**H are overwritten
   --                   in the array A;
   --           = 'N':  no columns of U or rows of V**H are computed.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the input matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the input matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the M-by-N matrix A.
   --           On exit,
   --           if JOBZ = 'O',  A is overwritten with the first N columns
   --                           of U (the left singular vectors, stored
   --                           columnwise) if M >= N;
   --                           A is overwritten with the first M rows
   --                           of V**H (the right singular vectors, stored
   --                           rowwise) otherwise.
   --           if JOBZ .ne. 'O', the contents of A are destroyed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] S
   --           S is DOUBLE PRECISION array, dimension (min(M,N))
   --           The singular values of A, sorted so that S(i) >= S(i+1).
   --
   --  [out] U
   --           U is COMPLEX*16 array, dimension (LDU,UCOL)
   --           UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
   --           UCOL = min(M,N) if JOBZ = 'S'.
   --           If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
   --           unitary matrix U;
   --           if JOBZ = 'S', U contains the first min(M,N) columns of U
   --           (the left singular vectors, stored columnwise);
   --           if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --           The leading dimension of the array U.  LDU >= 1; if
   --           JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.
   --
   --  [out] VT
   --           VT is COMPLEX*16 array, dimension (LDVT,N)
   --           If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
   --           N-by-N unitary matrix V**H;
   --           if JOBZ = 'S', VT contains the first min(M,N) rows of
   --           V**H (the right singular vectors, stored rowwise);
   --           if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --           The leading dimension of the array VT.  LDVT >= 1; if
   --           JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
   --           if JOBZ = 'S', LDVT >= min(M,N).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= 1.
   --           if JOBZ = 'N', LWORK >= 2*min(M,N)+max(M,N).
   --           if JOBZ = 'O',
   --                 LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
   --           if JOBZ = 'S' or 'A',
   --                 LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
   --           For good performance, LWORK should generally be larger.
   --
   --           If LWORK = -1, a workspace query is assumed.  The optimal
   --           size for the WORK array is calculated and stored in WORK(1),
   --           and no other work except argument checking is performed.
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array, dimension (MAX(1,LRWORK))
   --           If JOBZ = 'N', LRWORK >= 5*min(M,N).
   --           Otherwise,
   --           LRWORK >= min(M,N)*max(5*min(M,N)+7,2*max(M,N)+2*min(M,N)+1)
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (8*min(M,N))
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  The updating process of DBDSDC did not converge.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --      Ming Gu and Huan Ren, Computer Science Division, University of
   --      California at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( LQUERV = -1 )
   --      PARAMETER          ( CZERO = ( 0.0D+0, 0.0D+0 ), CONE = ( 1.0D+0, 0.0D+0 ) )
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DBDSDC, DLASCL, XERBLA, ZGEBRD, ZGELQF, ZGEMM, ZGEQRF, ZLACP2, ZLACPY, ZLACRM, ZLARCM, ZLASCL,
   --ZLASET, ZUNGBR, ZUNGLQ, ZUNGQR, ZUNMBR
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, ZLANGE
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          INT, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      MINMN  := min (M, N);
      MNTHR1 := int (Real (MINMN) * 17.0e0 / 9.0e0);
      MNTHR2 := int (Real (MINMN) * 5.0e0 / 3.0e0);
      WNTQA  := LSAME (JOBZ, 'A');
      WNTQS  := LSAME (JOBZ, 'S');
      WNTQAS := WNTQA or WNTQS;
      WNTQO  := LSAME (JOBZ, 'O');
      WNTQN  := LSAME (JOBZ, 'N');
      MINWRK := 1;
      MAXWRK := 1;
      --
      if not (WNTQA or WNTQS or WNTQO or WNTQN) then
         INFO := -1;
      elsif M < 0 then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      elsif LDU < 1 or (WNTQAS and LDU < M) or (WNTQO and M < N and LDU < M) then
         INFO := -8;
      elsif LDVT < 1 or (WNTQA and LDVT < N) or (WNTQS and LDVT < MINMN) or (WNTQO and M >= N and LDVT < N) then
         INFO := -10;
      end if;
      --
      --     Compute workspace
      --      (Note: Comments in the code beginning "Workspace:" describe the
      --       minimal amount of workspace needed at that point in the code,
      --       as well as the preferred amount for good performance.
      --       CWorkspace refers to complex workspace, and RWorkspace to
      --       real workspace. NB refers to the optimal block size for the
      --       immediately following subroutine, as returned by ILAENV.)
      --
      if INFO = 0 and M > 0 and N > 0 then
         if M >= N then
            --
            --           There is no complex work space needed for bidiagonal SVD
            --           The real work space needed for bidiagonal SVD is BDSPAC
            --           for computing singular values and singular vectors; BDSPAN
            --           for computing singular values only.
            --           BDSPAC = 5*N*N + 7*N
            --           BDSPAN = MAX(7*N+4, 3*N+2+SMLSIZ*(SMLSIZ+8))
            --
            if M >= MNTHR1 then
               if WNTQN then
                  --
                  --                 Path 1 (M much larger than N, JOBZ='N')
                  --
                  MAXWRK := N + N * ILAENV (1, "ZGEQRF", "   ", M, N, -1, -1);
                  MAXWRK := max (MAXWRK, 2 * N + 2 * N * ILAENV (1, "ZGEBRD", "   ", N, N, -1, -1));
                  MINWRK := 3 * N;
               elsif WNTQO then
                  --
                  --                 Path 2 (M much larger than N, JOBZ='O')
                  --
                  WRKBL  := N + N * ILAENV (1, "ZGEQRF", "   ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, N + N * ILAENV (1, "ZUNGQR", "   ", M, N, N, -1));
                  WRKBL  := max (WRKBL, 2 * N + 2 * N * ILAENV (1, "ZGEBRD", "   ", N, N, -1, -1));
                  WRKBL  := max (WRKBL, 2 * N + N * ILAENV (1, "ZUNMBR", "QLN", N, N, N, -1));
                  WRKBL  := max (WRKBL, 2 * N + N * ILAENV (1, "ZUNMBR", "PRC", N, N, N, -1));
                  MAXWRK := M * N + N * N + WRKBL;
                  MINWRK := 2 * N * N + 3 * N;
               elsif WNTQS then
                  --
                  --                 Path 3 (M much larger than N, JOBZ='S')
                  --
                  WRKBL  := N + N * ILAENV (1, "ZGEQRF", "   ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, N + N * ILAENV (1, "ZUNGQR", "   ", M, N, N, -1));
                  WRKBL  := max (WRKBL, 2 * N + 2 * N * ILAENV (1, "ZGEBRD", "   ", N, N, -1, -1));
                  WRKBL  := max (WRKBL, 2 * N + N * ILAENV (1, "ZUNMBR", "QLN", N, N, N, -1));
                  WRKBL  := max (WRKBL, 2 * N + N * ILAENV (1, "ZUNMBR", "PRC", N, N, N, -1));
                  MAXWRK := N * N + WRKBL;
                  MINWRK := N * N + 3 * N;
               elsif WNTQA then
                  --
                  --                 Path 4 (M much larger than N, JOBZ='A')
                  --
                  WRKBL  := N + N * ILAENV (1, "ZGEQRF", "   ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, N + M * ILAENV (1, "ZUNGQR", "   ", M, M, N, -1));
                  WRKBL  := max (WRKBL, 2 * N + 2 * N * ILAENV (1, "ZGEBRD", "   ", N, N, -1, -1));
                  WRKBL  := max (WRKBL, 2 * N + N * ILAENV (1, "ZUNMBR", "QLN", N, N, N, -1));
                  WRKBL  := max (WRKBL, 2 * N + N * ILAENV (1, "ZUNMBR", "PRC", N, N, N, -1));
                  MAXWRK := N * N + WRKBL;
                  MINWRK := N * N + 2 * N + M;
               end if;
            elsif M >= MNTHR2 then
               --
               --              Path 5 (M much larger than N, but not as much as MNTHR1)
               --
               MAXWRK := 2 * N + (M + N) * ILAENV (1, "ZGEBRD", "   ", M, N, -1, -1);
               MINWRK := 2 * N + M;
               if WNTQO then
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNGBR", "P  ", N, N, N, -1));
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNGBR", "Q  ", M, N, N, -1));
                  MAXWRK := MAXWRK + M * N;
                  MINWRK := MINWRK + N * N;
               elsif WNTQS then
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNGBR", "P  ", N, N, N, -1));
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNGBR", "Q  ", M, N, N, -1));
               elsif WNTQA then
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNGBR", "P  ", N, N, N, -1));
                  MAXWRK := max (MAXWRK, 2 * N + M * ILAENV (1, "ZUNGBR", "Q  ", M, M, N, -1));
               end if;
            else
               --
               --              Path 6 (M at least N, but not much larger)
               --
               MAXWRK := 2 * N + (M + N) * ILAENV (1, "ZGEBRD", "   ", M, N, -1, -1);
               MINWRK := 2 * N + M;
               if WNTQO then
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNMBR", "PRC", N, N, N, -1));
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNMBR", "QLN", M, N, N, -1));
                  MAXWRK := MAXWRK + M * N;
                  MINWRK := MINWRK + N * N;
               elsif WNTQS then
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNMBR", "PRC", N, N, N, -1));
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNMBR", "QLN", M, N, N, -1));
               elsif WNTQA then
                  MAXWRK := max (MAXWRK, 2 * N + N * ILAENV (1, "ZUNGBR", "PRC", N, N, N, -1));
                  MAXWRK := max (MAXWRK, 2 * N + M * ILAENV (1, "ZUNGBR", "QLN", M, M, N, -1));
               end if;
            end if;
         else
            --
            --           There is no complex work space needed for bidiagonal SVD
            --           The real work space needed for bidiagonal SVD is BDSPAC
            --           for computing singular values and singular vectors; BDSPAN
            --           for computing singular values only.
            --           BDSPAC = 5*M*M + 7*M
            --           BDSPAN = MAX(7*M+4, 3*M+2+SMLSIZ*(SMLSIZ+8))
            --
            if N >= MNTHR1 then
               if WNTQN then
                  --
                  --                 Path 1t (N much larger than M, JOBZ='N')
                  --
                  MAXWRK := M + M * ILAENV (1, "ZGELQF", "   ", M, N, -1, -1);
                  MAXWRK := max (MAXWRK, 2 * M + 2 * M * ILAENV (1, "ZGEBRD", "   ", M, M, -1, -1));
                  MINWRK := 3 * M;
               elsif WNTQO then
                  --
                  --                 Path 2t (N much larger than M, JOBZ='O')
                  --
                  WRKBL  := M + M * ILAENV (1, "ZGELQF", "   ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, M + M * ILAENV (1, "ZUNGLQ", "   ", M, N, M, -1));
                  WRKBL  := max (WRKBL, 2 * M + 2 * M * ILAENV (1, "ZGEBRD", "   ", M, M, -1, -1));
                  WRKBL  := max (WRKBL, 2 * M + M * ILAENV (1, "ZUNMBR", "PRC", M, M, M, -1));
                  WRKBL  := max (WRKBL, 2 * M + M * ILAENV (1, "ZUNMBR", "QLN", M, M, M, -1));
                  MAXWRK := M * N + M * M + WRKBL;
                  MINWRK := 2 * M * M + 3 * M;
               elsif WNTQS then
                  --
                  --                 Path 3t (N much larger than M, JOBZ='S')
                  --
                  WRKBL  := M + M * ILAENV (1, "ZGELQF", "   ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, M + M * ILAENV (1, "ZUNGLQ", "   ", M, N, M, -1));
                  WRKBL  := max (WRKBL, 2 * M + 2 * M * ILAENV (1, "ZGEBRD", "   ", M, M, -1, -1));
                  WRKBL  := max (WRKBL, 2 * M + M * ILAENV (1, "ZUNMBR", "PRC", M, M, M, -1));
                  WRKBL  := max (WRKBL, 2 * M + M * ILAENV (1, "ZUNMBR", "QLN", M, M, M, -1));
                  MAXWRK := M * M + WRKBL;
                  MINWRK := M * M + 3 * M;
               elsif WNTQA then
                  --
                  --                 Path 4t (N much larger than M, JOBZ='A')
                  --
                  WRKBL  := M + M * ILAENV (1, "ZGELQF", "   ", M, N, -1, -1);
                  WRKBL  := max (WRKBL, M + N * ILAENV (1, "ZUNGLQ", "   ", N, N, M, -1));
                  WRKBL  := max (WRKBL, 2 * M + 2 * M * ILAENV (1, "ZGEBRD", "   ", M, M, -1, -1));
                  WRKBL  := max (WRKBL, 2 * M + M * ILAENV (1, "ZUNMBR", "PRC", M, M, M, -1));
                  WRKBL  := max (WRKBL, 2 * M + M * ILAENV (1, "ZUNMBR", "QLN", M, M, M, -1));
                  MAXWRK := M * M + WRKBL;
                  MINWRK := M * M + 2 * M + N;
               end if;
            elsif N >= MNTHR2 then
               --
               --              Path 5t (N much larger than M, but not as much as MNTHR1)
               --
               MAXWRK := 2 * M + (M + N) * ILAENV (1, "ZGEBRD", "   ", M, N, -1, -1);
               MINWRK := 2 * M + N;
               if WNTQO then
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNGBR", "P  ", M, N, M, -1));
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNGBR", "Q  ", M, M, N, -1));
                  MAXWRK := MAXWRK + M * N;
                  MINWRK := MINWRK + M * M;
               elsif WNTQS then
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNGBR", "P  ", M, N, M, -1));
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNGBR", "Q  ", M, M, N, -1));
               elsif WNTQA then
                  MAXWRK := max (MAXWRK, 2 * M + N * ILAENV (1, "ZUNGBR", "P  ", N, N, M, -1));
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNGBR", "Q  ", M, M, N, -1));
               end if;
            else
               --
               --              Path 6t (N greater than M, but not much larger)
               --
               MAXWRK := 2 * M + (M + N) * ILAENV (1, "ZGEBRD", "   ", M, N, -1, -1);
               MINWRK := 2 * M + N;
               if WNTQO then
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNMBR", "PRC", M, N, M, -1));
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNMBR", "QLN", M, M, N, -1));
                  MAXWRK := MAXWRK + M * N;
                  MINWRK := MINWRK + M * M;
               elsif WNTQS then
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNGBR", "PRC", M, N, M, -1));
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNGBR", "QLN", M, M, N, -1));
               elsif WNTQA then
                  MAXWRK := max (MAXWRK, 2 * M + N * ILAENV (1, "ZUNGBR", "PRC", N, N, M, -1));
                  MAXWRK := max (MAXWRK, 2 * M + M * ILAENV (1, "ZUNGBR", "QLN", M, M, N, -1));
               end if;
            end if;
         end if;
         MAXWRK := max (MAXWRK, MINWRK);
      end if;
      if INFO = 0 then
         WORK (1) := Complex'(Real (MAXWRK), 0.0e0);
         if LWORK < MINWRK and LWORK /= LQUERV then
            INFO := -13;
         end if;
      end if;
      --
      --     Quick returns
      --
      if INFO /= 0 then
         XERBLA ("ZGESDD", -INFO);
         return;
      end if;
      if LWORK = LQUERV then
         return;
      end if;
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     Get machine constants
      --
      EPS    := DLAMCH ('P');
      SMLNUM := Sqrt (DLAMCH ('S')) / EPS;
      BIGNUM := ONE / SMLNUM;
      --
      --     Scale A if max element outside range [SMLNUM,BIGNUM]
      --
      ANRM := ZLANGE ('M', M, N, A, LDA, DUM);
      ISCL := 0;
      if ANRM > ZERO and ANRM < SMLNUM then
         ISCL := 1;
         ZLASCL ('G', 0, 0, ANRM, SMLNUM, M, N, A'Address, LDA, IERR);
      elsif ANRM > BIGNUM then
         ISCL := 1;
         ZLASCL ('G', 0, 0, ANRM, BIGNUM, M, N, A'Address, LDA, IERR);
      end if;
      --
      if M >= N then
         --
         --        A has at least as many rows as columns. If A has sufficiently
         --        more rows than columns, first reduce using the QR
         --        decomposition (if sufficient workspace available)
         --
         if M >= MNTHR1 then
            --
            if WNTQN then
               --
               --              Path 1 (M much larger than N, JOBZ='N')
               --              No singular vectors to be computed
               --
               ITAU  := 1;
               NWORK := ITAU + N;
               --
               --              Compute A=Q*R
               --              (CWorkspace: need 2*N, prefer N+N*NB)
               --              (RWorkspace: need 0)
               --
               ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Zero out below R
               --
               ZLASET ('L', N - 1, N - 1, CZERO, CZERO, A (2, 1)'Address, LDA);
               IE    := 1;
               ITAUQ := 1;
               ITAUP := ITAUQ + N;
               NWORK := ITAUP + N;
               --
               --              Bidiagonalize R in A
               --              (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
               --              (RWorkspace: need N)
               --
               ZGEBRD
                 (N,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               NRWORK := IE + N;
               --
               --              Perform bidiagonal SVD, compute singular values only
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAN)
               --
               DBDSDC
                 ('U',
                  'N',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
            --
            elsif WNTQO then
               --
               --              Path 2 (M much larger than N, JOBZ='O')
               --              N left singular vectors to be overwritten on A and
               --              N right singular vectors to be computed in VT
               --
               IU := 1;
               --
               --              WORK(IU) is N by N
               --
               LDWRKU := N;
               IR     := IU + LDWRKU * N;
               if LWORK >= M * N + N * N + 3 * N then
                  --
                  --                 WORK(IR) is M by N
                  --
                  LDWRKR := M;
               else
                  LDWRKR := (LWORK - N * N - 3 * N) / N;
               end if;
               ITAU  := IR + LDWRKR * N;
               NWORK := ITAU + N;
               --
               --              Compute A=Q*R
               --              (CWorkspace: need N*N+2*N, prefer M*N+N+N*NB)
               --              (RWorkspace: 0)
               --
               ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy R to WORK( IR ), zeroing out below it
               --
               ZLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
               ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IR + 1)'Address, LDWRKR);
               --
               --              Generate Q in A
               --              (CWorkspace: need 2*N, prefer N+N*NB)
               --              (RWorkspace: 0)
               --
               ZUNGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               IE    := 1;
               ITAUQ := ITAU;
               ITAUP := ITAUQ + N;
               NWORK := ITAUP + N;
               --
               --              Bidiagonalize R in WORK(IR)
               --              (CWorkspace: need N*N+3*N, prefer M*N+2*N+2*N*NB)
               --              (RWorkspace: need N)
               --
               ZGEBRD
                 (N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of R in WORK(IRU) and computing right singular vectors
               --              of R in WORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := IE + N;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
               --              Overwrite WORK(IU) by the left singular vectors of R
               --              (CWorkspace: need 2*N*N+3*N, prefer M*N+N*N+2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRU)'Address, N, WORK (IU)'Address, LDWRKU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  N,
                  N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  WORK (ITAUQ)'Address,
                  WORK (IU)'Address,
                  LDWRKU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by the right singular vectors of R
               --              (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  N,
                  N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply Q in A by left singular vectors of R in
               --              WORK(IU), storing result in WORK(IR) and copying to A
               --              (CWorkspace: need 2*N*N, prefer N*N+M*N)
               --              (RWorkspace: 0)
               --
               I := 1 - LDWRKR;
               loop
                  I := I + LDWRKR;
                  exit when I > M;
                  CHUNK := min (M - I + 1, LDWRKR);
                  ZGEMM
                    ('N',
                     'N',
                     CHUNK,
                     N,
                     N,
                     CONE,
                     A (I, 1)'Address,
                     LDA,
                     WORK (IU)'Address,
                     LDWRKU,
                     CZERO,
                     WORK (IR)'Address,
                     LDWRKR);
                  ZLACPY ('F', CHUNK, N, WORK (IR)'Address, LDWRKR, A (I, 1)'Address, LDA);
               end loop;
            --
            elsif WNTQS then
               --
               --              Path 3 (M much larger than N, JOBZ='S')
               --              N left singular vectors to be computed in U and
               --              N right singular vectors to be computed in VT
               --
               IR := 1;
               --
               --              WORK(IR) is N by N
               --
               LDWRKR := N;
               ITAU   := IR + LDWRKR * N;
               NWORK  := ITAU + N;
               --
               --              Compute A=Q*R
               --              (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
               --              (RWorkspace: 0)
               --
               ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy R to WORK(IR), zeroing out below it
               --
               ZLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
               ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IR + 1)'Address, LDWRKR);
               --
               --              Generate Q in A
               --              (CWorkspace: need 2*N, prefer N+N*NB)
               --              (RWorkspace: 0)
               --
               ZUNGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               IE    := 1;
               ITAUQ := ITAU;
               ITAUP := ITAUQ + N;
               NWORK := ITAUP + N;
               --
               --              Bidiagonalize R in WORK(IR)
               --              (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
               --              (RWorkspace: need N)
               --
               ZGEBRD
                 (N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := IE + N;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix U
               --              Overwrite U by left singular vectors of R
               --              (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRU)'Address, N, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  N,
                  N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by right singular vectors of R
               --              (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  N,
                  N,
                  N,
                  WORK (IR)'Address,
                  LDWRKR,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply Q in A by left singular vectors of R in
               --              WORK(IR), storing result in U
               --              (CWorkspace: need N*N)
               --              (RWorkspace: 0)
               --
               ZLACPY ('F', N, N, U'Address, LDU, WORK (IR)'Address, LDWRKR);
               ZGEMM ('N', 'N', M, N, N, CONE, A'Address, LDA, WORK (IR)'Address, LDWRKR, CZERO, U'Address, LDU);
            --
            elsif WNTQA then
               --
               --              Path 4 (M much larger than N, JOBZ='A')
               --              M left singular vectors to be computed in U and
               --              N right singular vectors to be computed in VT
               --
               IU := 1;
               --
               --              WORK(IU) is N by N
               --
               LDWRKU := N;
               ITAU   := IU + LDWRKU * N;
               NWORK  := ITAU + N;
               --
               --              Compute A=Q*R, copying result to U
               --              (CWorkspace: need 2*N, prefer N+N*NB)
               --              (RWorkspace: 0)
               --
               ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
               --
               --              Generate Q in U
               --              (CWorkspace: need N+M, prefer N+M*NB)
               --              (RWorkspace: 0)
               --
               ZUNGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Produce R in A, zeroing out below it
               --
               ZLASET ('L', N - 1, N - 1, CZERO, CZERO, A (2, 1)'Address, LDA);
               IE    := 1;
               ITAUQ := ITAU;
               ITAUP := ITAUQ + N;
               NWORK := ITAUP + N;
               --
               --              Bidiagonalize R in A
               --              (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
               --              (RWorkspace: need N)
               --
               ZGEBRD
                 (N,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               IRU    := IE + N;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
               --              Overwrite WORK(IU) by left singular vectors of R
               --              (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRU)'Address, N, WORK (IU)'Address, LDWRKU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  WORK (IU)'Address,
                  LDWRKU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by right singular vectors of R
               --              (CWorkspace: need 3*N, prefer 2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply Q in U by left singular vectors of R in
               --              WORK(IU), storing result in A
               --              (CWorkspace: need N*N)
               --              (RWorkspace: 0)
               --
               ZGEMM ('N', 'N', M, N, N, CONE, U'Address, LDU, WORK (IU)'Address, LDWRKU, CZERO, A'Address, LDA);
               --
               --              Copy left singular vectors of A from A to U
               --
               ZLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
               --
            end if;
         --
         elsif M >= MNTHR2 then
            --
            --           MNTHR2 <= M < MNTHR1
            --
            --           Path 5 (M much larger than N, but not as much as MNTHR1)
            --           Reduce to bidiagonal form without QR decomposition, use
            --           ZUNGBR and matrix multiplication to compute singular vectors
            --
            IE     := 1;
            NRWORK := IE + N;
            ITAUQ  := 1;
            ITAUP  := ITAUQ + N;
            NWORK  := ITAUP + N;
            --
            --           Bidiagonalize A
            --           (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
            --           (RWorkspace: need N)
            --
            ZGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               RWORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (NWORK)'Address,
               LWORK - NWORK + 1,
               IERR);
            if WNTQN then
               --
               --              Compute singular values only
               --              (Cworkspace: 0)
               --              (Rworkspace: need BDSPAN)
               --
               DBDSDC
                 ('U',
                  'N',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
            elsif WNTQO then
               IU     := NWORK;
               IRU    := NRWORK;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               --
               --              Copy A to VT, generate P**H
               --              (Cworkspace: need 2*N, prefer N+N*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
               ZUNGBR ('P', N, N, N, VT'Address, LDVT, WORK (ITAUP)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Generate Q in A
               --              (CWorkspace: need 2*N, prefer N+N*NB)
               --              (RWorkspace: 0)
               --
               ZUNGBR ('Q', M, N, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               if LWORK >= M * N + 3 * N then
                  --
                  --                 WORK( IU ) is M by N
                  --
                  LDWRKU := M;
               else
                  --
                  --                 WORK(IU) is LDWRKU by N
                  --
                  LDWRKU := (LWORK - 3 * N) / N;
               end if;
               NWORK := IU + LDWRKU * N;
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Multiply real matrix RWORK(IRVT) by P**H in VT,
               --              storing the result in WORK(IU), copying to VT
               --              (Cworkspace: need 0)
               --              (Rworkspace: need 3*N*N)
               --
               ZLARCM (N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT, WORK (IU)'Address, LDWRKU, RWORK (NRWORK)'Address);
               ZLACPY ('F', N, N, WORK (IU)'Address, LDWRKU, VT'Address, LDVT);
               --
               --              Multiply Q in A by real matrix RWORK(IRU), storing the
               --              result in WORK(IU), copying to A
               --              (CWorkspace: need N*N, prefer M*N)
               --              (Rworkspace: need 3*N*N, prefer N*N+2*M*N)
               --
               NRWORK := IRVT;
               I      := 1 - LDWRKU;
               loop
                  I := I + LDWRKU;
                  exit when I > M;
                  CHUNK := min (M - I + 1, LDWRKU);
                  ZLACRM
                    (CHUNK,
                     N,
                     A (I, 1)'Address,
                     LDA,
                     RWORK (IRU)'Address,
                     N,
                     WORK (IU)'Address,
                     LDWRKU,
                     RWORK (NRWORK)'Address);
                  ZLACPY ('F', CHUNK, N, WORK (IU)'Address, LDWRKU, A (I, 1)'Address, LDA);
               end loop;
            --
            elsif WNTQS then
               --
               --              Copy A to VT, generate P**H
               --              (Cworkspace: need 2*N, prefer N+N*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
               ZUNGBR ('P', N, N, N, VT'Address, LDVT, WORK (ITAUP)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy A to U, generate Q
               --              (Cworkspace: need 2*N, prefer N+N*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
               ZUNGBR ('Q', M, N, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := NRWORK;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Multiply real matrix RWORK(IRVT) by P**H in VT,
               --              storing the result in A, copying to VT
               --              (Cworkspace: need 0)
               --              (Rworkspace: need 3*N*N)
               --
               ZLARCM (N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT, A'Address, LDA, RWORK (NRWORK)'Address);
               ZLACPY ('F', N, N, A'Address, LDA, VT'Address, LDVT);
               --
               --              Multiply Q in U by real matrix RWORK(IRU), storing the
               --              result in A, copying to U
               --              (CWorkspace: need 0)
               --              (Rworkspace: need N*N+2*M*N)
               --
               NRWORK := IRVT;
               ZLACRM (M, N, U'Address, LDU, RWORK (IRU)'Address, N, A'Address, LDA, RWORK (NRWORK)'Address);
               ZLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
            else
               --
               --              Copy A to VT, generate P**H
               --              (Cworkspace: need 2*N, prefer N+N*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
               ZUNGBR ('P', N, N, N, VT'Address, LDVT, WORK (ITAUP)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy A to U, generate Q
               --              (Cworkspace: need 2*N, prefer N+N*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
               ZUNGBR ('Q', M, M, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := NRWORK;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Multiply real matrix RWORK(IRVT) by P**H in VT,
               --              storing the result in A, copying to VT
               --              (Cworkspace: need 0)
               --              (Rworkspace: need 3*N*N)
               --
               ZLARCM (N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT, A'Address, LDA, RWORK (NRWORK)'Address);
               ZLACPY ('F', N, N, A'Address, LDA, VT'Address, LDVT);
               --
               --              Multiply Q in U by real matrix RWORK(IRU), storing the
               --              result in A, copying to U
               --              (CWorkspace: 0)
               --              (Rworkspace: need 3*N*N)
               --
               NRWORK := IRVT;
               ZLACRM (M, N, U'Address, LDU, RWORK (IRU)'Address, N, A'Address, LDA, RWORK (NRWORK)'Address);
               ZLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
            end if;
         --
         else
            --
            --           M .LT. MNTHR2
            --
            --           Path 6 (M at least N, but not much larger)
            --           Reduce to bidiagonal form without QR decomposition
            --           Use ZUNMBR to compute singular vectors
            --
            IE     := 1;
            NRWORK := IE + N;
            ITAUQ  := 1;
            ITAUP  := ITAUQ + N;
            NWORK  := ITAUP + N;
            --
            --           Bidiagonalize A
            --           (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
            --           (RWorkspace: need N)
            --
            ZGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               RWORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (NWORK)'Address,
               LWORK - NWORK + 1,
               IERR);
            if WNTQN then
               --
               --              Compute singular values only
               --              (Cworkspace: 0)
               --              (Rworkspace: need BDSPAN)
               --
               DBDSDC
                 ('U',
                  'N',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
            elsif WNTQO then
               IU     := NWORK;
               IRU    := NRWORK;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               if LWORK >= M * N + 3 * N then
                  --
                  --                 WORK( IU ) is M by N
                  --
                  LDWRKU := M;
               else
                  --
                  --                 WORK( IU ) is LDWRKU by N
                  --
                  LDWRKU := (LWORK - 3 * N) / N;
               end if;
               NWORK := IU + LDWRKU * N;
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by right singular vectors of A
               --              (Cworkspace: need 2*N, prefer N+N*NB)
               --              (Rworkspace: need 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               if LWORK >= M * N + 3 * N then
                  --
                  --              Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                  --              Overwrite WORK(IU) by left singular vectors of A, copying
                  --              to A
                  --              (Cworkspace: need M*N+2*N, prefer M*N+N+N*NB)
                  --              (Rworkspace: need 0)
                  --
                  ZLASET ('F', M, N, CZERO, CZERO, WORK (IU)'Address, LDWRKU);
                  ZLACP2 ('F', N, N, RWORK (IRU)'Address, N, WORK (IU)'Address, LDWRKU);
                  ZUNMBR
                    ('Q',
                     'L',
                     'N',
                     M,
                     N,
                     N,
                     A'Address,
                     LDA,
                     WORK (ITAUQ)'Address,
                     WORK (IU)'Address,
                     LDWRKU,
                     WORK (NWORK)'Address,
                     LWORK - NWORK + 1,
                     IERR);
                  ZLACPY ('F', M, N, WORK (IU)'Address, LDWRKU, A'Address, LDA);
               else
                  --
                  --                 Generate Q in A
                  --                 (Cworkspace: need 2*N, prefer N+N*NB)
                  --                 (Rworkspace: need 0)
                  --
                  ZUNGBR ('Q', M, N, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
                  --
                  --                 Multiply Q in A by real matrix RWORK(IRU), storing the
                  --                 result in WORK(IU), copying to A
                  --                 (CWorkspace: need N*N, prefer M*N)
                  --                 (Rworkspace: need 3*N*N, prefer N*N+2*M*N)
                  --
                  NRWORK := IRVT;
                  I      := 1 - LDWRKU;
                  loop
                     I := I + LDWRKU;
                     exit when I > M;
                     CHUNK := min (M - I + 1, LDWRKU);
                     ZLACRM
                       (CHUNK,
                        N,
                        A (I, 1)'Address,
                        LDA,
                        RWORK (IRU)'Address,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        RWORK (NRWORK)'Address);
                     ZLACPY ('F', CHUNK, N, WORK (IU)'Address, LDWRKU, A (I, 1)'Address, LDA);
                  end loop;
               end if;
            --
            elsif WNTQS then
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := NRWORK;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix U
               --              Overwrite U by left singular vectors of A
               --              (CWorkspace: need 3*N, prefer 2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLASET ('F', M, N, CZERO, CZERO, U'Address, LDU);
               ZLACP2 ('F', N, N, RWORK (IRU)'Address, N, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by right singular vectors of A
               --              (CWorkspace: need 3*N, prefer 2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
            else
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := NRWORK;
               IRVT   := IRU + N * N;
               NRWORK := IRVT + N * N;
               DBDSDC
                 ('U',
                  'I',
                  N,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  N,
                  RWORK (IRVT)'Address,
                  N,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Set the right corner of U to identity matrix
               --
               ZLASET ('F', M, M, CZERO, CZERO, U'Address, LDU);
               if M > N then
                  ZLASET ('F', M - N, M - N, CZERO, CONE, U (N + 1, N + 1)'Address, LDU);
               end if;
               --
               --              Copy real matrix RWORK(IRU) to complex matrix U
               --              Overwrite U by left singular vectors of A
               --              (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRU)'Address, N, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by right singular vectors of A
               --              (CWorkspace: need 3*N, prefer 2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', N, N, RWORK (IRVT)'Address, N, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  N,
                  N,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
            end if;
            --
         end if;
      --
      else
         --
         --        A has more columns than rows. If A has sufficiently more
         --        columns than rows, first reduce using the LQ decomposition (if
         --        sufficient workspace available)
         --
         if N >= MNTHR1 then
            --
            if WNTQN then
               --
               --              Path 1t (N much larger than M, JOBZ='N')
               --              No singular vectors to be computed
               --
               ITAU  := 1;
               NWORK := ITAU + M;
               --
               --              Compute A=L*Q
               --              (CWorkspace: need 2*M, prefer M+M*NB)
               --              (RWorkspace: 0)
               --
               ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Zero out above L
               --
               ZLASET ('U', M - 1, M - 1, CZERO, CZERO, A (1, 2)'Address, LDA);
               IE    := 1;
               ITAUQ := 1;
               ITAUP := ITAUQ + M;
               NWORK := ITAUP + M;
               --
               --              Bidiagonalize L in A
               --              (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
               --              (RWorkspace: need M)
               --
               ZGEBRD
                 (M,
                  M,
                  A'Address,
                  LDA,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               NRWORK := IE + M;
               --
               --              Perform bidiagonal SVD, compute singular values only
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAN)
               --
               DBDSDC
                 ('U',
                  'N',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
            --
            elsif WNTQO then
               --
               --              Path 2t (N much larger than M, JOBZ='O')
               --              M right singular vectors to be overwritten on A and
               --              M left singular vectors to be computed in U
               --
               IVT    := 1;
               LDWKVT := M;
               --
               --              WORK(IVT) is M by M
               --
               IL := IVT + LDWKVT * M;
               if LWORK >= M * N + M * M + 3 * M then
                  --
                  --                 WORK(IL) M by N
                  --
                  LDWRKL := M;
                  CHUNK  := N;
               else
                  --
                  --                 WORK(IL) is M by CHUNK
                  --
                  LDWRKL := M;
                  CHUNK  := (LWORK - M * M - 3 * M) / M;
               end if;
               ITAU  := IL + LDWRKL * CHUNK;
               NWORK := ITAU + M;
               --
               --              Compute A=L*Q
               --              (CWorkspace: need 2*M, prefer M+M*NB)
               --              (RWorkspace: 0)
               --
               ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy L to WORK(IL), zeroing about above it
               --
               ZLACPY ('L', M, M, A'Address, LDA, WORK (IL)'Address, LDWRKL);
               ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IL + LDWRKL)'Address, LDWRKL);
               --
               --              Generate Q in A
               --              (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
               --              (RWorkspace: 0)
               --
               ZUNGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               IE    := 1;
               ITAUQ := ITAU;
               ITAUP := ITAUQ + M;
               NWORK := ITAUP + M;
               --
               --              Bidiagonalize L in WORK(IL)
               --              (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
               --              (RWorkspace: need M)
               --
               ZGEBRD
                 (M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := IE + M;
               IRVT   := IRU + M * M;
               NRWORK := IRVT + M * M;
               DBDSDC
                 ('U',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
               --              Overwrite WORK(IU) by the left singular vectors of L
               --              (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', M, M, RWORK (IRU)'Address, M, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
               --              Overwrite WORK(IVT) by the right singular vectors of L
               --              (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', M, M, RWORK (IRVT)'Address, M, WORK (IVT)'Address, LDWKVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  M,
                  M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  WORK (ITAUP)'Address,
                  WORK (IVT)'Address,
                  LDWKVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply right singular vectors of L in WORK(IL) by Q
               --              in A, storing result in WORK(IL) and copying to A
               --              (CWorkspace: need 2*M*M, prefer M*M+M*N)
               --              (RWorkspace: 0)
               --
               I := 1 - CHUNK;
               loop
                  I := I + CHUNK;
                  exit when I > N;
                  BLK := min (N - I + 1, CHUNK);
                  ZGEMM
                    ('N',
                     'N',
                     M,
                     BLK,
                     M,
                     CONE,
                     WORK (IVT)'Address,
                     M,
                     A (1, I)'Address,
                     LDA,
                     CZERO,
                     WORK (IL)'Address,
                     LDWRKL);
                  ZLACPY ('F', M, BLK, WORK (IL)'Address, LDWRKL, A (1, I)'Address, LDA);
               end loop;
            --
            elsif WNTQS then
               --
               --             Path 3t (N much larger than M, JOBZ='S')
               --             M right singular vectors to be computed in VT and
               --             M left singular vectors to be computed in U
               --
               IL := 1;
               --
               --              WORK(IL) is M by M
               --
               LDWRKL := M;
               ITAU   := IL + LDWRKL * M;
               NWORK  := ITAU + M;
               --
               --              Compute A=L*Q
               --              (CWorkspace: need 2*M, prefer M+M*NB)
               --              (RWorkspace: 0)
               --
               ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy L to WORK(IL), zeroing out above it
               --
               ZLACPY ('L', M, M, A'Address, LDA, WORK (IL)'Address, LDWRKL);
               ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IL + LDWRKL)'Address, LDWRKL);
               --
               --              Generate Q in A
               --              (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
               --              (RWorkspace: 0)
               --
               ZUNGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               IE    := 1;
               ITAUQ := ITAU;
               ITAUP := ITAUQ + M;
               NWORK := ITAUP + M;
               --
               --              Bidiagonalize L in WORK(IL)
               --              (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
               --              (RWorkspace: need M)
               --
               ZGEBRD
                 (M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := IE + M;
               IRVT   := IRU + M * M;
               NRWORK := IRVT + M * M;
               DBDSDC
                 ('U',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix U
               --              Overwrite U by left singular vectors of L
               --              (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', M, M, RWORK (IRU)'Address, M, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by left singular vectors of L
               --              (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', M, M, RWORK (IRVT)'Address, M, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  M,
                  M,
                  M,
                  WORK (IL)'Address,
                  LDWRKL,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy VT to WORK(IL), multiply right singular vectors of L
               --              in WORK(IL) by Q in A, storing result in VT
               --              (CWorkspace: need M*M)
               --              (RWorkspace: 0)
               --
               ZLACPY ('F', M, M, VT'Address, LDVT, WORK (IL)'Address, LDWRKL);
               ZGEMM ('N', 'N', M, N, M, CONE, WORK (IL)'Address, LDWRKL, A'Address, LDA, CZERO, VT'Address, LDVT);
            --
            elsif WNTQA then
               --
               --              Path 9t (N much larger than M, JOBZ='A')
               --              N right singular vectors to be computed in VT and
               --              M left singular vectors to be computed in U
               --
               IVT := 1;
               --
               --              WORK(IVT) is M by M
               --
               LDWKVT := M;
               ITAU   := IVT + LDWKVT * M;
               NWORK  := ITAU + M;
               --
               --              Compute A=L*Q, copying result to VT
               --              (CWorkspace: need 2*M, prefer M+M*NB)
               --              (RWorkspace: 0)
               --
               ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
               --
               --              Generate Q in VT
               --              (CWorkspace: need M+N, prefer M+N*NB)
               --              (RWorkspace: 0)
               --
               ZUNGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Produce L in A, zeroing out above it
               --
               ZLASET ('U', M - 1, M - 1, CZERO, CZERO, A (1, 2)'Address, LDA);
               IE    := 1;
               ITAUQ := ITAU;
               ITAUP := ITAUQ + M;
               NWORK := ITAUP + M;
               --
               --              Bidiagonalize L in A
               --              (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
               --              (RWorkspace: need M)
               --
               ZGEBRD
                 (M,
                  M,
                  A'Address,
                  LDA,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRU    := IE + M;
               IRVT   := IRU + M * M;
               NRWORK := IRVT + M * M;
               DBDSDC
                 ('U',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix U
               --              Overwrite U by left singular vectors of L
               --              (CWorkspace: need 3*M, prefer 2*M+M*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', M, M, RWORK (IRU)'Address, M, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
               --              Overwrite WORK(IVT) by right singular vectors of L
               --              (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
               --              (RWorkspace: 0)
               --
               ZLACP2 ('F', M, M, RWORK (IRVT)'Address, M, WORK (IVT)'Address, LDWKVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  M,
                  M,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  WORK (IVT)'Address,
                  LDWKVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Multiply right singular vectors of L in WORK(IVT) by
               --              Q in VT, storing result in A
               --              (CWorkspace: need M*M)
               --              (RWorkspace: 0)
               --
               ZGEMM ('N', 'N', M, N, M, CONE, WORK (IVT)'Address, LDWKVT, VT'Address, LDVT, CZERO, A'Address, LDA);
               --
               --              Copy right singular vectors of A from A to VT
               --
               ZLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
               --
            end if;
         --
         elsif N >= MNTHR2 then
            --
            --           MNTHR2 <= N < MNTHR1
            --
            --           Path 5t (N much larger than M, but not as much as MNTHR1)
            --           Reduce to bidiagonal form without QR decomposition, use
            --           ZUNGBR and matrix multiplication to compute singular vectors
            --
            --
            IE     := 1;
            NRWORK := IE + M;
            ITAUQ  := 1;
            ITAUP  := ITAUQ + M;
            NWORK  := ITAUP + M;
            --
            --           Bidiagonalize A
            --           (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
            --           (RWorkspace: M)
            --
            ZGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               RWORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (NWORK)'Address,
               LWORK - NWORK + 1,
               IERR);
            --
            if WNTQN then
               --
               --              Compute singular values only
               --              (Cworkspace: 0)
               --              (Rworkspace: need BDSPAN)
               --
               DBDSDC
                 ('L',
                  'N',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
            elsif WNTQO then
               IRVT   := NRWORK;
               IRU    := IRVT + M * M;
               NRWORK := IRU + M * M;
               IVT    := NWORK;
               --
               --              Copy A to U, generate Q
               --              (Cworkspace: need 2*M, prefer M+M*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
               ZUNGBR ('Q', M, M, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Generate P**H in A
               --              (Cworkspace: need 2*M, prefer M+M*NB)
               --              (Rworkspace: 0)
               --
               ZUNGBR ('P', M, N, M, A'Address, LDA, WORK (ITAUP)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               LDWKVT := M;
               if LWORK >= M * N + 3 * M then
                  --
                  --                 WORK( IVT ) is M by N
                  --
                  NWORK := IVT + LDWKVT * N;
                  CHUNK := N;
               else
                  --
                  --                 WORK( IVT ) is M by CHUNK
                  --
                  CHUNK := (LWORK - 3 * M) / M;
                  NWORK := IVT + LDWKVT * CHUNK;
               end if;
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Multiply Q in U by real matrix RWORK(IRVT)
               --              storing the result in WORK(IVT), copying to U
               --              (Cworkspace: need 0)
               --              (Rworkspace: need 2*M*M)
               --
               ZLACRM (M, M, U'Address, LDU, RWORK (IRU)'Address, M, WORK (IVT)'Address, LDWKVT, RWORK (NRWORK)'Address);
               ZLACPY ('F', M, M, WORK (IVT)'Address, LDWKVT, U'Address, LDU);
               --
               --              Multiply RWORK(IRVT) by P**H in A, storing the
               --              result in WORK(IVT), copying to A
               --              (CWorkspace: need M*M, prefer M*N)
               --              (Rworkspace: need 2*M*M, prefer 2*M*N)
               --
               NRWORK := IRU;
               I      := 1 - CHUNK;
               loop
                  I := I + CHUNK;
                  exit when I > N;
                  BLK := min (N - I + 1, CHUNK);
                  ZLARCM
                    (M,
                     BLK,
                     RWORK (IRVT)'Address,
                     M,
                     A (1, I)'Address,
                     LDA,
                     WORK (IVT)'Address,
                     LDWKVT,
                     RWORK (NRWORK)'Address);
                  ZLACPY ('F', M, BLK, WORK (IVT)'Address, LDWKVT, A (1, I)'Address, LDA);
               end loop;
            elsif WNTQS then
               --
               --              Copy A to U, generate Q
               --              (Cworkspace: need 2*M, prefer M+M*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
               ZUNGBR ('Q', M, M, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy A to VT, generate P**H
               --              (Cworkspace: need 2*M, prefer M+M*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
               ZUNGBR ('P', M, N, M, VT'Address, LDVT, WORK (ITAUP)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRVT   := NRWORK;
               IRU    := IRVT + M * M;
               NRWORK := IRU + M * M;
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Multiply Q in U by real matrix RWORK(IRU), storing the
               --              result in A, copying to U
               --              (CWorkspace: need 0)
               --              (Rworkspace: need 3*M*M)
               --
               ZLACRM (M, M, U'Address, LDU, RWORK (IRU)'Address, M, A'Address, LDA, RWORK (NRWORK)'Address);
               ZLACPY ('F', M, M, A'Address, LDA, U'Address, LDU);
               --
               --              Multiply real matrix RWORK(IRVT) by P**H in VT,
               --              storing the result in A, copying to VT
               --              (Cworkspace: need 0)
               --              (Rworkspace: need M*M+2*M*N)
               --
               NRWORK := IRU;
               ZLARCM (M, N, RWORK (IRVT)'Address, M, VT'Address, LDVT, A'Address, LDA, RWORK (NRWORK)'Address);
               ZLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
            else
               --
               --              Copy A to U, generate Q
               --              (Cworkspace: need 2*M, prefer M+M*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
               ZUNGBR ('Q', M, M, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Copy A to VT, generate P**H
               --              (Cworkspace: need 2*M, prefer M+M*NB)
               --              (Rworkspace: 0)
               --
               ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
               ZUNGBR ('P', N, N, M, VT'Address, LDVT, WORK (ITAUP)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRVT   := NRWORK;
               IRU    := IRVT + M * M;
               NRWORK := IRU + M * M;
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Multiply Q in U by real matrix RWORK(IRU), storing the
               --              result in A, copying to U
               --              (CWorkspace: need 0)
               --              (Rworkspace: need 3*M*M)
               --
               ZLACRM (M, M, U'Address, LDU, RWORK (IRU)'Address, M, A'Address, LDA, RWORK (NRWORK)'Address);
               ZLACPY ('F', M, M, A'Address, LDA, U'Address, LDU);
               --
               --              Multiply real matrix RWORK(IRVT) by P**H in VT,
               --              storing the result in A, copying to VT
               --              (Cworkspace: need 0)
               --              (Rworkspace: need M*M+2*M*N)
               --
               ZLARCM (M, N, RWORK (IRVT)'Address, M, VT'Address, LDVT, A'Address, LDA, RWORK (NRWORK)'Address);
               ZLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
            end if;
         --
         else
            --
            --           N .LT. MNTHR2
            --
            --           Path 6t (N greater than M, but not much larger)
            --           Reduce to bidiagonal form without LQ decomposition
            --           Use ZUNMBR to compute singular vectors
            --
            IE     := 1;
            NRWORK := IE + M;
            ITAUQ  := 1;
            ITAUP  := ITAUQ + M;
            NWORK  := ITAUP + M;
            --
            --           Bidiagonalize A
            --           (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
            --           (RWorkspace: M)
            --
            ZGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               RWORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (NWORK)'Address,
               LWORK - NWORK + 1,
               IERR);
            if WNTQN then
               --
               --              Compute singular values only
               --              (Cworkspace: 0)
               --              (Rworkspace: need BDSPAN)
               --
               DBDSDC
                 ('L',
                  'N',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  DUM'Address,
                  1,
                  DUM'Address,
                  1,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
            elsif WNTQO then
               LDWKVT := M;
               IVT    := NWORK;
               if LWORK >= M * N + 3 * M then
                  --
                  --                 WORK( IVT ) is M by N
                  --
                  ZLASET ('F', M, N, CZERO, CZERO, WORK (IVT)'Address, LDWKVT);
                  NWORK := IVT + LDWKVT * N;
               else
                  --
                  --                 WORK( IVT ) is M by CHUNK
                  --
                  CHUNK := (LWORK - 3 * M) / M;
                  NWORK := IVT + LDWKVT * CHUNK;
               end if;
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRVT   := NRWORK;
               IRU    := IRVT + M * M;
               NRWORK := IRU + M * M;
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix U
               --              Overwrite U by left singular vectors of A
               --              (Cworkspace: need 2*M, prefer M+M*NB)
               --              (Rworkspace: need 0)
               --
               ZLACP2 ('F', M, M, RWORK (IRU)'Address, M, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               if LWORK >= M * N + 3 * M then
                  --
                  --              Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                  --              Overwrite WORK(IVT) by right singular vectors of A,
                  --              copying to A
                  --              (Cworkspace: need M*N+2*M, prefer M*N+M+M*NB)
                  --              (Rworkspace: need 0)
                  --
                  ZLACP2 ('F', M, M, RWORK (IRVT)'Address, M, WORK (IVT)'Address, LDWKVT);
                  ZUNMBR
                    ('P',
                     'R',
                     'C',
                     M,
                     N,
                     M,
                     A'Address,
                     LDA,
                     WORK (ITAUP)'Address,
                     WORK (IVT)'Address,
                     LDWKVT,
                     WORK (NWORK)'Address,
                     LWORK - NWORK + 1,
                     IERR);
                  ZLACPY ('F', M, N, WORK (IVT)'Address, LDWKVT, A'Address, LDA);
               else
                  --
                  --                 Generate P**H in A
                  --                 (Cworkspace: need 2*M, prefer M+M*NB)
                  --                 (Rworkspace: need 0)
                  --
                  ZUNGBR ('P', M, N, M, A'Address, LDA, WORK (ITAUP)'Address, WORK (NWORK)'Address, LWORK - NWORK + 1, IERR);
                  --
                  --                 Multiply Q in A by real matrix RWORK(IRU), storing the
                  --                 result in WORK(IU), copying to A
                  --                 (CWorkspace: need M*M, prefer M*N)
                  --                 (Rworkspace: need 3*M*M, prefer M*M+2*M*N)
                  --
                  NRWORK := IRU;
                  I      := 1 - CHUNK;
                  loop
                     I := I + CHUNK;
                     exit when I > N;
                     BLK := min (N - I + 1, CHUNK);
                     ZLARCM
                       (M,
                        BLK,
                        RWORK (IRVT)'Address,
                        M,
                        A (1, I)'Address,
                        LDA,
                        WORK (IVT)'Address,
                        LDWKVT,
                        RWORK (NRWORK)'Address);
                     ZLACPY ('F', M, BLK, WORK (IVT)'Address, LDWKVT, A (1, I)'Address, LDA);
                  end loop;
               end if;
            elsif WNTQS then
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRVT   := NRWORK;
               IRU    := IRVT + M * M;
               NRWORK := IRU + M * M;
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix U
               --              Overwrite U by left singular vectors of A
               --              (CWorkspace: need 3*M, prefer 2*M+M*NB)
               --              (RWorkspace: M*M)
               --
               ZLACP2 ('F', M, M, RWORK (IRU)'Address, M, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by right singular vectors of A
               --              (CWorkspace: need 3*M, prefer 2*M+M*NB)
               --              (RWorkspace: M*M)
               --
               ZLASET ('F', M, N, CZERO, CZERO, VT'Address, LDVT);
               ZLACP2 ('F', M, M, RWORK (IRVT)'Address, M, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  M,
                  N,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
            else
               --
               --              Perform bidiagonal SVD, computing left singular vectors
               --              of bidiagonal matrix in RWORK(IRU) and computing right
               --              singular vectors of bidiagonal matrix in RWORK(IRVT)
               --              (CWorkspace: need 0)
               --              (RWorkspace: need BDSPAC)
               --
               IRVT   := NRWORK;
               IRU    := IRVT + M * M;
               NRWORK := IRU + M * M;
               --
               DBDSDC
                 ('L',
                  'I',
                  M,
                  S'Address,
                  RWORK (IE)'Address,
                  RWORK (IRU)'Address,
                  M,
                  RWORK (IRVT)'Address,
                  M,
                  DUM'Address,
                  IDUM'Address,
                  RWORK (NRWORK)'Address,
                  IWORK'Address,
                  INFO);
               --
               --              Copy real matrix RWORK(IRU) to complex matrix U
               --              Overwrite U by left singular vectors of A
               --              (CWorkspace: need 3*M, prefer 2*M+M*NB)
               --              (RWorkspace: M*M)
               --
               ZLACP2 ('F', M, M, RWORK (IRU)'Address, M, U'Address, LDU);
               ZUNMBR
                 ('Q',
                  'L',
                  'N',
                  M,
                  M,
                  N,
                  A'Address,
                  LDA,
                  WORK (ITAUQ)'Address,
                  U'Address,
                  LDU,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
               --
               --              Set all of VT to identity matrix
               --
               ZLASET ('F', N, N, CZERO, CONE, VT'Address, LDVT);
               --
               --              Copy real matrix RWORK(IRVT) to complex matrix VT
               --              Overwrite VT by right singular vectors of A
               --              (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
               --              (RWorkspace: M*M)
               --
               ZLACP2 ('F', M, M, RWORK (IRVT)'Address, M, VT'Address, LDVT);
               ZUNMBR
                 ('P',
                  'R',
                  'C',
                  N,
                  N,
                  M,
                  A'Address,
                  LDA,
                  WORK (ITAUP)'Address,
                  VT'Address,
                  LDVT,
                  WORK (NWORK)'Address,
                  LWORK - NWORK + 1,
                  IERR);
            end if;
            --
         end if;
         --
      end if;
      --
      --     Undo scaling if necessary
      --
      if ISCL = 1 then
         if ANRM > BIGNUM then
            DLASCL ('G', 0, 0, BIGNUM, ANRM, MINMN, 1, S'Address, MINMN, IERR);
         end if;
         if INFO /= 0 and ANRM > BIGNUM then
            DLASCL ('G', 0, 0, BIGNUM, ANRM, MINMN - 1, 1, RWORK (IE)'Address, MINMN, IERR);
         end if;
         if ANRM < SMLNUM then
            DLASCL ('G', 0, 0, SMLNUM, ANRM, MINMN, 1, S'Address, MINMN, IERR);
         end if;
         if INFO /= 0 and ANRM < SMLNUM then
            DLASCL ('G', 0, 0, SMLNUM, ANRM, MINMN - 1, 1, RWORK (IE)'Address, MINMN, IERR);
         end if;
      end if;
      --
      --     Return optimal workspace in WORK(1)
      --
      WORK (1) := Complex'(Real (MAXWRK), 0.0e0);
      --
      return;
      --
      --     End of ZGESDD
      --
   end ZGESDD;

   procedure ZGESV
     (N    : Integer;
      NRHS : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer;
      IPIV : in out Ftn_Integer_Vector;
      B    : in out Ftn_Complex_Matrix;
      LDB  : Integer;
      INFO : in out Integer)
   is
   --  ZGESV computes the solution to system of linear equations A * X = B for GE matrices
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LDB, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       Complex*16   A( LDA, * ), B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGESV computes the solution to a complex system of linear equations
   --     A * X = B,
   --  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
   --
   --  The LU decomposition with partial pivoting and row interchanges is
   --  used to factor A as
   --     A = P * L * U,
   --  where P is a permutation matrix, L is unit lower triangular, and U is
   --  upper triangular.  The factored form of A is then used to solve the
   --  system of equations A * X = B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The number of linear equations, i.e., the order of the
   --           matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in,out] A
   --           A is Complex*16 array, dimension (LDA,N)
   --           On entry, the N-by-N coefficient matrix A.
   --           On exit, the factors L and U from the factorization
   --           A = P*L*U; the unit diagonal elements of L are not stored.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           The pivot indices that define the permutation matrix P;
   --           row i of the matrix was interchanged with row IPIV(i).
   --
   --  [in,out] B
   --           B is Complex*16 array, dimension (LDB,NRHS)
   --           On entry, the N-by-NRHS matrix of right hand side matrix B.
   --           On exit, if INFO = 0, the N-by-NRHS solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
   --                 has been completed, but the factor U is exactly
   --                 singular, so the solution could not be computed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. External Subroutines ..
   --      EXTERNAL           ZGETRF, ZGETRS, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if N < 0 then
         INFO := -1;
      elsif NRHS < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      elsif LDB < max (1, N) then
         INFO := -7;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGESV ", -INFO);
         return;
      end if;
      --
      --     Compute the LU factorization of A.
      --
      ZGETRF (N, N, A, LDA, IPIV, INFO);
      if INFO = 0 then
         --
         --        Solve the system A*X = B, overwriting B with X.
         --
         ZGETRS ('N', N, NRHS, A, LDA, IPIV, B, LDB, INFO);
      end if;
      return;
      --
      --     End of ZGESV
      --
   end ZGESV;

   procedure ZGESVD
     (JOBU  : Character;
      JOBVT : Character;
      M     : Integer;
      N     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      S     : in out Ftn_Real_Vector;
      U     : in out Ftn_Complex_Matrix;
      LDU   : Integer;
      VT    : in out Ftn_Complex_Matrix;
      LDVT  : Integer;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      RWORK : in out Ftn_Real_Vector;
      INFO  : in out Integer)
   is
      CZERO          : constant Complex := (0.0e0, 0.0e0);
      CONE           : constant Complex := (1.0e0, 0.0e0);
      ZERO           : constant Real    := 0.0e0;
      ONE            : constant Real    := 1.0e0;
      LQUERY         : Boolean;
      WNTUA          : Boolean;
      WNTUAS         : Boolean;
      WNTUN          : Boolean;
      WNTUO          : Boolean;
      WNTUS          : Boolean;
      WNTVA          : Boolean;
      WNTVAS         : Boolean;
      WNTVN          : Boolean;
      WNTVO          : Boolean;
      WNTVS          : Boolean;
      BLK            : Integer;
      CHUNK          : Integer;
      I              : Integer;
      IE             : Integer;
      IERR           : Integer;
      IR             : Integer;
      IRWORK         : Integer;
      ISCL           : Integer;
      ITAU           : Integer;
      ITAUP          : Integer;
      ITAUQ          : Integer;
      IU             : Integer;
      IWORK          : Integer;
      LDWRKR         : Integer;
      LDWRKU         : Integer;
      MAXWRK         : Integer;
      MINMN          : Integer;
      MINWRK         : Integer;
      MNTHR          : Integer;
      NCU            : Integer;
      NCVT           : Integer;
      NRU            : Integer;
      NRVT           : Integer;
      WRKBL          : Integer;
      LWORK_ZGEQRF   : Integer;
      LWORK_ZUNGQR_N : Integer;
      LWORK_ZUNGQR_M : Integer;
      LWORK_ZGEBRD   : Integer;
      LWORK_ZUNGBR_P : Integer;
      LWORK_ZUNGBR_Q : Integer;
      LWORK_ZGELQF   : Integer;
      LWORK_ZUNGLQ_N : Integer;
      LWORK_ZUNGLQ_M : Integer;
      ANRM           : Real;
      BIGNUM         : Real;
      EPS            : Real;
      SMLNUM         : Real;
      Real_DUM       : Ftn_Real_Vector (1 .. 1);
      DUM            : Ftn_Complex_Vector (1 .. 1); -- was Ftn_Real_Vector
      CDUM           : Ftn_Complex_Vector (1 .. 1);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,
   --                          WORK, LWORK, RWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBU, JOBVT
   --       INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   RWORK( * ), S( * )
   --       COMPLEX*16         A( LDA, * ), U( LDU, * ), VT( LDVT, * ),
   --      $                   WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGESVD computes the singular value decomposition (SVD) of a complex
   --  M-by-N matrix A, optionally computing the left and/or right singular
   --  vectors. The SVD is written
   --
   --       A = U * SIGMA * conjugate-transpose(V)
   --
   --  where SIGMA is an M-by-N matrix which is zero except for its
   --  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
   --  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
   --  are the singular values of A; they are real and non-negative, and
   --  are returned in descending order.  The first min(m,n) columns of
   --  U and V are the left and right singular vectors of A.
   --
   --  Note that the routine returns V**H, not V.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBU
   --           JOBU is CHARACTER*1
   --           Specifies options for computing all or part of the matrix U:
   --           = 'A':  all M columns of U are returned in array U:
   --           = 'S':  the first min(m,n) columns of U (the left singular
   --                   vectors) are returned in the array U;
   --           = 'O':  the first min(m,n) columns of U (the left singular
   --                   vectors) are overwritten on the array A;
   --           = 'N':  no columns of U (no left singular vectors) are
   --                   computed.
   --
   --  [in] JOBVT
   --           JOBVT is CHARACTER*1
   --           Specifies options for computing all or part of the matrix
   --           V**H:
   --           = 'A':  all N rows of V**H are returned in the array VT;
   --           = 'S':  the first min(m,n) rows of V**H (the right singular
   --                   vectors) are returned in the array VT;
   --           = 'O':  the first min(m,n) rows of V**H (the right singular
   --                   vectors) are overwritten on the array A;
   --           = 'N':  no rows of V**H (no right singular vectors) are
   --                   computed.
   --
   --           JOBVT and JOBU cannot both be 'O'.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the input matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the input matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the M-by-N matrix A.
   --           On exit,
   --           if JOBU = 'O',  A is overwritten with the first min(m,n)
   --                           columns of U (the left singular vectors,
   --                           stored columnwise);
   --           if JOBVT = 'O', A is overwritten with the first min(m,n)
   --                           rows of V**H (the right singular vectors,
   --                           stored rowwise);
   --           if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
   --                           are destroyed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] S
   --           S is DOUBLE PRECISION array, dimension (min(M,N))
   --           The singular values of A, sorted so that S(i) >= S(i+1).
   --
   --  [out] U
   --           U is COMPLEX*16 array, dimension (LDU,UCOL)
   --           (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
   --           If JOBU = 'A', U contains the M-by-M unitary matrix U;
   --           if JOBU = 'S', U contains the first min(m,n) columns of U
   --           (the left singular vectors, stored columnwise);
   --           if JOBU = 'N' or 'O', U is not referenced.
   --
   --  [in] LDU
   --           LDU is INTEGER
   --           The leading dimension of the array U.  LDU >= 1; if
   --           JOBU = 'S' or 'A', LDU >= M.
   --
   --  [out] VT
   --           VT is COMPLEX*16 array, dimension (LDVT,N)
   --           If JOBVT = 'A', VT contains the N-by-N unitary matrix
   --           V**H;
   --           if JOBVT = 'S', VT contains the first min(m,n) rows of
   --           V**H (the right singular vectors, stored rowwise);
   --           if JOBVT = 'N' or 'O', VT is not referenced.
   --
   --  [in] LDVT
   --           LDVT is INTEGER
   --           The leading dimension of the array VT.  LDVT >= 1; if
   --           JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           LWORK >=  MAX(1,2*MIN(M,N)+MAX(M,N)).
   --           For good performance, LWORK should generally be larger.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array, dimension (5*min(M,N))
   --           On exit, if INFO > 0, RWORK(1:MIN(M,N)-1) contains the
   --           unconverged superdiagonal elements of an upper bidiagonal
   --           matrix B whose diagonal is in S (not necessarily sorted).
   --           B satisfies A = U * B * VT, so it has the same singular
   --           values as A, and singular vectors related by U and VT.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if ZBDSQR did not converge, INFO specifies how many
   --                 superdiagonals of an intermediate bidiagonal form B
   --                 did not converge to zero. See the description of RWORK
   --                 above for details.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( CZERO = ( 0.0D0, 0.0D0 ), CONE = ( 1.0D0, 0.0D0 ) )
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASCL, XERBLA, ZBDSQR, ZGEBRD, ZGELQF, ZGEMM, ZGEQRF, ZLACPY, ZLASCL, ZLASET, ZUNGBR, ZUNGLQ,
   --ZUNGQR, ZUNMBR
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, ZLANGE
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      MINMN  := min (M, N);
      WNTUA  := LSAME (JOBU, 'A');
      WNTUS  := LSAME (JOBU, 'S');
      WNTUAS := WNTUA or WNTUS;
      WNTUO  := LSAME (JOBU, 'O');
      WNTUN  := LSAME (JOBU, 'N');
      WNTVA  := LSAME (JOBVT, 'A');
      WNTVS  := LSAME (JOBVT, 'S');
      WNTVAS := WNTVA or WNTVS;
      WNTVO  := LSAME (JOBVT, 'O');
      WNTVN  := LSAME (JOBVT, 'N');
      LQUERY := (LWORK = -1);
      --
      if not (WNTUA or WNTUS or WNTUO or WNTUN) then
         INFO := -1;
      elsif not (WNTVA or WNTVS or WNTVO or WNTVN) or (WNTVO and WNTUO) then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif LDA < max (1, M) then
         INFO := -6;
      elsif LDU < 1 or (WNTUAS and LDU < M) then
         INFO := -9;
      elsif LDVT < 1 or (WNTVA and LDVT < N) or (WNTVS and LDVT < MINMN) then
         INFO := -11;
      end if;
      --
      --     Compute workspace
      --      (Note: Comments in the code beginning "Workspace:" describe the
      --       minimal amount of workspace needed at that point in the code,
      --       as well as the preferred amount for good performance.
      --       CWorkspace refers to complex workspace, and RWorkspace to
      --       real workspace. NB refers to the optimal block size for the
      --       immediately following subroutine, as returned by ILAENV.)
      --
      if INFO = 0 then
         MINWRK := 1;
         MAXWRK := 1;
         if M >= N and MINMN > 0 then
            --
            --           Space needed for ZBDSQR is BDSPAC = 5*N
            --
            MNTHR := ILAENV (6, "ZGESVD", JOBU & JOBVT, M, N, 0, 0);
            --           Compute space needed for ZGEQRF
            ZGEQRF (M, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZGEQRF := int (real_part (DUM (1)));
            --           Compute space needed for ZUNGQR
            ZUNGQR (M, N, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZUNGQR_N := int (real_part (DUM (1)));
            ZUNGQR (M, M, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZUNGQR_M := int (real_part (DUM (1)));
            --           Compute space needed for ZGEBRD
            ZGEBRD
              (N,
               N,
               A'Address,
               LDA,
               S'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               -1,
               IERR);
            LWORK_ZGEBRD := int (real_part (DUM (1)));
            --           Compute space needed for ZUNGBR
            ZUNGBR ('P', N, N, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZUNGBR_P := int (real_part (DUM (1)));
            ZUNGBR ('Q', N, N, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZUNGBR_Q := int (real_part (DUM (1)));
            --
            if M >= MNTHR then
               if WNTUN then
                  --
                  --                 Path 1 (M much larger than N, JOBU='N')
                  --
                  MAXWRK := N + LWORK_ZGEQRF;
                  MAXWRK := max (MAXWRK, 2 * N + LWORK_ZGEBRD);
                  if WNTVO or WNTVAS then
                     MAXWRK := max (MAXWRK, 2 * N + LWORK_ZUNGBR_P);
                  end if;
                  MINWRK := 3 * N;
               elsif WNTUO and WNTVN then
                  --
                  --                 Path 2 (M much larger than N, JOBU='O', JOBVT='N')
                  --
                  WRKBL  := N + LWORK_ZGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_ZUNGQR_N);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_Q);
                  MAXWRK := max (N * N + WRKBL, N * N + M * N);
                  MINWRK := 2 * N + M;
               elsif WNTUO and WNTVAS then
                  --
                  --                 Path 3 (M much larger than N, JOBU='O', JOBVT='S' or
                  --                 'A')
                  --
                  WRKBL  := N + LWORK_ZGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_ZUNGQR_N);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_Q);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_P);
                  MAXWRK := max (N * N + WRKBL, N * N + M * N);
                  MINWRK := 2 * N + M;
               elsif WNTUS and WNTVN then
                  --
                  --                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
                  --
                  WRKBL  := N + LWORK_ZGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_ZUNGQR_N);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_Q);
                  MAXWRK := N * N + WRKBL;
                  MINWRK := 2 * N + M;
               elsif WNTUS and WNTVO then
                  --
                  --                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
                  --
                  WRKBL  := N + LWORK_ZGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_ZUNGQR_N);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_Q);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_P);
                  MAXWRK := 2 * N * N + WRKBL;
                  MINWRK := 2 * N + M;
               elsif WNTUS and WNTVAS then
                  --
                  --                 Path 6 (M much larger than N, JOBU='S', JOBVT='S' or
                  --                 'A')
                  --
                  WRKBL  := N + LWORK_ZGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_ZUNGQR_N);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_Q);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_P);
                  MAXWRK := N * N + WRKBL;
                  MINWRK := 2 * N + M;
               elsif WNTUA and WNTVN then
                  --
                  --                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
                  --
                  WRKBL  := N + LWORK_ZGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_ZUNGQR_M);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_Q);
                  MAXWRK := N * N + WRKBL;
                  MINWRK := 2 * N + M;
               elsif WNTUA and WNTVO then
                  --
                  --                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
                  --
                  WRKBL  := N + LWORK_ZGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_ZUNGQR_M);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_Q);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_P);
                  MAXWRK := 2 * N * N + WRKBL;
                  MINWRK := 2 * N + M;
               elsif WNTUA and WNTVAS then
                  --
                  --                 Path 9 (M much larger than N, JOBU='A', JOBVT='S' or
                  --                 'A')
                  --
                  WRKBL  := N + LWORK_ZGEQRF;
                  WRKBL  := max (WRKBL, N + LWORK_ZUNGQR_M);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_Q);
                  WRKBL  := max (WRKBL, 2 * N + LWORK_ZUNGBR_P);
                  MAXWRK := N * N + WRKBL;
                  MINWRK := 2 * N + M;
               end if;
            else
               --
               --              Path 10 (M at least N, but not much larger)
               --
               ZGEBRD
                 (M,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  -1,
                  IERR);
               LWORK_ZGEBRD := int (real_part (DUM (1)));
               MAXWRK       := 2 * N + LWORK_ZGEBRD;
               if WNTUS or WNTUO then
                  ZUNGBR ('Q', M, N, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
                  LWORK_ZUNGBR_Q := int (real_part (DUM (1)));
                  MAXWRK         := max (MAXWRK, 2 * N + LWORK_ZUNGBR_Q);
               end if;
               if WNTUA then
                  ZUNGBR ('Q', M, M, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
                  LWORK_ZUNGBR_Q := int (real_part (DUM (1)));
                  MAXWRK         := max (MAXWRK, 2 * N + LWORK_ZUNGBR_Q);
               end if;
               if not WNTVN then
                  MAXWRK := max (MAXWRK, 2 * N + LWORK_ZUNGBR_P);
                  MINWRK := 2 * N + M;
               end if;
            end if;
         elsif MINMN > 0 then
            --
            --           Space needed for ZBDSQR is BDSPAC = 5*M
            --
            MNTHR := ILAENV (6, "ZGESVD", JOBU & JOBVT, M, N, 0, 0);
            --           Compute space needed for ZGELQF
            ZGELQF (M, N, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZGELQF := int (real_part (DUM (1)));
            --           Compute space needed for ZUNGLQ
            ZUNGLQ (N, N, M, DUM (1)'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZUNGLQ_N := int (real_part (DUM (1)));
            ZUNGLQ (M, N, M, A'Address, LDA, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZUNGLQ_M := int (real_part (DUM (1)));
            --           Compute space needed for ZGEBRD
            ZGEBRD
              (M,
               M,
               A'Address,
               LDA,
               S'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               DUM (1)'Address,
               -1,
               IERR);
            LWORK_ZGEBRD := int (real_part (DUM (1)));
            --            Compute space needed for ZUNGBR P
            ZUNGBR ('P', M, M, M, A'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZUNGBR_P := int (real_part (DUM (1)));
            --           Compute space needed for ZUNGBR Q
            ZUNGBR ('Q', M, M, M, A'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
            LWORK_ZUNGBR_Q := int (real_part (DUM (1)));
            if N >= MNTHR then
               if WNTVN then
                  --
                  --                 Path 1t(N much larger than M, JOBVT='N')
                  --
                  MAXWRK := M + LWORK_ZGELQF;
                  MAXWRK := max (MAXWRK, 2 * M + LWORK_ZGEBRD);
                  if WNTUO or WNTUAS then
                     MAXWRK := max (MAXWRK, 2 * M + LWORK_ZUNGBR_Q);
                  end if;
                  MINWRK := 3 * M;
               elsif WNTVO and WNTUN then
                  --
                  --                 Path 2t(N much larger than M, JOBU='N', JOBVT='O')
                  --
                  WRKBL  := M + LWORK_ZGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_ZUNGLQ_M);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_P);
                  MAXWRK := max (M * M + WRKBL, M * M + M * N);
                  MINWRK := 2 * M + N;
               elsif WNTVO and WNTUAS then
                  --
                  --                 Path 3t(N much larger than M, JOBU='S' or 'A',
                  --                 JOBVT='O')
                  --
                  WRKBL  := M + LWORK_ZGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_ZUNGLQ_M);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_P);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_Q);
                  MAXWRK := max (M * M + WRKBL, M * M + M * N);
                  MINWRK := 2 * M + N;
               elsif WNTVS and WNTUN then
                  --
                  --                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
                  --
                  WRKBL  := M + LWORK_ZGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_ZUNGLQ_M);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_P);
                  MAXWRK := M * M + WRKBL;
                  MINWRK := 2 * M + N;
               elsif WNTVS and WNTUO then
                  --
                  --                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
                  --
                  WRKBL  := M + LWORK_ZGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_ZUNGLQ_M);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_P);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_Q);
                  MAXWRK := 2 * M * M + WRKBL;
                  MINWRK := 2 * M + N;
               elsif WNTVS and WNTUAS then
                  --
                  --                 Path 6t(N much larger than M, JOBU='S' or 'A',
                  --                 JOBVT='S')
                  --
                  WRKBL  := M + LWORK_ZGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_ZUNGLQ_M);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_P);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_Q);
                  MAXWRK := M * M + WRKBL;
                  MINWRK := 2 * M + N;
               elsif WNTVA and WNTUN then
                  --
                  --                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
                  --
                  WRKBL  := M + LWORK_ZGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_ZUNGLQ_N);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_P);
                  MAXWRK := M * M + WRKBL;
                  MINWRK := 2 * M + N;
               elsif WNTVA and WNTUO then
                  --
                  --                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
                  --
                  WRKBL  := M + LWORK_ZGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_ZUNGLQ_N);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_P);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_Q);
                  MAXWRK := 2 * M * M + WRKBL;
                  MINWRK := 2 * M + N;
               elsif WNTVA and WNTUAS then
                  --
                  --                 Path 9t(N much larger than M, JOBU='S' or 'A',
                  --                 JOBVT='A')
                  --
                  WRKBL  := M + LWORK_ZGELQF;
                  WRKBL  := max (WRKBL, M + LWORK_ZUNGLQ_N);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZGEBRD);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_P);
                  WRKBL  := max (WRKBL, 2 * M + LWORK_ZUNGBR_Q);
                  MAXWRK := M * M + WRKBL;
                  MINWRK := 2 * M + N;
               end if;
            else
               --
               --              Path 10t(N greater than M, but not much larger)
               --
               ZGEBRD
                 (M,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  DUM (1)'Address,
                  -1,
                  IERR);
               LWORK_ZGEBRD := int (real_part (DUM (1)));
               MAXWRK       := 2 * M + LWORK_ZGEBRD;
               if WNTVS or WNTVO then
                  --                Compute space needed for ZUNGBR P
                  ZUNGBR ('P', M, N, M, A'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
                  LWORK_ZUNGBR_P := int (real_part (DUM (1)));
                  MAXWRK         := max (MAXWRK, 2 * M + LWORK_ZUNGBR_P);
               end if;
               if WNTVA then
                  ZUNGBR ('P', N, N, M, A'Address, N, DUM (1)'Address, DUM (1)'Address, -1, IERR);
                  LWORK_ZUNGBR_P := int (real_part (DUM (1)));
                  MAXWRK         := max (MAXWRK, 2 * M + LWORK_ZUNGBR_P);
               end if;
               if not WNTUN then
                  MAXWRK := max (MAXWRK, 2 * M + LWORK_ZUNGBR_Q);
                  MINWRK := 2 * M + N;
               end if;
            end if;
         end if;
         MAXWRK   := max (MAXWRK, MINWRK);
         WORK (1) := Complex'(Real (MAXWRK), 0.0e0);
         --
         if LWORK < MINWRK and not LQUERY then
            INFO := -13;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZGESVD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     Get machine constants
      --
      EPS    := DLAMCH ('P');
      SMLNUM := Sqrt (DLAMCH ('S')) / EPS;
      BIGNUM := ONE / SMLNUM;
      --
      --     Scale A if max element outside range [SMLNUM,BIGNUM]
      --
      Real_DUM (1) := real_part (DUM (1));
      ANRM         := ZLANGE ('M', M, N, A, LDA, Real_DUM);
      ISCL         := 0;
      if ANRM > ZERO and ANRM < SMLNUM then
         ISCL := 1;
         ZLASCL ('G', 0, 0, ANRM, SMLNUM, M, N, A'Address, LDA, IERR);
      elsif ANRM > BIGNUM then
         ISCL := 1;
         ZLASCL ('G', 0, 0, ANRM, BIGNUM, M, N, A'Address, LDA, IERR);
      end if;
      --
      if M >= N then
         --
         --        A has at least as many rows as columns. If A has sufficiently
         --        more rows than columns, first reduce using the QR
         --        decomposition (if sufficient workspace available)
         --
         if M >= MNTHR then
            --
            if WNTUN then
               --
               --              Path 1 (M much larger than N, JOBU='N')
               --              No left singular vectors to be computed
               --
               ITAU  := 1;
               IWORK := ITAU + N;
               --
               --              Compute A=Q*R
               --              (CWorkspace: need 2*N, prefer N+N*NB)
               --              (RWorkspace: need 0)
               --
               ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
               --
               --              Zero out below R
               --
               ZLASET ('L', N - 1, N - 1, CZERO, CZERO, A (2, 1)'Address, LDA);
               IE    := 1;
               ITAUQ := 1;
               ITAUP := ITAUQ + N;
               IWORK := ITAUP + N;
               --
               --              Bidiagonalize R in A
               --              (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
               --              (RWorkspace: need N)
               --
               ZGEBRD
                 (N,
                  N,
                  A'Address,
                  LDA,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (IWORK)'Address,
                  LWORK - IWORK + 1,
                  IERR);
               NCVT := 0;
               if WNTVO or WNTVAS then
                  --
                  --                 If right singular vectors desired, generate P'.
                  --                 (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR ('P', N, N, N, A'Address, LDA, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  NCVT := N;
               end if;
               IRWORK := IE + N;
               --
               --              Perform bidiagonal QR iteration, computing right
               --              singular vectors of A in A if desired
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAC)
               --
               ZBDSQR
                 ('U',
                  N,
                  NCVT,
                  0,
                  0,
                  S'Address,
                  RWORK (IE)'Address,
                  A'Address,
                  LDA,
                  CDUM'Address,
                  1,
                  CDUM'Address,
                  1,
                  RWORK (IRWORK)'Address,
                  INFO);
               --
               --              If right singular vectors desired in VT, copy them there
               --
               if WNTVAS then
                  ZLACPY ('F', N, N, A'Address, LDA, VT'Address, LDVT);
               end if;
            --
            elsif WNTUO and WNTVN then
               --
               --              Path 2 (M much larger than N, JOBU='O', JOBVT='N')
               --              N left singular vectors to be overwritten on A and
               --              no right singular vectors to be computed
               --
               if LWORK >= N * N + 3 * N then
                  --
                  --                 Sufficient workspace for a fast algorithm
                  --
                  IR := 1;
                  if LWORK >= max (WRKBL, LDA * N) + LDA * N then
                     --
                     --                    WORK(IU) is LDA by N, WORK(IR) is LDA by N
                     --
                     LDWRKU := LDA;
                     LDWRKR := LDA;
                  elsif LWORK >= max (WRKBL, LDA * N) + N * N then
                     --
                     --                    WORK(IU) is LDA by N, WORK(IR) is N by N
                     --
                     LDWRKU := LDA;
                     LDWRKR := N;
                  else
                     --
                     --                    WORK(IU) is LDWRKU by N, WORK(IR) is N by N
                     --
                     LDWRKU := (LWORK - N * N) / N;
                     LDWRKR := N;
                  end if;
                  ITAU  := IR + LDWRKR * N;
                  IWORK := ITAU + N;
                  --
                  --                 Compute A=Q*R
                  --                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy R to WORK(IR) and zero out below it
                  --
                  ZLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                  ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IR + 1)'Address, LDWRKR);
                  --
                  --                 Generate Q in A
                  --                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := 1;
                  ITAUQ := ITAU;
                  ITAUP := ITAUQ + N;
                  IWORK := ITAUP + N;
                  --
                  --                 Bidiagonalize R in WORK(IR)
                  --                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
                  --                 (RWorkspace: need N)
                  --
                  ZGEBRD
                    (N,
                     N,
                     WORK (IR)'Address,
                     LDWRKR,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate left vectors bidiagonalizing R
                  --                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                  --                 (RWorkspace: need 0)
                  --
                  ZUNGBR
                    ('Q',
                     N,
                     N,
                     N,
                     WORK (IR)'Address,
                     LDWRKR,
                     WORK (ITAUQ)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  IRWORK := IE + N;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of R in WORK(IR)
                  --                 (CWorkspace: need N*N)
                  --                 (RWorkspace: need BDSPAC)
                  --
                  ZBDSQR
                    ('U',
                     N,
                     0,
                     N,
                     0,
                     S'Address,
                     RWORK (IE)'Address,
                     CDUM'Address,
                     1,
                     WORK (IR)'Address,
                     LDWRKR,
                     CDUM'Address,
                     1,
                     RWORK (IRWORK)'Address,
                     INFO);
                  IU := ITAUQ;
                  --
                  --                 Multiply Q in A by left singular vectors of R in
                  --                 WORK(IR), storing result in WORK(IU) and copying to A
                  --                 (CWorkspace: need N*N+N, prefer N*N+M*N)
                  --                 (RWorkspace: 0)
                  --
                  I := 1 - LDWRKU;
                  loop
                     I := I + LDWRKU;
                     exit when I > M;
                     CHUNK := min (M - I + 1, LDWRKU);
                     ZGEMM
                       ('N',
                        'N',
                        CHUNK,
                        N,
                        N,
                        CONE,
                        A (I, 1)'Address,
                        LDA,
                        WORK (IR)'Address,
                        LDWRKR,
                        CZERO,
                        WORK (IU)'Address,
                        LDWRKU);
                     ZLACPY ('F', CHUNK, N, WORK (IU)'Address, LDWRKU, A (I, 1)'Address, LDA);
                  end loop;
               --
               else
                  --
                  --                 Insufficient workspace for a fast algorithm
                  --
                  IE    := 1;
                  ITAUQ := 1;
                  ITAUP := ITAUQ + N;
                  IWORK := ITAUP + N;
                  --
                  --                 Bidiagonalize A
                  --                 (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
                  --                 (RWorkspace: N)
                  --
                  ZGEBRD
                    (M,
                     N,
                     A'Address,
                     LDA,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate left vectors bidiagonalizing A
                  --                 (CWorkspace: need 3*N, prefer 2*N+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR ('Q', M, N, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IRWORK := IE + N;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of A in A
                  --                 (CWorkspace: need 0)
                  --                 (RWorkspace: need BDSPAC)
                  --
                  ZBDSQR
                    ('U',
                     N,
                     0,
                     M,
                     0,
                     S'Address,
                     RWORK (IE)'Address,
                     CDUM'Address,
                     1,
                     A'Address,
                     LDA,
                     CDUM'Address,
                     1,
                     RWORK (IRWORK)'Address,
                     INFO);
                  --
               end if;
            --
            elsif WNTUO and WNTVAS then
               --
               --              Path 3 (M much larger than N, JOBU='O', JOBVT='S' or 'A')
               --              N left singular vectors to be overwritten on A and
               --              N right singular vectors to be computed in VT
               --
               if LWORK >= N * N + 3 * N then
                  --
                  --                 Sufficient workspace for a fast algorithm
                  --
                  IR := 1;
                  if LWORK >= max (WRKBL, LDA * N) + LDA * N then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is LDA by N
                     --
                     LDWRKU := LDA;
                     LDWRKR := LDA;
                  elsif LWORK >= max (WRKBL, LDA * N) + N * N then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is N by N
                     --
                     LDWRKU := LDA;
                     LDWRKR := N;
                  else
                     --
                     --                    WORK(IU) is LDWRKU by N and WORK(IR) is N by N
                     --
                     LDWRKU := (LWORK - N * N) / N;
                     LDWRKR := N;
                  end if;
                  ITAU  := IR + LDWRKR * N;
                  IWORK := ITAU + N;
                  --
                  --                 Compute A=Q*R
                  --                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy R to VT, zeroing out below it
                  --
                  ZLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
                  if N > 1 then
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, VT (2, 1)'Address, LDVT);
                  end if;
                  --
                  --                 Generate Q in A
                  --                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := 1;
                  ITAUQ := ITAU;
                  ITAUP := ITAUQ + N;
                  IWORK := ITAUP + N;
                  --
                  --                 Bidiagonalize R in VT, copying result to WORK(IR)
                  --                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
                  --                 (RWorkspace: need N)
                  --
                  ZGEBRD
                    (N,
                     N,
                     VT'Address,
                     LDVT,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  ZLACPY ('L', N, N, VT'Address, LDVT, WORK (IR)'Address, LDWRKR);
                  --
                  --                 Generate left vectors bidiagonalizing R in WORK(IR)
                  --                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR
                    ('Q',
                     N,
                     N,
                     N,
                     WORK (IR)'Address,
                     LDWRKR,
                     WORK (ITAUQ)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate right vectors bidiagonalizing R in VT
                  --                 (CWorkspace: need N*N+3*N-1, prefer N*N+2*N+(N-1)*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR
                    ('P',
                     N,
                     N,
                     N,
                     VT'Address,
                     LDVT,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  IRWORK := IE + N;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of R in WORK(IR) and computing right
                  --                 singular vectors of R in VT
                  --                 (CWorkspace: need N*N)
                  --                 (RWorkspace: need BDSPAC)
                  --
                  ZBDSQR
                    ('U',
                     N,
                     N,
                     N,
                     0,
                     S'Address,
                     RWORK (IE)'Address,
                     VT'Address,
                     LDVT,
                     WORK (IR)'Address,
                     LDWRKR,
                     CDUM'Address,
                     1,
                     RWORK (IRWORK)'Address,
                     INFO);
                  IU := ITAUQ;
                  --
                  --                 Multiply Q in A by left singular vectors of R in
                  --                 WORK(IR), storing result in WORK(IU) and copying to A
                  --                 (CWorkspace: need N*N+N, prefer N*N+M*N)
                  --                 (RWorkspace: 0)
                  --
                  I := 1 - LDWRKU;
                  loop
                     I := I + LDWRKU;
                     exit when I > M;
                     CHUNK := min (M - I + 1, LDWRKU);
                     ZGEMM
                       ('N',
                        'N',
                        CHUNK,
                        N,
                        N,
                        CONE,
                        A (I, 1)'Address,
                        LDA,
                        WORK (IR)'Address,
                        LDWRKR,
                        CZERO,
                        WORK (IU)'Address,
                        LDWRKU);
                     ZLACPY ('F', CHUNK, N, WORK (IU)'Address, LDWRKU, A (I, 1)'Address, LDA);
                  end loop;
               --
               else
                  --
                  --                 Insufficient workspace for a fast algorithm
                  --
                  ITAU  := 1;
                  IWORK := ITAU + N;
                  --
                  --                 Compute A=Q*R
                  --                 (CWorkspace: need 2*N, prefer N+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy R to VT, zeroing out below it
                  --
                  ZLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
                  if N > 1 then
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, VT (2, 1)'Address, LDVT);
                  end if;
                  --
                  --                 Generate Q in A
                  --                 (CWorkspace: need 2*N, prefer N+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := 1;
                  ITAUQ := ITAU;
                  ITAUP := ITAUQ + N;
                  IWORK := ITAUP + N;
                  --
                  --                 Bidiagonalize R in VT
                  --                 (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                  --                 (RWorkspace: N)
                  --
                  ZGEBRD
                    (N,
                     N,
                     VT'Address,
                     LDVT,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Multiply Q in A by left vectors bidiagonalizing R
                  --                 (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNMBR
                    ('Q',
                     'R',
                     'N',
                     M,
                     N,
                     N,
                     VT'Address,
                     LDVT,
                     WORK (ITAUQ)'Address,
                     A'Address,
                     LDA,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate right vectors bidiagonalizing R in VT
                  --                 (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR
                    ('P',
                     N,
                     N,
                     N,
                     VT'Address,
                     LDVT,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  IRWORK := IE + N;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of A in A and computing right
                  --                 singular vectors of A in VT
                  --                 (CWorkspace: 0)
                  --                 (RWorkspace: need BDSPAC)
                  --
                  ZBDSQR
                    ('U',
                     N,
                     N,
                     M,
                     0,
                     S'Address,
                     RWORK (IE)'Address,
                     VT'Address,
                     LDVT,
                     A'Address,
                     LDA,
                     CDUM'Address,
                     1,
                     RWORK (IRWORK)'Address,
                     INFO);
                  --
               end if;
            --
            elsif WNTUS then
               --
               if WNTVN then
                  --
                  --                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
                  --                 N left singular vectors to be computed in U and
                  --                 no right singular vectors to be computed
                  --
                  if LWORK >= N * N + 3 * N then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IR := 1;
                     if LWORK >= WRKBL + LDA * N then
                        --
                        --                       WORK(IR) is LDA by N
                        --
                        LDWRKR := LDA;
                     else
                        --
                        --                       WORK(IR) is N by N
                        --
                        LDWRKR := N;
                     end if;
                     ITAU  := IR + LDWRKR * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R
                     --                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IR), zeroing out below it
                     --
                     ZLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IR + 1)'Address, LDWRKR);
                     --
                     --                    Generate Q in A
                     --                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IR)
                     --                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left vectors bidiagonalizing R in WORK(IR)
                     --                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IR)
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        0,
                        N,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        CDUM'Address,
                        1,
                        WORK (IR)'Address,
                        LDWRKR,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in A by left singular vectors of R in
                     --                    WORK(IR), storing result in U
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, N, CONE, A'Address, LDA, WORK (IR)'Address, LDWRKR, CZERO, U'Address, LDU);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, N, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Zero out below R in A
                     --
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, A (2, 1)'Address, LDA);
                     --
                     --                    Bidiagonalize R in A
                     --                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        A'Address,
                        LDA,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left vectors bidiagonalizing R
                     --                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        0,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        CDUM'Address,
                        1,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTVO then
                  --
                  --                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
                  --                 N left singular vectors to be computed in U and
                  --                 N right singular vectors to be overwritten on A
                  --
                  if LWORK >= 2 * N * N + 3 * N then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + 2 * LDA * N then
                        --
                        --                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := LDA;
                     elsif LWORK >= WRKBL + (LDA + N) * N then
                        --
                        --                       WORK(IU) is LDA by N and WORK(IR) is N by N
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := N;
                     else
                        --
                        --                       WORK(IU) is N by N and WORK(IR) is N by N
                        --
                        LDWRKU := N;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := N;
                     end if;
                     ITAU  := IR + LDWRKR * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R
                     --                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IU), zeroing out below it
                     --
                     ZLACPY ('U', N, N, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IU + 1)'Address, LDWRKU);
                     --
                     --                    Generate Q in A
                     --                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IU), copying result to
                     --                    WORK(IR)
                     --                    (CWorkspace: need   2*N*N+3*N,
                     --                                 prefer 2*N*N+2*N+2*N*NB)
                     --                    (RWorkspace: need   N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     ZLACPY ('U', N, N, WORK (IU)'Address, LDWRKU, WORK (IR)'Address, LDWRKR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IU)
                     --                    (CWorkspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IR)
                     --                    (CWorkspace: need   2*N*N+3*N-1,
                     --                                 prefer 2*N*N+2*N+(N-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        N,
                        N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IU) and computing
                     --                    right singular vectors of R in WORK(IR)
                     --                    (CWorkspace: need 2*N*N)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        N,
                        N,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (IU)'Address,
                        LDWRKU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in A by left singular vectors of R in
                     --                    WORK(IU), storing result in U
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, N, CONE, A'Address, LDA, WORK (IU)'Address, LDWRKU, CZERO, U'Address, LDU);
                     --
                     --                    Copy right singular vectors of R to A
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: 0)
                     --
                     ZLACPY ('F', N, N, WORK (IR)'Address, LDWRKR, A'Address, LDA);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, N, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Zero out below R in A
                     --
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, A (2, 1)'Address, LDA);
                     --
                     --                    Bidiagonalize R in A
                     --                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        A'Address,
                        LDA,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left vectors bidiagonalizing R
                     --                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right vectors bidiagonalizing R in A
                     --                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        N,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in A
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        N,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        A'Address,
                        LDA,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTVAS then
                  --
                  --                 Path 6 (M much larger than N, JOBU='S', JOBVT='S'
                  --                         or 'A')
                  --                 N left singular vectors to be computed in U and
                  --                 N right singular vectors to be computed in VT
                  --
                  if LWORK >= N * N + 3 * N then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + LDA * N then
                        --
                        --                       WORK(IU) is LDA by N
                        --
                        LDWRKU := LDA;
                     else
                        --
                        --                       WORK(IU) is N by N
                        --
                        LDWRKU := N;
                     end if;
                     ITAU  := IU + LDWRKU * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R
                     --                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IU), zeroing out below it
                     --
                     ZLACPY ('U', N, N, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IU + 1)'Address, LDWRKU);
                     --
                     --                    Generate Q in A
                     --                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, N, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IU), copying result to VT
                     --                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     ZLACPY ('U', N, N, WORK (IU)'Address, LDWRKU, VT'Address, LDVT);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IU)
                     --                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in VT
                     --                    (CWorkspace: need   N*N+3*N-1,
                     --                                 prefer N*N+2*N+(N-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        N,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IU) and computing
                     --                    right singular vectors of R in VT
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        N,
                        N,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IU)'Address,
                        LDWRKU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in A by left singular vectors of R in
                     --                    WORK(IU), storing result in U
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, N, CONE, A'Address, LDA, WORK (IU)'Address, LDWRKU, CZERO, U'Address, LDU);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, N, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to VT, zeroing out below it
                     --
                     ZLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
                     if N > 1 then
                        ZLASET ('L', N - 1, N - 1, CZERO, CZERO, VT (2, 1)'Address, LDVT);
                     end if;
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in VT
                     --                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        VT'Address,
                        LDVT,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left bidiagonalizing vectors
                     --                    in VT
                     --                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in VT
                     --                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        N,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in VT
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        N,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
                  --
               end if;
            --
            elsif WNTUA then
               --
               if WNTVN then
                  --
                  --                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
                  --                 M left singular vectors to be computed in U and
                  --                 no right singular vectors to be computed
                  --
                  if LWORK >= N * N + max (N + M, 3 * N) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IR := 1;
                     if LWORK >= WRKBL + LDA * N then
                        --
                        --                       WORK(IR) is LDA by N
                        --
                        LDWRKR := LDA;
                     else
                        --
                        --                       WORK(IR) is N by N
                        --
                        LDWRKR := N;
                     end if;
                     ITAU  := IR + LDWRKR * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Copy R to WORK(IR), zeroing out below it
                     --
                     ZLACPY ('U', N, N, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IR + 1)'Address, LDWRKR);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need N*N+N+M, prefer N*N+N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IR)
                     --                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IR)
                     --                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IR)
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        0,
                        N,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        CDUM'Address,
                        1,
                        WORK (IR)'Address,
                        LDWRKR,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in U by left singular vectors of R in
                     --                    WORK(IR), storing result in A
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, N, CONE, U'Address, LDU, WORK (IR)'Address, LDWRKR, CZERO, A'Address, LDA);
                     --
                     --                    Copy left singular vectors of A from A to U
                     --
                     ZLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need N+M, prefer N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Zero out below R in A
                     --
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, A (2, 1)'Address, LDA);
                     --
                     --                    Bidiagonalize R in A
                     --                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        A'Address,
                        LDA,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left bidiagonalizing vectors
                     --                    in A
                     --                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        0,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        CDUM'Address,
                        1,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTVO then
                  --
                  --                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
                  --                 M left singular vectors to be computed in U and
                  --                 N right singular vectors to be overwritten on A
                  --
                  if LWORK >= 2 * N * N + max (N + M, 3 * N) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + 2 * LDA * N then
                        --
                        --                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := LDA;
                     elsif LWORK >= WRKBL + (LDA + N) * N then
                        --
                        --                       WORK(IU) is LDA by N and WORK(IR) is N by N
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := N;
                     else
                        --
                        --                       WORK(IU) is N by N and WORK(IR) is N by N
                        --
                        LDWRKU := N;
                        IR     := IU + LDWRKU * N;
                        LDWRKR := N;
                     end if;
                     ITAU  := IR + LDWRKR * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need 2*N*N+N+M, prefer 2*N*N+N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IU), zeroing out below it
                     --
                     ZLACPY ('U', N, N, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IU + 1)'Address, LDWRKU);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IU), copying result to
                     --                    WORK(IR)
                     --                    (CWorkspace: need   2*N*N+3*N,
                     --                                 prefer 2*N*N+2*N+2*N*NB)
                     --                    (RWorkspace: need   N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     ZLACPY ('U', N, N, WORK (IU)'Address, LDWRKU, WORK (IR)'Address, LDWRKR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IU)
                     --                    (CWorkspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IR)
                     --                    (CWorkspace: need   2*N*N+3*N-1,
                     --                                 prefer 2*N*N+2*N+(N-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        N,
                        N,
                        N,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IU) and computing
                     --                    right singular vectors of R in WORK(IR)
                     --                    (CWorkspace: need 2*N*N)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        N,
                        N,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (IU)'Address,
                        LDWRKU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in U by left singular vectors of R in
                     --                    WORK(IU), storing result in A
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, N, CONE, U'Address, LDU, WORK (IU)'Address, LDWRKU, CZERO, A'Address, LDA);
                     --
                     --                    Copy left singular vectors of A from A to U
                     --
                     ZLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Copy right singular vectors of R from WORK(IR) to A
                     --
                     ZLACPY ('F', N, N, WORK (IR)'Address, LDWRKR, A'Address, LDA);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need N+M, prefer N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Zero out below R in A
                     --
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, A (2, 1)'Address, LDA);
                     --
                     --                    Bidiagonalize R in A
                     --                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        A'Address,
                        LDA,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left bidiagonalizing vectors
                     --                    in A
                     --                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in A
                     --                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        N,
                        N,
                        N,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in A
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        N,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        A'Address,
                        LDA,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTVAS then
                  --
                  --                 Path 9 (M much larger than N, JOBU='A', JOBVT='S'
                  --                         or 'A')
                  --                 M left singular vectors to be computed in U and
                  --                 N right singular vectors to be computed in VT
                  --
                  if LWORK >= N * N + max (N + M, 3 * N) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + LDA * N then
                        --
                        --                       WORK(IU) is LDA by N
                        --
                        LDWRKU := LDA;
                     else
                        --
                        --                       WORK(IU) is N by N
                        --
                        LDWRKU := N;
                     end if;
                     ITAU  := IU + LDWRKU * N;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need N*N+N+M, prefer N*N+N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R to WORK(IU), zeroing out below it
                     --
                     ZLACPY ('U', N, N, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     ZLASET ('L', N - 1, N - 1, CZERO, CZERO, WORK (IU + 1)'Address, LDWRKU);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in WORK(IU), copying result to VT
                     --                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     ZLACPY ('U', N, N, WORK (IU)'Address, LDWRKU, VT'Address, LDVT);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IU)
                     --                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        N,
                        N,
                        N,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in VT
                     --                    (CWorkspace: need   N*N+3*N-1,
                     --                                 prefer N*N+2*N+(N-1)*NB)
                     --                    (RWorkspace: need   0)
                     --
                     ZUNGBR
                       ('P',
                        N,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of R in WORK(IU) and computing
                     --                    right singular vectors of R in VT
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        N,
                        N,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IU)'Address,
                        LDWRKU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply Q in U by left singular vectors of R in
                     --                    WORK(IU), storing result in A
                     --                    (CWorkspace: need N*N)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, N, CONE, U'Address, LDU, WORK (IU)'Address, LDWRKU, CZERO, A'Address, LDA);
                     --
                     --                    Copy left singular vectors of A from A to U
                     --
                     ZLACPY ('F', M, N, A'Address, LDA, U'Address, LDU);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + N;
                     --
                     --                    Compute A=Q*R, copying result to U
                     --                    (CWorkspace: need 2*N, prefer N+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGEQRF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
                     --
                     --                    Generate Q in U
                     --                    (CWorkspace: need N+M, prefer N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGQR (M, M, N, U'Address, LDU, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy R from A to VT, zeroing out below it
                     --
                     ZLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
                     if N > 1 then
                        ZLASET ('L', N - 1, N - 1, CZERO, CZERO, VT (2, 1)'Address, LDVT);
                     end if;
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + N;
                     IWORK := ITAUP + N;
                     --
                     --                    Bidiagonalize R in VT
                     --                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                     --                    (RWorkspace: need N)
                     --
                     ZGEBRD
                       (N,
                        N,
                        VT'Address,
                        LDVT,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply Q in U by left bidiagonalizing vectors
                     --                    in VT
                     --                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('Q',
                        'R',
                        'N',
                        M,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUQ)'Address,
                        U'Address,
                        LDU,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in VT
                     --                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        N,
                        N,
                        N,
                        VT'Address,
                        LDVT,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + N;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in VT
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        N,
                        N,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
                  --
               end if;
               --
            end if;
         --
         else
            --
            --           M .LT. MNTHR
            --
            --           Path 10 (M at least N, but not much larger)
            --           Reduce to bidiagonal form without QR decomposition
            --
            IE    := 1;
            ITAUQ := 1;
            ITAUP := ITAUQ + N;
            IWORK := ITAUP + N;
            --
            --           Bidiagonalize A
            --           (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
            --           (RWorkspace: need N)
            --
            ZGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               RWORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (IWORK)'Address,
               LWORK - IWORK + 1,
               IERR);
            if WNTUAS then
               --
               --              If left singular vectors desired in U, copy result to U
               --              and generate left bidiagonalizing vectors in U
               --              (CWorkspace: need 2*N+NCU, prefer 2*N+NCU*NB)
               --              (RWorkspace: 0)
               --
               ZLACPY ('L', M, N, A'Address, LDA, U'Address, LDU);
               if WNTUS then
                  NCU := N;
               end if;
               if WNTUA then
                  NCU := M;
               end if;
               ZUNGBR ('Q', M, NCU, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTVAS then
               --
               --              If right singular vectors desired in VT, copy result to
               --              VT and generate right bidiagonalizing vectors in VT
               --              (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
               --              (RWorkspace: 0)
               --
               ZLACPY ('U', N, N, A'Address, LDA, VT'Address, LDVT);
               ZUNGBR ('P', N, N, N, VT'Address, LDVT, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTUO then
               --
               --              If left singular vectors desired in A, generate left
               --              bidiagonalizing vectors in A
               --              (CWorkspace: need 3*N, prefer 2*N+N*NB)
               --              (RWorkspace: 0)
               --
               ZUNGBR ('Q', M, N, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTVO then
               --
               --              If right singular vectors desired in A, generate right
               --              bidiagonalizing vectors in A
               --              (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
               --              (RWorkspace: 0)
               --
               ZUNGBR ('P', N, N, N, A'Address, LDA, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            IRWORK := IE + N;
            if WNTUAS or WNTUO then
               NRU := M;
            end if;
            if WNTUN then
               NRU := 0;
            end if;
            if WNTVAS or WNTVO then
               NCVT := N;
            end if;
            if WNTVN then
               NCVT := 0;
            end if;
            if (not WNTUO) and (not WNTVO) then
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in U and computing right singular
               --              vectors in VT
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAC)
               --
               ZBDSQR
                 ('U',
                  N,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  RWORK (IE)'Address,
                  VT'Address,
                  LDVT,
                  U'Address,
                  LDU,
                  CDUM'Address,
                  1,
                  RWORK (IRWORK)'Address,
                  INFO);
            elsif (not WNTUO) and WNTVO then
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in U and computing right singular
               --              vectors in A
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAC)
               --
               ZBDSQR
                 ('U',
                  N,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  RWORK (IE)'Address,
                  A'Address,
                  LDA,
                  U'Address,
                  LDU,
                  CDUM'Address,
                  1,
                  RWORK (IRWORK)'Address,
                  INFO);
            else
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in A and computing right singular
               --              vectors in VT
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAC)
               --
               ZBDSQR
                 ('U',
                  N,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  RWORK (IE)'Address,
                  VT'Address,
                  LDVT,
                  A'Address,
                  LDA,
                  CDUM'Address,
                  1,
                  RWORK (IRWORK)'Address,
                  INFO);
            end if;
            --
         end if;
      --
      else
         --
         --        A has more columns than rows. If A has sufficiently more
         --        columns than rows, first reduce using the LQ decomposition (if
         --        sufficient workspace available)
         --
         if N >= MNTHR then
            --
            if WNTVN then
               --
               --              Path 1t(N much larger than M, JOBVT='N')
               --              No right singular vectors to be computed
               --
               ITAU  := 1;
               IWORK := ITAU + M;
               --
               --              Compute A=L*Q
               --              (CWorkspace: need 2*M, prefer M+M*NB)
               --              (RWorkspace: 0)
               --
               ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
               --
               --              Zero out above L
               --
               ZLASET ('U', M - 1, M - 1, CZERO, CZERO, A (1, 2)'Address, LDA);
               IE    := 1;
               ITAUQ := 1;
               ITAUP := ITAUQ + M;
               IWORK := ITAUP + M;
               --
               --              Bidiagonalize L in A
               --              (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
               --              (RWorkspace: need M)
               --
               ZGEBRD
                 (M,
                  M,
                  A'Address,
                  LDA,
                  S'Address,
                  RWORK (IE)'Address,
                  WORK (ITAUQ)'Address,
                  WORK (ITAUP)'Address,
                  WORK (IWORK)'Address,
                  LWORK - IWORK + 1,
                  IERR);
               if WNTUO or WNTUAS then
                  --
                  --                 If left singular vectors desired, generate Q
                  --                 (CWorkspace: need 3*M, prefer 2*M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR ('Q', M, M, M, A'Address, LDA, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
               end if;
               IRWORK := IE + M;
               NRU    := 0;
               if WNTUO or WNTUAS then
                  NRU := M;
               end if;
               --
               --              Perform bidiagonal QR iteration, computing left singular
               --              vectors of A in A if desired
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAC)
               --
               ZBDSQR
                 ('U',
                  M,
                  0,
                  NRU,
                  0,
                  S'Address,
                  RWORK (IE)'Address,
                  CDUM'Address,
                  1,
                  A'Address,
                  LDA,
                  CDUM'Address,
                  1,
                  RWORK (IRWORK)'Address,
                  INFO);
               --
               --              If left singular vectors desired in U, copy them there
               --
               if WNTUAS then
                  ZLACPY ('F', M, M, A'Address, LDA, U'Address, LDU);
               end if;
            --
            elsif WNTVO and WNTUN then
               --
               --              Path 2t(N much larger than M, JOBU='N', JOBVT='O')
               --              M right singular vectors to be overwritten on A and
               --              no left singular vectors to be computed
               --
               if LWORK >= M * M + 3 * M then
                  --
                  --                 Sufficient workspace for a fast algorithm
                  --
                  IR := 1;
                  if LWORK >= max (WRKBL, LDA * N) + LDA * M then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
                     --
                     LDWRKU := LDA;
                     CHUNK  := N;
                     LDWRKR := LDA;
                  elsif LWORK >= max (WRKBL, LDA * N) + M * M then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is M by M
                     --
                     LDWRKU := LDA;
                     CHUNK  := N;
                     LDWRKR := M;
                  else
                     --
                     --                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
                     --
                     LDWRKU := M;
                     CHUNK  := (LWORK - M * M) / M;
                     LDWRKR := M;
                  end if;
                  ITAU  := IR + LDWRKR * M;
                  IWORK := ITAU + M;
                  --
                  --                 Compute A=L*Q
                  --                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy L to WORK(IR) and zero out above it
                  --
                  ZLACPY ('L', M, M, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                  ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IR + LDWRKR)'Address, LDWRKR);
                  --
                  --                 Generate Q in A
                  --                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := 1;
                  ITAUQ := ITAU;
                  ITAUP := ITAUQ + M;
                  IWORK := ITAUP + M;
                  --
                  --                 Bidiagonalize L in WORK(IR)
                  --                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                  --                 (RWorkspace: need M)
                  --
                  ZGEBRD
                    (M,
                     M,
                     WORK (IR)'Address,
                     LDWRKR,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate right vectors bidiagonalizing L
                  --                 (CWorkspace: need M*M+3*M-1, prefer M*M+2*M+(M-1)*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR
                    ('P',
                     M,
                     M,
                     M,
                     WORK (IR)'Address,
                     LDWRKR,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  IRWORK := IE + M;
                  --
                  --                 Perform bidiagonal QR iteration, computing right
                  --                 singular vectors of L in WORK(IR)
                  --                 (CWorkspace: need M*M)
                  --                 (RWorkspace: need BDSPAC)
                  --
                  ZBDSQR
                    ('U',
                     M,
                     M,
                     0,
                     0,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (IR)'Address,
                     LDWRKR,
                     CDUM'Address,
                     1,
                     CDUM'Address,
                     1,
                     RWORK (IRWORK)'Address,
                     INFO);
                  IU := ITAUQ;
                  --
                  --                 Multiply right singular vectors of L in WORK(IR) by Q
                  --                 in A, storing result in WORK(IU) and copying to A
                  --                 (CWorkspace: need M*M+M, prefer M*M+M*N)
                  --                 (RWorkspace: 0)
                  --
                  I := 1 - CHUNK;
                  loop
                     I := I + CHUNK;
                     exit when I > N;
                     BLK := min (N - I + 1, CHUNK);
                     ZGEMM
                       ('N',
                        'N',
                        M,
                        BLK,
                        M,
                        CONE,
                        WORK (IR)'Address,
                        LDWRKR,
                        A (1, I)'Address,
                        LDA,
                        CZERO,
                        WORK (IU)'Address,
                        LDWRKU);
                     ZLACPY ('F', M, BLK, WORK (IU)'Address, LDWRKU, A (1, I)'Address, LDA);
                  end loop;
               --
               else
                  --
                  --                 Insufficient workspace for a fast algorithm
                  --
                  IE    := 1;
                  ITAUQ := 1;
                  ITAUP := ITAUQ + M;
                  IWORK := ITAUP + M;
                  --
                  --                 Bidiagonalize A
                  --                 (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
                  --                 (RWorkspace: need M)
                  --
                  ZGEBRD
                    (M,
                     N,
                     A'Address,
                     LDA,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate right vectors bidiagonalizing A
                  --                 (CWorkspace: need 3*M, prefer 2*M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR ('P', M, N, M, A'Address, LDA, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IRWORK := IE + M;
                  --
                  --                 Perform bidiagonal QR iteration, computing right
                  --                 singular vectors of A in A
                  --                 (CWorkspace: 0)
                  --                 (RWorkspace: need BDSPAC)
                  --
                  ZBDSQR
                    ('L',
                     M,
                     N,
                     0,
                     0,
                     S'Address,
                     RWORK (IE)'Address,
                     A'Address,
                     LDA,
                     CDUM'Address,
                     1,
                     CDUM'Address,
                     1,
                     RWORK (IRWORK)'Address,
                     INFO);
                  --
               end if;
            --
            elsif WNTVO and WNTUAS then
               --
               --              Path 3t(N much larger than M, JOBU='S' or 'A', JOBVT='O')
               --              M right singular vectors to be overwritten on A and
               --              M left singular vectors to be computed in U
               --
               if LWORK >= M * M + 3 * M then
                  --
                  --                 Sufficient workspace for a fast algorithm
                  --
                  IR := 1;
                  if LWORK >= max (WRKBL, LDA * N) + LDA * M then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
                     --
                     LDWRKU := LDA;
                     CHUNK  := N;
                     LDWRKR := LDA;
                  elsif LWORK >= max (WRKBL, LDA * N) + M * M then
                     --
                     --                    WORK(IU) is LDA by N and WORK(IR) is M by M
                     --
                     LDWRKU := LDA;
                     CHUNK  := N;
                     LDWRKR := M;
                  else
                     --
                     --                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
                     --
                     LDWRKU := M;
                     CHUNK  := (LWORK - M * M) / M;
                     LDWRKR := M;
                  end if;
                  ITAU  := IR + LDWRKR * M;
                  IWORK := ITAU + M;
                  --
                  --                 Compute A=L*Q
                  --                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy L to U, zeroing about above it
                  --
                  ZLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
                  ZLASET ('U', M - 1, M - 1, CZERO, CZERO, U (1, 2)'Address, LDU);
                  --
                  --                 Generate Q in A
                  --                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := 1;
                  ITAUQ := ITAU;
                  ITAUP := ITAUQ + M;
                  IWORK := ITAUP + M;
                  --
                  --                 Bidiagonalize L in U, copying result to WORK(IR)
                  --                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                  --                 (RWorkspace: need M)
                  --
                  ZGEBRD
                    (M,
                     M,
                     U'Address,
                     LDU,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  ZLACPY ('U', M, M, U'Address, LDU, WORK (IR)'Address, LDWRKR);
                  --
                  --                 Generate right vectors bidiagonalizing L in WORK(IR)
                  --                 (CWorkspace: need M*M+3*M-1, prefer M*M+2*M+(M-1)*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR
                    ('P',
                     M,
                     M,
                     M,
                     WORK (IR)'Address,
                     LDWRKR,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate left vectors bidiagonalizing L in U
                  --                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR ('Q', M, M, M, U'Address, LDU, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IRWORK := IE + M;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of L in U, and computing right
                  --                 singular vectors of L in WORK(IR)
                  --                 (CWorkspace: need M*M)
                  --                 (RWorkspace: need BDSPAC)
                  --
                  ZBDSQR
                    ('U',
                     M,
                     M,
                     M,
                     0,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (IR)'Address,
                     LDWRKR,
                     U'Address,
                     LDU,
                     CDUM'Address,
                     1,
                     RWORK (IRWORK)'Address,
                     INFO);
                  IU := ITAUQ;
                  --
                  --                 Multiply right singular vectors of L in WORK(IR) by Q
                  --                 in A, storing result in WORK(IU) and copying to A
                  --                 (CWorkspace: need M*M+M, prefer M*M+M*N)
                  --                 (RWorkspace: 0)
                  --
                  I := 1 - CHUNK;
                  loop
                     I := I + CHUNK;
                     exit when I > N;
                     BLK := min (N - I + 1, CHUNK);
                     ZGEMM
                       ('N',
                        'N',
                        M,
                        BLK,
                        M,
                        CONE,
                        WORK (IR)'Address,
                        LDWRKR,
                        A (1, I)'Address,
                        LDA,
                        CZERO,
                        WORK (IU)'Address,
                        LDWRKU);
                     ZLACPY ('F', M, BLK, WORK (IU)'Address, LDWRKU, A (1, I)'Address, LDA);
                  end loop;
               --
               else
                  --
                  --                 Insufficient workspace for a fast algorithm
                  --
                  ITAU  := 1;
                  IWORK := ITAU + M;
                  --
                  --                 Compute A=L*Q
                  --                 (CWorkspace: need 2*M, prefer M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  --
                  --                 Copy L to U, zeroing out above it
                  --
                  ZLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
                  ZLASET ('U', M - 1, M - 1, CZERO, CZERO, U (1, 2)'Address, LDU);
                  --
                  --                 Generate Q in A
                  --                 (CWorkspace: need 2*M, prefer M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IE    := 1;
                  ITAUQ := ITAU;
                  ITAUP := ITAUQ + M;
                  IWORK := ITAUP + M;
                  --
                  --                 Bidiagonalize L in U
                  --                 (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                  --                 (RWorkspace: need M)
                  --
                  ZGEBRD
                    (M,
                     M,
                     U'Address,
                     LDU,
                     S'Address,
                     RWORK (IE)'Address,
                     WORK (ITAUQ)'Address,
                     WORK (ITAUP)'Address,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Multiply right vectors bidiagonalizing L by Q in A
                  --                 (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNMBR
                    ('P',
                     'L',
                     'C',
                     M,
                     N,
                     M,
                     U'Address,
                     LDU,
                     WORK (ITAUP)'Address,
                     A'Address,
                     LDA,
                     WORK (IWORK)'Address,
                     LWORK - IWORK + 1,
                     IERR);
                  --
                  --                 Generate left vectors bidiagonalizing L in U
                  --                 (CWorkspace: need 3*M, prefer 2*M+M*NB)
                  --                 (RWorkspace: 0)
                  --
                  ZUNGBR ('Q', M, M, M, U'Address, LDU, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                  IRWORK := IE + M;
                  --
                  --                 Perform bidiagonal QR iteration, computing left
                  --                 singular vectors of A in U and computing right
                  --                 singular vectors of A in A
                  --                 (CWorkspace: 0)
                  --                 (RWorkspace: need BDSPAC)
                  --
                  ZBDSQR
                    ('U',
                     M,
                     N,
                     M,
                     0,
                     S'Address,
                     RWORK (IE)'Address,
                     A'Address,
                     LDA,
                     U'Address,
                     LDU,
                     CDUM'Address,
                     1,
                     RWORK (IRWORK)'Address,
                     INFO);
                  --
               end if;
            --
            elsif WNTVS then
               --
               if WNTUN then
                  --
                  --                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
                  --                 M right singular vectors to be computed in VT and
                  --                 no left singular vectors to be computed
                  --
                  if LWORK >= M * M + 3 * M then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IR := 1;
                     if LWORK >= WRKBL + LDA * M then
                        --
                        --                       WORK(IR) is LDA by M
                        --
                        LDWRKR := LDA;
                     else
                        --
                        --                       WORK(IR) is M by M
                        --
                        LDWRKR := M;
                     end if;
                     ITAU  := IR + LDWRKR * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q
                     --                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IR), zeroing out above it
                     --
                     ZLACPY ('L', M, M, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IR + LDWRKR)'Address, LDWRKR);
                     --
                     --                    Generate Q in A
                     --                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IR)
                     --                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right vectors bidiagonalizing L in
                     --                    WORK(IR)
                     --                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+(M-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing right
                     --                    singular vectors of L in WORK(IR)
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        M,
                        0,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (IR)'Address,
                        LDWRKR,
                        CDUM'Address,
                        1,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IR) by
                     --                    Q in A, storing result in VT
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, M, CONE, WORK (IR)'Address, LDWRKR, A'Address, LDA, CZERO, VT'Address, LDVT);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy result to VT
                     --
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (M, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Zero out above L in A
                     --
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, A (1, 2)'Address, LDA);
                     --
                     --                    Bidiagonalize L in A
                     --                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        A'Address,
                        LDA,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right vectors bidiagonalizing L by Q in VT
                     --                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('P',
                        'L',
                        'C',
                        M,
                        N,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing right
                     --                    singular vectors of A in VT
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        N,
                        0,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        CDUM'Address,
                        1,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTUO then
                  --
                  --                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
                  --                 M right singular vectors to be computed in VT and
                  --                 M left singular vectors to be overwritten on A
                  --
                  if LWORK >= 2 * M * M + 3 * M then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + 2 * LDA * M then
                        --
                        --                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := LDA;
                     elsif LWORK >= WRKBL + (LDA + M) * M then
                        --
                        --                       WORK(IU) is LDA by M and WORK(IR) is M by M
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := M;
                     else
                        --
                        --                       WORK(IU) is M by M and WORK(IR) is M by M
                        --
                        LDWRKU := M;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := M;
                     end if;
                     ITAU  := IR + LDWRKR * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q
                     --                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IU), zeroing out below it
                     --
                     ZLACPY ('L', M, M, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IU + LDWRKU)'Address, LDWRKU);
                     --
                     --                    Generate Q in A
                     --                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IU), copying result to
                     --                    WORK(IR)
                     --                    (CWorkspace: need   2*M*M+3*M,
                     --                                 prefer 2*M*M+2*M+2*M*NB)
                     --                    (RWorkspace: need   M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     ZLACPY ('L', M, M, WORK (IU)'Address, LDWRKU, WORK (IR)'Address, LDWRKR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IU)
                     --                    (CWorkspace: need   2*M*M+3*M-1,
                     --                                 prefer 2*M*M+2*M+(M-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IR)
                     --                    (CWorkspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        M,
                        M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of L in WORK(IR) and computing
                     --                    right singular vectors of L in WORK(IU)
                     --                    (CWorkspace: need 2*M*M)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        M,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (IR)'Address,
                        LDWRKR,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IU) by
                     --                    Q in A, storing result in VT
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, M, CONE, WORK (IU)'Address, LDWRKU, A'Address, LDA, CZERO, VT'Address, LDVT);
                     --
                     --                    Copy left singular vectors of L to A
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: 0)
                     --
                     ZLACPY ('F', M, M, WORK (IR)'Address, LDWRKR, A'Address, LDA);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (M, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Zero out above L in A
                     --
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, A (1, 2)'Address, LDA);
                     --
                     --                    Bidiagonalize L in A
                     --                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        A'Address,
                        LDA,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right vectors bidiagonalizing L by Q in VT
                     --                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('P',
                        'L',
                        'C',
                        M,
                        N,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors of L in A
                     --                    (CWorkspace: need 3*M, prefer 2*M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        M,
                        M,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in A and computing right
                     --                    singular vectors of A in VT
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        N,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        A'Address,
                        LDA,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTUAS then
                  --
                  --                 Path 6t(N much larger than M, JOBU='S' or 'A',
                  --                         JOBVT='S')
                  --                 M right singular vectors to be computed in VT and
                  --                 M left singular vectors to be computed in U
                  --
                  if LWORK >= M * M + 3 * M then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + LDA * M then
                        --
                        --                       WORK(IU) is LDA by N
                        --
                        LDWRKU := LDA;
                     else
                        --
                        --                       WORK(IU) is LDA by M
                        --
                        LDWRKU := M;
                     end if;
                     ITAU  := IU + LDWRKU * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q
                     --                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IU), zeroing out above it
                     --
                     ZLACPY ('L', M, M, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IU + LDWRKU)'Address, LDWRKU);
                     --
                     --                    Generate Q in A
                     --                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (M, N, M, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IU), copying result to U
                     --                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     ZLACPY ('L', M, M, WORK (IU)'Address, LDWRKU, U'Address, LDU);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IU)
                     --                    (CWorkspace: need   M*M+3*M-1,
                     --                                 prefer M*M+2*M+(M-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in U
                     --                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        M,
                        M,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of L in U and computing right
                     --                    singular vectors of L in WORK(IU)
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        M,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (IU)'Address,
                        LDWRKU,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IU) by
                     --                    Q in A, storing result in VT
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, M, CONE, WORK (IU)'Address, LDWRKU, A'Address, LDA, CZERO, VT'Address, LDVT);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (M, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to U, zeroing out above it
                     --
                     ZLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, U (1, 2)'Address, LDU);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in U
                     --                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        U'Address,
                        LDU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right bidiagonalizing vectors in U by Q
                     --                    in VT
                     --                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('P',
                        'L',
                        'C',
                        M,
                        N,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in U
                     --                    (CWorkspace: need 3*M, prefer 2*M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        M,
                        M,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in VT
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        N,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
                  --
               end if;
            --
            elsif WNTVA then
               --
               if WNTUN then
                  --
                  --                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
                  --                 N right singular vectors to be computed in VT and
                  --                 no left singular vectors to be computed
                  --
                  if LWORK >= M * M + max (N + M, 3 * M) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IR := 1;
                     if LWORK >= WRKBL + LDA * M then
                        --
                        --                       WORK(IR) is LDA by M
                        --
                        LDWRKR := LDA;
                     else
                        --
                        --                       WORK(IR) is M by M
                        --
                        LDWRKR := M;
                     end if;
                     ITAU  := IR + LDWRKR * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Copy L to WORK(IR), zeroing out above it
                     --
                     ZLACPY ('L', M, M, A'Address, LDA, WORK (IR)'Address, LDWRKR);
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IR + LDWRKR)'Address, LDWRKR);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need M*M+M+N, prefer M*M+M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IR)
                     --                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IR)
                     --                    (CWorkspace: need   M*M+3*M-1,
                     --                                 prefer M*M+2*M+(M-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing right
                     --                    singular vectors of L in WORK(IR)
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        M,
                        0,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (IR)'Address,
                        LDWRKR,
                        CDUM'Address,
                        1,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IR) by
                     --                    Q in VT, storing result in A
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, M, CONE, WORK (IR)'Address, LDWRKR, VT'Address, LDVT, CZERO, A'Address, LDA);
                     --
                     --                    Copy right singular vectors of A from A to VT
                     --
                     ZLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need M+N, prefer M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Zero out above L in A
                     --
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, A (1, 2)'Address, LDA);
                     --
                     --                    Bidiagonalize L in A
                     --                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        A'Address,
                        LDA,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right bidiagonalizing vectors in A by Q
                     --                    in VT
                     --                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('P',
                        'L',
                        'C',
                        M,
                        N,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing right
                     --                    singular vectors of A in VT
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        N,
                        0,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        CDUM'Address,
                        1,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTUO then
                  --
                  --                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
                  --                 N right singular vectors to be computed in VT and
                  --                 M left singular vectors to be overwritten on A
                  --
                  if LWORK >= 2 * M * M + max (N + M, 3 * M) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + 2 * LDA * M then
                        --
                        --                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := LDA;
                     elsif LWORK >= WRKBL + (LDA + M) * M then
                        --
                        --                       WORK(IU) is LDA by M and WORK(IR) is M by M
                        --
                        LDWRKU := LDA;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := M;
                     else
                        --
                        --                       WORK(IU) is M by M and WORK(IR) is M by M
                        --
                        LDWRKU := M;
                        IR     := IU + LDWRKU * M;
                        LDWRKR := M;
                     end if;
                     ITAU  := IR + LDWRKR * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need 2*M*M+M+N, prefer 2*M*M+M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IU), zeroing out above it
                     --
                     ZLACPY ('L', M, M, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IU + LDWRKU)'Address, LDWRKU);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IU), copying result to
                     --                    WORK(IR)
                     --                    (CWorkspace: need   2*M*M+3*M,
                     --                                 prefer 2*M*M+2*M+2*M*NB)
                     --                    (RWorkspace: need   M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     ZLACPY ('L', M, M, WORK (IU)'Address, LDWRKU, WORK (IR)'Address, LDWRKR);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IU)
                     --                    (CWorkspace: need   2*M*M+3*M-1,
                     --                                 prefer 2*M*M+2*M+(M-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in WORK(IR)
                     --                    (CWorkspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        M,
                        M,
                        M,
                        WORK (IR)'Address,
                        LDWRKR,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of L in WORK(IR) and computing
                     --                    right singular vectors of L in WORK(IU)
                     --                    (CWorkspace: need 2*M*M)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        M,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (IR)'Address,
                        LDWRKR,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IU) by
                     --                    Q in VT, storing result in A
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, M, CONE, WORK (IU)'Address, LDWRKU, VT'Address, LDVT, CZERO, A'Address, LDA);
                     --
                     --                    Copy right singular vectors of A from A to VT
                     --
                     ZLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Copy left singular vectors of A from WORK(IR) to A
                     --
                     ZLACPY ('F', M, M, WORK (IR)'Address, LDWRKR, A'Address, LDA);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need M+N, prefer M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Zero out above L in A
                     --
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, A (1, 2)'Address, LDA);
                     --
                     --                    Bidiagonalize L in A
                     --                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        A'Address,
                        LDA,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right bidiagonalizing vectors in A by Q
                     --                    in VT
                     --                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('P',
                        'L',
                        'C',
                        M,
                        N,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in A
                     --                    (CWorkspace: need 3*M, prefer 2*M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        M,
                        M,
                        M,
                        A'Address,
                        LDA,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in A and computing right
                     --                    singular vectors of A in VT
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        N,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        A'Address,
                        LDA,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
               --
               elsif WNTUAS then
                  --
                  --                 Path 9t(N much larger than M, JOBU='S' or 'A',
                  --                         JOBVT='A')
                  --                 N right singular vectors to be computed in VT and
                  --                 M left singular vectors to be computed in U
                  --
                  if LWORK >= M * M + max (N + M, 3 * M) then
                     --
                     --                    Sufficient workspace for a fast algorithm
                     --
                     IU := 1;
                     if LWORK >= WRKBL + LDA * M then
                        --
                        --                       WORK(IU) is LDA by M
                        --
                        LDWRKU := LDA;
                     else
                        --
                        --                       WORK(IU) is M by M
                        --
                        LDWRKU := M;
                     end if;
                     ITAU  := IU + LDWRKU * M;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need M*M+M+N, prefer M*M+M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to WORK(IU), zeroing out above it
                     --
                     ZLACPY ('L', M, M, A'Address, LDA, WORK (IU)'Address, LDWRKU);
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, WORK (IU + LDWRKU)'Address, LDWRKU);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in WORK(IU), copying result to U
                     --                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     ZLACPY ('L', M, M, WORK (IU)'Address, LDWRKU, U'Address, LDU);
                     --
                     --                    Generate right bidiagonalizing vectors in WORK(IU)
                     --                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+(M-1)*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('P',
                        M,
                        M,
                        M,
                        WORK (IU)'Address,
                        LDWRKU,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in U
                     --                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        M,
                        M,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of L in U and computing right
                     --                    singular vectors of L in WORK(IU)
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        M,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (IU)'Address,
                        LDWRKU,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                     --                    Multiply right singular vectors of L in WORK(IU) by
                     --                    Q in VT, storing result in A
                     --                    (CWorkspace: need M*M)
                     --                    (RWorkspace: 0)
                     --
                     ZGEMM ('N', 'N', M, N, M, CONE, WORK (IU)'Address, LDWRKU, VT'Address, LDVT, CZERO, A'Address, LDA);
                     --
                     --                    Copy right singular vectors of A from A to VT
                     --
                     ZLACPY ('F', M, N, A'Address, LDA, VT'Address, LDVT);
                  --
                  else
                     --
                     --                    Insufficient workspace for a fast algorithm
                     --
                     ITAU  := 1;
                     IWORK := ITAU + M;
                     --
                     --                    Compute A=L*Q, copying result to VT
                     --                    (CWorkspace: need 2*M, prefer M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZGELQF (M, N, A'Address, LDA, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
                     --
                     --                    Generate Q in VT
                     --                    (CWorkspace: need M+N, prefer M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGLQ (N, N, M, VT'Address, LDVT, WORK (ITAU)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
                     --
                     --                    Copy L to U, zeroing out above it
                     --
                     ZLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
                     ZLASET ('U', M - 1, M - 1, CZERO, CZERO, U (1, 2)'Address, LDU);
                     IE    := 1;
                     ITAUQ := ITAU;
                     ITAUP := ITAUQ + M;
                     IWORK := ITAUP + M;
                     --
                     --                    Bidiagonalize L in U
                     --                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                     --                    (RWorkspace: need M)
                     --
                     ZGEBRD
                       (M,
                        M,
                        U'Address,
                        LDU,
                        S'Address,
                        RWORK (IE)'Address,
                        WORK (ITAUQ)'Address,
                        WORK (ITAUP)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Multiply right bidiagonalizing vectors in U by Q
                     --                    in VT
                     --                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNMBR
                       ('P',
                        'L',
                        'C',
                        M,
                        N,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUP)'Address,
                        VT'Address,
                        LDVT,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     --
                     --                    Generate left bidiagonalizing vectors in U
                     --                    (CWorkspace: need 3*M, prefer 2*M+M*NB)
                     --                    (RWorkspace: 0)
                     --
                     ZUNGBR
                       ('Q',
                        M,
                        M,
                        M,
                        U'Address,
                        LDU,
                        WORK (ITAUQ)'Address,
                        WORK (IWORK)'Address,
                        LWORK - IWORK + 1,
                        IERR);
                     IRWORK := IE + M;
                     --
                     --                    Perform bidiagonal QR iteration, computing left
                     --                    singular vectors of A in U and computing right
                     --                    singular vectors of A in VT
                     --                    (CWorkspace: 0)
                     --                    (RWorkspace: need BDSPAC)
                     --
                     ZBDSQR
                       ('U',
                        M,
                        N,
                        M,
                        0,
                        S'Address,
                        RWORK (IE)'Address,
                        VT'Address,
                        LDVT,
                        U'Address,
                        LDU,
                        CDUM'Address,
                        1,
                        RWORK (IRWORK)'Address,
                        INFO);
                     --
                  end if;
                  --
               end if;
               --
            end if;
         --
         else
            --
            --           N .LT. MNTHR
            --
            --           Path 10t(N greater than M, but not much larger)
            --           Reduce to bidiagonal form without LQ decomposition
            --
            IE    := 1;
            ITAUQ := 1;
            ITAUP := ITAUQ + M;
            IWORK := ITAUP + M;
            --
            --           Bidiagonalize A
            --           (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
            --           (RWorkspace: M)
            --
            ZGEBRD
              (M,
               N,
               A'Address,
               LDA,
               S'Address,
               RWORK (IE)'Address,
               WORK (ITAUQ)'Address,
               WORK (ITAUP)'Address,
               WORK (IWORK)'Address,
               LWORK - IWORK + 1,
               IERR);
            if WNTUAS then
               --
               --              If left singular vectors desired in U, copy result to U
               --              and generate left bidiagonalizing vectors in U
               --              (CWorkspace: need 3*M-1, prefer 2*M+(M-1)*NB)
               --              (RWorkspace: 0)
               --
               ZLACPY ('L', M, M, A'Address, LDA, U'Address, LDU);
               ZUNGBR ('Q', M, M, N, U'Address, LDU, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTVAS then
               --
               --              If right singular vectors desired in VT, copy result to
               --              VT and generate right bidiagonalizing vectors in VT
               --              (CWorkspace: need 2*M+NRVT, prefer 2*M+NRVT*NB)
               --              (RWorkspace: 0)
               --
               ZLACPY ('U', M, N, A'Address, LDA, VT'Address, LDVT);
               if WNTVA then
                  NRVT := N;
               end if;
               if WNTVS then
                  NRVT := M;
               end if;
               ZUNGBR
                 ('P',
                  NRVT,
                  N,
                  M,
                  VT'Address,
                  LDVT,
                  WORK (ITAUP)'Address,
                  WORK (IWORK)'Address,
                  LWORK - IWORK + 1,
                  IERR);
            end if;
            if WNTUO then
               --
               --              If left singular vectors desired in A, generate left
               --              bidiagonalizing vectors in A
               --              (CWorkspace: need 3*M-1, prefer 2*M+(M-1)*NB)
               --              (RWorkspace: 0)
               --
               ZUNGBR ('Q', M, M, N, A'Address, LDA, WORK (ITAUQ)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            if WNTVO then
               --
               --              If right singular vectors desired in A, generate right
               --              bidiagonalizing vectors in A
               --              (CWorkspace: need 3*M, prefer 2*M+M*NB)
               --              (RWorkspace: 0)
               --
               ZUNGBR ('P', M, N, M, A'Address, LDA, WORK (ITAUP)'Address, WORK (IWORK)'Address, LWORK - IWORK + 1, IERR);
            end if;
            IRWORK := IE + M;
            if WNTUAS or WNTUO then
               NRU := M;
            end if;
            if WNTUN then
               NRU := 0;
            end if;
            if WNTVAS or WNTVO then
               NCVT := N;
            end if;
            if WNTVN then
               NCVT := 0;
            end if;
            if (not WNTUO) and (not WNTVO) then
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in U and computing right singular
               --              vectors in VT
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAC)
               --
               ZBDSQR
                 ('L',
                  M,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  RWORK (IE)'Address,
                  VT'Address,
                  LDVT,
                  U'Address,
                  LDU,
                  CDUM'Address,
                  1,
                  RWORK (IRWORK)'Address,
                  INFO);
            elsif (not WNTUO) and WNTVO then
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in U and computing right singular
               --              vectors in A
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAC)
               --
               ZBDSQR
                 ('L',
                  M,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  RWORK (IE)'Address,
                  A'Address,
                  LDA,
                  U'Address,
                  LDU,
                  CDUM'Address,
                  1,
                  RWORK (IRWORK)'Address,
                  INFO);
            else
               --
               --              Perform bidiagonal QR iteration, if desired, computing
               --              left singular vectors in A and computing right singular
               --              vectors in VT
               --              (CWorkspace: 0)
               --              (RWorkspace: need BDSPAC)
               --
               ZBDSQR
                 ('L',
                  M,
                  NCVT,
                  NRU,
                  0,
                  S'Address,
                  RWORK (IE)'Address,
                  VT'Address,
                  LDVT,
                  A'Address,
                  LDA,
                  CDUM'Address,
                  1,
                  RWORK (IRWORK)'Address,
                  INFO);
            end if;
            --
         end if;
         --
      end if;
      --
      --     Undo scaling if necessary
      --
      if ISCL = 1 then
         if ANRM > BIGNUM then
            DLASCL ('G', 0, 0, BIGNUM, ANRM, MINMN, 1, S'Address, MINMN, IERR);
         end if;
         if INFO /= 0 and ANRM > BIGNUM then
            DLASCL ('G', 0, 0, BIGNUM, ANRM, MINMN - 1, 1, RWORK (IE)'Address, MINMN, IERR);
         end if;
         if ANRM < SMLNUM then
            DLASCL ('G', 0, 0, SMLNUM, ANRM, MINMN, 1, S'Address, MINMN, IERR);
         end if;
         if INFO /= 0 and ANRM < SMLNUM then
            DLASCL ('G', 0, 0, SMLNUM, ANRM, MINMN - 1, 1, RWORK (IE)'Address, MINMN, IERR);
         end if;
      end if;
      --
      --     Return optimal workspace in WORK(1)
      --
      WORK (1) := Complex'(Real (MAXWRK), 0.0e0);
      --
      return;
      --
      --     End of ZGESVD
      --
   end ZGESVD;

   procedure ZGETF2
     (M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      IPIV_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      IPIV : Ftn_Integer_Vector (1 .. min (M, N));

      for A'Address use A_adr;
      for IPIV'Address use IPIV_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, IPIV);

      ONE   : constant Complex := (1.0e0, 0.0e0);
      ZERO  : constant Complex := (0.0e0, 0.0e0);
      SFMIN : Real;
      I     : Integer;
      J     : Integer;
      JP    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGETF2( M, N, A, LDA, IPIV, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       Complex*16   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGETF2 computes an LU factorization of a general m-by-n matrix A
   --  using partial pivoting with row interchanges.
   --
   --  The factorization has the form
   --     A = P * L * U
   --  where P is a permutation matrix, L is lower triangular with unit
   --  diagonal elements (lower trapezoidal if m > n), and U is upper
   --  triangular (upper trapezoidal if m < n).
   --
   --  This is the right-looking Level 2 BLAS version of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is Complex*16 array, dimension (LDA,N)
   --           On entry, the m by n matrix to be factored.
   --           On exit, the factors L and U from the factorization
   --           A = P*L*U; the unit diagonal elements of L are not stored.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (min(M,N))
   --           The pivot indices; for 1 <= i <= min(M,N), row i of the
   --           matrix was interchanged with row IPIV(i).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -k, the k-th argument had an illegal value
   --           > 0: if INFO = k, U(k,k) is exactly zero. The factorization
   --                has been completed, but the factor U is exactly
   --                singular, and division by zero will occur if it is used
   --                to solve a system of equations.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      DOUBLE PRECISION   DLAMCH
   --      INTEGER            IZAMAX
   --      EXTERNAL           DLAMCH, IZAMAX
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZGERU, ZSCAL, ZSWAP, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGETF2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     Compute machine safe minimum
      --
      SFMIN := DLAMCH ('S');
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > min (M, N);
         --
         --        Find pivot and test for singularity.
         --
         JP       := J - 1 + IZAMAX (M - J + 1, A (J, J)'Address, 1);
         IPIV (J) := JP;
         if A (JP, J) /= ZERO then
            --
            --           Apply the interchange to columns 1:N.
            --
            if JP /= J then
               ZSWAP (N, A (J, 1)'Address, LDA, A (JP, 1)'Address, LDA);
            end if;
            --
            --           Compute elements J+1:M of J-th column.
            --
            if J < M then
               if abs (A (J, J)) >= SFMIN then
                  ZSCAL (M - J, ONE / A (J, J), A (J + 1, J)'Address, 1);
               else
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > M - J;
                     A (J + I, J) := A (J + I, J) / A (J, J);
                  end loop;
               end if;
            end if;
         --
         elsif INFO = 0 then
            --
            INFO := J;
         end if;
         --
         if J < min (M, N) then
            --
            --           Update trailing submatrix.
            --
            ZGERU (M - J, N - J, -ONE, A (J + 1, J)'Address, 1, A (J, J + 1)'Address, LDA, A (J + 1, J + 1)'Address, LDA);
         end if;
      end loop;
      return;
      --
      --     End of ZGETF2
      --
   end ZGETF2;

   procedure ZGETRF
     (M    : Integer;
      N    : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer;
      IPIV : in out Ftn_Integer_Vector;
      INFO : in out Integer)
   is
      ONE   : constant Complex := (1.0e0, 0.0e0);
      I     : Integer;
      IINFO : Integer;
      J     : Integer;
      JB    : Integer;
      NB    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGETRF( M, N, A, LDA, IPIV, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       Complex*16   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGETRF computes an LU factorization of a general M-by-N matrix A
   --  using partial pivoting with row interchanges.
   --
   --  The factorization has the form
   --     A = P * L * U
   --  where P is a permutation matrix, L is lower triangular with unit
   --  diagonal elements (lower trapezoidal if m > n), and U is upper
   --  triangular (upper trapezoidal if m < n).
   --
   --  This is the right-looking Level 3 BLAS version of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is Complex*16 array, dimension (LDA,N)
   --           On entry, the M-by-N matrix to be factored.
   --           On exit, the factors L and U from the factorization
   --           A = P*L*U; the unit diagonal elements of L are not stored.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (min(M,N))
   --           The pivot indices; for 1 <= i <= min(M,N), row i of the
   --           matrix was interchanged with row IPIV(i).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
   --                 has been completed, but the factor U is exactly
   --                 singular, and division by zero will occur if it is used
   --                 to solve a system of equations.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZGEMM, ZGETF2, ZLASWP, ZTRSM, XERBLA
   --     ..
   --     .. External Functions ..
   --      INTEGER            ILAENV
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, M) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGETRF", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      --     Determine the block size for this environment.
      --
      NB := ILAENV (1, "ZGETRF", " ", M, N, -1, -1);
      if NB <= 1 or NB >= min (M, N) then
         --
         --        Use unblocked code.
         --
         ZGETF2 (M, N, A'Address, LDA, IPIV'Address, INFO);
      else
         --
         --        Use blocked code.
         --
         J := 1 - NB;
         loop
            J := J + NB;
            exit when J > min (M, N);
            JB := min (min (M, N) - J + 1, NB);
            --
            --           Factor diagonal and subdiagonal blocks and test for exact
            --           singularity.
            --
            ZGETF2 (M - J + 1, JB, A (J, J)'Address, LDA, IPIV (J)'Address, IINFO);
            --
            --           Adjust INFO and the pivot indices.
            --
            if INFO = 0 and IINFO > 0 then
               INFO := IINFO + J - 1;
            end if;
            I := J - 1;
            loop
               I := I + 1;
               exit when I > min (M, J + JB - 1);
               IPIV (I) := J - 1 + IPIV (I);
            end loop;
            --
            --           Apply interchanges to columns 1:J-1.
            --
            ZLASWP (J - 1, A'Address, LDA, J, J + JB - 1, IPIV'Address, 1);
            --
            if J + JB <= N then
               --
               --              Apply interchanges to columns J+JB:N.
               --
               ZLASWP (N - J - JB + 1, A (1, J + JB)'Address, LDA, J, J + JB - 1, IPIV'Address, 1);
               --
               --              Compute block row of U.
               --
               ZTRSM ('L', 'L', 'N', 'U', JB, N - J - JB + 1, ONE, A (J, J)'Address, LDA, A (J, J + JB)'Address, LDA);
               if J + JB <= M then
                  --
                  --                 Update trailing submatrix.
                  --
                  ZGEMM
                    ('N',
                     'N',
                     M - J - JB + 1,
                     N - J - JB + 1,
                     JB,
                     -ONE,
                     A (J + JB, J)'Address,
                     LDA,
                     A (J, J + JB)'Address,
                     LDA,
                     ONE,
                     A (J + JB, J + JB)'Address,
                     LDA);
               end if;
            end if;
         end loop;
      end if;
      return;
      --
      --     End of ZGETRF
      --
   end ZGETRF;

   procedure ZGETRI
     (N     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      IPIV  : in out Ftn_Integer_Vector;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      ONE    : constant Complex := (1.0e0, 0.0e0);
      ZERO   : constant Complex := (0.0e0, 0.0e0);
      LQUERY : Boolean;
      I      : Integer;
      IWS    : Integer;
      J      : Integer;
      JB     : Integer;
      JJ     : Integer;
      JP     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NN     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       Complex*16   A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGETRI computes the inverse of a matrix using the LU factorization
   --  computed by ZGETRF.
   --
   --  This method inverts U and then computes inv(A) by solving the system
   --  inv(A)*L = inv(U) for inv(A).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is Complex*16 array, dimension (LDA,N)
   --           On entry, the factors L and U from the factorization
   --           A = P*L*U as computed by ZGETRF.
   --           On exit, if INFO = 0, the inverse of the original matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           The pivot indices from ZGETRF; for 1<=i<=N, row i of the
   --           matrix was interchanged with row IPIV(i).
   --
   --  [out] WORK
   --           WORK is Complex*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= max(1,N).
   --           For optimal performance LWORK >= N*NB, where NB is
   --           the optimal blocksize returned by ILAENV.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
   --                 singular and its inverse could not be computed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZGEMM, ZGEMV, ZSWAP, ZTRSM, ZTRTRI, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "ZGETRI", " ", N, -1, -1, -1);
      LWKOPT   := N * NB;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      LQUERY   := (LWORK = -1);
      if N < 0 then
         INFO := -1;
      elsif LDA < max (1, N) then
         INFO := -3;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -6;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGETRI", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     Form inv(U).  If INFO > 0 from ZTRTRI, then U is singular,
      --     and the inverse is not computed.
      --
      ZTRTRI ('U', 'N', N, A, LDA, INFO);
      if INFO > 0 then
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := N;
      if NB > 1 and NB < N then
         IWS := max (LDWORK * NB, 1);
         if LWORK < IWS then
            NB    := LWORK / LDWORK;
            NBMIN := max (2, ILAENV (2, "ZGETRI", " ", N, -1, -1, -1));
         end if;
      else
         IWS := N;
      end if;
      --
      --     Solve the equation inv(A)*L = inv(U) for inv(A).
      --
      if NB < NBMIN or NB >= N then
         --
         --        Use unblocked code.
         --
         J := N + 1;
         loop
            J := J - 1;
            exit when J < 1;
            --
            --           Copy current column of L to WORK and replace with zeros.
            --
            I := J + 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               WORK (I) := A (I, J);
               A (I, J) := ZERO;
            end loop;
            --
            --           Compute current column of inv(A).
            --
            if J < N then
               ZGEMV ('N', N, N - J, -ONE, A (1, J + 1)'Address, LDA, WORK (J + 1)'Address, 1, ONE, A (1, J)'Address, 1);
            end if;
         end loop;
      else
         --
         --        Use blocked code.
         --
         NN := ((N - 1) / NB) * NB + 1;
         J  := NN + 1;
         loop
            J := J - 1;
            exit when J < 1;
            JB := min (NB, N - J + 1);
            --
            --           Copy current block column of L to WORK and replace with
            --           zeros.
            --
            JJ := J - 1;
            loop
               JJ := JJ + 1;
               exit when JJ > J + JB - 1;
               I := JJ + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  WORK (I + (JJ - J) * LDWORK)   := A (I, JJ);
                  A (I, JJ)                      := ZERO;
               end loop;
            end loop;
            --
            --           Compute current block column of inv(A).
            --
            if J + JB <= N then
               ZGEMM
                 ('N',
                  'N',
                  N,
                  JB,
                  N - J - JB + 1,
                  -ONE,
                  A (1, J + JB)'Address,
                  LDA,
                  WORK (J + JB)'Address,
                  LDWORK,
                  ONE,
                  A (1, J)'Address,
                  LDA);
            end if;
            ZTRSM ('R', 'L', 'N', 'U', N, JB, ONE, WORK (J)'Address, LDWORK, A (1, J)'Address, LDA);
         end loop;
      end if;
      --
      --     Apply column interchanges.
      --
      J := N - 1 + 1;
      loop
         J := J - 1;
         exit when J < 1;
         JP := IPIV (J);
         if JP /= J then
            ZSWAP (N, A (1, J)'Address, 1, A (1, JP)'Address, 1);
         end if;
      end loop;
      --
      WORK (1) := Complex'(Real (IWS), 0.0e0);
      return;
      --
      --     End of ZGETRI
      --
   end ZGETRI;

   procedure ZGETRS
     (TRANS : Character;
      N     : Integer;
      NRHS  : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      IPIV  : in out Ftn_Integer_Vector;
      B     : in out Ftn_Complex_Matrix;
      LDB   : Integer;
      INFO  : in out Integer)
   is
      ONE    : constant Complex := (1.0e0, 0.0e0);
      NOTRAN : Boolean;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          TRANS
   --       INTEGER            INFO, LDA, LDB, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       Complex*16   A( LDA, * ), B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZGETRS solves a system of linear equations
   --     A * X = B,  A**T * X = B,  or  A**H * X = B
   --  with a general N-by-N matrix A using the LU factorization computed
   --  by ZGETRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           Specifies the form of the system of equations:
   --           = 'N':  A * X = B     (No transpose)
   --           = 'T':  A**T * X = B  (Transpose)
   --           = 'C':  A**T * X = B  (Conjugate transpose)
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in] A
   --           A is Complex*16 array, dimension (LDA,N)
   --           The factors L and U from the factorization A = P*L*U
   --           as computed by ZGETRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           The pivot indices from ZGETRF; for 1<=i<=N, row i of the
   --           matrix was interchanged with row IPIV(i).
   --
   --  [in,out] B
   --           B is Complex*16 array, dimension (LDB,NRHS)
   --           On entry, the right hand side matrix B.
   --           On exit, the solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      LOGICAL            LSAME
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZLASWP, ZTRSM, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      NOTRAN := LSAME (TRANS, 'N');
      if not NOTRAN and not LSAME (TRANS, 'T') and not LSAME (TRANS, 'C') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NRHS < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDB < max (1, N) then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZGETRS", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 or NRHS = 0 then
         return;
      end if;
      --
      if NOTRAN then
         --
         --        Solve A * X = B.
         --
         --        Apply row interchanges to the right hand sides.
         --
         ZLASWP (NRHS, B'Address, LDB, 1, N, IPIV'Address, 1);
         --
         --        Solve L*X = B, overwriting B with X.
         --
         ZTRSM ('L', 'L', 'N', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --        Solve U*X = B, overwriting B with X.
         --
         ZTRSM ('L', 'U', 'N', 'N', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
      else
         --
         --        Solve A**T * X = B  or A**H * X = B.
         --
         --        Solve U**T *X = B or U**H *X = B, overwriting B with X.
         --
         ZTRSM ('L', 'U', 'T', 'N', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --        Solve L**T *X = B, or L**H *X = B overwriting B with X.
         --
         ZTRSM ('L', 'L', 'T', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --        Apply row interchanges to the solution vectors.
         --
         ZLASWP (NRHS, B'Address, LDB, 1, N, IPIV'Address, -1);
      end if;
      --
      return;
      --
      --     End of ZGETRS
      --
   end ZGETRS;

   procedure ZHEEV
     (JOBZ  : Character;
      UPLO  : Character;
      N     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      W     : in out Ftn_Real_Vector;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      RWORK : out Ftn_Real_Vector;
      INFO  : in out Integer)
   is
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      CONE   : constant Complex := (1.0, 0.0);
      LOWER  : Boolean;
      LQUERY : Boolean;
      WANTZ  : Boolean;
      IINFO  : Integer;
      IMAX   : Integer;
      INDE   : Integer;
      INDTAU : Integer;
      INDWRK : Integer;
      ISCALE : Integer;
      LLWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      ANRM   : Real;
      BIGNUM : Real;
      EPS    : Real;
      RMAX   : Real;
      RMIN   : Real;
      SAFMIN : Real;
      SIGMA  : Real;
      SMLNUM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZHEEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK,
   --                         INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBZ, UPLO
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   RWORK( * ), W( * )
   --       COMPLEX*16         A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZHEEV computes all eigenvalues and, optionally, eigenvectors of a
   --  complex Hermitian matrix A.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBZ
   --           JOBZ is CHARACTER*1
   --           = 'N':  Compute eigenvalues only;
   --           = 'V':  Compute eigenvalues and eigenvectors.
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA, N)
   --           On entry, the Hermitian matrix A.  If UPLO = 'U', the
   --           leading N-by-N upper triangular part of A contains the
   --           upper triangular part of the matrix A.  If UPLO = 'L',
   --           the leading N-by-N lower triangular part of A contains
   --           the lower triangular part of the matrix A.
   --           On exit, if JOBZ = 'V', then if INFO = 0, A contains the
   --           orthonormal eigenvectors of the matrix A.
   --           If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
   --           or the upper triangle (if UPLO='U') of A, including the
   --           diagonal, is destroyed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (N)
   --           If INFO = 0, the eigenvalues in ascending order.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of the array WORK.  LWORK >= max(1,2*N-1).
   --           For optimal efficiency, LWORK >= (NB+1)*N,
   --           where NB is the blocksize for ZHETRD returned by ILAENV.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array, dimension (max(1, 3*N-2))
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, the algorithm failed to converge; i
   --                 off-diagonal elements of an intermediate tridiagonal
   --                 form did not converge to zero.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --      PARAMETER          ( CONE = ( 1.0D0, 0.0D0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, ZLANHE
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DSCAL, DSTERF, XERBLA, ZHETRD, ZLASCL, ZSTEQR, ZUNGTR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      WANTZ  := LSAME (JOBZ, 'V');
      LOWER  := LSAME (UPLO, 'L');
      LQUERY := (LWORK = -1);
      --
      INFO := 0;
      if not (WANTZ or LSAME (JOBZ, 'N')) then
         INFO := -1;
      elsif not (LOWER or LSAME (UPLO, 'U')) then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      --
      if INFO = 0 then
         declare
            str_UPLO : String (1 .. 1);
         begin
            str_UPLO (1) := UPLO;
            NB           := ILAENV (1, "ZHETRD", str_UPLO, N, -1, -1, -1);
         end;
         LWKOPT   := max (1, (NB + 1) * N);
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
         --
         if LWORK < max (1, 2 * N - 1) and not LQUERY then
            INFO := -8;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZHEEV ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      if N = 1 then
         W (1)    := real_part (A (1, 1));
         WORK (1) := Complex'(1.0, 0.0);
         if WANTZ then
            A (1, 1) := CONE;
         end if;
         return;
      end if;
      --
      --     Get machine constants.
      --
      SAFMIN := DLAMCH ('S');
      EPS    := DLAMCH ('P');
      SMLNUM := SAFMIN / EPS;
      BIGNUM := ONE / SMLNUM;
      RMIN   := Sqrt (SMLNUM);
      RMAX   := Sqrt (BIGNUM);
      --
      --     Scale matrix to allowable range, if necessary.
      --
      ANRM   := ZLANHE ('M', UPLO, N, A, LDA, RWORK);
      ISCALE := 0;
      if ANRM > ZERO and ANRM < RMIN then
         ISCALE := 1;
         SIGMA  := RMIN / ANRM;
      elsif ANRM > RMAX then
         ISCALE := 1;
         SIGMA  := RMAX / ANRM;
      end if;
      if ISCALE = 1 then
         ZLASCL (UPLO, 0, 0, ONE, SIGMA, N, N, A'Address, LDA, INFO);
      end if;
      --
      --     Call ZHETRD to reduce Hermitian matrix to tridiagonal form.
      --
      INDE   := 1;
      INDTAU := 1;
      INDWRK := INDTAU + N;
      LLWORK := LWORK - INDWRK + 1;
      ZHETRD
        (UPLO,
         N,
         A'Address,
         LDA,
         W'Address,
         RWORK (INDE)'Address,
         WORK (INDTAU)'Address,
         WORK (INDWRK)'Address,
         LLWORK,
         IINFO);
      --
      --     For eigenvalues only, call DSTERF.  For eigenvectors, first call
      --     ZUNGTR to generate the unitary matrix, then call ZSTEQR.
      --
      if not WANTZ then
         DSTERF (N, W'Address, RWORK (INDE)'Address, INFO);
      else
         ZUNGTR (UPLO, N, A'Address, LDA, WORK (INDTAU)'Address, WORK (INDWRK)'Address, LLWORK, IINFO);
         INDWRK := INDE + N;
         ZSTEQR (JOBZ, N, W'Address, RWORK (INDE)'Address, A'Address, LDA, RWORK (INDWRK)'Address, INFO);
      end if;
      --
      --     If matrix was scaled, then rescale eigenvalues appropriately.
      --
      if ISCALE = 1 then
         if INFO = 0 
            then IMAX := N;
            else IMAX := INFO - 1;
         end if;
         DSCAL (IMAX, ONE / SIGMA, W'Address, 1);
      end if;
      --
      --     Set WORK(1) to optimal complex workspace size.
      --
      WORK (1) := Complex'(Real (LWKOPT), 0.0);
      --
      return;
      --
      --     End of ZHEEV
      --
   end ZHEEV;

   procedure ZHEEVD
     (JOBZ   : Character;
      UPLO   : Character;
      N      : Integer;
      A      : in out Ftn_Complex_Matrix;
      LDA    : Integer;
      W      : in out Ftn_Real_Vector;
      WORK   : in out Ftn_Complex_Vector;
      LWORK  : Integer;
      RWORK  : in out Ftn_Real_Vector;
      LRWORK : Integer;
      IWORK  : in out Ftn_Integer_Vector;
      LIWORK : Integer;
      INFO   : in out Integer)
   is
      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      CONE   : constant Complex := (1.0, 0.0);
      LOWER  : Boolean;
      LQUERY : Boolean;
      WANTZ  : Boolean;
      IINFO  : Integer;
      IMAX   : Integer;
      INDE   : Integer;
      INDRWK : Integer;
      INDTAU : Integer;
      INDWK2 : Integer;
      INDWRK : Integer;
      ISCALE : Integer;
      LIOPT  : Integer;
      LIWMIN : Integer;
      LLRWK  : Integer;
      LLWORK : Integer;
      LLWRK2 : Integer;
      LOPT   : Integer;
      LROPT  : Integer;
      LRWMIN : Integer;
      LWMIN  : Integer;
      ANRM   : Real;
      BIGNUM : Real;
      EPS    : Real;
      RMAX   : Real;
      RMIN   : Real;
      SAFMIN : Real;
      SIGMA  : Real;
      SMLNUM : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZHEEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK,
   --                          LRWORK, IWORK, LIWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          JOBZ, UPLO
   --       INTEGER            INFO, LDA, LIWORK, LRWORK, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   RWORK( * ), W( * )
   --       COMPLEX*16         A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZHEEVD computes all eigenvalues and, optionally, eigenvectors of a
   --  complex Hermitian matrix A.  If eigenvectors are desired, it uses a
   --  divide and conquer algorithm.
   --
   --  The divide and conquer algorithm makes very mild assumptions about
   --  floating point arithmetic. It will work on machines with a guard
   --  digit in add/subtract, or on those binary machines without guard
   --  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
   --  Cray-2. It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOBZ
   --           JOBZ is CHARACTER*1
   --           = 'N':  Compute eigenvalues only;
   --           = 'V':  Compute eigenvalues and eigenvectors.
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA, N)
   --           On entry, the Hermitian matrix A.  If UPLO = 'U', the
   --           leading N-by-N upper triangular part of A contains the
   --           upper triangular part of the matrix A.  If UPLO = 'L',
   --           the leading N-by-N lower triangular part of A contains
   --           the lower triangular part of the matrix A.
   --           On exit, if JOBZ = 'V', then if INFO = 0, A contains the
   --           orthonormal eigenvectors of the matrix A.
   --           If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
   --           or the upper triangle (if UPLO='U') of A, including the
   --           diagonal, is destroyed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (N)
   --           If INFO = 0, the eigenvalues in ascending order.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of the array WORK.
   --           If N <= 1,                LWORK must be at least 1.
   --           If JOBZ  = 'N' and N > 1, LWORK must be at least N + 1.
   --           If JOBZ  = 'V' and N > 1, LWORK must be at least 2*N + N**2.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal sizes of the WORK, RWORK and
   --           IWORK arrays, returns these values as the first entries of
   --           the WORK, RWORK and IWORK arrays, and no error message
   --           related to LWORK or LRWORK or LIWORK is issued by XERBLA.
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array,
   --                                          dimension (LRWORK)
   --           On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
   --
   --  [in] LRWORK
   --           LRWORK is INTEGER
   --           The dimension of the array RWORK.
   --           If N <= 1,                LRWORK must be at least 1.
   --           If JOBZ  = 'N' and N > 1, LRWORK must be at least N.
   --           If JOBZ  = 'V' and N > 1, LRWORK must be at least
   --                          1 + 5*N + 2*N**2.
   --
   --           If LRWORK = -1, then a workspace query is assumed; the
   --           routine only calculates the optimal sizes of the WORK, RWORK
   --           and IWORK arrays, returns these values as the first entries
   --           of the WORK, RWORK and IWORK arrays, and no error message
   --           related to LWORK or LRWORK or LIWORK is issued by XERBLA.
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (MAX(1,LIWORK))
   --           On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
   --
   --  [in] LIWORK
   --           LIWORK is INTEGER
   --           The dimension of the array IWORK.
   --           If N <= 1,                LIWORK must be at least 1.
   --           If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
   --           If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
   --
   --           If LIWORK = -1, then a workspace query is assumed; the
   --           routine only calculates the optimal sizes of the WORK, RWORK
   --           and IWORK arrays, returns these values as the first entries
   --           of the WORK, RWORK and IWORK arrays, and no error message
   --           related to LWORK or LRWORK or LIWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
   --                 to converge; i off-diagonal elements of an intermediate
   --                 tridiagonal form did not converge to zero;
   --                 if INFO = i and JOBZ = 'V', then the algorithm failed
   --                 to compute an eigenvalue while working on the submatrix
   --                 lying in rows and columns INFO/(N+1) through
   --                 mod(INFO,N+1).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --   Modified description of INFO. Sven, 16 Feb 05.
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --      PARAMETER          ( CONE = ( 1.0D0, 0.0D0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, ZLANHE
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DSCAL, DSTERF, XERBLA, ZHETRD, ZLACPY, ZLASCL, ZSTEDC, ZUNMTR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      WANTZ  := LSAME (JOBZ, 'V');
      LOWER  := LSAME (UPLO, 'L');
      LQUERY := (LWORK = -1 or LRWORK = -1 or LIWORK = -1);
      --
      INFO := 0;
      if not (WANTZ or LSAME (JOBZ, 'N')) then
         INFO := -1;
      elsif not (LOWER or LSAME (UPLO, 'U')) then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      --
      if INFO = 0 then
         if N <= 1 then
            LWMIN  := 1;
            LRWMIN := 1;
            LIWMIN := 1;
            LOPT   := LWMIN;
            LROPT  := LRWMIN;
            LIOPT  := LIWMIN;
         else
            if WANTZ then
               LWMIN  := 2 * N + N * N;
               LRWMIN := 1 + 5 * N + 2 * N ** 2;
               LIWMIN := 3 + 5 * N;
            else
               LWMIN  := N + 1;
               LRWMIN := N;
               LIWMIN := 1;
            end if;
            declare
               str_UPLO : String (1 .. 1);
            begin
               str_UPLO (1) := UPLO;
               LOPT         := max (LWMIN, N + ILAENV (1, "ZHETRD", str_UPLO, N, -1, -1, -1));
            end;
            LROPT := LRWMIN;
            LIOPT := LIWMIN;
         end if;
         WORK (1)  := Complex'(Real (LOPT), 0.0);
         RWORK (1) := Real (LROPT);
         IWORK (1) := LIOPT;
         --
         if LWORK < LWMIN and not LQUERY then
            INFO := -8;
         elsif LRWORK < LRWMIN and not LQUERY then
            INFO := -10;
         elsif LIWORK < LIWMIN and not LQUERY then
            INFO := -12;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZHEEVD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      if N = 1 then
         W (1) := real_part (A (1, 1));
         if WANTZ then
            A (1, 1) := CONE;
         end if;
         return;
      end if;
      --
      --     Get machine constants.
      --
      SAFMIN := DLAMCH ('S');
      EPS    := DLAMCH ('P');
      SMLNUM := SAFMIN / EPS;
      BIGNUM := ONE / SMLNUM;
      RMIN   := Sqrt (SMLNUM);
      RMAX   := Sqrt (BIGNUM);
      --
      --     Scale matrix to allowable range, if necessary.
      --
      ANRM   := ZLANHE ('M', UPLO, N, A, LDA, RWORK);
      ISCALE := 0;
      if ANRM > ZERO and ANRM < RMIN then
         ISCALE := 1;
         SIGMA  := RMIN / ANRM;
      elsif ANRM > RMAX then
         ISCALE := 1;
         SIGMA  := RMAX / ANRM;
      end if;
      if ISCALE = 1 then
         ZLASCL (UPLO, 0, 0, ONE, SIGMA, N, N, A'Address, LDA, INFO);
      end if;
      --
      --     Call ZHETRD to reduce Hermitian matrix to tridiagonal form.
      --
      INDE   := 1;
      INDTAU := 1;
      INDWRK := INDTAU + N;
      INDRWK := INDE + N;
      INDWK2 := INDWRK + N * N;
      LLWORK := LWORK - INDWRK + 1;
      LLWRK2 := LWORK - INDWK2 + 1;
      LLRWK  := LRWORK - INDRWK + 1;
      ZHETRD
        (UPLO,
         N,
         A'Address,
         LDA,
         W'Address,
         RWORK (INDE)'Address,
         WORK (INDTAU)'Address,
         WORK (INDWRK)'Address,
         LLWORK,
         IINFO);
      --
      --     For eigenvalues only, call DSTERF.  For eigenvectors, first call
      --     ZSTEDC to generate the eigenvector matrix, WORK(INDWRK), of the
      --     tridiagonal matrix, then call ZUNMTR to multiply it to the
      --     Householder transformations represented as Householder vectors in
      --     A.
      --
      if not WANTZ then
         DSTERF (N, W'Address, RWORK (INDE)'Address, INFO);
      else
         ZSTEDC
           ('I',
            N,
            W'Address,
            RWORK (INDE)'Address,
            WORK (INDWRK)'Address,
            N,
            WORK (INDWK2)'Address,
            LLWRK2,
            RWORK (INDRWK)'Address,
            LLRWK,
            IWORK'Address,
            LIWORK,
            INFO);
         ZUNMTR
           ('L',
            UPLO,
            'N',
            N,
            N,
            A'Address,
            LDA,
            WORK (INDTAU)'Address,
            WORK (INDWRK)'Address,
            N,
            WORK (INDWK2)'Address,
            LLWRK2,
            IINFO);
         ZLACPY ('A', N, N, WORK (INDWRK)'Address, N, A'Address, LDA);
      end if;
      --
      --     If matrix was scaled, then rescale eigenvalues appropriately.
      --
      if ISCALE = 1 then
         if INFO = 0 
            then IMAX := N;
            else IMAX := INFO - 1;
         end if;
         DSCAL (IMAX, ONE / SIGMA, W'Address, 1);
      end if;
      --
      WORK (1)  := Complex'(Real (LOPT), 0.0);
      RWORK (1) := Real (LROPT);
      IWORK (1) := LIOPT;
      --
      return;
      --
      --     End of ZHEEVD
      --
   end ZHEEVD;

   procedure ZHETD2
     (UPLO    : Character;
      N       : Integer;
      A_adr   : Address;
      LDA     : Integer;
      D_adr   : Address;
      E_adr   : Address;
      TAU_adr : Address;
      INFO    : in out Integer)
   is

      A   : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      D   : Ftn_Real_Vector (1 .. N);
      E   : Ftn_Real_Vector (1 .. N - 1);
      TAU : Ftn_Complex_Vector (1 .. N - 1);

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAU'Address use TAU_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAU);

      ONE   : constant Complex := (1.0, 0.0);
      ZERO  : constant Complex := (0.0, 0.0);
      HALF  : constant Complex := (0.5, 0.0);
      UPPER : Boolean;
      I     : Integer;
      ALPHA : Complex;
      TAUI  : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZHETD2( UPLO, N, A, LDA, D, E, TAU, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * )
   --       COMPLEX*16         A( LDA, * ), TAU( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZHETD2 reduces a complex Hermitian matrix A to real symmetric
   --  tridiagonal form T by a unitary similarity transformation:
   --  Q**H * A * Q = T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the upper or lower triangular part of the
   --           Hermitian matrix A is stored:
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
   --           n-by-n upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n-by-n lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --           On exit, if UPLO = 'U', the diagonal and first superdiagonal
   --           of A are overwritten by the corresponding elements of the
   --           tridiagonal matrix T, and the elements above the first
   --           superdiagonal, with the array TAU, represent the unitary
   --           matrix Q as a product of elementary reflectors; if UPLO
   --           = 'L', the diagonal and first subdiagonal of A are over-
   --           written by the corresponding elements of the tridiagonal
   --           matrix T, and the elements below the first subdiagonal, with
   --           the array TAU, represent the unitary matrix Q as a product
   --           of elementary reflectors. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           The diagonal elements of the tridiagonal matrix T:
   --           D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           The off-diagonal elements of the tridiagonal matrix T:
   --           E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (N-1)
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(n-1) . . . H(2) H(1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
   --   A(1:i-1,i+1), and tau in TAU(i).
   --
   --   If UPLO = 'L', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(1) H(2) . . . H(n-1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
   --   and tau in TAU(i).
   --
   --   The contents of A on exit are illustrated by the following examples
   --   with n = 5:
   --
   --   if UPLO = 'U':                       if UPLO = 'L':
   --
   --     (  d   e   v2  v3  v4 )              (  d                  )
   --     (      d   e   v3  v4 )              (  e   d              )
   --     (          d   e   v4 )              (  v1  e   d          )
   --     (              d   e  )              (  v1  v2  e   d      )
   --     (                  d  )              (  v1  v2  v3  e   d  )
   --
   --   where d and e denote diagonal and off-diagonal elements of T, and vi
   --   denotes an element of the vector defining H(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ), ZERO = ( 0.0D+0, 0.0D+0 ), HALF = ( 0.5D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZAXPY, ZHEMV, ZHER2, ZLARFG
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ZDOTC
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO  := 0;
      UPPER := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("ZHETD2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         return;
      end if;
      --
      if UPPER then
         --
         --        Reduce the upper triangle of A
         --
         A (N, N) := Pure_Real (A (N, N));
         I        := N - 1 + 1;
         loop
            I := I - 1;
            exit when I < 1;
            --
            --           Generate elementary reflector H(i) = I - tau * v * v**H
            --           to annihilate A(1:i-1,i+1)
            --
            ALPHA := A (I, I + 1);
            ZLARFG (I, ALPHA, A (1, I + 1)'Address, 1, TAUI);
            E (I) := real_part (ALPHA);
            --
            if TAUI /= ZERO then
               --
               --              Apply H(i) from both sides to A(1:i,1:i)
               --
               A (I, I + 1) := ONE;
               --
               --              Compute  x := tau * A * v  storing x in TAU(1:i)
               --
               ZHEMV (UPLO, I, TAUI, A'Address, LDA, A (1, I + 1)'Address, 1, ZERO, TAU'Address, 1);
               --
               --              Compute  w := x - 1/2 * tau * (x**H * v) * v
               --
               ALPHA := -HALF * TAUI * ZDOTC (I, TAU'Address, 1, A (1, I + 1)'Address, 1);
               ZAXPY (I, ALPHA, A (1, I + 1)'Address, 1, TAU'Address, 1);
               --
               --              Apply the transformation as a rank-2 update:
               --                 A := A - v * w**H - w * v**H
               --
               ZHER2 (UPLO, I, -ONE, A (1, I + 1)'Address, 1, TAU'Address, 1, A'Address, LDA);
            --
            else
               A (I, I) := Pure_Real (A (I, I));
            end if;
            A (I, I + 1) := Complex'(E (I), 0.0);
            D (I + 1)    := real_part (A (I + 1, I + 1));
            TAU (I)      := TAUI;
         end loop;
         D (1) := real_part (A (1, 1));
      else
         --
         --        Reduce the lower triangle of A
         --
         A (1, 1) := Pure_Real (A (1, 1));
         I        := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            --
            --           Generate elementary reflector H(i) = I - tau * v * v**H
            --           to annihilate A(i+2:n,i)
            --
            ALPHA := A (I + 1, I);
            ZLARFG (N - I, ALPHA, A (min (I + 2, N), I)'Address, 1, TAUI);
            E (I) := real_part (ALPHA);
            --
            if TAUI /= ZERO then
               --
               --              Apply H(i) from both sides to A(i+1:n,i+1:n)
               --
               A (I + 1, I) := ONE;
               --
               --              Compute  x := tau * A * v  storing y in TAU(i:n-1)
               --
               ZHEMV (UPLO, N - I, TAUI, A (I + 1, I + 1)'Address, LDA, A (I + 1, I)'Address, 1, ZERO, TAU (I)'Address, 1);
               --
               --              Compute  w := x - 1/2 * tau * (x**H * v) * v
               --
               ALPHA := -HALF * TAUI * ZDOTC (N - I, TAU (I)'Address, 1, A (I + 1, I)'Address, 1);
               ZAXPY (N - I, ALPHA, A (I + 1, I)'Address, 1, TAU (I)'Address, 1);
               --
               --              Apply the transformation as a rank-2 update:
               --                 A := A - v * w**H - w * v**H
               --
               ZHER2 (UPLO, N - I, -ONE, A (I + 1, I)'Address, 1, TAU (I)'Address, 1, A (I + 1, I + 1)'Address, LDA);
            --
            else
               A (I + 1, I + 1) := Pure_Real (A (I + 1, I + 1));
            end if;
            A (I + 1, I) := Complex'(E (I), 0.0);
            D (I)        := real_part (A (I, I));
            TAU (I)      := TAUI;
         end loop;
         D (N) := real_part (A (N, N));
      end if;
      --
      return;
      --
      --     End of ZHETD2
      --
   end ZHETD2;

   procedure ZHETRD
     (UPLO     : Character;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      D    : Ftn_Real_Vector (1 .. N);
      E    : Ftn_Real_Vector (1 .. N - 1);
      TAU  : Ftn_Complex_Vector (1 .. N - 1);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE    : constant Real    := 1.0e0;
      CONE   : constant Complex := (1.0, 0.0);
      LQUERY : Boolean;
      UPPER  : Boolean;
      I      : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      KK     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZHETRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * )
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZHETRD reduces a complex Hermitian matrix A to real symmetric
   --  tridiagonal form T by a unitary similarity transformation:
   --  Q**H * A * Q = T.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
   --           N-by-N upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading N-by-N lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --           On exit, if UPLO = 'U', the diagonal and first superdiagonal
   --           of A are overwritten by the corresponding elements of the
   --           tridiagonal matrix T, and the elements above the first
   --           superdiagonal, with the array TAU, represent the unitary
   --           matrix Q as a product of elementary reflectors; if UPLO
   --           = 'L', the diagonal and first subdiagonal of A are over-
   --           written by the corresponding elements of the tridiagonal
   --           matrix T, and the elements below the first subdiagonal, with
   --           the array TAU, represent the unitary matrix Q as a product
   --           of elementary reflectors. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           The diagonal elements of the tridiagonal matrix T:
   --           D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           The off-diagonal elements of the tridiagonal matrix T:
   --           E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (N-1)
   --           The scalar factors of the elementary reflectors (see Further
   --           Details).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.  LWORK >= 1.
   --           For optimum performance LWORK >= N*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(n-1) . . . H(2) H(1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
   --   A(1:i-1,i+1), and tau in TAU(i).
   --
   --   If UPLO = 'L', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(1) H(2) . . . H(n-1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
   --   and tau in TAU(i).
   --
   --   The contents of A on exit are illustrated by the following examples
   --   with n = 5:
   --
   --   if UPLO = 'U':                       if UPLO = 'L':
   --
   --     (  d   e   v2  v3  v4 )              (  d                  )
   --     (      d   e   v3  v4 )              (  e   d              )
   --     (          d   e   v4 )              (  v1  e   d          )
   --     (              d   e  )              (  v1  v2  e   d      )
   --     (                  d  )              (  v1  v2  v3  e   d  )
   --
   --   where d and e denote diagonal and off-diagonal elements of T, and vi
   --   denotes an element of the vector defining H(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --      PARAMETER          ( CONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZHER2K, ZHETD2, ZLATRD
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      LQUERY := (LWORK = -1);
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      elsif LWORK < 1 and not LQUERY then
         INFO := -9;
      end if;
      --
      if INFO = 0 then
         --
         --        Determine the block size.
         --
         declare
            str_UPLO : String (1 .. 1);
         begin
            str_UPLO (1) := UPLO;
            NB           := ILAENV (1, "ZHETRD", str_UPLO, N, -1, -1, -1);
         end;
         LWKOPT   := N * NB;
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZHETRD", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         WORK (1) := Complex'(1.0, 0.0);
         return;
      end if;
      --
      NX  := N;
      IWS := 1;
      if NB > 1 and NB < N then
         --
         --        Determine when to cross over from blocked to unblocked code
         --        (last block is always handled by unblocked code).
         --
         declare
            str_UPLO : String (1 .. 1);
         begin
            str_UPLO (1) := UPLO;
            NX           := max (NB, ILAENV (3, "ZHETRD", str_UPLO, N, -1, -1, -1));
         end;
         if NX < N then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := N;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  determine the
               --              minimum value of NB, and reduce NB or force use of
               --              unblocked code by setting NX = N.
               --
               NB := max (LWORK / LDWORK, 1);
               declare
                  str_UPLO : String (1 .. 1);
               begin
                  str_UPLO (1) := UPLO;
                  NBMIN        := ILAENV (2, "ZHETRD", str_UPLO, N, -1, -1, -1);
               end;
               if NB < NBMIN then
                  NX := N;
               end if;
            end if;
         else
            NX := N;
         end if;
      else
         NB := 1;
      end if;
      --
      if UPPER then
         --
         --        Reduce the upper triangle of A.
         --        Columns 1:kk are handled by the unblocked method.
         --
         KK := N - ((N - NX + NB - 1) / NB) * NB;
         I  := N - NB + 1 + NB;
         loop
            I := I - NB;
            exit when I < KK + 1;
            --
            --           Reduce columns i:i+nb-1 to tridiagonal form and form the
            --           matrix W which is needed to update the unreduced part of
            --           the matrix
            --
            ZLATRD (UPLO, I + NB - 1, NB, A'Address, LDA, E'Address, TAU'Address, WORK'Address, LDWORK);
            --
            --           Update the unreduced submatrix A(1:i-1,1:i-1), using an
            --           update of the form:  A := A - V*W**H - W*V**H
            --
            ZHER2K (UPLO, 'N', I - 1, NB, -CONE, A (1, I)'Address, LDA, WORK'Address, LDWORK, ONE, A'Address, LDA);
            --
            --           Copy superdiagonal elements back into A, and diagonal
            --           elements into D
            --
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + NB - 1;
               A (J - 1, J) := Complex'(E (J - 1), 0.0);
               D (J)        := real_part (A (J, J));
            end loop;
         end loop;
         --
         --        Use unblocked code to reduce the last or only block
         --
         ZHETD2 (UPLO, KK, A'Address, LDA, D'Address, E'Address, TAU'Address, IINFO);
      else
         --
         --        Reduce the lower triangle of A
         --
         I := 1 - NB;
         loop
            I := I + NB;
            exit when I > N - NX;
            --
            --           Reduce columns i:i+nb-1 to tridiagonal form and form the
            --           matrix W which is needed to update the unreduced part of
            --           the matrix
            --
            ZLATRD (UPLO, N - I + 1, NB, A (I, I)'Address, LDA, E (I)'Address, TAU (I)'Address, WORK'Address, LDWORK);
            --
            --           Update the unreduced submatrix A(i+nb:n,i+nb:n), using
            --           an update of the form:  A := A - V*W**H - W*V**H
            --
            ZHER2K
              (UPLO,
               'N',
               N - I - NB + 1,
               NB,
               -CONE,
               A (I + NB, I)'Address,
               LDA,
               WORK (NB + 1)'Address,
               LDWORK,
               ONE,
               A (I + NB, I + NB)'Address,
               LDA);
            --
            --           Copy subdiagonal elements back into A, and diagonal
            --           elements into D
            --
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + NB - 1;
               A (J + 1, J) := Complex'(E (J), 0.0);
               D (J)        := real_part (A (J, J));
            end loop;
         end loop;
         --
         --        Use unblocked code to reduce the last or only block
         --
         ZHETD2 (UPLO, N - I + 1, A (I, I)'Address, LDA, D (I)'Address, E (I)'Address, TAU (I)'Address, IINFO);
      end if;
      --
      WORK (1) := Complex'(Real (LWKOPT), 0.0);
      return;
      --
      --     End of ZHETRD
      --
   end ZHETRD;

   procedure ZHSEQR
     (JOB      : Character;
      COMPZ    : Character;
      N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      H_adr    : Address;
      LDH      : Integer;
      W_adr    : Address;
      Z_adr    : Address;
      LDZ      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      H    : Ftn_Complex_Matrix (1 .. LDH, 1 .. N);
      W    : Ftn_Complex_Vector (1 .. N);
      Z    : Ftn_Complex_Matrix (1 .. LDZ, 1 .. N);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for H'Address use H_adr;
      for W'Address use W_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, W);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);

      NTINY  : constant Integer := 11;
      NL     : constant Integer := 49;
      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      RZERO  : constant Real    := 0.0e0;
      HL     : Ftn_Complex_Matrix (1 .. NL, 1 .. NL);
      WORKL  : Ftn_Complex_Vector (1 .. NL);
      KBOT   : Integer;
      NMIN   : Integer;
      INITZ  : Boolean;
      LQUERY : Boolean;
      WANTT  : Boolean;
      WANTZ  : Boolean;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZHSEQR( JOB, COMPZ, N, ILO, IHI, H, LDH, W, Z, LDZ,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, INFO, LDH, LDZ, LWORK, N
   --       CHARACTER          COMPZ, JOB
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         H( LDH, * ), W( * ), WORK( * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZHSEQR computes the eigenvalues of a Hessenberg matrix H
   --     and, optionally, the matrices T and Z from the Schur decomposition
   --     H = Z T Z**H, where T is an upper triangular matrix (the
   --     Schur form), and Z is the unitary matrix of Schur vectors.
   --
   --     Optionally Z may be postmultiplied into an input unitary
   --     matrix Q so that this routine can give the Schur factorization
   --     of a matrix A which has been reduced to the Hessenberg form H
   --     by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] JOB
   --           JOB is CHARACTER*1
   --            = 'E':  compute eigenvalues only;
   --            = 'S':  compute eigenvalues and the Schur form T.
   --
   --  [in] COMPZ
   --           COMPZ is CHARACTER*1
   --            = 'N':  no Schur vectors are computed;
   --            = 'I':  Z is initialized to the unit matrix and the matrix Z
   --                    of Schur vectors of H is returned;
   --            = 'V':  Z must contain an unitary matrix Q on entry, and
   --                    the product Q*Z is returned.
   --
   --  [in] N
   --           N is INTEGER
   --            The order of the matrix H.  N .GE. 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --            It is assumed that H is already upper triangular in rows
   --            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
   --            set by a previous call to ZGEBAL, and then passed to ZGEHRD
   --            when the matrix output by ZGEBAL is reduced to Hessenberg
   --            form. Otherwise ILO and IHI should be set to 1 and N
   --            respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
   --            If N = 0, then ILO = 1 and IHI = 0.
   --
   --  [in,out] H
   --           H is COMPLEX*16 array, dimension (LDH,N)
   --            On entry, the upper Hessenberg matrix H.
   --            On exit, if INFO = 0 and JOB = 'S', H contains the upper
   --            triangular matrix T from the Schur decomposition (the
   --            Schur form). If INFO = 0 and JOB = 'E', the contents of
   --            H are unspecified on exit.  (The output value of H when
   --            INFO.GT.0 is given under the description of INFO below.)
   --
   --            Unlike earlier versions of ZHSEQR, this subroutine may
   --            explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
   --            or j = IHI+1, IHI+2, ... N.
   --
   --  [in] LDH
   --           LDH is INTEGER
   --            The leading dimension of the array H. LDH .GE. max(1,N).
   --
   --  [out] W
   --           W is COMPLEX*16 array, dimension (N)
   --            The computed eigenvalues. If JOB = 'S', the eigenvalues are
   --            stored in the same order as on the diagonal of the Schur
   --            form returned in H, with W(i) = H(i,i).
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array, dimension (LDZ,N)
   --            If COMPZ = 'N', Z is not referenced.
   --            If COMPZ = 'I', on entry Z need not be set and on exit,
   --            if INFO = 0, Z contains the unitary matrix Z of the Schur
   --            vectors of H.  If COMPZ = 'V', on entry Z must contain an
   --            N-by-N matrix Q, which is assumed to be equal to the unit
   --            matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
   --            if INFO = 0, Z contains Q*Z.
   --            Normally Q is the unitary matrix generated by ZUNGHR
   --            after the call to ZGEHRD which formed the Hessenberg matrix
   --            H. (The output value of Z when INFO.GT.0 is given under
   --            the description of INFO below.)
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --            The leading dimension of the array Z.  if COMPZ = 'I' or
   --            COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (LWORK)
   --            On exit, if INFO = 0, WORK(1) returns an estimate of
   --            the optimal value for LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --            The dimension of the array WORK.  LWORK .GE. max(1,N)
   --            is sufficient and delivers very good and sometimes
   --            optimal performance.  However, LWORK as large as 11*N
   --            may be required for optimal performance.  A workspace
   --            query is recommended to determine the optimal workspace
   --            size.
   --
   --            If LWORK = -1, then ZHSEQR does a workspace query.
   --            In this case, ZHSEQR checks the input parameters and
   --            estimates the optimal workspace size for the given
   --            values of N, ILO and IHI.  The estimate is returned
   --            in WORK(1).  No error message related to LWORK is
   --            issued by XERBLA.  Neither H nor Z are accessed.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --              =  0:  successful exit
   --            .LT. 0:  if INFO = -i, the i-th argument had an illegal
   --                     value
   --            .GT. 0:  if INFO = i, ZHSEQR failed to compute all of
   --                 the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
   --                 and WI contain those eigenvalues which have been
   --                 successfully computed.  (Failures are rare.)
   --
   --                 If INFO .GT. 0 and JOB = 'E', then on exit, the
   --                 remaining unconverged eigenvalues are the eigen-
   --                 values of the upper Hessenberg matrix rows and
   --                 columns ILO through INFO of the final, output
   --                 value of H.
   --
   --                 If INFO .GT. 0 and JOB   = 'S', then on exit
   --
   --            (*)  (initial value of H)*U  = U*(final value of H)
   --
   --                 where U is a unitary matrix.  The final
   --                 value of  H is upper Hessenberg and triangular in
   --                 rows and columns INFO+1 through IHI.
   --
   --                 If INFO .GT. 0 and COMPZ = 'V', then on exit
   --
   --                   (final value of Z)  =  (initial value of Z)*U
   --
   --                 where U is the unitary matrix in (*) (regard-
   --                 less of the value of JOB.)
   --
   --                 If INFO .GT. 0 and COMPZ = 'I', then on exit
   --                       (final value of Z)  = U
   --                 where U is the unitary matrix in (*) (regard-
   --                 less of the value of JOB.)
   --
   --                 If INFO .GT. 0 and COMPZ = 'N', then Z is not
   --                 accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  Further Details:
   --  ================
   --
   --
   --              Default values supplied by
   --              ILAENV(ISPEC,'ZHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
   --              It is suggested that these defaults be adjusted in order
   --              to attain best performance in each particular
   --              computational environment.
   --
   --             ISPEC=12: The ZLAHQR vs ZLAQR0 crossover point.
   --                       Default: 75. (Must be at least 11.)
   --
   --             ISPEC=13: Recommended deflation window size.
   --                       This depends on ILO, IHI and NS.  NS is the
   --                       number of simultaneous shifts returned
   --                       by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
   --                       The default for (IHI-ILO+1).LE.500 is NS.
   --                       The default for (IHI-ILO+1).GT.500 is 3*NS/2.
   --
   --             ISPEC=14: Nibble crossover point. (See IPARMQ for
   --                       details.)  Default: 14% of deflation window
   --                       size.
   --
   --             ISPEC=15: Number of simultaneous shifts in a multishift
   --                       QR iteration.
   --
   --                       If IHI-ILO+1 is ...
   --
   --                       greater than      ...but less    ... the
   --                       or equal to ...      than        default is
   --
   --                            1               30          NS =   2(+)
   --                           30               60          NS =   4(+)
   --                           60              150          NS =  10(+)
   --                          150              590          NS =  **
   --                          590             3000          NS =  64
   --                         3000             6000          NS = 128
   --                         6000             infinity      NS = 256
   --
   --                   (+)  By default some or all matrices of this order
   --                        are passed to the implicit Real shift routine
   --                        ZLAHQR and this parameter is ignored.  See
   --                        ISPEC=12 above and comments in IPARMQ for
   --                        details.
   --
   --                  (**)  The asterisks (**) indicate an ad-hoc
   --                        function of N increasing from 10 to 64.
   --
   --             ISPEC=16: Select structured matrix multiply.
   --                       If the number of simultaneous shifts (specified
   --                       by ISPEC=15) is less than 14, then the default
   --                       for ISPEC=16 is 0.  Otherwise the default for
   --                       ISPEC=16 is 2.
   --
   --  References:
   --  ================
   --
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
   --        Performance, SIAM Journal of Matrix Analysis, volume 23, pages
   --        929--947, 2002.
   --  \n
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part II: Aggressive Early Deflation, SIAM Journal
   --        of Matrix Analysis, volume 23, pages 948--973, 2002.
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --
   --     ==== Matrices of order NTINY or smaller must be processed by
   --     .    ZLAHQR because of insufficient subdiagonal scratch space.
   --     .    (This is a hard limit.) ====
   --      PARAMETER          ( NTINY = 11 )
   --
   --     ==== NL allocates some local workspace to help small matrices
   --     .    through a rare ZLAHQR failure.  NL .GT. NTINY = 11 is
   --     .    required and NL .LE. NMIN = ILAENV(ISPEC=12,...) is recom-
   --     .    mended.  (The default value of NMIN is 75.)  Using NL = 49
   --     .    allows up to six simultaneous shifts and a 16-by-16
   --     .    deflation window.  ====
   --      PARAMETER          ( NL = 49 )
   --      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ), ONE = ( 1.0d0, 0.0d0 ) )
   --      PARAMETER          ( RZERO = 0.0d0 )
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       INTEGER            ILAENV
   --       LOGICAL            LSAME
   --       EXTERNAL           ILAENV, LSAME
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZCOPY, ZLACPY, ZLAHQR, ZLAQR0, ZLASET
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, DCMPLX, MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     ==== Decode and check the input parameters. ====
   --
   begin
      WANTT    := LSAME (JOB, 'S');
      INITZ    := LSAME (COMPZ, 'I');
      WANTZ    := INITZ or LSAME (COMPZ, 'V');
      WORK (1) := Complex'(Real (max (1, N)), 0.0e0);
      LQUERY   := LWORK = -1;
      --
      INFO := 0;
      if not LSAME (JOB, 'E') and not WANTT then
         INFO := -1;
      elsif not LSAME (COMPZ, 'N') and not WANTZ then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -4;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -5;
      elsif LDH < max (1, N) then
         INFO := -7;
      elsif LDZ < 1 or (WANTZ and LDZ < max (1, N)) then
         INFO := -10;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -12;
      end if;
      --
      if INFO /= 0 then
         --
         --        ==== Quick return in case of invalid argument. ====
         --
         XERBLA ("ZHSEQR", -INFO);
         return;
      --
      elsif N = 0 then
         --
         --        ==== Quick return in case N = 0; nothing to do. ====
         --
         return;
      --
      elsif LQUERY then
         --
         --        ==== Quick return in case of a workspace query ====
         --
         ZLAQR0 (WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILO, IHI, Z, LDZ, WORK, LWORK, INFO);
         --        ==== Ensure reported workspace size is backward-compatible with
         --        .    previous LAPACK versions. ====
         WORK (1) := Complex'(max (real_part (WORK (1)), Real (max (1, N))), 0.0e0);
         return;
      --
      else
         --
         --        ==== copy eigenvalues isolated by ZGEBAL ====
         --
         if ILO > 1 then
            ZCOPY (ILO - 1, H'Address, LDH + 1, W'Address, 1);
         end if;
         if IHI < N then
            ZCOPY (N - IHI, H (IHI + 1, IHI + 1)'Address, LDH + 1, W (IHI + 1)'Address, 1);
         end if;
         --
         --        ==== Initialize Z, if requested ====
         --
         if INITZ then
            ZLASET ('A', N, N, ZERO, ONE, Z'Address, LDZ);
         end if;
         --
         --        ==== Quick return if possible ====
         --
         if ILO = IHI then
            W (ILO) := H (ILO, ILO);
            return;
         end if;
         --
         --        ==== ZLAHQR/ZLAQR0 crossover point ====
         --
         NMIN := ILAENV (12, "ZHSEQR", JOB & COMPZ, N, ILO, IHI, LWORK);
         NMIN := max (NTINY, NMIN);
         --
         --        ==== ZLAQR0 for big matrices; ZLAHQR for small ones ====
         --
         if N > NMIN then
            ZLAQR0 (WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILO, IHI, Z, LDZ, WORK, LWORK, INFO);
         else
            --
            --           ==== Small matrix ====
            --
            ZLAHQR (WANTT, WANTZ, N, ILO, IHI, H'Address, LDH, W'Address, ILO, IHI, Z'Address, LDZ, INFO);
            --
            if INFO > 0 then
               --
               --              ==== A rare ZLAHQR failure!  ZLAQR0 sometimes succeeds
               --              .    when ZLAHQR fails. ====
               --
               KBOT := INFO;
               --
               if N >= NL then
                  --
                  --                 ==== Larger matrices have enough subdiagonal scratch
                  --                 .    space to call ZLAQR0 directly. ====
                  --
                  ZLAQR0 (WANTT, WANTZ, N, ILO, KBOT, H, LDH, W, ILO, IHI, Z, LDZ, WORK, LWORK, INFO);
               --
               else
                  --
                  --                 ==== Tiny matrices don't have enough subdiagonal
                  --                 .    scratch space to benefit from ZLAQR0.  Hence,
                  --                 .    tiny matrices must be copied into a larger
                  --                 .    array before calling ZLAQR0. ====
                  --
                  ZLACPY ('A', N, N, H'Address, LDH, HL'Address, NL);
                  HL (N + 1, N) := ZERO;
                  ZLASET ('A', NL, NL - N, ZERO, ZERO, HL (1, N + 1)'Address, NL);
                  ZLAQR0 (WANTT, WANTZ, NL, ILO, KBOT, HL, NL, W, ILO, IHI, Z, LDZ, WORKL, NL, INFO);
                  if WANTT or INFO /= 0 then
                     ZLACPY ('A', N, N, HL'Address, NL, H'Address, LDH);
                  end if;
               end if;
            end if;
         end if;
         --
         --        ==== Clear out the trash, if necessary. ====
         --
         if (WANTT or INFO /= 0) and N > 2 then
            ZLASET ('L', N - 2, N - 2, ZERO, ZERO, H (3, 1)'Address, LDH);
         end if;
         --
         --        ==== Ensure reported workspace size is backward-compatible with
         --        .    previous LAPACK versions. ====
         --
         WORK (1) := Complex'(max (Real (max (1, N)), real_part (WORK (1))), 0.0e0);
      end if;
      --
      --     ==== End of ZHSEQR ====
      --
   end ZHSEQR;

   procedure ZLABRD
     (M        : Integer;
      N        : Integer;
      NB       : Integer;
      A_adr    : Address;
      LDA      : Integer;
      D_adr    : Address;
      E_adr    : Address;
      TAUQ_adr : Address;
      TAUP_adr : Address;
      X_adr    : Address;
      LDX      : Integer;
      Y_adr    : Address;
      LDY      : Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      D    : Ftn_Real_Vector (1 .. NB);
      E    : Ftn_Real_Vector (1 .. NB);
      TAUQ : Ftn_Complex_Vector (1 .. NB);
      TAUP : Ftn_Complex_Vector (1 .. NB);
      X    : Ftn_Complex_Matrix (1 .. LDX, 1 .. NB);
      Y    : Ftn_Complex_Matrix (1 .. LDY, 1 .. NB);

      for A'Address use A_adr;
      for D'Address use D_adr;
      for E'Address use E_adr;
      for TAUQ'Address use TAUQ_adr;
      for TAUP'Address use TAUP_adr;
      for X'Address use X_adr;
      for Y'Address use Y_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, TAUQ);
      pragma Import (Ada, TAUP);
      pragma Import (Ada, X);
      pragma Import (Ada, Y);

      ZERO  : constant Complex := (0.0e0, 0.0e0);
      ONE   : constant Complex := (1.0e0, 0.0e0);
      I     : Integer;
      ALPHA : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLABRD( M, N, NB, A, LDA, D, E, TAUQ, TAUP, X, LDX, Y,
   --                          LDY )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            LDA, LDX, LDY, M, N, NB
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * )
   --       COMPLEX*16         A( LDA, * ), TAUP( * ), TAUQ( * ), X( LDX, * ),
   --      $                   Y( LDY, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLABRD reduces the first NB rows and columns of a complex general
   --  m by n matrix A to upper or lower real bidiagonal form by a unitary
   --  transformation Q**H * A * P, and returns the matrices X and Y which
   --  are needed to apply the transformation to the unreduced part of A.
   --
   --  If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
   --  bidiagonal form.
   --
   --  This is an auxiliary routine called by ZGEBRD
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows in the matrix A.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns in the matrix A.
   --
   --  [in] NB
   --           NB is INTEGER
   --           The number of leading rows and columns of A to be reduced.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the m by n general matrix to be reduced.
   --           On exit, the first NB rows and columns of the matrix are
   --           overwritten; the rest of the array is unchanged.
   --           If m >= n, elements on and below the diagonal in the first NB
   --             columns, with the array TAUQ, represent the unitary
   --             matrix Q as a product of elementary reflectors; and
   --             elements above the diagonal in the first NB rows, with the
   --             array TAUP, represent the unitary matrix P as a product
   --             of elementary reflectors.
   --           If m < n, elements below the diagonal in the first NB
   --             columns, with the array TAUQ, represent the unitary
   --             matrix Q as a product of elementary reflectors, and
   --             elements on and above the diagonal in the first NB rows,
   --             with the array TAUP, represent the unitary matrix P as
   --             a product of elementary reflectors.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] D
   --           D is DOUBLE PRECISION array, dimension (NB)
   --           The diagonal elements of the first NB rows and columns of
   --           the reduced matrix.  D(i) = A(i,i).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (NB)
   --           The off-diagonal elements of the first NB rows and columns of
   --           the reduced matrix.
   --
   --  [out] TAUQ
   --           TAUQ is COMPLEX*16 array dimension (NB)
   --           The scalar factors of the elementary reflectors which
   --           represent the unitary matrix Q. See Further Details.
   --
   --  [out] TAUP
   --           TAUP is COMPLEX*16 array, dimension (NB)
   --           The scalar factors of the elementary reflectors which
   --           represent the unitary matrix P. See Further Details.
   --
   --  [out] X
   --           X is COMPLEX*16 array, dimension (LDX,NB)
   --           The m-by-nb matrix X required to update the unreduced part
   --           of A.
   --
   --  [in] LDX
   --           LDX is INTEGER
   --           The leading dimension of the array X. LDX >= max(1,M).
   --
   --  [out] Y
   --           Y is COMPLEX*16 array, dimension (LDY,NB)
   --           The n-by-nb matrix Y required to update the unreduced part
   --           of A.
   --
   --  [in] LDY
   --           LDY is INTEGER
   --           The leading dimension of the array Y. LDY >= max(1,N).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrices Q and P are represented as products of elementary
   --   reflectors:
   --
   --      Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
   --
   --   Each H(i) and G(i) has the form:
   --
   --      H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
   --
   --   where tauq and taup are complex scalars, and v and u are complex
   --   vectors.
   --
   --   If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
   --   A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
   --   A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
   --   A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
   --   A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
   --
   --   The elements of the vectors v and u together form the m-by-nb matrix
   --   V and the nb-by-n matrix U**H which are needed, with X and Y, to apply
   --   the transformation to the unreduced part of the matrix, using a block
   --   update of the form:  A := A - V*Y**H - X*U**H.
   --
   --   The contents of A on exit are illustrated by the following examples
   --   with nb = 2:
   --
   --   m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):
   --
   --     (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
   --     (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
   --     (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
   --     (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
   --     (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
   --     (  v1  v2  a   a   a  )
   --
   --   where a denotes an element of the original matrix which is unchanged,
   --   vi denotes an element of the vector defining H(i), and ui an element
   --   of the vector defining G(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ), ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZGEMV, ZLACGV, ZLARFG, ZSCAL
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if M <= 0 or N <= 0 then
         return;
      end if;
      --
      if M >= N then
         --
         --        Reduce to upper bidiagonal form
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > NB;
            --
            --           Update A(i:m,i)
            --
            ZLACGV (I - 1, Y (I, 1)'Address, LDY);
            ZGEMV ('N', M - I + 1, I - 1, -ONE, A (I, 1)'Address, LDA, Y (I, 1)'Address, LDY, ONE, A (I, I)'Address, 1);
            ZLACGV (I - 1, Y (I, 1)'Address, LDY);
            ZGEMV ('N', M - I + 1, I - 1, -ONE, X (I, 1)'Address, LDX, A (1, I)'Address, 1, ONE, A (I, I)'Address, 1);
            --
            --           Generate reflection Q(i) to annihilate A(i+1:m,i)
            --
            ALPHA := A (I, I);
            ZLARFG (M - I + 1, ALPHA, A (min (I + 1, M), I)'Address, 1, TAUQ (I));
            D (I) := real_part (ALPHA);
            if I < N then
               A (I, I) := ONE;
               --
               --              Compute Y(i+1:n,i)
               --
               ZGEMV
                 ('C',
                  M - I + 1,
                  N - I,
                  ONE,
                  A (I, I + 1)'Address,
                  LDA,
                  A (I, I)'Address,
                  1,
                  ZERO,
                  Y (I + 1, I)'Address,
                  1);
               ZGEMV ('C', M - I + 1, I - 1, ONE, A (I, 1)'Address, LDA, A (I, I)'Address, 1, ZERO, Y (1, I)'Address, 1);
               ZGEMV
                 ('N',
                  N - I,
                  I - 1,
                  -ONE,
                  Y (I + 1, 1)'Address,
                  LDY,
                  Y (1, I)'Address,
                  1,
                  ONE,
                  Y (I + 1, I)'Address,
                  1);
               ZGEMV ('C', M - I + 1, I - 1, ONE, X (I, 1)'Address, LDX, A (I, I)'Address, 1, ZERO, Y (1, I)'Address, 1);
               ZGEMV
                 ('C',
                  I - 1,
                  N - I,
                  -ONE,
                  A (1, I + 1)'Address,
                  LDA,
                  Y (1, I)'Address,
                  1,
                  ONE,
                  Y (I + 1, I)'Address,
                  1);
               ZSCAL (N - I, TAUQ (I), Y (I + 1, I)'Address, 1);
               --
               --              Update A(i,i+1:n)
               --
               ZLACGV (N - I, A (I, I + 1)'Address, LDA);
               ZLACGV (I, A (I, 1)'Address, LDA);
               ZGEMV
                 ('N',
                  N - I,
                  I,
                  -ONE,
                  Y (I + 1, 1)'Address,
                  LDY,
                  A (I, 1)'Address,
                  LDA,
                  ONE,
                  A (I, I + 1)'Address,
                  LDA);
               ZLACGV (I, A (I, 1)'Address, LDA);
               ZLACGV (I - 1, X (I, 1)'Address, LDX);
               ZGEMV
                 ('C',
                  I - 1,
                  N - I,
                  -ONE,
                  A (1, I + 1)'Address,
                  LDA,
                  X (I, 1)'Address,
                  LDX,
                  ONE,
                  A (I, I + 1)'Address,
                  LDA);
               ZLACGV (I - 1, X (I, 1)'Address, LDX);
               --
               --              Generate reflection P(i) to annihilate A(i,i+2:n)
               --
               ALPHA := A (I, I + 1);
               ZLARFG (N - I, ALPHA, A (I, min (I + 2, N))'Address, LDA, TAUP (I));
               E (I)        := real_part (ALPHA);
               A (I, I + 1) := ONE;
               --
               --              Compute X(i+1:m,i)
               --
               ZGEMV
                 ('N',
                  M - I,
                  N - I,
                  ONE,
                  A (I + 1, I + 1)'Address,
                  LDA,
                  A (I, I + 1)'Address,
                  LDA,
                  ZERO,
                  X (I + 1, I)'Address,
                  1);
               ZGEMV ('C', N - I, I, ONE, Y (I + 1, 1)'Address, LDY, A (I, I + 1)'Address, LDA, ZERO, X (1, I)'Address, 1);
               ZGEMV ('N', M - I, I, -ONE, A (I + 1, 1)'Address, LDA, X (1, I)'Address, 1, ONE, X (I + 1, I)'Address, 1);
               ZGEMV
                 ('N',
                  I - 1,
                  N - I,
                  ONE,
                  A (1, I + 1)'Address,
                  LDA,
                  A (I, I + 1)'Address,
                  LDA,
                  ZERO,
                  X (1, I)'Address,
                  1);
               ZGEMV
                 ('N',
                  M - I,
                  I - 1,
                  -ONE,
                  X (I + 1, 1)'Address,
                  LDX,
                  X (1, I)'Address,
                  1,
                  ONE,
                  X (I + 1, I)'Address,
                  1);
               ZSCAL (M - I, TAUP (I), X (I + 1, I)'Address, 1);
               ZLACGV (N - I, A (I, I + 1)'Address, LDA);
            end if;
         end loop;
      else
         --
         --        Reduce to lower bidiagonal form
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > NB;
            --
            --           Update A(i,i:n)
            --
            ZLACGV (N - I + 1, A (I, I)'Address, LDA);
            ZLACGV (I - 1, A (I, 1)'Address, LDA);
            ZGEMV ('N', N - I + 1, I - 1, -ONE, Y (I, 1)'Address, LDY, A (I, 1)'Address, LDA, ONE, A (I, I)'Address, LDA);
            ZLACGV (I - 1, A (I, 1)'Address, LDA);
            ZLACGV (I - 1, X (I, 1)'Address, LDX);
            ZGEMV ('C', I - 1, N - I + 1, -ONE, A (1, I)'Address, LDA, X (I, 1)'Address, LDX, ONE, A (I, I)'Address, LDA);
            ZLACGV (I - 1, X (I, 1)'Address, LDX);
            --
            --           Generate reflection P(i) to annihilate A(i,i+1:n)
            --
            ALPHA := A (I, I);
            ZLARFG (N - I + 1, ALPHA, A (I, min (I + 1, N))'Address, LDA, TAUP (I));
            D (I) := real_part (ALPHA);
            if I < M then
               A (I, I) := ONE;
               --
               --              Compute X(i+1:m,i)
               --
               ZGEMV
                 ('N',
                  M - I,
                  N - I + 1,
                  ONE,
                  A (I + 1, I)'Address,
                  LDA,
                  A (I, I)'Address,
                  LDA,
                  ZERO,
                  X (I + 1, I)'Address,
                  1);
               ZGEMV ('C', N - I + 1, I - 1, ONE, Y (I, 1)'Address, LDY, A (I, I)'Address, LDA, ZERO, X (1, I)'Address, 1);
               ZGEMV
                 ('N',
                  M - I,
                  I - 1,
                  -ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  X (1, I)'Address,
                  1,
                  ONE,
                  X (I + 1, I)'Address,
                  1);
               ZGEMV ('N', I - 1, N - I + 1, ONE, A (1, I)'Address, LDA, A (I, I)'Address, LDA, ZERO, X (1, I)'Address, 1);
               ZGEMV
                 ('N',
                  M - I,
                  I - 1,
                  -ONE,
                  X (I + 1, 1)'Address,
                  LDX,
                  X (1, I)'Address,
                  1,
                  ONE,
                  X (I + 1, I)'Address,
                  1);
               ZSCAL (M - I, TAUP (I), X (I + 1, I)'Address, 1);
               ZLACGV (N - I + 1, A (I, I)'Address, LDA);
               --
               --              Update A(i+1:m,i)
               --
               ZLACGV (I - 1, Y (I, 1)'Address, LDY);
               ZGEMV
                 ('N',
                  M - I,
                  I - 1,
                  -ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  Y (I, 1)'Address,
                  LDY,
                  ONE,
                  A (I + 1, I)'Address,
                  1);
               ZLACGV (I - 1, Y (I, 1)'Address, LDY);
               ZGEMV ('N', M - I, I, -ONE, X (I + 1, 1)'Address, LDX, A (1, I)'Address, 1, ONE, A (I + 1, I)'Address, 1);
               --
               --              Generate reflection Q(i) to annihilate A(i+2:m,i)
               --
               ALPHA := A (I + 1, I);
               ZLARFG (M - I, ALPHA, A (min (I + 2, M), I)'Address, 1, TAUQ (I));
               E (I)        := real_part (ALPHA);
               A (I + 1, I) := ONE;
               --
               --              Compute Y(i+1:n,i)
               --
               ZGEMV
                 ('C',
                  M - I,
                  N - I,
                  ONE,
                  A (I + 1, I + 1)'Address,
                  LDA,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  Y (I + 1, I)'Address,
                  1);
               ZGEMV
                 ('C',
                  M - I,
                  I - 1,
                  ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  Y (1, I)'Address,
                  1);
               ZGEMV
                 ('N',
                  N - I,
                  I - 1,
                  -ONE,
                  Y (I + 1, 1)'Address,
                  LDY,
                  Y (1, I)'Address,
                  1,
                  ONE,
                  Y (I + 1, I)'Address,
                  1);
               ZGEMV ('C', M - I, I, ONE, X (I + 1, 1)'Address, LDX, A (I + 1, I)'Address, 1, ZERO, Y (1, I)'Address, 1);
               ZGEMV ('C', I, N - I, -ONE, A (1, I + 1)'Address, LDA, Y (1, I)'Address, 1, ONE, Y (I + 1, I)'Address, 1);
               ZSCAL (N - I, TAUQ (I), Y (I + 1, I)'Address, 1);
            else
               ZLACGV (N - I + 1, A (I, I)'Address, LDA);
            end if;
         end loop;
      end if;
      return;
      --
      --     End of ZLABRD
      --
   end ZLABRD;

   procedure ZLACGV (N : Integer; X_adr : Address; INCX : Integer) is

      X : Ftn_Complex_Vector (1 .. (1 + (N - 1) * abs (INCX)));

      for X'Address use X_adr;

      pragma Import (Ada, X);

      I    : Integer;
      IOFF : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLACGV( N, X, INCX )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         X( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLACGV conjugates a complex vector of length N.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The length of the vector X.  N >= 0.
   --
   --  [in,out] X
   --           X is COMPLEX*16 array, dimension
   --                          (1+(N-1)*abs(INCX))
   --           On entry, the vector of length N to be conjugated.
   --           On exit, X is overwritten with conjg(X).
   --
   --  [in] INCX
   --           INCX is INTEGER
   --           The spacing between successive elements of X.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if INCX = 1 then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            X (I) := dconjg (X (I));
         end loop;
      else
         IOFF := 1;
         if INCX < 0 then
            IOFF := 1 - (N - 1) * INCX;
         end if;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            X (IOFF) := dconjg (X (IOFF));
            IOFF     := IOFF + INCX;
         end loop;
      end if;
      return;
      --
      --     End of ZLACGV
      --
   end ZLACGV;

   procedure ZLACP2
     (UPLO  : Character;
      M     : Integer;
      N     : Integer;
      A_adr : Address;
      LDA   : Integer;
      B_adr : Address;
      LDB   : Integer)
   is

      A : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      B : Ftn_Complex_Matrix (1 .. LDB, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);

      I : Integer;
      J : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLACP2( UPLO, M, N, A, LDA, B, LDB )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            LDA, LDB, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * )
   --       COMPLEX*16         B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLACP2 copies all or part of a real two-dimensional matrix A to a
   --  complex matrix B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies the part of the matrix A to be copied to B.
   --           = 'U':      Upper triangular part
   --           = 'L':      Lower triangular part
   --           Otherwise:  All of the matrix A
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA,N)
   --           The m by n matrix A.  If UPLO = 'U', only the upper trapezium
   --           is accessed; if UPLO = 'L', only the lower trapezium is
   --           accessed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] B
   --           B is COMPLEX*16 array, dimension (LDB,N)
   --           On exit, B = A in the locations specified by UPLO.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if LSAME (UPLO, 'U') then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J, M);
               B (I, J) := Complex'(A (I, J), 0.0e0);
            end loop;
         end loop;
      --
      elsif LSAME (UPLO, 'L') then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := J - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := Complex'(A (I, J), 0.0e0);
            end loop;
         end loop;
      --
      else
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := Complex'(A (I, J), 0.0e0);
            end loop;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZLACP2
      --
   end ZLACP2;

   procedure ZLACPY
     (UPLO  : Character;
      M     : Integer;
      N     : Integer;
      A_adr : Address;
      LDA   : Integer;
      B_adr : Address;
      LDB   : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      B : Ftn_Complex_Matrix (1 .. LDB, 1 .. N);

      for A'Address use A_adr;
      for B'Address use B_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);

      I : Integer;
      J : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLACPY( UPLO, M, N, A, LDA, B, LDB )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            LDA, LDB, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLACPY copies all or part of a two-dimensional matrix A to another
   --  matrix B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies the part of the matrix A to be copied to B.
   --           = 'U':      Upper triangular part
   --           = 'L':      Lower triangular part
   --           Otherwise:  All of the matrix A
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The m by n matrix A.  If UPLO = 'U', only the upper trapezium
   --           is accessed; if UPLO = 'L', only the lower trapezium is
   --           accessed.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] B
   --           B is COMPLEX*16 array, dimension (LDB,N)
   --           On exit, B = A in the locations specified by UPLO.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if LSAME (UPLO, 'U') then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J, M);
               B (I, J) := A (I, J);
            end loop;
         end loop;
      --
      elsif LSAME (UPLO, 'L') then
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := J - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := A (I, J);
            end loop;
         end loop;
      --
      else
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               B (I, J) := A (I, J);
            end loop;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZLACPY
      --
   end ZLACPY;

   procedure ZLACRM
     (M         : Integer;
      N         : Integer;
      A_adr     : Address;
      LDA       : Integer;
      B_adr     : Address;
      LDB       : Integer;
      C_adr     : Address;
      LDC       : Integer;
      RWORK_adr : Address)
   is

      A     : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      B     : Ftn_Real_Matrix (1 .. LDB, 1 .. N);
      C     : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      RWORK : Ftn_Real_Vector (1 .. 2 * M * N);

      for A'Address use A_adr;
      for B'Address use B_adr;
      for C'Address use C_adr;
      for RWORK'Address use RWORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);
      pragma Import (Ada, C);
      pragma Import (Ada, RWORK);

      ONE  : constant Real := 1.0e0;
      ZERO : constant Real := 0.0e0;
      I    : Integer;
      J    : Integer;
      L    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLACRM( M, N, A, LDA, B, LDB, C, LDC, RWORK)
   --
   --       .. Scalar Arguments ..
   --       INTEGER            LDA, LDB, LDC, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   B( LDB, * ), RWORK( * )
   --       COMPLEX*16         A( LDA, * ), C( LDC, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLACRM performs a very simple matrix-matrix multiplication:
   --           C := A * B,
   --  where A is M by N and complex; B is N by N and real;
   --  C is M by N and complex.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A and of the matrix C.
   --           M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns and rows of the matrix B and
   --           the number of columns of the matrix C.
   --           N >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA, N)
   --           A contains the M by N matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >=max(1,M).
   --
   --  [in] B
   --           B is DOUBLE PRECISION array, dimension (LDB, N)
   --           B contains the N by N matrix B.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B. LDB >=max(1,N).
   --
   --  [in] C
   --           C is COMPLEX*16 array, dimension (LDC, N)
   --           C contains the M by N matrix C.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >=max(1,N).
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array, dimension (2*M*N)
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D0, ZERO = 0.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, DCMPLX, DIMAG
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMM
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible.
   --
   begin
      if (M = 0) or (N = 0) then
         return;
      end if;
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            RWORK ((J - 1) * M + I)   := dble (A (I, J));
         end loop;
      end loop;
      --
      L := M * N + 1;
      DGEMM ('N', 'N', M, N, N, ONE, RWORK'Address, M, B'Address, LDB, ZERO, RWORK (L)'Address, M);
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            C (I, J) := Complex'(RWORK (L + (J - 1) * M + I - 1), 0.0e0);
         end loop;
      end loop;
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            RWORK ((J - 1) * M + I)   := dimag (A (I, J));
         end loop;
      end loop;
      DGEMM ('N', 'N', M, N, N, ONE, RWORK'Address, M, B'Address, LDB, ZERO, RWORK (L)'Address, M);
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            C (I, J) := dcmplx (dble (C (I, J)), RWORK (L + (J - 1) * M + I - 1));
         end loop;
      end loop;
      --
      return;
      --
      --     End of ZLACRM
      --
   end ZLACRM;

   function ZLADIV (X : Complex; Y : Complex) return Complex is
      ZI            : Real;
      ZR            : Real;
      ZLADIV_Result : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       COMPLEX*16     FUNCTION ZLADIV( X, Y )
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16         X, Y
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLADIV := X / Y, where X and Y are complex.  The computation of X / Y
   --  will not overflow on an intermediary step unless the results
   --  overflows.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] X
   --           X is COMPLEX*16
   --
   --  [in] Y
   --           Y is COMPLEX*16
   --           The complex scalars X and Y.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLADIV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, DCMPLX, DIMAG
   --     ..
   --     .. Executable Statements ..
   --
   begin
      DLADIV (dble (X), dimag (X), dble (Y), dimag (Y), ZR, ZI);
      ZLADIV_Result := Complex'(ZR, ZI);
      --
      return ZLADIV_Result;
      --
      --     End of ZLADIV
      --
   end ZLADIV;

   procedure ZLAED0
     (QSIZ       : Integer;
      N          : Integer;
      D_adr      : Address;
      E_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      QSTORE_adr : Address;
      LDQS       : Integer;
      RWORK_adr  : Address;
      IWORK_adr  : Address;
      INFO       : in out Integer)
   is

      N_Log2_N  : constant Integer := N * (1 + intlog2 (N));
      tmp_RWORK : constant Integer := 1 + 3 * N + 2 * N_Log2_N + 3 * N * N;
      tmp_IWORK : constant Integer := 6 + 6 * N + 5 * N_Log2_N;

      D      : Ftn_Real_Vector (1 .. N);
      E      : Ftn_Real_Vector (1 .. N - 1);
      Q      : Ftn_Complex_Matrix (1 .. LDQ, 1 .. N);
      QSTORE : Ftn_Complex_Matrix (1 .. LDQS, 1 .. N);
      RWORK  : Ftn_Real_Vector (1 .. tmp_RWORK);
      IWORK  : Ftn_Integer_Vector (1 .. tmp_IWORK);

      for D'Address use D_adr;
      for E'Address use E_adr;
      for Q'Address use Q_adr;
      for QSTORE'Address use QSTORE_adr;
      for RWORK'Address use RWORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, Q);
      pragma Import (Ada, QSTORE);
      pragma Import (Ada, RWORK);
      pragma Import (Ada, IWORK);

      TWO    : constant Real := 2.0e0;
      CURLVL : Integer;
      CURPRB : Integer;
      CURR   : Integer;
      I      : Integer;
      IGIVCL : Integer;
      IGIVNM : Integer;
      IGIVPT : Integer;
      INDXQ  : Integer;
      IPERM  : Integer;
      IPRMPT : Integer;
      IQ     : Integer;
      IQPTR  : Integer;
      IWREM  : Integer;
      J      : Integer;
      K      : Integer;
      LGN    : Integer;
      LL     : Integer;
      MATSIZ : Integer;
      MSD2   : Integer;
      SMLSIZ : Integer;
      SMM1   : Integer;
      SPM1   : Integer;
      SPM2   : Integer;
      SUBMAT : Integer;
      SUBPBS : Integer;
      TLVLS  : Integer;
      TEMP   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAED0( QSIZ, N, D, E, Q, LDQ, QSTORE, LDQS, RWORK,
   --                          IWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, LDQ, LDQS, N, QSIZ
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   D( * ), E( * ), RWORK( * )
   --       COMPLEX*16         Q( LDQ, * ), QSTORE( LDQS, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  Using the divide and conquer method, ZLAED0 computes all eigenvalues
   --  of a symmetric tridiagonal matrix which is one diagonal block of
   --  those from reducing a dense or band Hermitian matrix and
   --  corresponding eigenvectors of the dense or band matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] QSIZ
   --           QSIZ is INTEGER
   --          The dimension of the unitary matrix used to reduce
   --          the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry, the diagonal elements of the tridiagonal matrix.
   --          On exit, the eigenvalues in ascending order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --          On entry, the off-diagonal elements of the tridiagonal matrix.
   --          On exit, E has been destroyed.
   --
   --  [in,out] Q
   --           Q is COMPLEX*16 array, dimension (LDQ,N)
   --          On entry, Q must contain an QSIZ x N matrix whose columns
   --          unitarily orthonormal. It is a part of the unitary matrix
   --          that reduces the full dense Hermitian matrix to a
   --          (reducible) symmetric tridiagonal matrix.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [out] IWORK
   --           IWORK is INTEGER array,
   --          the dimension of IWORK must be at least
   --                       6 + 6*N + 5*N*lg N
   --                       ( lg( N ) = smallest integer k
   --                                   such that 2^k >= N )
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array,
   --                                dimension (1 + 3*N + 2*N*lg N + 3*N**2)
   --                         ( lg( N ) = smallest integer k
   --                                     such that 2^k >= N )
   --
   --  [out] QSTORE
   --           QSTORE is COMPLEX*16 array, dimension (LDQS, N)
   --          Used to store parts of
   --          the eigenvector matrix when the updating matrix multiplies
   --          take place.
   --
   --  [in] LDQS
   --           LDQS is INTEGER
   --          The leading dimension of the array QSTORE.
   --          LDQS >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  The algorithm failed to compute an eigenvalue while
   --                 working on the submatrix lying in rows and columns
   --                 INFO/(N+1) through mod(INFO,N+1).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --  Warning:      N could be as big as QSIZ!
   --
   --     .. Parameters ..
   --      PARAMETER          ( TWO = 2.D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DSTEQR, XERBLA, ZCOPY, ZLACRM, ZLAED7
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, LOG, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      --     IF( ICOMPQ .LT. 0 .OR. ICOMPQ .GT. 2 ) THEN
      --        INFO = -1
      --     ELSE IF( ( ICOMPQ .EQ. 1 ) .AND. ( QSIZ .LT. MAX( 0, N ) ) )
      --    $        THEN
      if QSIZ < max (0, N) then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDQ < max (1, N) then
         INFO := -6;
      elsif LDQS < max (1, N) then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZLAED0", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      SMLSIZ := ILAENV (9, "ZLAED0", " ", 0, 0, 0, 0);
      --
      --     Determine the size and placement of the submatrices, and save in
      --     the leading elements of IWORK.
      --
      IWORK (1) := N;
      SUBPBS    := 1;
      TLVLS     := 0;
      <<L10>> null;
      if IWORK (SUBPBS) > SMLSIZ then
         J := SUBPBS + 1;
         loop
            J := J - 1;
            exit when J < 1;
            IWORK (2 * J)     := (IWORK (J) + 1) / 2;
            IWORK (2 * J - 1) := IWORK (J) / 2;
         end loop;
         TLVLS  := TLVLS + 1;
         SUBPBS := 2 * SUBPBS;
         goto L10;
      end if;
      J := 2 - 1;
      loop
         J := J + 1;
         exit when J > SUBPBS;
         IWORK (J) := IWORK (J) + IWORK (J - 1);
      end loop;
      --
      --     Divide the matrix into SUBPBS submatrices of size at most SMLSIZ+1
      --     using rank-1 modifications (cuts).
      --
      SPM1 := SUBPBS - 1;
      I    := 1 - 1;
      loop
         I := I + 1;
         exit when I > SPM1;
         SUBMAT     := IWORK (I) + 1;
         SMM1       := SUBMAT - 1;
         D (SMM1)   := D (SMM1) - abs (E (SMM1));
         D (SUBMAT) := D (SUBMAT) - abs (E (SMM1));
      end loop;
      --
      INDXQ := 4 * N + 3;
      --
      --     Set up workspaces for eigenvalues only/accumulate new vectors
      --     routine
      --
      TEMP := Log (Real (N)) / Log (TWO);
      LGN  := int (TEMP);
      if 2 ** LGN < N then
         LGN := LGN + 1;
      end if;
      if 2 ** LGN < N then
         LGN := LGN + 1;
      end if;
      IPRMPT := INDXQ + N + 1;
      IPERM  := IPRMPT + N * LGN;
      IQPTR  := IPERM + N * LGN;
      IGIVPT := IQPTR + N + 2;
      IGIVCL := IGIVPT + N * LGN;
      --
      IGIVNM := 1;
      IQ     := IGIVNM + 2 * N * LGN;
      IWREM  := IQ + N ** 2 + 1;
      --     Initialize pointers
      I := 0 - 1;
      loop
         I := I + 1;
         exit when I > SUBPBS;
         IWORK (IPRMPT + I) := 1;
         IWORK (IGIVPT + I) := 1;
      end loop;
      IWORK (IQPTR) := 1;
      --
      --     Solve each submatrix eigenproblem at the bottom of the divide and
      --     conquer tree.
      --
      CURR := 0;
      I    := 0 - 1;
      loop
         I := I + 1;
         exit when I > SPM1;
         if I = 0 then
            SUBMAT := 1;
            MATSIZ := IWORK (1);
         else
            SUBMAT := IWORK (I) + 1;
            MATSIZ := IWORK (I + 1) - IWORK (I);
         end if;
         LL := IQ - 1 + IWORK (IQPTR + CURR);
         DSTEQR ('I', MATSIZ, D (SUBMAT)'Address, E (SUBMAT)'Address, RWORK (LL)'Address, MATSIZ, RWORK'Address, INFO);
         ZLACRM
           (QSIZ,
            MATSIZ,
            Q (1, SUBMAT)'Address,
            LDQ,
            RWORK (LL)'Address,
            MATSIZ,
            QSTORE (1, SUBMAT)'Address,
            LDQS,
            RWORK (IWREM)'Address);
         IWORK (IQPTR + CURR + 1) := IWORK (IQPTR + CURR) + MATSIZ ** 2;
         CURR                     := CURR + 1;
         if INFO > 0 then
            INFO := SUBMAT * (N + 1) + SUBMAT + MATSIZ - 1;
            return;
         end if;
         K := 1;
         J := SUBMAT - 1;
         loop
            J := J + 1;
            exit when J > IWORK (I + 1);
            IWORK (INDXQ + J) := K;
            K                 := K + 1;
         end loop;
      end loop;
      --
      --     Successively merge eigensystems of adjacent submatrices
      --     into eigensystem for the corresponding larger matrix.
      --
      --     while ( SUBPBS > 1 )
      --
      CURLVL := 1;
      <<L80>> null;
      if SUBPBS > 1 then
         SPM2 := SUBPBS - 2;
         I    := 0 - 2;
         loop
            I := I + 2;
            exit when I > SPM2;
            if I = 0 then
               SUBMAT := 1;
               MATSIZ := IWORK (2);
               MSD2   := IWORK (1);
               CURPRB := 0;
            else
               SUBMAT := IWORK (I) + 1;
               MATSIZ := IWORK (I + 2) - IWORK (I);
               MSD2   := MATSIZ / 2;
               CURPRB := CURPRB + 1;
            end if;
            --
            --     Merge lower order eigensystems (of size MSD2 and MATSIZ - MSD2)
            --     into an eigensystem of size MATSIZ.  ZLAED7 handles the case
            --     when the eigenvectors of a full or band Hermitian matrix (which
            --     was reduced to tridiagonal form) are desired.
            --
            --     I am free to use Q as a valuable working space until Loop 150.
            --
            ZLAED7
              (MATSIZ,
               MSD2,
               QSIZ,
               TLVLS,
               CURLVL,
               CURPRB,
               D (SUBMAT)'Address,
               QSTORE (1, SUBMAT)'Address,
               LDQS,
               E (SUBMAT + MSD2 - 1),
               IWORK (INDXQ + SUBMAT)'Address,
               RWORK (IQ)'Address,
               IWORK (IQPTR)'Address,
               IWORK (IPRMPT)'Address,
               IWORK (IPERM)'Address,
               IWORK (IGIVPT)'Address,
               IWORK (IGIVCL)'Address,
               RWORK (IGIVNM)'Address,
               Q (1, SUBMAT)'Address,
               RWORK (IWREM)'Address,
               IWORK (SUBPBS + 1)'Address,
               INFO);
            if INFO > 0 then
               INFO := SUBMAT * (N + 1) + SUBMAT + MATSIZ - 1;
               return;
            end if;
            IWORK (I / 2 + 1) := IWORK (I + 2);
            I                 := I + 2;
         end loop;
         SUBPBS := SUBPBS / 2;
         CURLVL := CURLVL + 1;
         goto L80;
      end if;
      --
      --     end while
      --
      --     Re-merge the eigenvalues/vectors which were deflated at the final
      --     merge step.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         J         := IWORK (INDXQ + I);
         RWORK (I) := D (J);
         ZCOPY (QSIZ, QSTORE (1, J)'Address, 1, Q (1, I)'Address, 1);
      end loop;
      DCOPY (N, RWORK'Address, 1, D'Address, 1);
      --
      return;
      --
      --     End of ZLAED0
      --
   end ZLAED0;

   procedure ZLAED7
     (N          : Integer;
      CUTPNT     : Integer;
      QSIZ       : Integer;
      TLVLS      : Integer;
      CURLVL     : Integer;
      CURPBM     : Integer;
      D_adr      : Address;
      Q_adr      : Address;
      LDQ        : Integer;
      RHO        : in out Real;
      INDXQ_adr  : Address;
      QSTORE_adr : Address;
      QPTR_adr   : Address;
      PRMPTR_adr : Address;
      PERM_adr   : Address;
      GIVPTR_adr : Address;
      GIVCOL_adr : Address;
      GIVNUM_adr : Address;
      WORK_adr   : Address;
      RWORK_adr  : Address;
      IWORK_adr  : Address;
      INFO       : in out Integer)
   is

      N_Log2_N : constant Integer := N * (1 + intlog2 (N));

      D      : Ftn_Real_Vector (1 .. N);
      Q      : Ftn_Complex_Matrix (1 .. LDQ, 1 .. N);
      INDXQ  : Ftn_Integer_Vector (1 .. N);
      QSTORE : Ftn_Real_Vector (1 .. 1 + N * N);
      QPTR   : Ftn_Integer_Vector (1 .. N + 2);
      PRMPTR : Ftn_Integer_Vector (1 .. N_Log2_N);
      PERM   : Ftn_Integer_Vector (1 .. N_Log2_N);
      GIVPTR : Ftn_Integer_Vector (1 .. N_Log2_N);
      GIVCOL : Ftn_Integer_Matrix (1 .. 2, 1 .. N_Log2_N);
      GIVNUM : Ftn_Real_Matrix (1 .. 2, 1 .. N_Log2_N);
      WORK   : Ftn_Complex_Vector (1 .. QSIZ * N);
      RWORK  : Ftn_Real_Vector (1 .. 3 * N + 2 * QSIZ * N);
      IWORK  : Ftn_Integer_Vector (1 .. 4 * N);

      for D'Address use D_adr;
      for Q'Address use Q_adr;
      for INDXQ'Address use INDXQ_adr;
      for QSTORE'Address use QSTORE_adr;
      for QPTR'Address use QPTR_adr;
      for PRMPTR'Address use PRMPTR_adr;
      for PERM'Address use PERM_adr;
      for GIVPTR'Address use GIVPTR_adr;
      for GIVCOL'Address use GIVCOL_adr;
      for GIVNUM'Address use GIVNUM_adr;
      for WORK'Address use WORK_adr;
      for RWORK'Address use RWORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, Q);
      pragma Import (Ada, INDXQ);
      pragma Import (Ada, QSTORE);
      pragma Import (Ada, QPTR);
      pragma Import (Ada, PRMPTR);
      pragma Import (Ada, PERM);
      pragma Import (Ada, GIVPTR);
      pragma Import (Ada, GIVCOL);
      pragma Import (Ada, GIVNUM);
      pragma Import (Ada, WORK);
      pragma Import (Ada, RWORK);
      pragma Import (Ada, IWORK);

      COLTYP : Integer;
      CURR   : Integer;
      I      : Integer;
      IDLMDA : Integer;
      INDX   : Integer;
      INDXC  : Integer;
      INDXP  : Integer;
      IQ     : Integer;
      IW     : Integer;
      IZ     : Integer;
      K      : Integer;
      N1     : Integer;
      N2     : Integer;
      PTR    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAED7( N, CUTPNT, QSIZ, TLVLS, CURLVL, CURPBM, D, Q,
   --                          LDQ, RHO, INDXQ, QSTORE, QPTR, PRMPTR, PERM,
   --                          GIVPTR, GIVCOL, GIVNUM, WORK, RWORK, IWORK,
   --                          INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            CURLVL, CURPBM, CUTPNT, INFO, LDQ, N, QSIZ,
   --      $                   TLVLS
   --       DOUBLE PRECISION   RHO
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            GIVCOL( 2, * ), GIVPTR( * ), INDXQ( * ),
   --      $                   IWORK( * ), PERM( * ), PRMPTR( * ), QPTR( * )
   --       DOUBLE PRECISION   D( * ), GIVNUM( 2, * ), QSTORE( * ), RWORK( * )
   --       COMPLEX*16         Q( LDQ, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLAED7 computes the updated eigensystem of a diagonal
   --  matrix after modification by a rank-one symmetric matrix. This
   --  routine is used only for the eigenproblem which requires all
   --  eigenvalues and optionally eigenvectors of a dense or banded
   --  Hermitian matrix that has been reduced to tridiagonal form.
   --
   --    T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
   --
   --    where Z = Q**Hu, u is a vector of length N with ones in the
   --    CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
   --
   --     The eigenvectors of the original matrix are stored in Q, and the
   --     eigenvalues are in D.  The algorithm consists of three stages:
   --
   --        The first stage consists of deflating the size of the problem
   --        when there are multiple eigenvalues or if there is a zero in
   --        the Z vector.  For each such occurence the dimension of the
   --        secular equation problem is reduced by one.  This stage is
   --        performed by the routine DLAED2.
   --
   --        The second stage consists of calculating the updated
   --        eigenvalues. This is done by finding the roots of the secular
   --        equation via the routine DLAED4 (as called by SLAED3).
   --        This routine also calculates the eigenvectors of the current
   --        problem.
   --
   --        The final stage consists of computing the updated eigenvectors
   --        directly using the updated eigenvalues.  The eigenvectors for
   --        the current problem are multiplied with the eigenvectors from
   --        the overall problem.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in] CUTPNT
   --           CUTPNT is INTEGER
   --          Contains the location of the last eigenvalue in the leading
   --          sub-matrix.  min(1,N) <= CUTPNT <= N.
   --
   --  [in] QSIZ
   --           QSIZ is INTEGER
   --          The dimension of the unitary matrix used to reduce
   --          the full matrix to tridiagonal form.  QSIZ >= N.
   --
   --  [in] TLVLS
   --           TLVLS is INTEGER
   --          The total number of merging levels in the overall divide and
   --          conquer tree.
   --
   --  [in] CURLVL
   --           CURLVL is INTEGER
   --          The current level in the overall merge routine,
   --          0 <= curlvl <= tlvls.
   --
   --  [in] CURPBM
   --           CURPBM is INTEGER
   --          The current problem in the current level in the overall
   --          merge routine (counting from upper left to lower right).
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry, the eigenvalues of the rank-1-perturbed matrix.
   --          On exit, the eigenvalues of the repaired matrix.
   --
   --  [in,out] Q
   --           Q is COMPLEX*16 array, dimension (LDQ,N)
   --          On entry, the eigenvectors of the rank-1-perturbed matrix.
   --          On exit, the eigenvectors of the repaired tridiagonal matrix.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [in] RHO
   --           RHO is DOUBLE PRECISION
   --          Contains the subdiagonal element used to create the rank-1
   --          modification.
   --
   --  [out] INDXQ
   --           INDXQ is INTEGER array, dimension (N)
   --          This contains the permutation which will reintegrate the
   --          subproblem just solved back into sorted order,
   --          ie. D( INDXQ( I = 1, N ) ) will be in ascending order.
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (4*N)
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array,
   --                                  dimension (3*N+2*QSIZ*N)
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (QSIZ*N)
   --
   --  [in,out] QSTORE
   --           QSTORE is DOUBLE PRECISION array, dimension (N**2+1)
   --          Stores eigenvectors of submatrices encountered during
   --          divide and conquer, packed together. QPTR points to
   --          beginning of the submatrices.
   --
   --  [in,out] QPTR
   --           QPTR is INTEGER array, dimension (N+2)
   --          List of indices pointing to beginning of submatrices stored
   --          in QSTORE. The submatrices are numbered starting at the
   --          bottom left of the divide and conquer tree, from left to
   --          right and bottom to top.
   --
   --  [in] PRMPTR
   --           PRMPTR is INTEGER array, dimension (N lg N)
   --          Contains a list of pointers which indicate where in PERM a
   --          level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
   --          indicates the size of the permutation and also the size of
   --          the full, non-deflated problem.
   --
   --  [in] PERM
   --           PERM is INTEGER array, dimension (N lg N)
   --          Contains the permutations (from deflation and sorting) to be
   --          applied to each eigenblock.
   --
   --  [in] GIVPTR
   --           GIVPTR is INTEGER array, dimension (N lg N)
   --          Contains a list of pointers which indicate where in GIVCOL a
   --          level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
   --          indicates the number of Givens rotations.
   --
   --  [in] GIVCOL
   --           GIVCOL is INTEGER array, dimension (2, N lg N)
   --          Each pair of numbers indicates a pair of columns to take place
   --          in a Givens rotation.
   --
   --  [in] GIVNUM
   --           GIVNUM is DOUBLE PRECISION array, dimension (2, N lg N)
   --          Each number indicates the S value to be used in the
   --          corresponding Givens rotation.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  if INFO = 1, an eigenvalue did not converge
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLAED9, DLAEDA, DLAMRG, XERBLA, ZLACRM, ZLAED8
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      --     IF( ICOMPQ.LT.0 .OR. ICOMPQ.GT.1 ) THEN
      --        INFO = -1
      --     ELSE IF( N.LT.0 ) THEN
      if N < 0 then
         INFO := -1;
      elsif min (1, N) > CUTPNT or N < CUTPNT then
         INFO := -2;
      elsif QSIZ < N then
         INFO := -3;
      elsif LDQ < max (1, N) then
         INFO := -9;
      end if;
      if INFO /= 0 then
         XERBLA ("ZLAED7", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     The following values are for bookkeeping purposes only.  They are
      --     integer pointers which indicate the portion of the workspace
      --     used by a particular array in DLAED2 and SLAED3.
      --
      IZ     := 1;
      IDLMDA := IZ + N;
      IW     := IDLMDA + N;
      IQ     := IW + N;
      --
      INDX   := 1;
      INDXC  := INDX + N;
      COLTYP := INDXC + N;
      INDXP  := COLTYP + N;
      --
      --     Form the z-vector which consists of the last row of Q_1 and the
      --     first row of Q_2.
      --
      PTR := 1 + 2 ** TLVLS;
      I   := 1 - 1;
      loop
         I := I + 1;
         exit when I > CURLVL - 1;
         PTR := PTR + 2 ** (TLVLS - I);
      end loop;
      CURR := PTR + CURPBM;
      DLAEDA
        (N,
         TLVLS,
         CURLVL,
         CURPBM,
         PRMPTR'Address,
         PERM'Address,
         GIVPTR'Address,
         GIVCOL'Address,
         GIVNUM'Address,
         QSTORE'Address,
         QPTR'Address,
         RWORK (IZ)'Address,
         RWORK (IZ + N)'Address,
         INFO);
      --
      --     When solving the final problem, we no longer need the stored data,
      --     so we will overwrite the data from this level onto the previously
      --     used storage space.
      --
      if CURLVL = TLVLS then
         QPTR (CURR)   := 1;
         PRMPTR (CURR) := 1;
         GIVPTR (CURR) := 1;
      end if;
      --
      --     Sort and Deflate eigenvalues.
      --
      ZLAED8
        (K,
         N,
         QSIZ,
         Q'Address,
         LDQ,
         D'Address,
         RHO,
         CUTPNT,
         RWORK (IZ)'Address,
         RWORK (IDLMDA)'Address,
         WORK'Address,
         QSIZ,
         RWORK (IW)'Address,
         IWORK (INDXP)'Address,
         IWORK (INDX)'Address,
         INDXQ'Address,
         PERM (PRMPTR (CURR))'Address,
         GIVPTR (CURR + 1),
         GIVCOL (1, GIVPTR (CURR))'Address,
         GIVNUM (1, GIVPTR (CURR))'Address,
         INFO);
      PRMPTR (CURR + 1) := PRMPTR (CURR) + N;
      GIVPTR (CURR + 1) := GIVPTR (CURR + 1) + GIVPTR (CURR);
      --
      --     Solve Secular Equation.
      --
      if K /= 0 then
         DLAED9
           (K,
            1,
            K,
            N,
            D'Address,
            RWORK (IQ)'Address,
            K,
            RHO,
            RWORK (IDLMDA)'Address,
            RWORK (IW)'Address,
            QSTORE (QPTR (CURR))'Address,
            K,
            INFO);
         ZLACRM (QSIZ, K, WORK'Address, QSIZ, QSTORE (QPTR (CURR))'Address, K, Q'Address, LDQ, RWORK (IQ)'Address);
         QPTR (CURR + 1) := QPTR (CURR) + K ** 2;
         if INFO /= 0 then
            return;
         end if;
         --
         --     Prepare the INDXQ sorting premutation.
         --
         N1 := K;
         N2 := N - K;
         DLAMRG (N1, N2, D'Address, 1, -1, INDXQ'Address);
      else
         QPTR (CURR + 1) := QPTR (CURR);
         I               := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            INDXQ (I) := I;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZLAED7
      --
   end ZLAED7;

   procedure ZLAED8
     (K          : in out Integer;
      N          : Integer;
      QSIZ       : Integer;
      Q_adr      : Address;
      LDQ        : Integer;
      D_adr      : Address;
      RHO        : in out Real;
      CUTPNT     : Integer;
      Z_adr      : Address;
      DLAMDA_adr : Address;
      Q2_adr     : Address;
      LDQ2       : Integer;
      W_adr      : Address;
      INDXP_adr  : Address;
      INDX_adr   : Address;
      INDXQ_adr  : Address;
      PERM_adr   : Address;
      GIVPTR     : in out Integer;
      GIVCOL_adr : Address;
      GIVNUM_adr : Address;
      INFO       : in out Integer)
   is

      Q      : Ftn_Complex_Matrix (1 .. LDQ, 1 .. N);
      D      : Ftn_Real_Vector (1 .. N);
      Z      : Ftn_Real_Vector (1 .. N);
      DLAMDA : Ftn_Real_Vector (1 .. N);
      Q2     : Ftn_Complex_Matrix (1 .. LDQ2, 1 .. N);
      W      : Ftn_Real_Vector (1 .. N);
      INDXP  : Ftn_Integer_Vector (1 .. N);
      INDX   : Ftn_Integer_Vector (1 .. N);
      INDXQ  : Ftn_Integer_Vector (1 .. N);
      PERM   : Ftn_Integer_Vector (1 .. N);
      GIVCOL : Ftn_Integer_Matrix (1 .. 2, 1 .. N);
      GIVNUM : Ftn_Real_Matrix (1 .. 2, 1 .. N);

      for Q'Address use Q_adr;
      for D'Address use D_adr;
      for Z'Address use Z_adr;
      for DLAMDA'Address use DLAMDA_adr;
      for Q2'Address use Q2_adr;
      for W'Address use W_adr;
      for INDXP'Address use INDXP_adr;
      for INDX'Address use INDX_adr;
      for INDXQ'Address use INDXQ_adr;
      for PERM'Address use PERM_adr;
      for GIVCOL'Address use GIVCOL_adr;
      for GIVNUM'Address use GIVNUM_adr;

      pragma Import (Ada, Q);
      pragma Import (Ada, D);
      pragma Import (Ada, Z);
      pragma Import (Ada, DLAMDA);
      pragma Import (Ada, Q2);
      pragma Import (Ada, W);
      pragma Import (Ada, INDXP);
      pragma Import (Ada, INDX);
      pragma Import (Ada, INDXQ);
      pragma Import (Ada, PERM);
      pragma Import (Ada, GIVCOL);
      pragma Import (Ada, GIVNUM);

      MONE  : constant Real := -1.0e0;
      ZERO  : constant Real := 0.0e0;
      ONE   : constant Real := 1.0e0;
      TWO   : constant Real := 2.0e0;
      EIGHT : constant Real := 8.0e0;
      I     : Integer;
      IMAX  : Integer;
      J     : Integer;
      JLAM  : Integer;
      JMAX  : Integer;
      JP    : Integer;
      K2    : Integer;
      N1    : Integer;
      N1P1  : Integer;
      N2    : Integer;
      C     : Real;
      EPS   : Real;
      S     : Real;
      T     : Real;
      TAU   : Real;
      TOL   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAED8( K, N, QSIZ, Q, LDQ, D, RHO, CUTPNT, Z, DLAMDA,
   --                          Q2, LDQ2, W, INDXP, INDX, INDXQ, PERM, GIVPTR,
   --                          GIVCOL, GIVNUM, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            CUTPNT, GIVPTR, INFO, K, LDQ, LDQ2, N, QSIZ
   --       DOUBLE PRECISION   RHO
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            GIVCOL( 2, * ), INDX( * ), INDXP( * ),
   --      $                   INDXQ( * ), PERM( * )
   --       DOUBLE PRECISION   D( * ), DLAMDA( * ), GIVNUM( 2, * ), W( * ),
   --      $                   Z( * )
   --       COMPLEX*16         Q( LDQ, * ), Q2( LDQ2, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLAED8 merges the two sets of eigenvalues together into a single
   --  sorted set.  Then it tries to deflate the size of the problem.
   --  There are two ways in which deflation can occur:  when two or more
   --  eigenvalues are close together or if there is a tiny element in the
   --  Z vector.  For each such occurrence the order of the related secular
   --  equation problem is reduced by one.
   --
   --  Arguments:
   --  ==========
   --
   --  [out] K
   --           K is INTEGER
   --          Contains the number of non-deflated eigenvalues.
   --          This is the order of the related secular equation.
   --
   --  [in] N
   --           N is INTEGER
   --          The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in] QSIZ
   --           QSIZ is INTEGER
   --          The dimension of the unitary matrix used to reduce
   --          the dense or band matrix to tridiagonal form.
   --          QSIZ >= N if ICOMPQ = 1.
   --
   --  [in,out] Q
   --           Q is COMPLEX*16 array, dimension (LDQ,N)
   --          On entry, Q contains the eigenvectors of the partially solved
   --          system which has been previously updated in matrix
   --          multiplies with other partially solved eigensystems.
   --          On exit, Q contains the trailing (N-K) updated eigenvectors
   --          (those which were deflated) in its last N-K columns.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --          The leading dimension of the array Q.  LDQ >= max( 1, N ).
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --          On entry, D contains the eigenvalues of the two submatrices to
   --          be combined.  On exit, D contains the trailing (N-K) updated
   --          eigenvalues (those which were deflated) sorted into increasing
   --          order.
   --
   --  [in,out] RHO
   --           RHO is DOUBLE PRECISION
   --          Contains the off diagonal element associated with the rank-1
   --          cut which originally split the two submatrices which are now
   --          being recombined. RHO is modified during the computation to
   --          the value required by DLAED3.
   --
   --  [in] CUTPNT
   --           CUTPNT is INTEGER
   --          Contains the location of the last eigenvalue in the leading
   --          sub-matrix.  MIN(1,N) <= CUTPNT <= N.
   --
   --  [in] Z
   --           Z is DOUBLE PRECISION array, dimension (N)
   --          On input this vector contains the updating vector (the last
   --          row of the first sub-eigenvector matrix and the first row of
   --          the second sub-eigenvector matrix).  The contents of Z are
   --          destroyed during the updating process.
   --
   --  [out] DLAMDA
   --           DLAMDA is DOUBLE PRECISION array, dimension (N)
   --          Contains a copy of the first K eigenvalues which will be used
   --          by DLAED3 to form the secular equation.
   --
   --  [out] Q2
   --           Q2 is COMPLEX*16 array, dimension (LDQ2,N)
   --          If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
   --          Contains a copy of the first K eigenvectors which will be used
   --          by DLAED7 in a matrix multiply (DGEMM) to update the new
   --          eigenvectors.
   --
   --  [in] LDQ2
   --           LDQ2 is INTEGER
   --          The leading dimension of the array Q2.  LDQ2 >= max( 1, N ).
   --
   --  [out] W
   --           W is DOUBLE PRECISION array, dimension (N)
   --          This will hold the first k values of the final
   --          deflation-altered z-vector and will be passed to DLAED3.
   --
   --  [out] INDXP
   --           INDXP is INTEGER array, dimension (N)
   --          This will contain the permutation used to place deflated
   --          values of D at the end of the array. On output INDXP(1:K)
   --          points to the nondeflated D-values and INDXP(K+1:N)
   --          points to the deflated eigenvalues.
   --
   --  [out] INDX
   --           INDX is INTEGER array, dimension (N)
   --          This will contain the permutation used to sort the contents of
   --          D into ascending order.
   --
   --  [in] INDXQ
   --           INDXQ is INTEGER array, dimension (N)
   --          This contains the permutation which separately sorts the two
   --          sub-problems in D into ascending order.  Note that elements in
   --          the second half of this permutation must first have CUTPNT
   --          added to their values in order to be accurate.
   --
   --  [out] PERM
   --           PERM is INTEGER array, dimension (N)
   --          Contains the permutations (from deflation and sorting) to be
   --          applied to each eigenblock.
   --
   --  [out] GIVPTR
   --           GIVPTR is INTEGER
   --          Contains the number of Givens rotations which took place in
   --          this subproblem.
   --
   --  [out] GIVCOL
   --           GIVCOL is INTEGER array, dimension (2, N)
   --          Each pair of numbers indicates a pair of columns to take place
   --          in a Givens rotation.
   --
   --  [out] GIVNUM
   --           GIVNUM is DOUBLE PRECISION array, dimension (2, N)
   --          Each number indicates the S value to be used in the
   --          corresponding Givens rotation.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( MONE = -1.0D0, ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, EIGHT = 8.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           IDAMAX, DLAMCH, DLAPY2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DCOPY, DLAMRG, DSCAL, XERBLA, ZCOPY, ZDROT, ZLACPY
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if N < 0 then
         INFO := -2;
      elsif QSIZ < N then
         INFO := -3;
      elsif LDQ < max (1, N) then
         INFO := -5;
      elsif CUTPNT < min (1, N) or CUTPNT > N then
         INFO := -8;
      elsif LDQ2 < max (1, N) then
         INFO := -12;
      end if;
      if INFO /= 0 then
         XERBLA ("ZLAED8", -INFO);
         return;
      end if;
      --
      --     Need to initialize GIVPTR to O here in case of quick exit
      --     to prevent an unspecified code behavior (usually sigfault)
      --     when IWORK array on entry to *stedc is not zeroed
      --     (or at least some IWORK entries which used in *laed7 for GIVPTR).
      --
      GIVPTR := 0;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      N1   := CUTPNT;
      N2   := N - N1;
      N1P1 := N1 + 1;
      --
      if RHO < ZERO then
         DSCAL (N2, MONE, Z (N1P1)'Address, 1);
      end if;
      --
      --     Normalize z so that norm(z) = 1
      --
      T := ONE / Sqrt (TWO);
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         INDX (J) := J;
      end loop;
      DSCAL (N, T, Z'Address, 1);
      RHO := abs (TWO * RHO);
      --
      --     Sort the eigenvalues into increasing order
      --
      I := CUTPNT + 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         INDXQ (I) := INDXQ (I) + CUTPNT;
      end loop;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         DLAMDA (I) := D (INDXQ (I));
         W (I)      := Z (INDXQ (I));
      end loop;
      I := 1;
      J := CUTPNT + 1;
      DLAMRG (N1, N2, DLAMDA'Address, 1, 1, INDX'Address);
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         D (I) := DLAMDA (INDX (I));
         Z (I) := W (INDX (I));
      end loop;
      --
      --     Calculate the allowable deflation tolerance
      --
      IMAX := IDAMAX (N, Z'Address, 1);
      JMAX := IDAMAX (N, D'Address, 1);
      EPS  := DLAMCH ('E');
      TOL  := EIGHT * EPS * abs (D (JMAX));
      --
      --     If the rank-1 modifier is small enough, no more needs to be done
      --     -- except to reorganize Q so that its columns correspond with the
      --     elements in D.
      --
      if RHO * abs (Z (IMAX)) <= TOL then
         K := 0;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            PERM (J) := INDXQ (INDX (J));
            ZCOPY (QSIZ, Q (1, PERM (J))'Address, 1, Q2 (1, J)'Address, 1);
         end loop;
         ZLACPY ('A', QSIZ, N, Q2 (1, 1)'Address, LDQ2, Q (1, 1)'Address, LDQ);
         return;
      end if;
      --
      --     If there are multiple eigenvalues then the problem deflates.  Here
      --     the number of equal eigenvalues are found.  As each equal
      --     eigenvalue is found, an elementary reflector is computed to rotate
      --     the corresponding eigensubspace so that the corresponding
      --     components of Z are zero in this new basis.
      --
      K  := 0;
      K2 := N + 1;
      J  := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         if RHO * abs (Z (J)) <= TOL then
            --
            --           Deflate due to small z component.
            --
            K2         := K2 - 1;
            INDXP (K2) := J;
            if J = N then
               goto L100;
            end if;
         else
            JLAM := J;
            goto L70;
         end if;
      end loop;
      <<L70>> null;
      J := J + 1;
      if J > N then
         goto L90;
      end if;
      if RHO * abs (Z (J)) <= TOL then
         --
         --        Deflate due to small z component.
         --
         K2         := K2 - 1;
         INDXP (K2) := J;
      else
         --
         --        Check if eigenvalues are close enough to allow deflation.
         --
         S := Z (JLAM);
         C := Z (J);
         --
         --        Find sqrt(a**2+b**2) without overflow or
         --        destructive underflow.
         --
         TAU := DLAPY2 (C, S);
         T   := D (J) - D (JLAM);
         C   := C / TAU;
         S   := -S / TAU;
         if abs (T * C * S) <= TOL then
            --
            --           Deflation is possible.
            --
            Z (J)    := TAU;
            Z (JLAM) := ZERO;
            --
            --           Record the appropriate Givens rotation
            --
            GIVPTR             := GIVPTR + 1;
            GIVCOL (1, GIVPTR) := INDXQ (INDX (JLAM));
            GIVCOL (2, GIVPTR) := INDXQ (INDX (J));
            GIVNUM (1, GIVPTR) := C;
            GIVNUM (2, GIVPTR) := S;
            ZDROT (QSIZ, Q (1, INDXQ (INDX (JLAM)))'Address, 1, Q (1, INDXQ (INDX (J)))'Address, 1, C, S);
            T        := D (JLAM) * C * C + D (J) * S * S;
            D (J)    := D (JLAM) * S * S + D (J) * C * C;
            D (JLAM) := T;
            K2       := K2 - 1;
            I        := 1;
            <<L80>> null;
            if K2 + I <= N then
               if D (JLAM) < D (INDXP (K2 + I)) then
                  INDXP (K2 + I - 1) := INDXP (K2 + I);
                  INDXP (K2 + I)     := JLAM;
                  I                  := I + 1;
                  goto L80;
               else
                  INDXP (K2 + I - 1) := JLAM;
               end if;
            else
               INDXP (K2 + I - 1) := JLAM;
            end if;
            JLAM := J;
         else
            K          := K + 1;
            W (K)      := Z (JLAM);
            DLAMDA (K) := D (JLAM);
            INDXP (K)  := JLAM;
            JLAM       := J;
         end if;
      end if;
      goto L70;
      <<L90>> null;
      --
      --     Record the last eigenvalue.
      --
      K          := K + 1;
      W (K)      := Z (JLAM);
      DLAMDA (K) := D (JLAM);
      INDXP (K)  := JLAM;
      --
      <<L100>> null;
      --
      --     Sort the eigenvalues and corresponding eigenvectors into DLAMDA
      --     and Q2 respectively.  The eigenvalues/vectors which were not
      --     deflated go into the first K slots of DLAMDA and Q2 respectively,
      --     while those which were deflated go into the last N - K slots.
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         JP         := INDXP (J);
         DLAMDA (J) := D (JP);
         PERM (J)   := INDXQ (INDX (JP));
         ZCOPY (QSIZ, Q (1, PERM (J))'Address, 1, Q2 (1, J)'Address, 1);
      end loop;
      --
      --     The deflated eigenvalues and their corresponding vectors go back
      --     into the last N - K slots of D and Q respectively.
      --
      if K < N then
         DCOPY (N - K, DLAMDA (K + 1)'Address, 1, D (K + 1)'Address, 1);
         ZLACPY ('A', QSIZ, N - K, Q2 (1, K + 1)'Address, LDQ2, Q (1, K + 1)'Address, LDQ);
      end if;
      --
      return;
      --
      --     End of ZLAED8
      --
   end ZLAED8;

   procedure ZLAHQR
     (WANTT : Boolean;
      WANTZ : Boolean;
      N     : Integer;
      ILO   : Integer;
      IHI   : Integer;
      H_adr : Address;
      LDH   : Integer;
      W_adr : Address;
      ILOZ  : Integer;
      IHIZ  : Integer;
      Z_adr : Address;
      LDZ   : Integer;
      INFO  : in out Integer)
   is

      H : Ftn_Complex_Matrix (1 .. LDH, 1 .. N);
      W : Ftn_Complex_Vector (1 .. N);
      Z : Ftn_Complex_Matrix (1 .. LDZ, 1 .. N);

      for H'Address use H_adr;
      for W'Address use W_adr;
      for Z'Address use Z_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, W);
      pragma Import (Ada, Z);

      ITMAX  : Integer          := 30;
      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      RZERO  : constant Real    := 0.0e0;
      RONE   : constant Real    := 1.0e0;
      HALF   : constant Real    := 0.5e0;
      DAT1   : constant Real    := 0.75e0;
      CDUM   : Complex;
      H11    : Complex;
      H11S   : Complex;
      H22    : Complex;
      SC     : Complex;
      SUM    : Complex;
      T      : Complex;
      T1     : Complex;
      TEMP   : Complex;
      U      : Complex;
      V2     : Complex;
      X      : Complex;
      Y      : Complex;
      AA     : Real;
      AB     : Real;
      BA     : Real;
      BB     : Real;
      H10    : Real;
      H21    : Real;
      RTEMP  : Real;
      S      : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SMLNUM : Real;
      SX     : Real;
      T2     : Real;
      TST    : Real;
      ULP    : Real;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      ITS    : Integer;
      J      : Integer;
      JHI    : Integer;
      JLO    : Integer;
      K      : Integer;
      L      : Integer;
      M      : Integer;
      NH     : Integer;
      NZ     : Integer;
      V      : Ftn_Complex_Vector (1 .. 2);

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAHQR( WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ,
   --                          IHIZ, Z, LDZ, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, N
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         H( LDH, * ), W( * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZLAHQR is an auxiliary routine called by CHSEQR to update the
   --     eigenvalues and Schur decomposition already computed by CHSEQR, by
   --     dealing with the Hessenberg submatrix in rows and columns ILO to
   --     IHI.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           = .TRUE. : the full Schur form T is required;
   --           = .FALSE.: only eigenvalues are required.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           = .TRUE. : the matrix of Schur vectors Z is required;
   --           = .FALSE.: Schur vectors are not required.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix H.  N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --           It is assumed that H is already upper triangular in rows and
   --           columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1).
   --           ZLAHQR works primarily with the Hessenberg submatrix in rows
   --           and columns ILO to IHI, but applies transformations to all of
   --           H if WANTT is .TRUE..
   --           1 <= ILO <= max(1,IHI); IHI <= N.
   --
   --  [in,out] H
   --           H is COMPLEX*16 array, dimension (LDH,N)
   --           On entry, the upper Hessenberg matrix H.
   --           On exit, if INFO is zero and if WANTT is .TRUE., then H
   --           is upper triangular in rows and columns ILO:IHI.  If INFO
   --           is zero and if WANTT is .FALSE., then the contents of H
   --           are unspecified on exit.  The output state of H in case
   --           INF is positive is below under the description of INFO.
   --
   --  [in] LDH
   --           LDH is INTEGER
   --           The leading dimension of the array H. LDH >= max(1,N).
   --
   --  [out] W
   --           W is COMPLEX*16 array, dimension (N)
   --           The computed eigenvalues ILO to IHI are stored in the
   --           corresponding elements of W. If WANTT is .TRUE., the
   --           eigenvalues are stored in the same order as on the diagonal
   --           of the Schur form returned in H, with W(i) = H(i,i).
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --           Specify the rows of Z to which transformations must be
   --           applied if WANTZ is .TRUE..
   --           1 <= ILOZ <= ILO; IHI <= IHIZ <= N.
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array, dimension (LDZ,N)
   --           If WANTZ is .TRUE., on entry Z must contain the current
   --           matrix Z of transformations accumulated by CHSEQR, and on
   --           exit Z has been updated; transformations are applied only to
   --           the submatrix Z(ILOZ:IHIZ,ILO:IHI).
   --           If WANTZ is .FALSE., Z is not referenced.
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --           The leading dimension of the array Z. LDZ >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --            =   0: successful exit
   --           .GT. 0: if INFO = i, ZLAHQR failed to compute all the
   --                   eigenvalues ILO to IHI in a total of 30 iterations
   --                   per eigenvalue; elements i+1:ihi of W contain
   --                   those eigenvalues which have been successfully
   --                   computed.
   --
   --                   If INFO .GT. 0 and WANTT is .FALSE., then on exit,
   --                   the remaining unconverged eigenvalues are the
   --                   eigenvalues of the upper Hessenberg matrix
   --                   rows and columns ILO thorugh INFO of the final,
   --                   output value of H.
   --
   --                   If INFO .GT. 0 and WANTT is .TRUE., then on exit
   --           (*)       (initial value of H)*U  = U*(final value of H)
   --                   where U is an orthognal matrix.    The final
   --                   value of H is upper Hessenberg and triangular in
   --                   rows and columns INFO+1 through IHI.
   --
   --                   If INFO .GT. 0 and WANTZ is .TRUE., then on exit
   --                       (final value of Z)  = (initial value of Z)*U
   --                   where U is the orthogonal matrix in (*)
   --                   (regardless of the value of WANTT.)
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --
   --      02-96 Based on modifications by
   --      David Day, Sandia National Laboratory, USA
   --
   --      12-04 Further modifications by
   --      Ralph Byers, University of Kansas, USA
   --      This is a modified version of ZLAHQR from LAPACK version 3.0.
   --      It is (1) more robust against overflow and underflow and
   --      (2) adopts the more conservative Ahues & Tisseur stopping
   --      criterion (LAWN 122, 1997).
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =========================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ITMAX = 30 )
   --      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ), ONE = ( 1.0d0, 0.0d0 ) )
   --      PARAMETER          ( RZERO = 0.0d0, RONE = 1.0d0, HALF = 0.5d0 )
   --      PARAMETER          ( DAT1 = 3.0d0 / 4.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --       COMPLEX*16         ZLADIV
   --       DOUBLE PRECISION   DLAMCH
   --       EXTERNAL           ZLADIV, DLAMCH
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           DLABAD, ZCOPY, ZLARFG, ZSCAL
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCONJG, DIMAG, MAX, MIN, SQRT
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      --
      INFO := 0;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      if ILO = IHI then
         W (ILO) := H (ILO, ILO);
         return;
      end if;
      --
      --     ==== clear out the trash ====
      J := ILO - 1;
      loop
         J := J + 1;
         exit when J > IHI - 3;
         H (J + 2, J) := ZERO;
         H (J + 3, J) := ZERO;
      end loop;
      if ILO <= IHI - 2 then
         H (IHI, IHI - 2) := ZERO;
      end if;
      --     ==== ensure that subdiagonal entries are real ====
      if WANTT then
         JLO := 1;
         JHI := N;
      else
         JLO := ILO;
         JHI := IHI;
      end if;
      I := ILO + 1 - 1;
      loop
         I := I + 1;
         exit when I > IHI;
         if dimag (H (I, I - 1)) /= RZERO then
            --           ==== The following redundant normalization
            --           .    avoids problems with both gradual and
            --           .    sudden underflow in ABS(H(I,I-1)) ====
            SC           := H (I, I - 1) / CABS1 (H (I, I - 1));
            SC           := dconjg (SC) / abs (SC);
            H (I, I - 1) := Complex'(abs (H (I, I - 1)), 0.0e0);
            ZSCAL (JHI - I + 1, SC, H (I, I)'Address, LDH);
            ZSCAL (min (JHI, I + 1) - JLO + 1, dconjg (SC), H (JLO, I)'Address, 1);
            if WANTZ then
               ZSCAL (IHIZ - ILOZ + 1, dconjg (SC), Z (ILOZ, I)'Address, 1);
            end if;
         end if;
      end loop;
      --
      NH := IHI - ILO + 1;
      NZ := IHIZ - ILOZ + 1;
      --
      --     Set machine-dependent constants for the stopping criterion.
      --
      SAFMIN := DLAMCH ('S');
      SAFMAX := RONE / SAFMIN;
      DLABAD (SAFMIN, SAFMAX);
      ULP    := DLAMCH ('P');
      SMLNUM := SAFMIN * (Real (NH) / ULP);
      --
      --     I1 and I2 are the indices of the first row and last column of H
      --     to which transformations must be applied. If eigenvalues only are
      --     being computed, I1 and I2 are set inside the main loop.
      --
      if WANTT then
         I1 := 1;
         I2 := N;
      end if;
      --
      --     The main loop begins here. I is the loop index and decreases from
      --     IHI to ILO in steps of 1. Each iteration of the loop works
      --     with the active submatrix in rows and columns L to I.
      --     Eigenvalues I+1 to IHI have already converged. Either L = ILO, or
      --     H(L,L-1) is negligible so that the matrix splits.
      --
      I := IHI;
      <<L30>> null;
      if I < ILO then
         goto L150;
      end if;
      --
      --     Perform QR iterations on rows and columns ILO to I until a
      --     submatrix of order 1 splits off at the bottom because a
      --     subdiagonal element has become negligible.
      --
      L   := ILO;
      ITS := 0 - 1;
      loop
         ITS := ITS + 1;
         exit when ITS > ITMAX;
         --
         --        Look for a single small subdiagonal element.
         --
         K := I + 1;
         loop
            K := K - 1;
            exit when K < L + 1;
            if CABS1 (H (K, K - 1)) <= SMLNUM then
               goto L50;
            end if;
            TST := CABS1 (H (K - 1, K - 1)) + CABS1 (H (K, K));
            if TST = RZERO then
               if K - 2 >= ILO then
                  TST := TST + abs (dble (H (K - 1, K - 2)));
               end if;
               if K + 1 <= IHI then
                  TST := TST + abs (dble (H (K + 1, K)));
               end if;
            end if;
            --           ==== The following is a conservative small subdiagonal
            --           .    deflation criterion due to Ahues & Tisseur (LAWN 122,
            --           .    1997). It has better mathematical foundation and
            --           .    improves accuracy in some examples.  ====
            if abs (dble (H (K, K - 1))) <= ULP * TST then
               AB := max (CABS1 (H (K, K - 1)), CABS1 (H (K - 1, K)));
               BA := min (CABS1 (H (K, K - 1)), CABS1 (H (K - 1, K)));
               AA := max (CABS1 (H (K, K)), CABS1 (H (K - 1, K - 1) - H (K, K)));
               BB := min (CABS1 (H (K, K)), CABS1 (H (K - 1, K - 1) - H (K, K)));
               S  := AA + AB;
               if BA * (AB / S) <= max (SMLNUM, ULP * (BB * (AA / S))) then
                  goto L50;
               end if;
            end if;
         end loop;
         <<L50>> null;
         L := K;
         if L > ILO then
            --
            --           H(L,L-1) is negligible
            --
            H (L, L - 1) := ZERO;
         end if;
         --
         --        Exit from loop if a submatrix of order 1 has split off.
         --
         if L >= I then
            goto L140;
         end if;
         --
         --        Now the active submatrix is in rows and columns L to I. If
         --        eigenvalues only are being computed, only the active submatrix
         --        need be transformed.
         --
         if not WANTT then
            I1 := L;
            I2 := I;
         end if;
         --
         if ITS = 10 then
            --
            --           Exceptional shift.
            --
            S := DAT1 * abs (dble (H (L + 1, L)));
            T := S + H (L, L);
         elsif ITS = 20 then
            --
            --           Exceptional shift.
            --
            S := DAT1 * abs (dble (H (I, I - 1)));
            T := S + H (I, I);
         else
            --
            --           Wilkinson's shift.
            --
            T := H (I, I);
            U := Sqrt (H (I - 1, I)) * Sqrt (H (I, I - 1));
            S := CABS1 (U);
            if S /= RZERO then
               X  := HALF * (H (I - 1, I - 1) - T);
               SX := CABS1 (X);
               S  := max (S, CABS1 (X));
               Y  := S * Sqrt ((X / S) ** 2 + (U / S) ** 2);
               if SX > RZERO then
                  if dble (X / SX) * dble (Y) + dimag (X / SX) * dimag (Y) < RZERO then
                     Y := -Y;
                  end if;
               end if;
               T := T - U * ZLADIV (U, (X + Y));
            end if;
         end if;
         --
         --        Look for two consecutive small subdiagonal elements.
         --
         M := I - 1 + 1;
         loop
            M := M - 1;
            exit when M < L + 1;
            --
            --           Determine the effect of starting the single-shift QR
            --           iteration at row M, and see if this would make H(M,M-1)
            --           negligible.
            --
            H11   := H (M, M);
            H22   := H (M + 1, M + 1);
            H11S  := H11 - T;
            H21   := dble (H (M + 1, M));
            S     := CABS1 (H11S) + abs (H21);
            H11S  := H11S / S;
            H21   := H21 / S;
            V (1) := H11S;
            V (2) := Complex'(H21, 0.0e0);
            H10   := dble (H (M, M - 1));
            if abs (H10) * abs (H21) <= ULP * (CABS1 (H11S) * (CABS1 (H11) + CABS1 (H22))) then
               goto L70;
            end if;
         end loop;
         H11   := H (L, L);
         H22   := H (L + 1, L + 1);
         H11S  := H11 - T;
         H21   := dble (H (L + 1, L));
         S     := CABS1 (H11S) + abs (H21);
         H11S  := H11S / S;
         H21   := H21 / S;
         V (1) := H11S;
         V (2) := Complex'(H21, 0.0e0);
         <<L70>> null;
         --
         --        Single-shift QR step
         --
         K := M - 1;
         loop
            K := K + 1;
            exit when K > I - 1;
            --
            --           The first iteration of this loop determines a reflection G
            --           from the vector V and applies it from left and right to H,
            --           thus creating a nonzero bulge below the subdiagonal.
            --
            --           Each subsequent iteration determines a reflection G to
            --           restore the Hessenberg form in the (K-1)th column, and thus
            --           chases the bulge one step toward the bottom of the active
            --           submatrix.
            --
            --           V(2) is always real before the call to ZLARFG, and hence
            --           after the call T2 ( = T1*V(2) ) is also real.
            --
            if K > M then
               ZCOPY (2, H (K, K - 1)'Address, 1, V'Address, 1);
            end if;
            ZLARFG (2, V (1), V (2)'Address, 1, T1);
            if K > M then
               H (K, K - 1)     := V (1);
               H (K + 1, K - 1) := ZERO;
            end if;
            V2 := V (2);
            T2 := dble (T1 * V2);
            --
            --           Apply G from the left to transform the rows of the matrix
            --           in columns K to I2.
            --
            J := K - 1;
            loop
               J := J + 1;
               exit when J > I2;
               SUM          := dconjg (T1) * H (K, J) + T2 * H (K + 1, J);
               H (K, J)     := H (K, J) - SUM;
               H (K + 1, J) := H (K + 1, J) - SUM * V2;
            end loop;
            --
            --           Apply G from the right to transform the columns of the
            --           matrix in rows I1 to min(K+2,I).
            --
            J := I1 - 1;
            loop
               J := J + 1;
               exit when J > min (K + 2, I);
               SUM          := T1 * H (J, K) + T2 * H (J, K + 1);
               H (J, K)     := H (J, K) - SUM;
               H (J, K + 1) := H (J, K + 1) - SUM * dconjg (V2);
            end loop;
            --
            if WANTZ then
               --
               --              Accumulate transformations in the matrix Z
               --
               J := ILOZ - 1;
               loop
                  J := J + 1;
                  exit when J > IHIZ;
                  SUM          := T1 * Z (J, K) + T2 * Z (J, K + 1);
                  Z (J, K)     := Z (J, K) - SUM;
                  Z (J, K + 1) := Z (J, K + 1) - SUM * dconjg (V2);
               end loop;
            end if;
            --
            if K = M and M > L then
               --
               --              If the QR step was started at row M > L because two
               --              consecutive small subdiagonals were found, then extra
               --              scaling must be performed to ensure that H(M,M-1) remains
               --              real.
               --
               TEMP         := ONE - T1;
               TEMP         := TEMP / abs (TEMP);
               H (M + 1, M) := H (M + 1, M) * dconjg (TEMP);
               if M + 2 <= I then
                  H (M + 2, M + 1) := H (M + 2, M + 1) * TEMP;
               end if;
               J := M - 1;
               loop
                  J := J + 1;
                  exit when J > I;
                  if J /= M + 1 then
                     if I2 > J then
                        ZSCAL (I2 - J, TEMP, H (J, J + 1)'Address, LDH);
                     end if;
                     ZSCAL (J - I1, dconjg (TEMP), H (I1, J)'Address, 1);
                     if WANTZ then
                        ZSCAL (NZ, dconjg (TEMP), Z (ILOZ, J)'Address, 1);
                     end if;
                  end if;
               end loop;
            end if;
         end loop;
         --
         --        Ensure that H(I,I-1) is real.
         --
         TEMP := H (I, I - 1);
         if dimag (TEMP) /= RZERO then
            RTEMP        := abs (TEMP);
            H (I, I - 1) := Complex'(RTEMP, 0.0e0);
            TEMP         := TEMP / RTEMP;
            if I2 > I then
               ZSCAL (I2 - I, dconjg (TEMP), H (I, I + 1)'Address, LDH);
            end if;
            ZSCAL (I - I1, TEMP, H (I1, I)'Address, 1);
            if WANTZ then
               ZSCAL (NZ, TEMP, Z (ILOZ, I)'Address, 1);
            end if;
         end if;
         --
      end loop;
      --
      --     Failure to converge in remaining number of iterations
      --
      INFO := I;
      return;
      --
      <<L140>> null;
      --
      --     H(I,I-1) is negligible: one eigenvalue has converged.
      --
      W (I) := H (I, I);
      --
      --     return to start of the main loop with new value of I.
      --
      I := L - 1;
      goto L30;
      --
      <<L150>> null;
      return;
      --
      --     End of ZLAHQR
      --
   end ZLAHQR;

   procedure ZLAHR2
     (N       : Integer;
      K       : Integer;
      NB      : Integer;
      A_adr   : Address;
      LDA     : Integer;
      TAU_adr : Address;
      T_adr   : Address;
      LDT     : Integer;
      Y_adr   : Address;
      LDY     : Integer)
   is

      A   : Ftn_Complex_Matrix (1 .. LDA, 1 .. N - K + 1);
      TAU : Ftn_Complex_Vector (1 .. NB);
      T   : Ftn_Complex_Matrix (1 .. LDT, 1 .. NB);
      Y   : Ftn_Complex_Matrix (1 .. LDY, 1 .. NB);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for T'Address use T_adr;
      for Y'Address use Y_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, T);
      pragma Import (Ada, Y);

      ZERO : constant Complex := (0.0e0, 0.0e0);
      ONE  : constant Complex := (1.0e0, 0.0e0);
      I    : Integer;
      EI   : Complex;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAHR2( N, K, NB, A, LDA, TAU, T, LDT, Y, LDY )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            K, LDA, LDT, LDY, N, NB
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16        A( LDA, * ), T( LDT, NB ), TAU( NB ),
   --      $                   Y( LDY, NB )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
   --  matrix A so that elements below the k-th subdiagonal are zero. The
   --  reduction is performed by an unitary similarity transformation
   --  Q**H * A * Q. The routine returns the matrices V and T which determine
   --  Q as a block reflector I - V*T*V**H, and also the matrix Y = A * V * T.
   --
   --  This is an auxiliary routine called by ZGEHRD.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.
   --
   --  [in] K
   --           K is INTEGER
   --           The offset for the reduction. Elements below the k-th
   --           subdiagonal in the first NB columns are reduced to zero.
   --           K < N.
   --
   --  [in] NB
   --           NB is INTEGER
   --           The number of columns to be reduced.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N-K+1)
   --           On entry, the n-by-(n-k+1) general matrix A.
   --           On exit, the elements on and above the k-th subdiagonal in
   --           the first NB columns are overwritten with the corresponding
   --           elements of the reduced matrix; the elements below the k-th
   --           subdiagonal, with the array TAU, represent the matrix Q as a
   --           product of elementary reflectors. The other columns of A are
   --           unchanged. See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (NB)
   --           The scalar factors of the elementary reflectors. See Further
   --           Details.
   --
   --  [out] T
   --           T is COMPLEX*16 array, dimension (LDT,NB)
   --           The upper triangular matrix T.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T.  LDT >= NB.
   --
   --  [out] Y
   --           Y is COMPLEX*16 array, dimension (LDY,NB)
   --           The n-by-nb matrix Y.
   --
   --  [in] LDY
   --           LDY is INTEGER
   --           The leading dimension of the array Y. LDY >= N.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The matrix Q is represented as a product of nb elementary reflectors
   --
   --      Q = H(1) H(2) . . . H(nb).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
   --   A(i+k+1:n,i), and tau in TAU(i).
   --
   --   The elements of the vectors v together form the (n-k+1)-by-nb matrix
   --   V which is needed, with T and Y, to apply the transformation to the
   --   unreduced part of the matrix, using an update of the form:
   --   A := (I - V*T*V**H) * (A - Y*V**H).
   --
   --   The contents of A on exit are illustrated by the following example
   --   with n = 7, k = 3 and nb = 2:
   --
   --      ( a   a   a   a   a )
   --      ( a   a   a   a   a )
   --      ( a   a   a   a   a )
   --      ( h   h   a   a   a )
   --      ( v1  h   a   a   a )
   --      ( v1  v2  a   a   a )
   --      ( v1  v2  a   a   a )
   --
   --   where a denotes an element of the original matrix A, h denotes a
   --   modified element of the upper Hessenberg matrix H, and vi denotes an
   --   element of the vector defining H(i).
   --
   --   This subroutine is a slight modification of LAPACK-3.0's DLAHRD
   --   incorporating improvements proposed by Quintana-Orti and Van de
   --   Gejin. Note that the entries of A(1:K,2:NB) differ from those
   --   returned by the original LAPACK-3.0's DLAHRD routine. (This
   --   subroutine is not backward compatible with LAPACK-3.0's DLAHRD.)
   --
   --  References:
   --  ================
   --
   --   Gregorio Quintana-Orti and Robert van de Geijn, "Improving the
   --   performance of reduction to Hessenberg form," ACM Transactions on
   --   Mathematical Software, 32(2):180-194, June 2006.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ),  ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           ZAXPY, ZCOPY, ZGEMM, ZGEMV, ZLACPY,
   --      $                   ZLARFG, ZSCAL, ZTRMM, ZTRMV, ZLACGV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if N <= 1 then
         return;
      end if;
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > NB;
         if I > 1 then
            --
            --           Update A(K+1:N,I)
            --
            --           Update I-th column of A - Y * V**H
            --
            ZLACGV (I - 1, A (K + I - 1, 1)'Address, LDA);
            ZGEMV
              ('N',
               N - K,
               I - 1,
               -ONE,
               Y (K + 1, 1)'Address,
               LDY,
               A (K + I - 1, 1)'Address,
               LDA,
               ONE,
               A (K + 1, I)'Address,
               1);
            ZLACGV (I - 1, A (K + I - 1, 1)'Address, LDA);
            --
            --           Apply I - V * T**H * V**H to this column (call it b) from the
            --           left, using the last column of T as workspace
            --
            --           Let  V = ( V1 )   and   b = ( b1 )   (first I-1 rows)
            --                    ( V2 )             ( b2 )
            --
            --           where V1 is unit lower triangular
            --
            --           w := V1**H * b1
            --
            ZCOPY (I - 1, A (K + 1, I)'Address, 1, T (1, NB)'Address, 1);
            ZTRMV ('L', 'C', 'U', I - 1, A (K + 1, 1)'Address, LDA, T (1, NB)'Address, 1);
            --
            --           w := w + V2**H * b2
            --
            ZGEMV
              ('C',
               N - K - I + 1,
               I - 1,
               ONE,
               A (K + I, 1)'Address,
               LDA,
               A (K + I, I)'Address,
               1,
               ONE,
               T (1, NB)'Address,
               1);
            --
            --           w := T**H * w
            --
            ZTRMV ('U', 'C', 'N', I - 1, T'Address, LDT, T (1, NB)'Address, 1);
            --
            --           b2 := b2 - V2*w
            --
            ZGEMV
              ('N',
               N - K - I + 1,
               I - 1,
               -ONE,
               A (K + I, 1)'Address,
               LDA,
               T (1, NB)'Address,
               1,
               ONE,
               A (K + I, I)'Address,
               1);
            --
            --           b1 := b1 - V1*w
            --
            ZTRMV ('L', 'N', 'U', I - 1, A (K + 1, 1)'Address, LDA, T (1, NB)'Address, 1);
            ZAXPY (I - 1, -ONE, T (1, NB)'Address, 1, A (K + 1, I)'Address, 1);
            --
            A (K + I - 1, I - 1) := EI;
         end if;
         --
         --        Generate the elementary reflector H(I) to annihilate
         --        A(K+I+1:N,I)
         --
         ZLARFG (N - K - I + 1, A (K + I, I), A (min (K + I + 1, N), I)'Address, 1, TAU (I));
         EI           := A (K + I, I);
         A (K + I, I) := ONE;
         --
         --        Compute  Y(K+1:N,I)
         --
         ZGEMV
           ('N',
            N - K,
            N - K - I + 1,
            ONE,
            A (K + 1, I + 1)'Address,
            LDA,
            A (K + I, I)'Address,
            1,
            ZERO,
            Y (K + 1, I)'Address,
            1);
         ZGEMV
           ('C',
            N - K - I + 1,
            I - 1,
            ONE,
            A (K + I, 1)'Address,
            LDA,
            A (K + I, I)'Address,
            1,
            ZERO,
            T (1, I)'Address,
            1);
         ZGEMV ('N', N - K, I - 1, -ONE, Y (K + 1, 1)'Address, LDY, T (1, I)'Address, 1, ONE, Y (K + 1, I)'Address, 1);
         ZSCAL (N - K, TAU (I), Y (K + 1, I)'Address, 1);
         --
         --        Compute T(1:I,I)
         --
         ZSCAL (I - 1, -TAU (I), T (1, I)'Address, 1);
         ZTRMV ('U', 'N', 'N', I - 1, T'Address, LDT, T (1, I)'Address, 1);
         T (I, I) := TAU (I);
         --
      end loop;
      A (K + NB, NB) := EI;
      --
      --     Compute Y(1:K,1:NB)
      --
      ZLACPY ('A', K, NB, A (1, 2)'Address, LDA, Y'Address, LDY);
      ZTRMM ('R', 'L', 'N', 'U', K, NB, ONE, A (K + 1, 1)'Address, LDA, Y'Address, LDY);
      if N > K + NB then
         ZGEMM
           ('N',
            'N',
            K,
            NB,
            N - K - NB,
            ONE,
            A (1, 2 + NB)'Address,
            LDA,
            A (K + 1 + NB, 1)'Address,
            LDA,
            ONE,
            Y'Address,
            LDY);
      end if;
      ZTRMM ('R', 'U', 'N', 'N', K, NB, ONE, T'Address, LDT, Y'Address, LDY);
      --
      return;
      --
      --     End of ZLAHR2
      --
   end ZLAHR2;

   function ZLANGE
     (NORM : Character;
      M    : Integer;
      N    : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer;
      WORK : in out Ftn_Real_Vector)
      return Real
   is
      ONE           : constant Real := 1.0e0;
      ZERO          : constant Real := 0.0e0;
      I             : Integer;
      J             : Integer;
      SCALE         : Real;
      SUM           : Real;
      VALUE         : Real;
      ZLANGE_Result : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       DOUBLE PRECISION FUNCTION ZLANGE( NORM, M, N, A, LDA, WORK )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          NORM
   --       INTEGER            LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   WORK( * )
   --       COMPLEX*16         A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLANGE  returns the value of the one norm,  or the Frobenius norm, or
   --  the  infinity norm,  or the  element of  largest absolute value  of a
   --  complex matrix A.
   --
   --  \return ZLANGE
   --
   --     ZLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm' )
   --
   --              ( norm1(A),         NORM = '1', 'O' or 'o' )
   --
   --              ( normI(A),         NORM = 'I' or 'i' )
   --
   --              ( normF(A),         NORM = 'F', 'f', 'E' or 'e' )
   --
   --  where  norm1  denotes the  one norm of a matrix (maximum column sum),
   --  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
   --  normF  denotes the  Frobenius norm of a matrix (square root of sum of
   --  squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] NORM
   --           NORM is CHARACTER*1
   --           Specifies the value to be returned in ZLANGE as described
   --           above.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.  When M = 0,
   --           ZLANGE is set to zero.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.  When N = 0,
   --           ZLANGE is set to zero.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The m by n matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(M,1).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
   --           where LWORK >= M when NORM = 'I'; otherwise, WORK is not
   --           referenced.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZLASSQ
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if min (M, N) = 0 then
         VALUE := ZERO;
      elsif LSAME (NORM, 'M') then
         --
         --        Find max(abs(A(i,j))).
         --
         VALUE := ZERO;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               VALUE := max (VALUE, abs (A (I, J)));
            end loop;
         end loop;
      -- LCB: check the following, should it be (NORM = '1') or LSAME(NORM, '1') ?
      elsif (LSAME (NORM, 'O')) or (NORM = '1') then
         --
         --        Find norm1(A).
         --
         VALUE := ZERO;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            SUM := ZERO;
            I   := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               SUM := SUM + abs (A (I, J));
            end loop;
            VALUE := max (VALUE, SUM);
         end loop;
      elsif LSAME (NORM, 'I') then
         --
         --        Find normI(A).
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            WORK (I) := ZERO;
         end loop;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               WORK (I) := WORK (I) + abs (A (I, J));
            end loop;
         end loop;
         VALUE := ZERO;
         I     := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            VALUE := max (VALUE, WORK (I));
         end loop;
      elsif (LSAME (NORM, 'F')) or (LSAME (NORM, 'E')) then
         --
         --        Find normF(A).
         --
         SCALE := ZERO;
         SUM   := ONE;
         J     := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            ZLASSQ (M, A (1, J)'Address, 1, SCALE, SUM);
         end loop;
         VALUE := SCALE * Sqrt (SUM);
      end if;
      --
      ZLANGE_Result := VALUE;
      return ZLANGE_Result;
      --
      --     End of ZLANGE
      --
   end ZLANGE;

   function ZLANHE
     (NORM : Character;
      UPLO : Character;
      N    : Integer;
      A    : Ftn_Complex_Matrix;
      LDA  : Integer;
      WORK : in out Ftn_Real_Vector)
      return Real
   is
      ONE           : constant Real := 1.0e0;
      ZERO          : constant Real := 0.0e0;
      I             : Integer;
      J             : Integer;
      ABSA          : Real;
      SCALE         : Real;
      SUM           : Real;
      VALUE         : Real;
      ZLANHE_Result : Real;

   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZLASSQ
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, MAX, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N = 0 then
         VALUE := ZERO;
      elsif LSAME (NORM, 'M') then
         --
         --        Find max(abs(A(i,j))).
         --
         VALUE := ZERO;
         if LSAME (UPLO, 'U') then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J - 1;
                  VALUE := max (VALUE, abs (A (I, J)));
               end loop;
               VALUE := max (VALUE, abs (dble (A (J, J))));
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               VALUE := max (VALUE, abs (dble (A (J, J))));
               I     := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  VALUE := max (VALUE, abs (A (I, J)));
               end loop;
            end loop;
         end if;
      elsif (LSAME (NORM, 'I')) or (LSAME (NORM, 'O')) or (NORM = '1') then
         --
         --        Find normI(A) ( = norm1(A), since A is hermitian).
         --
         VALUE := ZERO;
         if LSAME (UPLO, 'U') then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               SUM := ZERO;
               I   := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > J - 1;
                  ABSA     := abs (A (I, J));
                  SUM      := SUM + ABSA;
                  WORK (I) := WORK (I) + ABSA;
               end loop;
               WORK (J) := SUM + abs (dble (A (J, J)));
            end loop;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               VALUE := max (VALUE, WORK (I));
            end loop;
         else
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               WORK (I) := ZERO;
            end loop;
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               SUM := WORK (J) + abs (dble (A (J, J)));
               I   := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  ABSA     := abs (A (I, J));
                  SUM      := SUM + ABSA;
                  WORK (I) := WORK (I) + ABSA;
               end loop;
               VALUE := max (VALUE, SUM);
            end loop;
         end if;
      elsif (LSAME (NORM, 'F')) or (LSAME (NORM, 'E')) then
         --
         --        Find normF(A).
         --
         SCALE := ZERO;
         SUM   := ONE;
         if LSAME (UPLO, 'U') then
            J := 2 - 1;
            loop
               J := J + 1;
               exit when J > N;
               ZLASSQ (J - 1, A (1, J)'Address, 1, SCALE, SUM);
            end loop;
         else
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N - 1;
               ZLASSQ (N - J, A (J + 1, J)'Address, 1, SCALE, SUM);
            end loop;
         end if;
         SUM := 2.0 * SUM;
         I   := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            if dble (A (I, I)) /= ZERO then
               ABSA := abs (dble (A (I, I)));
               if SCALE < ABSA then
                  SUM   := ONE + SUM * (SCALE / ABSA) ** 2;
                  SCALE := ABSA;
               else
                  SUM := SUM + (ABSA / SCALE) ** 2;
               end if;
            end if;
         end loop;
         VALUE := SCALE * Sqrt (SUM);
      end if;
      --
      ZLANHE_Result := VALUE;
      return ZLANHE_Result;
      --
      --     End of ZLANHE
      --
   end ZLANHE;

   procedure ZLAQR0
     (WANTT : Boolean;
      WANTZ : Boolean;
      N     : Integer;
      ILO   : Integer;
      IHI   : Integer;
      H     : in out Ftn_Complex_Matrix;
      LDH   : Integer;
      W     : in out Ftn_Complex_Vector;
      ILOZ  : Integer;
      IHIZ  : Integer;
      Z     : in out Ftn_Complex_Matrix;
      LDZ   : Integer;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      NTINY  : constant Integer := 11;
      KEXNW  : constant Integer := 5;
      KEXSH  : constant Integer := 6;
      WILK1  : constant Real    := 0.75e0;
      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      TWO    : constant Real    := 2.0e0;
      AA     : Complex;
      BB     : Complex;
      CC     : Complex;
      CDUM   : Complex;
      DD     : Complex;
      DET    : Complex;
      RTDISC : Complex;
      SWAP   : Complex;
      TR2    : Complex;
      S      : Real;
      I      : Integer;
      INF    : Integer;
      IT     : Integer;
      ITMAX  : Integer;
      K      : Integer;
      KACC22 : Integer;
      KBOT   : Integer;
      KDU    : Integer;
      KS     : Integer;
      KT     : Integer;
      KTOP   : Integer;
      KU     : Integer;
      KV     : Integer;
      KWH    : Integer;
      KWTOP  : Integer;
      KWV    : Integer;
      LD     : Integer;
      LS     : Integer;
      LWKOPT : Integer;
      NDEC   : Integer;
      NDFL   : Integer;
      NH     : Integer;
      NHO    : Integer;
      NIBBLE : Integer;
      NMIN   : Integer;
      NS     : Integer;
      NSMAX  : Integer;
      NSR    : Integer;
      NVE    : Integer;
      NW     : Integer;
      NWMAX  : Integer;
      NWR    : Integer;
      NWUPBD : Integer;
      SORTED : Boolean;
      JBCMPZ : String (1 .. 2);
      ZDUM   : Ftn_Complex_Matrix (1 .. 1, 1 .. 1);

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAQR0( WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ,
   --                          IHIZ, Z, LDZ, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, LWORK, N
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         H( LDH, * ), W( * ), WORK( * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZLAQR0 computes the eigenvalues of a Hessenberg matrix H
   --     and, optionally, the matrices T and Z from the Schur decomposition
   --     H = Z T Z**H, where T is an upper triangular matrix (the
   --     Schur form), and Z is the unitary matrix of Schur vectors.
   --
   --     Optionally Z may be postmultiplied into an input unitary
   --     matrix Q so that this routine can give the Schur factorization
   --     of a matrix A which has been reduced to the Hessenberg form H
   --     by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           = .TRUE. : the full Schur form T is required;
   --           = .FALSE.: only eigenvalues are required.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           = .TRUE. : the matrix of Schur vectors Z is required;
   --           = .FALSE.: Schur vectors are not required.
   --
   --  [in] N
   --           N is INTEGER
   --            The order of the matrix H.  N .GE. 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --            It is assumed that H is already upper triangular in rows
   --            and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
   --            H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
   --            previous call to ZGEBAL, and then passed to ZGEHRD when the
   --            matrix output by ZGEBAL is reduced to Hessenberg form.
   --            Otherwise, ILO and IHI should be set to 1 and N,
   --            respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
   --            If N = 0, then ILO = 1 and IHI = 0.
   --
   --  [in,out] H
   --           H is COMPLEX*16 array, dimension (LDH,N)
   --            On entry, the upper Hessenberg matrix H.
   --            On exit, if INFO = 0 and WANTT is .TRUE., then H
   --            contains the upper triangular matrix T from the Schur
   --            decomposition (the Schur form). If INFO = 0 and WANT is
   --            .FALSE., then the contents of H are unspecified on exit.
   --            (The output value of H when INFO.GT.0 is given under the
   --            description of INFO below.)
   --
   --            This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
   --            j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
   --
   --  [in] LDH
   --           LDH is INTEGER
   --            The leading dimension of the array H. LDH .GE. max(1,N).
   --
   --  [out] W
   --           W is COMPLEX*16 array, dimension (N)
   --            The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
   --            in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
   --            stored in the same order as on the diagonal of the Schur
   --            form returned in H, with W(i) = H(i,i).
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --            Specify the rows of Z to which transformations must be
   --            applied if WANTZ is .TRUE..
   --            1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array, dimension (LDZ,IHI)
   --            If WANTZ is .FALSE., then Z is not referenced.
   --            If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
   --            replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
   --            orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
   --            (The output value of Z when INFO.GT.0 is given under
   --            the description of INFO below.)
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --            The leading dimension of the array Z.  if WANTZ is .TRUE.
   --            then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension LWORK
   --            On exit, if LWORK = -1, WORK(1) returns an estimate of
   --            the optimal value for LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --            The dimension of the array WORK.  LWORK .GE. max(1,N)
   --            is sufficient, but LWORK typically as large as 6*N may
   --            be required for optimal performance.  A workspace query
   --            to determine the optimal workspace size is recommended.
   --
   --            If LWORK = -1, then ZLAQR0 does a workspace query.
   --            In this case, ZLAQR0 checks the input parameters and
   --            estimates the optimal workspace size for the given
   --            values of N, ILO and IHI.  The estimate is returned
   --            in WORK(1).  No error message related to LWORK is
   --            issued by XERBLA.  Neither H nor Z are accessed.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --              =  0:  successful exit
   --            .GT. 0:  if INFO = i, ZLAQR0 failed to compute all of
   --                 the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
   --                 and WI contain those eigenvalues which have been
   --                 successfully computed.  (Failures are rare.)
   --
   --                 If INFO .GT. 0 and WANT is .FALSE., then on exit,
   --                 the remaining unconverged eigenvalues are the eigen-
   --                 values of the upper Hessenberg matrix rows and
   --                 columns ILO through INFO of the final, output
   --                 value of H.
   --
   --                 If INFO .GT. 0 and WANTT is .TRUE., then on exit
   --
   --            (*)  (initial value of H)*U  = U*(final value of H)
   --
   --                 where U is a unitary matrix.  The final
   --                 value of  H is upper Hessenberg and triangular in
   --                 rows and columns INFO+1 through IHI.
   --
   --                 If INFO .GT. 0 and WANTZ is .TRUE., then on exit
   --
   --                   final value of Z(ILO:IHI,ILOZ:IHIZ)
   --                    =  initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
   --
   --                 where U is the unitary matrix in (*) (regard-
   --                 less of the value of WANTT.)
   --
   --                 If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
   --                 accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  References:
   --  ================
   --
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
   --        Performance, SIAM Journal of Matrix Analysis, volume 23, pages
   --        929--947, 2002.
   --  \n
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part II: Aggressive Early Deflation, SIAM Journal
   --        of Matrix Analysis, volume 23, pages 948--973, 2002.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --
   --     .. Parameters ..
   --
   --     ==== Matrices of order NTINY or smaller must be processed by
   --     .    ZLAHQR because of insufficient subdiagonal scratch space.
   --     .    (This is a hard limit.) ====
   --      PARAMETER          ( NTINY = 11 )
   --
   --     ==== Exceptional deflation windows:  try to cure rare
   --     .    slow convergence by varying the size of the
   --     .    deflation window after KEXNW iterations. ====
   --      PARAMETER          ( KEXNW = 5 )
   --
   --     ==== Exceptional shifts: try to cure rare slow convergence
   --     .    with ad-hoc exceptional shifts every KEXSH iterations.
   --     .    ====
   --      PARAMETER          ( KEXSH = 6 )
   --
   --     ==== The constant WILK1 is used to form the exceptional
   --     .    shifts. ====
   --      PARAMETER          ( WILK1 = 0.75d0 )
   --      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ), ONE = ( 1.0d0, 0.0d0 ) )
   --      PARAMETER          ( TWO = 2.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       INTEGER            ILAENV
   --       EXTERNAL           ILAENV
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           ZLACPY, ZLAHQR, ZLAQR3, ZLAQR4, ZLAQR5
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCMPLX, DIMAG, INT, MAX, MIN, MOD, SQRT
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      INFO := 0;
      --
      --     ==== Quick return for N = 0: nothing to do. ====
      --
      if N = 0 then
         WORK (1) := ONE;
         return;
      end if;
      --
      if N <= NTINY then
         --
         --        ==== Tiny matrices must use ZLAHQR. ====
         --
         LWKOPT := 1;
         if LWORK /= -1 then
            ZLAHQR (WANTT, WANTZ, N, ILO, IHI, H'Address, LDH, W'Address, ILOZ, IHIZ, Z'Address, LDZ, INFO);
         end if;
      else
         --
         --        ==== Use small bulge multi-shift QR with aggressive early
         --        .    deflation on larger-than-tiny matrices. ====
         --
         --        ==== Hope for the best. ====
         --
         INFO := 0;
         --
         --        ==== Set up job flags for ILAENV. ====
         --
         if WANTT 
            then JBCMPZ (1) := 'S';
            else JBCMPZ (1) := 'E';
         end if;
         if WANTZ 
            then JBCMPZ (2) := 'V';
            else JBCMPZ (2) := 'N';
         end if;
         --
         --        ==== NWR = recommended deflation window size.  At this
         --        .    point,  N .GT. NTINY = 11, so there is enough
         --        .    subdiagonal workspace for NWR.GE.2 as required.
         --        .    (In fact, there is enough subdiagonal space for
         --        .    NWR.GE.3.) ====
         --
         NWR := ILAENV (13, "ZLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         NWR := max (2, NWR);
         NWR := min (IHI - ILO + 1, (N - 1) / 3, NWR);
         --
         --        ==== NSR = recommended number of simultaneous shifts.
         --        .    At this point N .GT. NTINY = 11, so there is at
         --        .    enough subdiagonal workspace for NSR to be even
         --        .    and greater than or equal to two as required. ====
         --
         NSR := ILAENV (15, "ZLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         NSR := min (NSR, (N + 6) / 9, IHI - ILO);
         NSR := max (2, NSR - "mod" (NSR, 2));
         --
         --        ==== Estimate optimal workspace ====
         --
         --        ==== Workspace query call to ZLAQR3 ====
         --
         ZLAQR3
           (WANTT,
            WANTZ,
            N,
            ILO,
            IHI,
            NWR + 1,
            H'Address,
            LDH,
            ILOZ,
            IHIZ,
            Z'Address,
            LDZ,
            LS,
            LD,
            W'Address,
            H'Address,
            LDH,
            N,
            H'Address,
            LDH,
            N,
            H'Address,
            LDH,
            WORK'Address,
            -1);
         --
         --        ==== Optimal workspace = MAX(ZLAQR5, ZLAQR3) ====
         --
         LWKOPT := max (3 * NSR / 2, int (real_part (WORK (1))));
         --
         --        ==== Quick return in case of workspace query. ====
         --
         if LWORK = -1 then
            WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
            return;
         end if;
         --
         --        ==== ZLAHQR/ZLAQR0 crossover point ====
         --
         NMIN := ILAENV (12, "ZLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         NMIN := max (NTINY, NMIN);
         --
         --        ==== Nibble crossover point ====
         --
         NIBBLE := ILAENV (14, "ZLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         NIBBLE := max (0, NIBBLE);
         --
         --        ==== Accumulate reflections during ttswp?  Use block
         --        .    2-by-2 structure during matrix-matrix multiply? ====
         --
         KACC22 := ILAENV (16, "ZLAQR0", JBCMPZ, N, ILO, IHI, LWORK);
         KACC22 := max (0, KACC22);
         KACC22 := min (2, KACC22);
         --
         --        ==== NWMAX = the largest possible deflation window for
         --        .    which there is sufficient workspace. ====
         --
         NWMAX := min ((N - 1) / 3, LWORK / 2);
         NW    := NWMAX;
         --
         --        ==== NSMAX = the Largest number of simultaneous shifts
         --        .    for which there is sufficient workspace. ====
         --
         NSMAX := min ((N + 6) / 9, 2 * LWORK / 3);
         NSMAX := NSMAX - "mod" (NSMAX, 2);
         --
         --        ==== NDFL: an iteration count restarted at deflation. ====
         --
         NDFL := 1;
         --
         --        ==== ITMAX = iteration limit ====
         --
         ITMAX := max (30, 2 * KEXSH) * max (10, (IHI - ILO + 1));
         --
         --        ==== Last row and column in the active block ====
         --
         KBOT := IHI;
         --
         --        ==== Main Loop ====
         --
         IT := 1 - 1;
         loop
            IT := IT + 1;
            exit when IT > ITMAX;
            --
            --           ==== Done when KBOT falls below ILO ====
            --
            if KBOT < ILO then
               goto L80;
            end if;
            --
            --           ==== Locate active block ====
            --
            K := KBOT + 1;
            loop
               K := K - 1;
               exit when K < ILO + 1;
               if H (K, K - 1) = ZERO then
                  goto L20;
               end if;
            end loop;
            K := ILO;
            <<L20>> null;
            KTOP := K;
            --
            --           ==== Select deflation window size:
            --           .    Typical Case:
            --           .      If possible and advisable, nibble the entire
            --           .      active block.  If not, use size MIN(NWR,NWMAX)
            --           .      or MIN(NWR+1,NWMAX) depending upon which has
            --           .      the smaller corresponding subdiagonal entry
            --           .      (a heuristic).
            --           .
            --           .    Exceptional Case:
            --           .      If there have been no deflations in KEXNW or
            --           .      more iterations, then vary the deflation window
            --           .      size.   At first, because, larger windows are,
            --           .      in general, more powerful than smaller ones,
            --           .      rapidly increase the window to the maximum possible.
            --           .      Then, gradually reduce the window size. ====
            --
            NH     := KBOT - KTOP + 1;
            NWUPBD := min (NH, NWMAX);
            if NDFL < KEXNW 
               then NW := min (NWUPBD, NWR);
               else NW := min (NWUPBD, 2 * NW);
            end if;
            if NW < NWMAX then
               if NW >= NH - 1 then
                  NW := NH;
               else
                  KWTOP := KBOT - NW + 1;
                  if CABS1 (H (KWTOP, KWTOP - 1)) > CABS1 (H (KWTOP - 1, KWTOP - 2)) then
                     NW := NW + 1;
                  end if;
               end if;
            end if;
            if NDFL < KEXNW then
               NDEC := -1;
            elsif NDEC >= 0 or NW >= NWUPBD then
               NDEC := NDEC + 1;
               if NW - NDEC < 2 then
                  NDEC := 0;
               end if;
               NW := NW - NDEC;
            end if;
            --
            --           ==== Aggressive early deflation:
            --           .    split workspace under the subdiagonal into
            --           .      - an nw-by-nw work array V in the lower
            --           .        left-hand-corner,
            --           .      - an NW-by-at-least-NW-but-more-is-better
            --           .        (NW-by-NHO) horizontal work array along
            --           .        the bottom edge,
            --           .      - an at-least-NW-but-more-is-better (NHV-by-NW)
            --           .        vertical work array along the left-hand-edge.
            --           .        ====
            --
            KV  := N - NW + 1;
            KT  := NW + 1;
            NHO := (N - NW - 1) - KT + 1;
            KWV := NW + 2;
            NVE := (N - NW) - KWV + 1;
            --
            --           ==== Aggressive early deflation ====
            --
            ZLAQR3
              (WANTT,
               WANTZ,
               N,
               KTOP,
               KBOT,
               NW,
               H'Address,
               LDH,
               ILOZ,
               IHIZ,
               Z'Address,
               LDZ,
               LS,
               LD,
               W'Address,
               H (KV, 1)'Address,
               LDH,
               NHO,
               H (KV, KT)'Address,
               LDH,
               NVE,
               H (KWV, 1)'Address,
               LDH,
               WORK'Address,
               LWORK);
            --
            --           ==== Adjust KBOT accounting for new deflations. ====
            --
            KBOT := KBOT - LD;
            --
            --           ==== KS points to the shifts. ====
            --
            KS := KBOT - LS + 1;
            --
            --           ==== Skip an expensive QR sweep if there is a (partly
            --           .    heuristic) reason to expect that many eigenvalues
            --           .    will deflate without it.  Here, the QR sweep is
            --           .    skipped if many eigenvalues have just been deflated
            --           .    or if the remaining active block is small.
            --
            if (LD = 0) or ((100 * LD <= NW * NIBBLE) and (KBOT - KTOP + 1 > min (NMIN, NWMAX))) then
               --
               --              ==== NS = nominal number of simultaneous shifts.
               --              .    This may be lowered (slightly) if ZLAQR3
               --              .    did not provide that many shifts. ====
               --
               NS := min (NSMAX, NSR, max (2, KBOT - KTOP));
               NS := NS - "mod" (NS, 2);
               --
               --              ==== If there have been no deflations
               --              .    in a multiple of KEXSH iterations,
               --              .    then try exceptional shifts.
               --              .    Otherwise use shifts provided by
               --              .    ZLAQR3 above or from the eigenvalues
               --              .    of a trailing principal submatrix. ====
               --
               if "mod" (NDFL, KEXSH) = 0 then
                  KS := KBOT - NS + 1;
                  I  := KBOT + 2;
                  loop
                     I := I - 2;
                     exit when I < KS + 1;
                     W (I)     := H (I, I) + WILK1 * CABS1 (H (I, I - 1));
                     W (I - 1) := W (I);
                  end loop;
               else
                  --
                  --                 ==== Got NS/2 or fewer shifts? Use ZLAQR4 or
                  --                 .    ZLAHQR on a trailing principal submatrix to
                  --                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                  --                 .    there is enough space below the subdiagonal
                  --                 .    to fit an NS-by-NS scratch array.) ====
                  --
                  if KBOT - KS + 1 <= NS / 2 then
                     KS := KBOT - NS + 1;
                     KT := N - NS + 1;
                     ZLACPY ('A', NS, NS, H (KS, KS)'Address, LDH, H (KT, 1)'Address, LDH);
                     if NS > NMIN then
                        ZLAQR4
                          (False,
                           False,
                           NS,
                           1,
                           NS,
                           H (KT, 1)'Address,
                           LDH,
                           W (KS)'Address,
                           1,
                           1,
                           ZDUM'Address,
                           1,
                           WORK'Address,
                           LWORK,
                           INF);
                     else
                        ZLAHQR (False, False, NS, 1, NS, H (KT, 1)'Address, LDH, W (KS)'Address, 1, 1, ZDUM'Address, 1, INF);
                     end if;
                     KS := KS + INF;
                     --
                     --                    ==== In case of a rare QR failure use
                     --                    .    eigenvalues of the trailing 2-by-2
                     --                    .    principal submatrix.  Scale to avoid
                     --                    .    overflows, underflows and subnormals.
                     --                    .    (The scale factor S can not be zero,
                     --                    .    because H(KBOT,KBOT-1) is nonzero.) ====
                     --
                     if KS >= KBOT then
                        S            := CABS1 (H (KBOT - 1, KBOT - 1)) +
                                        CABS1 (H (KBOT, KBOT - 1)) +
                                        CABS1 (H (KBOT - 1, KBOT)) +
                                        CABS1 (H (KBOT, KBOT));
                        AA           := H (KBOT - 1, KBOT - 1) / S;
                        CC           := H (KBOT, KBOT - 1) / S;
                        BB           := H (KBOT - 1, KBOT) / S;
                        DD           := H (KBOT, KBOT) / S;
                        TR2          := (AA + DD) / TWO;
                        DET          := (AA - TR2) * (DD - TR2) - BB * CC;
                        RTDISC       := Sqrt (-DET);
                        W (KBOT - 1) := (TR2 + RTDISC) * S;
                        W (KBOT)     := (TR2 - RTDISC) * S;
                        --
                        KS := KBOT - 1;
                     end if;
                  end if;
                  --
                  if KBOT - KS + 1 > NS then
                     --
                     --                    ==== Sort the shifts (Helps a little) ====
                     --
                     SORTED := False;
                     K      := KBOT + 1;
                     loop
                        K := K - 1;
                        exit when K < KS + 1;
                        if SORTED then
                           goto L60;
                        end if;
                        SORTED := True;
                        I      := KS - 1;
                        loop
                           I := I + 1;
                           exit when I > K - 1;
                           if CABS1 (W (I)) < CABS1 (W (I + 1)) then
                              SORTED    := False;
                              SWAP      := W (I);
                              W (I)     := W (I + 1);
                              W (I + 1) := SWAP;
                           end if;
                        end loop;
                     end loop;
                     <<L60>> null;
                  end if;
               end if;
               --
               --              ==== If there are only two shifts, then use
               --              .    only one.  ====
               --
               if KBOT - KS + 1 = 2 then
                  if CABS1 (W (KBOT) - H (KBOT, KBOT)) < CABS1 (W (KBOT - 1) - H (KBOT, KBOT)) 
                     then W (KBOT - 1) := W (KBOT);
                     else W (KBOT) := W (KBOT - 1);
                  end if;
               end if;
               --
               --              ==== Use up to NS of the the smallest magnatiude
               --              .    shifts.  If there aren't NS shifts available,
               --              .    then use them all, possibly dropping one to
               --              .    make the number of shifts even. ====
               --
               NS := min (NS, KBOT - KS + 1);
               NS := NS - "mod" (NS, 2);
               KS := KBOT - NS + 1;
               --
               --              ==== Small-bulge multi-shift QR sweep:
               --              .    split workspace under the subdiagonal into
               --              .    - a KDU-by-KDU work array U in the lower
               --              .      left-hand-corner,
               --              .    - a KDU-by-at-least-KDU-but-more-is-better
               --              .      (KDU-by-NHo) horizontal work array WH along
               --              .      the bottom edge,
               --              .    - and an at-least-KDU-but-more-is-better-by-KDU
               --              .      (NVE-by-KDU) vertical work WV arrow along
               --              .      the left-hand-edge. ====
               --
               KDU := 3 * NS - 3;
               KU  := N - KDU + 1;
               KWH := KDU + 1;
               NHO := (N - KDU + 1 - 4) - (KDU + 1) + 1;
               KWV := KDU + 4;
               NVE := N - KDU - KWV + 1;
               --
               --              ==== Small-bulge multi-shift QR sweep ====
               --
               ZLAQR5
                 (WANTT,
                  WANTZ,
                  KACC22,
                  N,
                  KTOP,
                  KBOT,
                  NS,
                  W (KS)'Address,
                  H'Address,
                  LDH,
                  ILOZ,
                  IHIZ,
                  Z'Address,
                  LDZ,
                  WORK'Address,
                  3,
                  H (KU, 1)'Address,
                  LDH,
                  NVE,
                  H (KWV, 1)'Address,
                  LDH,
                  NHO,
                  H (KU, KWH)'Address,
                  LDH);
            end if;
            --
            --           ==== Note progress (or the lack of it). ====
            --
            if LD > 0 
               then NDFL := 1;
               else NDFL := NDFL + 1;
            end if;
            --
            --           ==== End of main loop ====
         end loop;
         --
         --        ==== Iteration limit exceeded.  Set INFO to show where
         --        .    the problem occurred and exit. ====
         --
         INFO := KBOT;
         <<L80>> null;
      end if;
      --
      --     ==== Return the optimal value of LWORK. ====
      --
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      --
      --     ==== End of ZLAQR0 ====
      --
   end ZLAQR0;

   procedure ZLAQR1
     (N     : Integer;
      H_adr : Address;
      LDH   : Integer;
      S1    : Complex;
      S2    : Complex;
      V_adr : Address)
   is

      H : Ftn_Complex_Matrix (1 .. LDH, 1 .. N);
      V : Ftn_Complex_Vector (1 .. N);

      for H'Address use H_adr;
      for V'Address use V_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, V);

      ZERO  : constant Complex := (0.0e0, 0.0e0);
      RZERO : constant Real    := 0.0e0;
      CDUM  : Complex;
      H21S  : Complex;
      H31S  : Complex;
      S     : Real;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAQR1( N, H, LDH, S1, S2, V)
   --
   --       .. Scalar Arguments ..
   --       COMPLEX*16         S1, S2
   --       INTEGER            LDH, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         H( LDH, * ), V( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --       Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1 sets v to a
   --       scalar multiple of the first column of the product
   --
   --       (*)  K = (H - s1*I)*(H - s2*I)
   --
   --       scaling to avoid overflows and most underflows.
   --
   --       This is useful for starting Real implicit shift bulges
   --       in the QR algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is integer
   --               Order of the matrix H. N must be either 2 or 3.
   --
   --  [in] H
   --           H is COMPLEX*16 array of dimension (LDH,N)
   --               The 2-by-2 or 3-by-3 matrix H in (*).
   --
   --  [in] LDH
   --           LDH is integer
   --               The leading dimension of H as declared in
   --               the calling procedure.  LDH.GE.N
   --
   --  [in] S1
   --           S1 is COMPLEX*16
   --
   --  [in] S2
   --           S2 is COMPLEX*16
   --
   --           S1 and S2 are the shifts defining K in (*) above.
   --
   --  [out] V
   --           V is COMPLEX*16 array of dimension N
   --               A scalar multiple of the first column of the
   --               matrix K in (*).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ) )
   --      PARAMETER          ( RZERO = 0.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DIMAG
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      if N = 2 then
         S := CABS1 (H (1, 1) - S2) + CABS1 (H (2, 1));
         if S = RZERO then
            V (1) := ZERO;
            V (2) := ZERO;
         else
            H21S  := H (2, 1) / S;
            V (1) := H21S * H (1, 2) + (H (1, 1) - S1) * ((H (1, 1) - S2) / S);
            V (2) := H21S * (H (1, 1) + H (2, 2) - S1 - S2);
         end if;
      else
         S := CABS1 (H (1, 1) - S2) + CABS1 (H (2, 1)) + CABS1 (H (3, 1));
         if S = RZERO then
            V (1) := ZERO;
            V (2) := ZERO;
            V (3) := ZERO;
         else
            H21S  := H (2, 1) / S;
            H31S  := H (3, 1) / S;
            V (1) := (H (1, 1) - S1) * ((H (1, 1) - S2) / S) + H (1, 2) * H21S + H (1, 3) * H31S;
            V (2) := H21S * (H (1, 1) + H (2, 2) - S1 - S2) + H (2, 3) * H31S;
            V (3) := H31S * (H (1, 1) + H (3, 3) - S1 - S2) + H21S * H (3, 2);
         end if;
      end if;
   end ZLAQR1;

   procedure ZLAQR2
     (WANTT    : Boolean;
      WANTZ    : Boolean;
      N        : Integer;
      KTOP     : Integer;
      KBOT     : Integer;
      NW       : Integer;
      H_adr    : Address;
      LDH      : Integer;
      ILOZ     : Integer;
      IHIZ     : Integer;
      Z_adr    : Address;
      LDZ      : Integer;
      NS       : in out Integer;
      ND       : in out Integer;
      SH_adr   : Address;
      V_adr    : Address;
      LDV      : Integer;
      NH       : Integer;
      T_adr    : Address;
      LDT      : Integer;
      NV       : Integer;
      WV_adr   : Address;
      LDWV     : Integer;
      WORK_adr : Address;
      LWORK    : Integer)
   is

      H    : Ftn_Complex_Matrix (1 .. LDH, 1 .. N);
      Z    : Ftn_Complex_Matrix (1 .. LDZ, 1 .. N);
      SH   : Ftn_Complex_Vector (1 .. KBOT);
      V    : Ftn_Complex_Matrix (1 .. LDV, 1 .. NW);
      T    : Ftn_Complex_Matrix (1 .. LDT, 1 .. NW);
      WV   : Ftn_Complex_Matrix (1 .. LDWV, 1 .. NW);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for H'Address use H_adr;
      for Z'Address use Z_adr;
      for SH'Address use SH_adr;
      for V'Address use V_adr;
      for T'Address use T_adr;
      for WV'Address use WV_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, Z);
      pragma Import (Ada, SH);
      pragma Import (Ada, V);
      pragma Import (Ada, T);
      pragma Import (Ada, WV);
      pragma Import (Ada, WORK);

      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      RZERO  : constant Real    := 0.0e0;
      RONE   : constant Real    := 1.0e0;
      BETA   : Complex;
      CDUM   : Complex;
      S      : Complex;
      TAU    : Complex;
      FOO    : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SMLNUM : Real;
      ULP    : Real;
      I      : Integer;
      IFST   : Integer;
      ILST   : Integer;
      INFO   : Integer;
      INFQR  : Integer;
      J      : Integer;
      JW     : Integer;
      KCOL   : Integer;
      KLN    : Integer;
      KNT    : Integer;
      KROW   : Integer;
      KWTOP  : Integer;
      LTOP   : Integer;
      LWK1   : Integer;
      LWK2   : Integer;
      LWKOPT : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAQR2( WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ,
   --                          IHIZ, Z, LDZ, NS, ND, SH, V, LDV, NH, T, LDT,
   --                          NV, WV, LDWV, WORK, LWORK )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHIZ, ILOZ, KBOT, KTOP, LDH, LDT, LDV, LDWV,
   --      $                   LDZ, LWORK, N, ND, NH, NS, NV, NW
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         H( LDH, * ), SH( * ), T( LDT, * ), V( LDV, * ),
   --      $                   WORK( * ), WV( LDWV, * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZLAQR2 is identical to ZLAQR3 except that it avoids
   --     recursion by calling ZLAHQR instead of ZLAQR4.
   --
   --     Aggressive early deflation:
   --
   --     ZLAQR2 accepts as input an upper Hessenberg matrix
   --     H and performs an unitary similarity transformation
   --     designed to detect and deflate fully converged eigenvalues from
   --     a trailing principal submatrix.  On output H has been over-
   --     written by a new Hessenberg matrix that is a perturbation of
   --     an unitary similarity transformation of H.  It is to be
   --     hoped that the final version of H has many zero subdiagonal
   --     entries.
   --
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           If .TRUE., then the Hessenberg matrix H is fully updated
   --           so that the triangular Schur factor may be
   --           computed (in cooperation with the calling subroutine).
   --           If .FALSE., then only enough of H is updated to preserve
   --           the eigenvalues.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           If .TRUE., then the unitary matrix Z is updated so
   --           so that the unitary Schur factor may be computed
   --           (in cooperation with the calling subroutine).
   --           If .FALSE., then Z is not referenced.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix H and (if WANTZ is .TRUE.) the
   --           order of the unitary matrix Z.
   --
   --  [in] KTOP
   --           KTOP is INTEGER
   --           It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
   --           KBOT and KTOP together determine an isolated block
   --           along the diagonal of the Hessenberg matrix.
   --
   --  [in] KBOT
   --           KBOT is INTEGER
   --           It is assumed without a check that either
   --           KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
   --           determine an isolated block along the diagonal of the
   --           Hessenberg matrix.
   --
   --  [in] NW
   --           NW is INTEGER
   --           Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
   --
   --  [in,out] H
   --           H is COMPLEX*16 array, dimension (LDH,N)
   --           On input the initial N-by-N section of H stores the
   --           Hessenberg matrix undergoing aggressive early deflation.
   --           On output H has been transformed by a unitary
   --           similarity transformation, perturbed, and the returned
   --           to Hessenberg form that (it is to be hoped) has some
   --           zero subdiagonal entries.
   --
   --  [in] LDH
   --           LDH is integer
   --           Leading dimension of H just as declared in the calling
   --           subroutine.  N .LE. LDH
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --           Specify the rows of Z to which transformations must be
   --           applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array, dimension (LDZ,N)
   --           IF WANTZ is .TRUE., then on output, the unitary
   --           similarity transformation mentioned above has been
   --           accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
   --           If WANTZ is .FALSE., then Z is unreferenced.
   --
   --  [in] LDZ
   --           LDZ is integer
   --           The leading dimension of Z just as declared in the
   --           calling subroutine.  1 .LE. LDZ.
   --
   --  [out] NS
   --           NS is integer
   --           The number of unconverged (ie approximate) eigenvalues
   --           returned in SR and SI that may be used as shifts by the
   --           calling subroutine.
   --
   --  [out] ND
   --           ND is integer
   --           The number of converged eigenvalues uncovered by this
   --           subroutine.
   --
   --  [out] SH
   --           SH is COMPLEX*16 array, dimension KBOT
   --           On output, approximate eigenvalues that may
   --           be used for shifts are stored in SH(KBOT-ND-NS+1)
   --           through SR(KBOT-ND).  Converged eigenvalues are
   --           stored in SH(KBOT-ND+1) through SH(KBOT).
   --
   --  [out] V
   --           V is COMPLEX*16 array, dimension (LDV,NW)
   --           An NW-by-NW work array.
   --
   --  [in] LDV
   --           LDV is integer scalar
   --           The leading dimension of V just as declared in the
   --           calling subroutine.  NW .LE. LDV
   --
   --  [in] NH
   --           NH is integer scalar
   --           The number of columns of T.  NH.GE.NW.
   --
   --  [out] T
   --           T is COMPLEX*16 array, dimension (LDT,NW)
   --
   --  [in] LDT
   --           LDT is integer
   --           The leading dimension of T just as declared in the
   --           calling subroutine.  NW .LE. LDT
   --
   --  [in] NV
   --           NV is integer
   --           The number of rows of work array WV available for
   --           workspace.  NV.GE.NW.
   --
   --  [out] WV
   --           WV is COMPLEX*16 array, dimension (LDWV,NW)
   --
   --  [in] LDWV
   --           LDWV is integer
   --           The leading dimension of W just as declared in the
   --           calling subroutine.  NW .LE. LDV
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension LWORK.
   --           On exit, WORK(1) is set to an estimate of the optimal value
   --           of LWORK for the given values of N, NW, KTOP and KBOT.
   --
   --  [in] LWORK
   --           LWORK is integer
   --           The dimension of the work array WORK.  LWORK = 2*NW
   --           suffices, but greater efficiency may result from larger
   --           values of LWORK.
   --
   --           If LWORK = -1, then a workspace query is assumed; ZLAQR2
   --           only estimates the optimal workspace size for the given
   --           values of N, NW, KTOP and KBOT.  The estimate is returned
   --           in WORK(1).  No error message related to LWORK is issued
   --           by XERBLA.  Neither H nor Z are accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ), ONE = ( 1.0d0, 0.0d0 ) )
   --      PARAMETER          ( RZERO = 0.0d0, RONE = 1.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       DOUBLE PRECISION   DLAMCH
   --       EXTERNAL           DLAMCH
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           DLABAD, ZCOPY, ZGEHRD, ZGEMM, ZLACPY, ZLAHQR,
   --      $                   ZLARF, ZLARFG, ZLASET, ZTREXC, ZUNMHR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCMPLX, DCONJG, DIMAG, INT, MAX, MIN
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      --
      --     ==== Estimate optimal workspace. ====
      --
      JW := min (NW, KBOT - KTOP + 1);
      if JW <= 2 then
         LWKOPT := 1;
      else
         --
         --        ==== Workspace query call to ZGEHRD ====
         --
         ZGEHRD (JW, 1, JW - 1, T'Address, LDT, WORK'Address, WORK'Address, -1, INFO);
         LWK1 := int (real_part (WORK (1)));
         --
         --        ==== Workspace query call to ZUNMHR ====
         --
         ZUNMHR ('R', 'N', JW, JW, 1, JW - 1, T'Address, LDT, WORK'Address, V'Address, LDV, WORK'Address, -1, INFO);
         LWK2 := int (real_part (WORK (1)));
         --
         --        ==== Optimal workspace ====
         --
         LWKOPT := JW + max (LWK1, LWK2);
      end if;
      --
      --     ==== Quick return in case of workspace query. ====
      --
      if LWORK = -1 then
         WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
         return;
      end if;
      --
      --     ==== Nothing to do ...
      --     ... for an empty active block ... ====
      NS       := 0;
      ND       := 0;
      WORK (1) := ONE;
      if KTOP > KBOT then
         return;
      end if;
      --     ... nor for an empty deflation window. ====
      if NW < 1 then
         return;
      end if;
      --
      --     ==== Machine constants ====
      --
      SAFMIN := DLAMCH ('S');
      SAFMAX := RONE / SAFMIN;
      DLABAD (SAFMIN, SAFMAX);
      ULP    := DLAMCH ('P');
      SMLNUM := SAFMIN * (Real (N) / ULP);
      --
      --     ==== Setup deflation window ====
      --
      JW    := min (NW, KBOT - KTOP + 1);
      KWTOP := KBOT - JW + 1;
      if KWTOP = KTOP 
         then S := ZERO;
         else S := H (KWTOP, KWTOP - 1);
      end if;
      --
      if KBOT = KWTOP then
         --
         --        ==== 1-by-1 deflation window: not much to do ====
         --
         SH (KWTOP) := H (KWTOP, KWTOP);
         NS         := 1;
         ND         := 0;
         if CABS1 (S) <= max (SMLNUM, ULP * CABS1 (H (KWTOP, KWTOP))) then
            NS := 0;
            ND := 1;
            if KWTOP > KTOP then
               H (KWTOP, KWTOP - 1) := ZERO;
            end if;
         end if;
         WORK (1) := ONE;
         return;
      end if;
      --
      --     ==== Convert to spike-triangular form.  (In case of a
      --     .    rare QR failure, this routine continues to do
      --     .    aggressive early deflation using that part of
      --     .    the deflation window that converged using INFQR
      --     .    here and there to keep track.) ====
      --
      ZLACPY ('U', JW, JW, H (KWTOP, KWTOP)'Address, LDH, T'Address, LDT);
      ZCOPY (JW - 1, H (KWTOP + 1, KWTOP)'Address, LDH + 1, T (2, 1)'Address, LDT + 1);
      --
      ZLASET ('A', JW, JW, ZERO, ONE, V'Address, LDV);
      ZLAHQR (True, True, JW, 1, JW, T'Address, LDT, SH (KWTOP)'Address, 1, JW, V'Address, LDV, INFQR);
      --
      --     ==== Deflation detection loop ====
      --
      NS   := JW;
      ILST := INFQR + 1;
      KNT  := INFQR + 1 - 1;
      loop
         KNT := KNT + 1;
         exit when KNT > JW;
         --
         --        ==== Small spike tip deflation test ====
         --
         FOO := CABS1 (T (NS, NS));
         if FOO = RZERO then
            FOO := CABS1 (S);
         end if;
         if CABS1 (S) * CABS1 (V (1, NS)) <= max (SMLNUM, ULP * FOO) then
            --
            --           ==== One more converged eigenvalue ====
            --
            NS := NS - 1;
         else
            --
            --           ==== One undeflatable eigenvalue.  Move it up out of the
            --           .    way.   (ZTREXC can not fail in this case.) ====
            --
            IFST := NS;
            ZTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, INFO);
            ILST := ILST + 1;
         end if;
      end loop;
      --
      --        ==== Return to Hessenberg form ====
      --
      if NS = 0 then
         S := ZERO;
      end if;
      --
      if NS < JW then
         --
         --        ==== sorting the diagonal of T improves accuracy for
         --        .    graded matrices.  ====
         --
         I := INFQR + 1 - 1;
         loop
            I := I + 1;
            exit when I > NS;
            IFST := I;
            J    := I + 1 - 1;
            loop
               J := J + 1;
               exit when J > NS;
               if CABS1 (T (J, J)) > CABS1 (T (IFST, IFST)) then
                  IFST := J;
               end if;
            end loop;
            ILST := I;
            if IFST /= ILST then
               ZTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, INFO);
            end if;
         end loop;
      end if;
      --
      --     ==== Restore shift/eigenvalue array from T ====
      --
      I := INFQR + 1 - 1;
      loop
         I := I + 1;
         exit when I > JW;
         SH (KWTOP + I - 1) := T (I, I);
      end loop;
      --
      --
      if NS < JW or S = ZERO then
         if NS > 1 and S /= ZERO then
            --
            --           ==== Reflect spike back into lower triangle ====
            --
            ZCOPY (NS, V'Address, LDV, WORK'Address, 1);
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > NS;
               WORK (I) := dconjg (WORK (I));
            end loop;
            BETA := WORK (1);
            ZLARFG (NS, BETA, WORK (2)'Address, 1, TAU);
            WORK (1) := ONE;
            --
            ZLASET ('L', JW - 2, JW - 2, ZERO, ZERO, T (3, 1)'Address, LDT);
            --
            ZLARF ('L', NS, JW, WORK'Address, 1, dconjg (TAU), T'Address, LDT, WORK (JW + 1)'Address);
            ZLARF ('R', NS, NS, WORK'Address, 1, TAU, T'Address, LDT, WORK (JW + 1)'Address);
            ZLARF ('R', JW, NS, WORK'Address, 1, TAU, V'Address, LDV, WORK (JW + 1)'Address);
            --
            ZGEHRD (JW, 1, NS, T'Address, LDT, WORK'Address, WORK (JW + 1)'Address, LWORK - JW, INFO);
         end if;
         --
         --        ==== Copy updated reduced window into place ====
         --
         if KWTOP > 1 then
            H (KWTOP, KWTOP - 1) := S * dconjg (V (1, 1));
         end if;
         ZLACPY ('U', JW, JW, T'Address, LDT, H (KWTOP, KWTOP)'Address, LDH);
         ZCOPY (JW - 1, T (2, 1)'Address, LDT + 1, H (KWTOP + 1, KWTOP)'Address, LDH + 1);
         --
         --        ==== Accumulate orthogonal matrix in order update
         --        .    H and Z, if requested.  ====
         --
         if NS > 1 and S /= ZERO then
            ZUNMHR
              ('R',
               'N',
               JW,
               NS,
               1,
               NS,
               T'Address,
               LDT,
               WORK'Address,
               V'Address,
               LDV,
               WORK (JW + 1)'Address,
               LWORK - JW,
               INFO);
         end if;
         --
         --        ==== Update vertical slab in H ====
         --
         if WANTT 
            then LTOP := 1;
            else LTOP := KTOP;
         end if;
         KROW := LTOP - NV;
         loop
            KROW := KROW + NV;
            exit when KROW > KWTOP - 1;
            KLN := min (NV, KWTOP - KROW);
            ZGEMM ('N', 'N', KLN, JW, JW, ONE, H (KROW, KWTOP)'Address, LDH, V'Address, LDV, ZERO, WV'Address, LDWV);
            ZLACPY ('A', KLN, JW, WV'Address, LDWV, H (KROW, KWTOP)'Address, LDH);
         end loop;
         --
         --        ==== Update horizontal slab in H ====
         --
         if WANTT then
            KCOL := KBOT + 1 - NH;
            loop
               KCOL := KCOL + NH;
               exit when KCOL > N;
               KLN := min (NH, N - KCOL + 1);
               ZGEMM ('C', 'N', JW, KLN, JW, ONE, V'Address, LDV, H (KWTOP, KCOL)'Address, LDH, ZERO, T'Address, LDT);
               ZLACPY ('A', JW, KLN, T'Address, LDT, H (KWTOP, KCOL)'Address, LDH);
            end loop;
         end if;
         --
         --        ==== Update vertical slab in Z ====
         --
         if WANTZ then
            KROW := ILOZ - NV;
            loop
               KROW := KROW + NV;
               exit when KROW > IHIZ;
               KLN := min (NV, IHIZ - KROW + 1);
               ZGEMM ('N', 'N', KLN, JW, JW, ONE, Z (KROW, KWTOP)'Address, LDZ, V'Address, LDV, ZERO, WV'Address, LDWV);
               ZLACPY ('A', KLN, JW, WV'Address, LDWV, Z (KROW, KWTOP)'Address, LDZ);
            end loop;
         end if;
      end if;
      --
      --     ==== Return the number of deflations ... ====
      --
      ND := JW - NS;
      --
      --     ==== ... and the number of shifts. (Subtracting
      --     .    INFQR from the spike length takes care
      --     .    of the case of a rare QR failure while
      --     .    calculating eigenvalues of the deflation
      --     .    window.)  ====
      --
      NS := NS - INFQR;
      --
      --      ==== Return optimal workspace. ====
      --
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      --
      --     ==== End of ZLAQR2 ====
      --
   end ZLAQR2;

   procedure ZLAQR3
     (WANTT    : Boolean;
      WANTZ    : Boolean;
      N        : Integer;
      KTOP     : Integer;
      KBOT     : Integer;
      NW       : Integer;
      H_adr    : Address;
      LDH      : Integer;
      ILOZ     : Integer;
      IHIZ     : Integer;
      Z_adr    : Address;
      LDZ      : Integer;
      NS       : in out Integer;
      ND       : in out Integer;
      SH_adr   : Address;
      V_adr    : Address;
      LDV      : Integer;
      NH       : Integer;
      T_adr    : Address;
      LDT      : Integer;
      NV       : Integer;
      WV_adr   : Address;
      LDWV     : Integer;
      WORK_adr : Address;
      LWORK    : Integer)
   is

      H    : Ftn_Complex_Matrix (1 .. LDH, 1 .. N);
      Z    : Ftn_Complex_Matrix (1 .. LDZ, 1 .. N);
      SH   : Ftn_Complex_Vector (1 .. KBOT);
      V    : Ftn_Complex_Matrix (1 .. LDV, 1 .. NW);
      T    : Ftn_Complex_Matrix (1 .. LDT, 1 .. NW);
      WV   : Ftn_Complex_Matrix (1 .. LDWV, 1 .. NW);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for H'Address use H_adr;
      for Z'Address use Z_adr;
      for SH'Address use SH_adr;
      for V'Address use V_adr;
      for T'Address use T_adr;
      for WV'Address use WV_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, Z);
      pragma Import (Ada, SH);
      pragma Import (Ada, V);
      pragma Import (Ada, T);
      pragma Import (Ada, WV);
      pragma Import (Ada, WORK);

      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      RZERO  : constant Real    := 0.0e0;
      RONE   : constant Real    := 1.0e0;
      BETA   : Complex;
      CDUM   : Complex;
      S      : Complex;
      TAU    : Complex;
      FOO    : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SMLNUM : Real;
      ULP    : Real;
      I      : Integer;
      IFST   : Integer;
      ILST   : Integer;
      INFO   : Integer;
      INFQR  : Integer;
      J      : Integer;
      JW     : Integer;
      KCOL   : Integer;
      KLN    : Integer;
      KNT    : Integer;
      KROW   : Integer;
      KWTOP  : Integer;
      LTOP   : Integer;
      LWK1   : Integer;
      LWK2   : Integer;
      LWK3   : Integer;
      LWKOPT : Integer;
      NMIN   : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAQR3( WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ,
   --                          IHIZ, Z, LDZ, NS, ND, SH, V, LDV, NH, T, LDT,
   --                          NV, WV, LDWV, WORK, LWORK )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHIZ, ILOZ, KBOT, KTOP, LDH, LDT, LDV, LDWV,
   --      $                   LDZ, LWORK, N, ND, NH, NS, NV, NW
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         H( LDH, * ), SH( * ), T( LDT, * ), V( LDV, * ),
   --      $                   WORK( * ), WV( LDWV, * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     Aggressive early deflation:
   --
   --     ZLAQR3 accepts as input an upper Hessenberg matrix
   --     H and performs an unitary similarity transformation
   --     designed to detect and deflate fully converged eigenvalues from
   --     a trailing principal submatrix.  On output H has been over-
   --     written by a new Hessenberg matrix that is a perturbation of
   --     an unitary similarity transformation of H.  It is to be
   --     hoped that the final version of H has many zero subdiagonal
   --     entries.
   --
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           If .TRUE., then the Hessenberg matrix H is fully updated
   --           so that the triangular Schur factor may be
   --           computed (in cooperation with the calling subroutine).
   --           If .FALSE., then only enough of H is updated to preserve
   --           the eigenvalues.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           If .TRUE., then the unitary matrix Z is updated so
   --           so that the unitary Schur factor may be computed
   --           (in cooperation with the calling subroutine).
   --           If .FALSE., then Z is not referenced.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix H and (if WANTZ is .TRUE.) the
   --           order of the unitary matrix Z.
   --
   --  [in] KTOP
   --           KTOP is INTEGER
   --           It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
   --           KBOT and KTOP together determine an isolated block
   --           along the diagonal of the Hessenberg matrix.
   --
   --  [in] KBOT
   --           KBOT is INTEGER
   --           It is assumed without a check that either
   --           KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
   --           determine an isolated block along the diagonal of the
   --           Hessenberg matrix.
   --
   --  [in] NW
   --           NW is INTEGER
   --           Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
   --
   --  [in,out] H
   --           H is COMPLEX*16 array, dimension (LDH,N)
   --           On input the initial N-by-N section of H stores the
   --           Hessenberg matrix undergoing aggressive early deflation.
   --           On output H has been transformed by a unitary
   --           similarity transformation, perturbed, and the returned
   --           to Hessenberg form that (it is to be hoped) has some
   --           zero subdiagonal entries.
   --
   --  [in] LDH
   --           LDH is integer
   --           Leading dimension of H just as declared in the calling
   --           subroutine.  N .LE. LDH
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --           Specify the rows of Z to which transformations must be
   --           applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array, dimension (LDZ,N)
   --           IF WANTZ is .TRUE., then on output, the unitary
   --           similarity transformation mentioned above has been
   --           accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
   --           If WANTZ is .FALSE., then Z is unreferenced.
   --
   --  [in] LDZ
   --           LDZ is integer
   --           The leading dimension of Z just as declared in the
   --           calling subroutine.  1 .LE. LDZ.
   --
   --  [out] NS
   --           NS is integer
   --           The number of unconverged (ie approximate) eigenvalues
   --           returned in SR and SI that may be used as shifts by the
   --           calling subroutine.
   --
   --  [out] ND
   --           ND is integer
   --           The number of converged eigenvalues uncovered by this
   --           subroutine.
   --
   --  [out] SH
   --           SH is COMPLEX*16 array, dimension KBOT
   --           On output, approximate eigenvalues that may
   --           be used for shifts are stored in SH(KBOT-ND-NS+1)
   --           through SR(KBOT-ND).  Converged eigenvalues are
   --           stored in SH(KBOT-ND+1) through SH(KBOT).
   --
   --  [out] V
   --           V is COMPLEX*16 array, dimension (LDV,NW)
   --           An NW-by-NW work array.
   --
   --  [in] LDV
   --           LDV is integer scalar
   --           The leading dimension of V just as declared in the
   --           calling subroutine.  NW .LE. LDV
   --
   --  [in] NH
   --           NH is integer scalar
   --           The number of columns of T.  NH.GE.NW.
   --
   --  [out] T
   --           T is COMPLEX*16 array, dimension (LDT,NW)
   --
   --  [in] LDT
   --           LDT is integer
   --           The leading dimension of T just as declared in the
   --           calling subroutine.  NW .LE. LDT
   --
   --  [in] NV
   --           NV is integer
   --           The number of rows of work array WV available for
   --           workspace.  NV.GE.NW.
   --
   --  [out] WV
   --           WV is COMPLEX*16 array, dimension (LDWV,NW)
   --
   --  [in] LDWV
   --           LDWV is integer
   --           The leading dimension of W just as declared in the
   --           calling subroutine.  NW .LE. LDV
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension LWORK.
   --           On exit, WORK(1) is set to an estimate of the optimal value
   --           of LWORK for the given values of N, NW, KTOP and KBOT.
   --
   --  [in] LWORK
   --           LWORK is integer
   --           The dimension of the work array WORK.  LWORK = 2*NW
   --           suffices, but greater efficiency may result from larger
   --           values of LWORK.
   --
   --           If LWORK = -1, then a workspace query is assumed; ZLAQR3
   --           only estimates the optimal workspace size for the given
   --           values of N, NW, KTOP and KBOT.  The estimate is returned
   --           in WORK(1).  No error message related to LWORK is issued
   --           by XERBLA.  Neither H nor Z are accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ), ONE = ( 1.0d0, 0.0d0 ) )
   --      PARAMETER          ( RZERO = 0.0d0, RONE = 1.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       DOUBLE PRECISION   DLAMCH
   --       INTEGER            ILAENV
   --       EXTERNAL           DLAMCH, ILAENV
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           DLABAD, ZCOPY, ZGEHRD, ZGEMM, ZLACPY, ZLAHQR,
   --      $                   ZLAQR4, ZLARF, ZLARFG, ZLASET, ZTREXC, ZUNMHR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCMPLX, DCONJG, DIMAG, INT, MAX, MIN
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      --
      --     ==== Estimate optimal workspace. ====
      --
      JW := min (NW, KBOT - KTOP + 1);
      if JW <= 2 then
         LWKOPT := 1;
      else
         --
         --        ==== Workspace query call to ZGEHRD ====
         --
         ZGEHRD (JW, 1, JW - 1, T'Address, LDT, WORK'Address, WORK'Address, -1, INFO);
         LWK1 := int (real_part (WORK (1)));
         --
         --        ==== Workspace query call to ZUNMHR ====
         --
         ZUNMHR ('R', 'N', JW, JW, 1, JW - 1, T'Address, LDT, WORK'Address, V'Address, LDV, WORK'Address, -1, INFO);
         LWK2 := int (real_part (WORK (1)));
         --
         --        ==== Workspace query call to ZLAQR4 ====
         --
         ZLAQR4 (True, True, JW, 1, JW, T'Address, LDT, SH'Address, 1, JW, V'Address, LDV, WORK'Address, -1, INFQR);
         LWK3 := int (real_part (WORK (1)));
         --
         --        ==== Optimal workspace ====
         --
         LWKOPT := max (JW + max (LWK1, LWK2), LWK3);
      end if;
      --
      --     ==== Quick return in case of workspace query. ====
      --
      if LWORK = -1 then
         WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
         return;
      end if;
      --
      --     ==== Nothing to do ...
      --     ... for an empty active block ... ====
      NS       := 0;
      ND       := 0;
      WORK (1) := ONE;
      if KTOP > KBOT then
         return;
      end if;
      --     ... nor for an empty deflation window. ====
      if NW < 1 then
         return;
      end if;
      --
      --     ==== Machine constants ====
      --
      SAFMIN := DLAMCH ('S');
      SAFMAX := RONE / SAFMIN;
      DLABAD (SAFMIN, SAFMAX);
      ULP    := DLAMCH ('P');
      SMLNUM := SAFMIN * (Real (N) / ULP);
      --
      --     ==== Setup deflation window ====
      --
      JW    := min (NW, KBOT - KTOP + 1);
      KWTOP := KBOT - JW + 1;
      if KWTOP = KTOP 
         then S := ZERO;
         else S := H (KWTOP, KWTOP - 1);
      end if;
      --
      if KBOT = KWTOP then
         --
         --        ==== 1-by-1 deflation window: not much to do ====
         --
         SH (KWTOP) := H (KWTOP, KWTOP);
         NS         := 1;
         ND         := 0;
         if CABS1 (S) <= max (SMLNUM, ULP * CABS1 (H (KWTOP, KWTOP))) then
            NS := 0;
            ND := 1;
            if KWTOP > KTOP then
               H (KWTOP, KWTOP - 1) := ZERO;
            end if;
         end if;
         WORK (1) := ONE;
         return;
      end if;
      --
      --     ==== Convert to spike-triangular form.  (In case of a
      --     .    rare QR failure, this routine continues to do
      --     .    aggressive early deflation using that part of
      --     .    the deflation window that converged using INFQR
      --     .    here and there to keep track.) ====
      --
      ZLACPY ('U', JW, JW, H (KWTOP, KWTOP)'Address, LDH, T'Address, LDT);
      ZCOPY (JW - 1, H (KWTOP + 1, KWTOP)'Address, LDH + 1, T (2, 1)'Address, LDT + 1);
      --
      ZLASET ('A', JW, JW, ZERO, ONE, V'Address, LDV);
      NMIN := ILAENV (12, "ZLAQR3", "SV", JW, 1, JW, LWORK);
      if JW > NMIN then
         ZLAQR4
           (True,
            True,
            JW,
            1,
            JW,
            T'Address,
            LDT,
            SH (KWTOP)'Address,
            1,
            JW,
            V'Address,
            LDV,
            WORK'Address,
            LWORK,
            INFQR);
      else
         ZLAHQR (True, True, JW, 1, JW, T'Address, LDT, SH (KWTOP)'Address, 1, JW, V'Address, LDV, INFQR);
      end if;
      --
      --     ==== Deflation detection loop ====
      --
      NS   := JW;
      ILST := INFQR + 1;
      KNT  := INFQR + 1 - 1;
      loop
         KNT := KNT + 1;
         exit when KNT > JW;
         --
         --        ==== Small spike tip deflation test ====
         --
         FOO := CABS1 (T (NS, NS));
         if FOO = RZERO then
            FOO := CABS1 (S);
         end if;
         if CABS1 (S) * CABS1 (V (1, NS)) <= max (SMLNUM, ULP * FOO) then
            --
            --           ==== One more converged eigenvalue ====
            --
            NS := NS - 1;
         else
            --
            --           ==== One undeflatable eigenvalue.  Move it up out of the
            --           .    way.   (ZTREXC can not fail in this case.) ====
            --
            IFST := NS;
            ZTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, INFO);
            ILST := ILST + 1;
         end if;
      end loop;
      --
      --        ==== Return to Hessenberg form ====
      --
      if NS = 0 then
         S := ZERO;
      end if;
      --
      if NS < JW then
         --
         --        ==== sorting the diagonal of T improves accuracy for
         --        .    graded matrices.  ====
         --
         I := INFQR + 1 - 1;
         loop
            I := I + 1;
            exit when I > NS;
            IFST := I;
            J    := I + 1 - 1;
            loop
               J := J + 1;
               exit when J > NS;
               if CABS1 (T (J, J)) > CABS1 (T (IFST, IFST)) then
                  IFST := J;
               end if;
            end loop;
            ILST := I;
            if IFST /= ILST then
               ZTREXC ('V', JW, T, LDT, V, LDV, IFST, ILST, INFO);
            end if;
         end loop;
      end if;
      --
      --     ==== Restore shift/eigenvalue array from T ====
      --
      I := INFQR + 1 - 1;
      loop
         I := I + 1;
         exit when I > JW;
         SH (KWTOP + I - 1) := T (I, I);
      end loop;
      --
      --
      if NS < JW or S = ZERO then
         if NS > 1 and S /= ZERO then
            --
            --           ==== Reflect spike back into lower triangle ====
            --
            ZCOPY (NS, V'Address, LDV, WORK'Address, 1);
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > NS;
               WORK (I) := dconjg (WORK (I));
            end loop;
            BETA := WORK (1);
            ZLARFG (NS, BETA, WORK (2)'Address, 1, TAU);
            WORK (1) := ONE;
            --
            ZLASET ('L', JW - 2, JW - 2, ZERO, ZERO, T (3, 1)'Address, LDT);
            --
            ZLARF ('L', NS, JW, WORK'Address, 1, dconjg (TAU), T'Address, LDT, WORK (JW + 1)'Address);
            ZLARF ('R', NS, NS, WORK'Address, 1, TAU, T'Address, LDT, WORK (JW + 1)'Address);
            ZLARF ('R', JW, NS, WORK'Address, 1, TAU, V'Address, LDV, WORK (JW + 1)'Address);
            --
            ZGEHRD (JW, 1, NS, T'Address, LDT, WORK'Address, WORK (JW + 1)'Address, LWORK - JW, INFO);
         end if;
         --
         --        ==== Copy updated reduced window into place ====
         --
         if KWTOP > 1 then
            H (KWTOP, KWTOP - 1) := S * dconjg (V (1, 1));
         end if;
         ZLACPY ('U', JW, JW, T'Address, LDT, H (KWTOP, KWTOP)'Address, LDH);
         ZCOPY (JW - 1, T (2, 1)'Address, LDT + 1, H (KWTOP + 1, KWTOP)'Address, LDH + 1);
         --
         --        ==== Accumulate orthogonal matrix in order update
         --        .    H and Z, if requested.  ====
         --
         if NS > 1 and S /= ZERO then
            ZUNMHR
              ('R',
               'N',
               JW,
               NS,
               1,
               NS,
               T'Address,
               LDT,
               WORK'Address,
               V'Address,
               LDV,
               WORK (JW + 1)'Address,
               LWORK - JW,
               INFO);
         end if;
         --
         --        ==== Update vertical slab in H ====
         --
         if WANTT 
            then LTOP := 1;
            else LTOP := KTOP;
         end if;
         KROW := LTOP - NV;
         loop
            KROW := KROW + NV;
            exit when KROW > KWTOP - 1;
            KLN := min (NV, KWTOP - KROW);
            ZGEMM ('N', 'N', KLN, JW, JW, ONE, H (KROW, KWTOP)'Address, LDH, V'Address, LDV, ZERO, WV'Address, LDWV);
            ZLACPY ('A', KLN, JW, WV'Address, LDWV, H (KROW, KWTOP)'Address, LDH);
         end loop;
         --
         --        ==== Update horizontal slab in H ====
         --
         if WANTT then
            KCOL := KBOT + 1 - NH;
            loop
               KCOL := KCOL + NH;
               exit when KCOL > N;
               KLN := min (NH, N - KCOL + 1);
               ZGEMM ('C', 'N', JW, KLN, JW, ONE, V'Address, LDV, H (KWTOP, KCOL)'Address, LDH, ZERO, T'Address, LDT);
               ZLACPY ('A', JW, KLN, T'Address, LDT, H (KWTOP, KCOL)'Address, LDH);
            end loop;
         end if;
         --
         --        ==== Update vertical slab in Z ====
         --
         if WANTZ then
            KROW := ILOZ - NV;
            loop
               KROW := KROW + NV;
               exit when KROW > IHIZ;
               KLN := min (NV, IHIZ - KROW + 1);
               ZGEMM ('N', 'N', KLN, JW, JW, ONE, Z (KROW, KWTOP)'Address, LDZ, V'Address, LDV, ZERO, WV'Address, LDWV);
               ZLACPY ('A', KLN, JW, WV'Address, LDWV, Z (KROW, KWTOP)'Address, LDZ);
            end loop;
         end if;
      end if;
      --
      --     ==== Return the number of deflations ... ====
      --
      ND := JW - NS;
      --
      --     ==== ... and the number of shifts. (Subtracting
      --     .    INFQR from the spike length takes care
      --     .    of the case of a rare QR failure while
      --     .    calculating eigenvalues of the deflation
      --     .    window.)  ====
      --
      NS := NS - INFQR;
      --
      --      ==== Return optimal workspace. ====
      --
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      --
      --     ==== End of ZLAQR3 ====
      --
   end ZLAQR3;

   procedure ZLAQR4
     (WANTT    : Boolean;
      WANTZ    : Boolean;
      N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      H_adr    : Address;
      LDH      : Integer;
      W_adr    : Address;
      ILOZ     : Integer;
      IHIZ     : Integer;
      Z_adr    : Address;
      LDZ      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      H    : Ftn_Complex_Matrix (1 .. LDH, 1 .. N);
      W    : Ftn_Complex_Vector (1 .. N);
      Z    : Ftn_Complex_Matrix (1 .. LDZ, 1 .. IHI);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for H'Address use H_adr;
      for W'Address use W_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, H);
      pragma Import (Ada, W);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);

      NTINY  : constant Integer := 11;
      KEXNW  : constant Integer := 5;
      KEXSH  : constant Integer := 6;
      WILK1  : constant Real    := 0.75e0;
      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      TWO    : constant Real    := 2.0e0;
      AA     : Complex;
      BB     : Complex;
      CC     : Complex;
      CDUM   : Complex;
      DD     : Complex;
      DET    : Complex;
      RTDISC : Complex;
      SWAP   : Complex;
      TR2    : Complex;
      S      : Real;
      I      : Integer;
      INF    : Integer;
      IT     : Integer;
      ITMAX  : Integer;
      K      : Integer;
      KACC22 : Integer;
      KBOT   : Integer;
      KDU    : Integer;
      KS     : Integer;
      KT     : Integer;
      KTOP   : Integer;
      KU     : Integer;
      KV     : Integer;
      KWH    : Integer;
      KWTOP  : Integer;
      KWV    : Integer;
      LD     : Integer;
      LS     : Integer;
      LWKOPT : Integer;
      NDEC   : Integer;
      NDFL   : Integer;
      NH     : Integer;
      NHO    : Integer;
      NIBBLE : Integer;
      NMIN   : Integer;
      NS     : Integer;
      NSMAX  : Integer;
      NSR    : Integer;
      NVE    : Integer;
      NW     : Integer;
      NWMAX  : Integer;
      NWR    : Integer;
      NWUPBD : Integer;
      SORTED : Boolean;
      JBCMPZ : String (1 .. 2);
      ZDUM   : Ftn_Complex_Matrix (1 .. 1, 1 .. 1);

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAQR4( WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ,
   --                          IHIZ, Z, LDZ, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, LWORK, N
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         H( LDH, * ), W( * ), WORK( * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZLAQR4 implements one level of recursion for ZLAQR0.
   --     It is a complete implementation of the small bulge multi-shift
   --     QR algorithm.  It may be called by ZLAQR0 and, for large enough
   --     deflation window size, it may be called by ZLAQR3.  This
   --     subroutine is identical to ZLAQR0 except that it calls ZLAQR2
   --     instead of ZLAQR3.
   --
   --     ZLAQR4 computes the eigenvalues of a Hessenberg matrix H
   --     and, optionally, the matrices T and Z from the Schur decomposition
   --     H = Z T Z**H, where T is an upper triangular matrix (the
   --     Schur form), and Z is the unitary matrix of Schur vectors.
   --
   --     Optionally Z may be postmultiplied into an input unitary
   --     matrix Q so that this routine can give the Schur factorization
   --     of a matrix A which has been reduced to the Hessenberg form H
   --     by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL
   --           = .TRUE. : the full Schur form T is required;
   --           = .FALSE.: only eigenvalues are required.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL
   --           = .TRUE. : the matrix of Schur vectors Z is required;
   --           = .FALSE.: Schur vectors are not required.
   --
   --  [in] N
   --           N is INTEGER
   --            The order of the matrix H.  N .GE. 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --            It is assumed that H is already upper triangular in rows
   --            and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
   --            H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
   --            previous call to ZGEBAL, and then passed to ZGEHRD when the
   --            matrix output by ZGEBAL is reduced to Hessenberg form.
   --            Otherwise, ILO and IHI should be set to 1 and N,
   --            respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
   --            If N = 0, then ILO = 1 and IHI = 0.
   --
   --  [in,out] H
   --           H is COMPLEX*16 array, dimension (LDH,N)
   --            On entry, the upper Hessenberg matrix H.
   --            On exit, if INFO = 0 and WANTT is .TRUE., then H
   --            contains the upper triangular matrix T from the Schur
   --            decomposition (the Schur form). If INFO = 0 and WANT is
   --            .FALSE., then the contents of H are unspecified on exit.
   --            (The output value of H when INFO.GT.0 is given under the
   --            description of INFO below.)
   --
   --            This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
   --            j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
   --
   --  [in] LDH
   --           LDH is INTEGER
   --            The leading dimension of the array H. LDH .GE. max(1,N).
   --
   --  [out] W
   --           W is COMPLEX*16 array, dimension (N)
   --            The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
   --            in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
   --            stored in the same order as on the diagonal of the Schur
   --            form returned in H, with W(i) = H(i,i).
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --            Specify the rows of Z to which transformations must be
   --            applied if WANTZ is .TRUE..
   --            1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array, dimension (LDZ,IHI)
   --            If WANTZ is .FALSE., then Z is not referenced.
   --            If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
   --            replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
   --            orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
   --            (The output value of Z when INFO.GT.0 is given under
   --            the description of INFO below.)
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --            The leading dimension of the array Z.  if WANTZ is .TRUE.
   --            then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension LWORK
   --            On exit, if LWORK = -1, WORK(1) returns an estimate of
   --            the optimal value for LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --            The dimension of the array WORK.  LWORK .GE. max(1,N)
   --            is sufficient, but LWORK typically as large as 6*N may
   --            be required for optimal performance.  A workspace query
   --            to determine the optimal workspace size is recommended.
   --
   --            If LWORK = -1, then ZLAQR4 does a workspace query.
   --            In this case, ZLAQR4 checks the input parameters and
   --            estimates the optimal workspace size for the given
   --            values of N, ILO and IHI.  The estimate is returned
   --            in WORK(1).  No error message related to LWORK is
   --            issued by XERBLA.  Neither H nor Z are accessed.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --              =  0:  successful exit
   --            .GT. 0:  if INFO = i, ZLAQR4 failed to compute all of
   --                 the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
   --                 and WI contain those eigenvalues which have been
   --                 successfully computed.  (Failures are rare.)
   --
   --                 If INFO .GT. 0 and WANT is .FALSE., then on exit,
   --                 the remaining unconverged eigenvalues are the eigen-
   --                 values of the upper Hessenberg matrix rows and
   --                 columns ILO through INFO of the final, output
   --                 value of H.
   --
   --                 If INFO .GT. 0 and WANTT is .TRUE., then on exit
   --
   --            (*)  (initial value of H)*U  = U*(final value of H)
   --
   --                 where U is a unitary matrix.  The final
   --                 value of  H is upper Hessenberg and triangular in
   --                 rows and columns INFO+1 through IHI.
   --
   --                 If INFO .GT. 0 and WANTZ is .TRUE., then on exit
   --
   --                   final value of Z(ILO:IHI,ILOZ:IHIZ)
   --                    =  initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
   --
   --                 where U is the unitary matrix in (*) (regard-
   --                 less of the value of WANTT.)
   --
   --                 If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
   --                 accessed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  References:
   --  ================
   --
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
   --        Performance, SIAM Journal of Matrix Analysis, volume 23, pages
   --        929--947, 2002.
   --  \n
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part II: Aggressive Early Deflation, SIAM Journal
   --        of Matrix Analysis, volume 23, pages 948--973, 2002.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --
   --     .. Parameters ..
   --
   --     ==== Matrices of order NTINY or smaller must be processed by
   --     .    ZLAHQR because of insufficient subdiagonal scratch space.
   --     .    (This is a hard limit.) ====
   --      PARAMETER          ( NTINY = 11 )
   --
   --     ==== Exceptional deflation windows:  try to cure rare
   --     .    slow convergence by varying the size of the
   --     .    deflation window after KEXNW iterations. ====
   --      PARAMETER          ( KEXNW = 5 )
   --
   --     ==== Exceptional shifts: try to cure rare slow convergence
   --     .    with ad-hoc exceptional shifts every KEXSH iterations.
   --     .    ====
   --      PARAMETER          ( KEXSH = 6 )
   --
   --     ==== The constant WILK1 is used to form the exceptional
   --     .    shifts. ====
   --      PARAMETER          ( WILK1 = 0.75d0 )
   --      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ), ONE = ( 1.0d0, 0.0d0 ) )
   --      PARAMETER          ( TWO = 2.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       INTEGER            ILAENV
   --       EXTERNAL           ILAENV
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           ZLACPY, ZLAHQR, ZLAQR2, ZLAQR5
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCMPLX, DIMAG, INT, MAX, MIN, MOD, SQRT
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      INFO := 0;
      --
      --     ==== Quick return for N = 0: nothing to do. ====
      --
      if N = 0 then
         WORK (1) := ONE;
         return;
      end if;
      --
      if N <= NTINY then
         --
         --        ==== Tiny matrices must use ZLAHQR. ====
         --
         LWKOPT := 1;
         if LWORK /= -1 then
            ZLAHQR (WANTT, WANTZ, N, ILO, IHI, H'Address, LDH, W'Address, ILOZ, IHIZ, Z'Address, LDZ, INFO);
         end if;
      else
         --
         --        ==== Use small bulge multi-shift QR with aggressive early
         --        .    deflation on larger-than-tiny matrices. ====
         --
         --        ==== Hope for the best. ====
         --
         INFO := 0;
         --
         --        ==== Set up job flags for ILAENV. ====
         --
         if WANTT 
            then JBCMPZ (1) := 'S';
            else JBCMPZ (1) := 'E';
         end if;
         if WANTZ 
            then JBCMPZ (2) := 'V';
            else JBCMPZ (2) := 'N';
         end if;
         --
         --        ==== NWR = recommended deflation window size.  At this
         --        .    point,  N .GT. NTINY = 11, so there is enough
         --        .    subdiagonal workspace for NWR.GE.2 as required.
         --        .    (In fact, there is enough subdiagonal space for
         --        .    NWR.GE.3.) ====
         --
         NWR := ILAENV (13, "ZLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         NWR := max (2, NWR);
         NWR := min (IHI - ILO + 1, (N - 1) / 3, NWR);
         --
         --        ==== NSR = recommended number of simultaneous shifts.
         --        .    At this point N .GT. NTINY = 11, so there is at
         --        .    enough subdiagonal workspace for NSR to be even
         --        .    and greater than or equal to two as required. ====
         --
         NSR := ILAENV (15, "ZLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         NSR := min (NSR, (N + 6) / 9, IHI - ILO);
         NSR := max (2, NSR - "mod" (NSR, 2));
         --
         --        ==== Estimate optimal workspace ====
         --
         --        ==== Workspace query call to ZLAQR2 ====
         --
         ZLAQR2
           (WANTT,
            WANTZ,
            N,
            ILO,
            IHI,
            NWR + 1,
            H'Address,
            LDH,
            ILOZ,
            IHIZ,
            Z'Address,
            LDZ,
            LS,
            LD,
            W'Address,
            H'Address,
            LDH,
            N,
            H'Address,
            LDH,
            N,
            H'Address,
            LDH,
            WORK'Address,
            -1);
         --
         --        ==== Optimal workspace = MAX(ZLAQR5, ZLAQR2) ====
         --
         LWKOPT := max (3 * NSR / 2, int (real_part (WORK (1))));
         --
         --        ==== Quick return in case of workspace query. ====
         --
         if LWORK = -1 then
            WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
            return;
         end if;
         --
         --        ==== ZLAHQR/ZLAQR0 crossover point ====
         --
         NMIN := ILAENV (12, "ZLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         NMIN := max (NTINY, NMIN);
         --
         --        ==== Nibble crossover point ====
         --
         NIBBLE := ILAENV (14, "ZLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         NIBBLE := max (0, NIBBLE);
         --
         --        ==== Accumulate reflections during ttswp?  Use block
         --        .    2-by-2 structure during matrix-matrix multiply? ====
         --
         KACC22 := ILAENV (16, "ZLAQR4", JBCMPZ, N, ILO, IHI, LWORK);
         KACC22 := max (0, KACC22);
         KACC22 := min (2, KACC22);
         --
         --        ==== NWMAX = the largest possible deflation window for
         --        .    which there is sufficient workspace. ====
         --
         NWMAX := min ((N - 1) / 3, LWORK / 2);
         NW    := NWMAX;
         --
         --        ==== NSMAX = the Largest number of simultaneous shifts
         --        .    for which there is sufficient workspace. ====
         --
         NSMAX := min ((N + 6) / 9, 2 * LWORK / 3);
         NSMAX := NSMAX - "mod" (NSMAX, 2);
         --
         --        ==== NDFL: an iteration count restarted at deflation. ====
         --
         NDFL := 1;
         --
         --        ==== ITMAX = iteration limit ====
         --
         ITMAX := max (30, 2 * KEXSH) * max (10, (IHI - ILO + 1));
         --
         --        ==== Last row and column in the active block ====
         --
         KBOT := IHI;
         --
         --        ==== Main Loop ====
         --
         IT := 1 - 1;
         loop
            IT := IT + 1;
            exit when IT > ITMAX;
            --
            --           ==== Done when KBOT falls below ILO ====
            --
            if KBOT < ILO then
               goto L80;
            end if;
            --
            --           ==== Locate active block ====
            --
            K := KBOT + 1;
            loop
               K := K - 1;
               exit when K < ILO + 1;
               if H (K, K - 1) = ZERO then
                  goto L20;
               end if;
            end loop;
            K := ILO;
            <<L20>> null;
            KTOP := K;
            --
            --           ==== Select deflation window size:
            --           .    Typical Case:
            --           .      If possible and advisable, nibble the entire
            --           .      active block.  If not, use size MIN(NWR,NWMAX)
            --           .      or MIN(NWR+1,NWMAX) depending upon which has
            --           .      the smaller corresponding subdiagonal entry
            --           .      (a heuristic).
            --           .
            --           .    Exceptional Case:
            --           .      If there have been no deflations in KEXNW or
            --           .      more iterations, then vary the deflation window
            --           .      size.   At first, because, larger windows are,
            --           .      in general, more powerful than smaller ones,
            --           .      rapidly increase the window to the maximum possible.
            --           .      Then, gradually reduce the window size. ====
            --
            NH     := KBOT - KTOP + 1;
            NWUPBD := min (NH, NWMAX);
            if NDFL < KEXNW 
               then NW := min (NWUPBD, NWR);
               else NW := min (NWUPBD, 2 * NW);
            end if;
            if NW < NWMAX then
               if NW >= NH - 1 then
                  NW := NH;
               else
                  KWTOP := KBOT - NW + 1;
                  if CABS1 (H (KWTOP, KWTOP - 1)) > CABS1 (H (KWTOP - 1, KWTOP - 2)) then
                     NW := NW + 1;
                  end if;
               end if;
            end if;
            if NDFL < KEXNW then
               NDEC := -1;
            elsif NDEC >= 0 or NW >= NWUPBD then
               NDEC := NDEC + 1;
               if NW - NDEC < 2 then
                  NDEC := 0;
               end if;
               NW := NW - NDEC;
            end if;
            --
            --           ==== Aggressive early deflation:
            --           .    split workspace under the subdiagonal into
            --           .      - an nw-by-nw work array V in the lower
            --           .        left-hand-corner,
            --           .      - an NW-by-at-least-NW-but-more-is-better
            --           .        (NW-by-NHO) horizontal work array along
            --           .        the bottom edge,
            --           .      - an at-least-NW-but-more-is-better (NHV-by-NW)
            --           .        vertical work array along the left-hand-edge.
            --           .        ====
            --
            KV  := N - NW + 1;
            KT  := NW + 1;
            NHO := (N - NW - 1) - KT + 1;
            KWV := NW + 2;
            NVE := (N - NW) - KWV + 1;
            --
            --           ==== Aggressive early deflation ====
            --
            ZLAQR2
              (WANTT,
               WANTZ,
               N,
               KTOP,
               KBOT,
               NW,
               H'Address,
               LDH,
               ILOZ,
               IHIZ,
               Z'Address,
               LDZ,
               LS,
               LD,
               W'Address,
               H (KV, 1)'Address,
               LDH,
               NHO,
               H (KV, KT)'Address,
               LDH,
               NVE,
               H (KWV, 1)'Address,
               LDH,
               WORK'Address,
               LWORK);
            --
            --           ==== Adjust KBOT accounting for new deflations. ====
            --
            KBOT := KBOT - LD;
            --
            --           ==== KS points to the shifts. ====
            --
            KS := KBOT - LS + 1;
            --
            --           ==== Skip an expensive QR sweep if there is a (partly
            --           .    heuristic) reason to expect that many eigenvalues
            --           .    will deflate without it.  Here, the QR sweep is
            --           .    skipped if many eigenvalues have just been deflated
            --           .    or if the remaining active block is small.
            --
            if (LD = 0) or ((100 * LD <= NW * NIBBLE) and (KBOT - KTOP + 1 > min (NMIN, NWMAX))) then
               --
               --              ==== NS = nominal number of simultaneous shifts.
               --              .    This may be lowered (slightly) if ZLAQR2
               --              .    did not provide that many shifts. ====
               --
               NS := min (NSMAX, NSR, max (2, KBOT - KTOP));
               NS := NS - "mod" (NS, 2);
               --
               --              ==== If there have been no deflations
               --              .    in a multiple of KEXSH iterations,
               --              .    then try exceptional shifts.
               --              .    Otherwise use shifts provided by
               --              .    ZLAQR2 above or from the eigenvalues
               --              .    of a trailing principal submatrix. ====
               --
               if "mod" (NDFL, KEXSH) = 0 then
                  KS := KBOT - NS + 1;
                  I  := KBOT + 2;
                  loop
                     I := I - 2;
                     exit when I < KS + 1;
                     W (I)     := H (I, I) + WILK1 * CABS1 (H (I, I - 1));
                     W (I - 1) := W (I);
                  end loop;
               else
                  --
                  --                 ==== Got NS/2 or fewer shifts? Use ZLAHQR
                  --                 .    on a trailing principal submatrix to
                  --                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
                  --                 .    there is enough space below the subdiagonal
                  --                 .    to fit an NS-by-NS scratch array.) ====
                  --
                  if KBOT - KS + 1 <= NS / 2 then
                     KS := KBOT - NS + 1;
                     KT := N - NS + 1;
                     ZLACPY ('A', NS, NS, H (KS, KS)'Address, LDH, H (KT, 1)'Address, LDH);
                     ZLAHQR (False, False, NS, 1, NS, H (KT, 1)'Address, LDH, W (KS)'Address, 1, 1, ZDUM'Address, 1, INF);
                     KS := KS + INF;
                     --
                     --                    ==== In case of a rare QR failure use
                     --                    .    eigenvalues of the trailing 2-by-2
                     --                    .    principal submatrix.  Scale to avoid
                     --                    .    overflows, underflows and subnormals.
                     --                    .    (The scale factor S can not be zero,
                     --                    .    because H(KBOT,KBOT-1) is nonzero.) ====
                     --
                     if KS >= KBOT then
                        S            := CABS1 (H (KBOT - 1, KBOT - 1)) +
                                        CABS1 (H (KBOT, KBOT - 1)) +
                                        CABS1 (H (KBOT - 1, KBOT)) +
                                        CABS1 (H (KBOT, KBOT));
                        AA           := H (KBOT - 1, KBOT - 1) / S;
                        CC           := H (KBOT, KBOT - 1) / S;
                        BB           := H (KBOT - 1, KBOT) / S;
                        DD           := H (KBOT, KBOT) / S;
                        TR2          := (AA + DD) / TWO;
                        DET          := (AA - TR2) * (DD - TR2) - BB * CC;
                        RTDISC       := Sqrt (-DET);
                        W (KBOT - 1) := (TR2 + RTDISC) * S;
                        W (KBOT)     := (TR2 - RTDISC) * S;
                        --
                        KS := KBOT - 1;
                     end if;
                  end if;
                  --
                  if KBOT - KS + 1 > NS then
                     --
                     --                    ==== Sort the shifts (Helps a little) ====
                     --
                     SORTED := False;
                     K      := KBOT + 1;
                     loop
                        K := K - 1;
                        exit when K < KS + 1;
                        if SORTED then
                           goto L60;
                        end if;
                        SORTED := True;
                        I      := KS - 1;
                        loop
                           I := I + 1;
                           exit when I > K - 1;
                           if CABS1 (W (I)) < CABS1 (W (I + 1)) then
                              SORTED    := False;
                              SWAP      := W (I);
                              W (I)     := W (I + 1);
                              W (I + 1) := SWAP;
                           end if;
                        end loop;
                     end loop;
                     <<L60>> null;
                  end if;
               end if;
               --
               --              ==== If there are only two shifts, then use
               --              .    only one.  ====
               --
               if KBOT - KS + 1 = 2 then
                  if CABS1 (W (KBOT) - H (KBOT, KBOT)) < CABS1 (W (KBOT - 1) - H (KBOT, KBOT)) 
                     then W (KBOT - 1) := W (KBOT);
                     else W (KBOT) := W (KBOT - 1);
                  end if;
               end if;
               --
               --              ==== Use up to NS of the the smallest magnatiude
               --              .    shifts.  If there aren't NS shifts available,
               --              .    then use them all, possibly dropping one to
               --              .    make the number of shifts even. ====
               --
               NS := min (NS, KBOT - KS + 1);
               NS := NS - "mod" (NS, 2);
               KS := KBOT - NS + 1;
               --
               --              ==== Small-bulge multi-shift QR sweep:
               --              .    split workspace under the subdiagonal into
               --              .    - a KDU-by-KDU work array U in the lower
               --              .      left-hand-corner,
               --              .    - a KDU-by-at-least-KDU-but-more-is-better
               --              .      (KDU-by-NHo) horizontal work array WH along
               --              .      the bottom edge,
               --              .    - and an at-least-KDU-but-more-is-better-by-KDU
               --              .      (NVE-by-KDU) vertical work WV arrow along
               --              .      the left-hand-edge. ====
               --
               KDU := 3 * NS - 3;
               KU  := N - KDU + 1;
               KWH := KDU + 1;
               NHO := (N - KDU + 1 - 4) - (KDU + 1) + 1;
               KWV := KDU + 4;
               NVE := N - KDU - KWV + 1;
               --
               --              ==== Small-bulge multi-shift QR sweep ====
               --
               ZLAQR5
                 (WANTT,
                  WANTZ,
                  KACC22,
                  N,
                  KTOP,
                  KBOT,
                  NS,
                  W (KS)'Address,
                  H'Address,
                  LDH,
                  ILOZ,
                  IHIZ,
                  Z'Address,
                  LDZ,
                  WORK'Address,
                  3,
                  H (KU, 1)'Address,
                  LDH,
                  NVE,
                  H (KWV, 1)'Address,
                  LDH,
                  NHO,
                  H (KU, KWH)'Address,
                  LDH);
            end if;
            --
            --           ==== Note progress (or the lack of it). ====
            --
            if LD > 0 
               then NDFL := 1;
               else NDFL := NDFL + 1;
            end if;
            --
            --           ==== End of main loop ====
         end loop;
         --
         --        ==== Iteration limit exceeded.  Set INFO to show where
         --        .    the problem occurred and exit. ====
         --
         INFO := KBOT;
         <<L80>> null;
      end if;
      --
      --     ==== Return the optimal value of LWORK. ====
      --
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      --
      --     ==== End of ZLAQR4 ====
      --
   end ZLAQR4;

   procedure ZLAQR5
     (WANTT  : Boolean;
      WANTZ  : Boolean;
      KACC22 : Integer;
      N      : Integer;
      KTOP   : Integer;
      KBOT   : Integer;
      NSHFTS : Integer;
      S_adr  : Address;
      H_adr  : Address;
      LDH    : Integer;
      ILOZ   : Integer;
      IHIZ   : Integer;
      Z_adr  : Address;
      LDZ    : Integer;
      V_adr  : Address;
      LDV    : Integer;
      U_adr  : Address;
      LDU    : Integer;
      NV     : Integer;
      WV_adr : Address;
      LDWV   : Integer;
      NH     : Integer;
      WH_adr : Address;
      LDWH   : Integer)
   is

      S  : Ftn_Complex_Vector (1 .. NSHFTS);
      H  : Ftn_Complex_Matrix (1 .. LDH, 1 .. N);
      Z  : Ftn_Complex_Matrix (1 .. LDZ, 1 .. IHIZ); -- LCB: comment in the Fortran source has dimensions of Z = (LDZ,IHI)
      V  : Ftn_Complex_Matrix (1 .. LDV, 1 .. NSHFTS / 2);
      U  : Ftn_Complex_Matrix (1 .. LDU, 1 .. 3 * NSHFTS - 3);
      WV : Ftn_Complex_Matrix (1 .. LDWV, 1 .. 3 * NSHFTS - 3);
      WH : Ftn_Complex_Matrix (1 .. LDWH, 1 .. NH);

      for S'Address use S_adr;
      for H'Address use H_adr;
      for Z'Address use Z_adr;
      for V'Address use V_adr;
      for U'Address use U_adr;
      for WV'Address use WV_adr;
      for WH'Address use WH_adr;

      pragma Import (Ada, S);
      pragma Import (Ada, H);
      pragma Import (Ada, Z);
      pragma Import (Ada, V);
      pragma Import (Ada, U);
      pragma Import (Ada, WV);
      pragma Import (Ada, WH);

      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      RZERO  : constant Real    := 0.0e0;
      RONE   : constant Real    := 1.0e0;
      ALPHA  : Complex;
      BETA   : Complex;
      CDUM   : Complex;
      REFSUM : Complex;
      H11    : Real;
      H12    : Real;
      H21    : Real;
      H22    : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SCL    : Real;
      SMLNUM : Real;
      TST1   : Real;
      TST2   : Real;
      ULP    : Real;
      I2     : Integer;
      I4     : Integer;
      INCOL  : Integer;
      J      : Integer;
      J2     : Integer;
      J4     : Integer;
      JBOT   : Integer;
      JCOL   : Integer;
      JLEN   : Integer;
      JROW   : Integer;
      JTOP   : Integer;
      K      : Integer;
      K1     : Integer;
      KDU    : Integer;
      KMS    : Integer;
      KNZ    : Integer;
      KRCOL  : Integer;
      KZS    : Integer;
      M      : Integer;
      M22    : Integer;
      MBOT   : Integer;
      MEND   : Integer;
      MSTART : Integer;
      MTOP   : Integer;
      NBMPS  : Integer;
      NDCOL  : Integer;
      NS     : Integer;
      NU     : Integer;
      ACCUM  : Boolean;
      BLK22  : Boolean;
      BMP22  : Boolean;
      VT     : Ftn_Complex_Vector (1 .. 3);

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLAQR5( WANTT, WANTZ, KACC22, N, KTOP, KBOT, NSHFTS, S,
   --                          H, LDH, ILOZ, IHIZ, Z, LDZ, V, LDV, U, LDU, NV,
   --                          WV, LDWV, NH, WH, LDWH )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHIZ, ILOZ, KACC22, KBOT, KTOP, LDH, LDU, LDV,
   --      $                   LDWH, LDWV, LDZ, N, NH, NSHFTS, NV
   --       LOGICAL            WANTT, WANTZ
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         H( LDH, * ), S( * ), U( LDU, * ), V( LDV, * ),
   --      $                   WH( LDWH, * ), WV( LDWV, * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --     ZLAQR5, called by ZLAQR0, performs a
   --     single small-bulge multi-shift QR sweep.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] WANTT
   --           WANTT is LOGICAL scalar
   --              WANTT = .true. if the triangular Schur factor
   --              is being computed.  WANTT is set to .false. otherwise.
   --
   --  [in] WANTZ
   --           WANTZ is LOGICAL scalar
   --              WANTZ = .true. if the unitary Schur factor is being
   --              computed.  WANTZ is set to .false. otherwise.
   --
   --  [in] KACC22
   --           KACC22 is integer with value 0, 1, or 2.
   --              Specifies the computation mode of far-from-diagonal
   --              orthogonal updates.
   --         = 0: ZLAQR5 does not accumulate reflections and does not
   --              use matrix-matrix multiply to update far-from-diagonal
   --              matrix entries.
   --         = 1: ZLAQR5 accumulates reflections and uses matrix-matrix
   --              multiply to update the far-from-diagonal matrix entries.
   --         = 2: ZLAQR5 accumulates reflections, uses matrix-matrix
   --              multiply to update the far-from-diagonal matrix entries,
   --              and takes advantage of 2-by-2 block structure during
   --              matrix multiplies.
   --
   --  [in] N
   --           N is integer scalar
   --              N is the order of the Hessenberg matrix H upon which this
   --              subroutine operates.
   --
   --  [in] KTOP
   --           KTOP is integer scalar
   --
   --  [in] KBOT
   --           KBOT is integer scalar
   --              These are the first and last rows and columns of an
   --              isolated diagonal block upon which the QR sweep is to be
   --              applied. It is assumed without a check that
   --                        either KTOP = 1  or   H(KTOP,KTOP-1) = 0
   --              and
   --                        either KBOT = N  or   H(KBOT+1,KBOT) = 0.
   --
   --  [in] NSHFTS
   --           NSHFTS is integer scalar
   --              NSHFTS gives the number of simultaneous shifts.  NSHFTS
   --              must be positive and even.
   --
   --  [in,out] S
   --           S is COMPLEX*16 array of size (NSHFTS)
   --              S contains the shifts of origin that define the multi-
   --              shift QR sweep.  On output S may be reordered.
   --
   --  [in,out] H
   --           H is COMPLEX*16 array of size (LDH,N)
   --              On input H contains a Hessenberg matrix.  On output a
   --              multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
   --              to the isolated diagonal block in rows and columns KTOP
   --              through KBOT.
   --
   --  [in] LDH
   --           LDH is integer scalar
   --              LDH is the leading dimension of H just as declared in the
   --              calling procedure.  LDH.GE.MAX(1,N).
   --
   --  [in] ILOZ
   --           ILOZ is INTEGER
   --
   --  [in] IHIZ
   --           IHIZ is INTEGER
   --              Specify the rows of Z to which transformations must be
   --              applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array of size (LDZ,IHI)
   --              If WANTZ = .TRUE., then the QR Sweep unitary
   --              similarity transformation is accumulated into
   --              Z(ILOZ:IHIZ,ILO:IHI) from the right.
   --              If WANTZ = .FALSE., then Z is unreferenced.
   --
   --  [in] LDZ
   --           LDZ is integer scalar
   --              LDA is the leading dimension of Z just as declared in
   --              the calling procedure. LDZ.GE.N.
   --
   --  [out] V
   --           V is COMPLEX*16 array of size (LDV,NSHFTS/2)
   --
   --  [in] LDV
   --           LDV is integer scalar
   --              LDV is the leading dimension of V as declared in the
   --              calling procedure.  LDV.GE.3.
   --
   --  [out] U
   --           U is COMPLEX*16 array of size
   --              (LDU,3*NSHFTS-3)
   --
   --  [in] LDU
   --           LDU is integer scalar
   --              LDU is the leading dimension of U just as declared in the
   --              in the calling subroutine.  LDU.GE.3*NSHFTS-3.
   --
   --  [in] NH
   --           NH is integer scalar
   --              NH is the number of columns in array WH available for
   --              workspace. NH.GE.1.
   --
   --  [out] WH
   --           WH is COMPLEX*16 array of size (LDWH,NH)
   --
   --  [in] LDWH
   --           LDWH is integer scalar
   --              Leading dimension of WH just as declared in the
   --              calling procedure.  LDWH.GE.3*NSHFTS-3.
   --
   --  [in] NV
   --           NV is integer scalar
   --              NV is the number of rows in WV agailable for workspace.
   --              NV.GE.1.
   --
   --  [out] WV
   --           WV is COMPLEX*16 array of size
   --              (LDWV,3*NSHFTS-3)
   --
   --  [in] LDWV
   --           LDWV is integer scalar
   --              LDWV is the leading dimension of WV as declared in the
   --              in the calling subroutine.  LDWV.GE.NV.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --        Karen Braman and Ralph Byers, Department of Mathematics,
   --        University of Kansas, USA
   --
   --  References:
   --  ================
   --
   --        K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
   --        Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
   --        Performance, SIAM Journal of Matrix Analysis, volume 23, pages
   --        929--947, 2002.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  ================================================================
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ), ONE = ( 1.0d0, 0.0d0 ) )
   --      PARAMETER          ( RZERO = 0.0d0, RONE = 1.0d0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       DOUBLE PRECISION   DLAMCH
   --       EXTERNAL           DLAMCH
   --     ..
   --     .. Intrinsic Functions ..
   --
   --      INTRINSIC          ABS, DBLE, DCONJG, DIMAG, MAX, MIN, MOD
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           DLABAD, ZGEMM, ZLACPY, ZLAQR1, ZLARFG, ZLASET,
   --      $                   ZTRMM
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      --
      --     ==== If there are no shifts, then there is nothing to do. ====
      --
      if NSHFTS < 2 then
         return;
      end if;
      --
      --     ==== If the active block is empty or 1-by-1, then there
      --     .    is nothing to do. ====
      --
      if KTOP >= KBOT then
         return;
      end if;
      --
      --     ==== NSHFTS is supposed to be even, but if it is odd,
      --     .    then simply reduce it by one.  ====
      --
      NS := NSHFTS - "mod" (NSHFTS, 2);
      --
      --     ==== Machine constants for deflation ====
      --
      SAFMIN := DLAMCH ('S');
      SAFMAX := RONE / SAFMIN;
      DLABAD (SAFMIN, SAFMAX);
      ULP    := DLAMCH ('P');
      SMLNUM := SAFMIN * (Real (N) / ULP);
      --
      --     ==== Use accumulated reflections to update far-from-diagonal
      --     .    entries ? ====
      --
      ACCUM := (KACC22 = 1) or (KACC22 = 2);
      --
      --     ==== If so, exploit the 2-by-2 block structure? ====
      --
      BLK22 := (NS > 2) and (KACC22 = 2);
      --
      --     ==== clear trash ====
      --
      if KTOP + 2 <= KBOT then
         H (KTOP + 2, KTOP) := ZERO;
      end if;
      --
      --     ==== NBMPS = number of 2-shift bulges in the chain ====
      --
      NBMPS := NS / 2;
      --
      --     ==== KDU = width of slab ====
      --
      KDU := 6 * NBMPS - 3;
      --
      --     ==== Create and chase chains of NBMPS bulges ====
      --
      INCOL := 3 * (1 - NBMPS) + KTOP - 1 - (3 * NBMPS - 2);
      loop
         INCOL := INCOL + 3 * NBMPS - 2;
         if 3 * NBMPS - 2 > 0 
            then exit when INCOL > KBOT - 2;
            else exit when INCOL < KBOT - 2;
         end if;
         NDCOL := INCOL + KDU;
         if ACCUM then
            ZLASET ('A', KDU, KDU, ZERO, ONE, U'Address, LDU);
         end if;
         --
         --        ==== Near-the-diagonal bulge chase.  The following loop
         --        .    performs the near-the-diagonal part of a small bulge
         --        .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal
         --        .    chunk extends from column INCOL to column NDCOL
         --        .    (including both column INCOL and column NDCOL). The
         --        .    following loop chases a 3*NBMPS column long chain of
         --        .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL
         --        .    may be less than KTOP and and NDCOL may be greater than
         --        .    KBOT indicating phantom columns from which to chase
         --        .    bulges before they are actually introduced or to which
         --        .    to chase bulges beyond column KBOT.)  ====
         --
         KRCOL := INCOL - 1;
         loop
            KRCOL := KRCOL + 1;
            exit when KRCOL > min (INCOL + 3 * NBMPS - 3, KBOT - 2);
            --
            --           ==== Bulges number MTOP to MBOT are active Real implicit
            --           .    shift bulges.  There may or may not also be small
            --           .    2-by-2 bulge, if there is room.  The inactive bulges
            --           .    (if any) must wait until the active bulges have moved
            --           .    down the diagonal to make room.  The phantom matrix
            --           .    paradigm described above helps keep track.  ====
            --
            MTOP  := max (1, ((KTOP - 1) - KRCOL + 2) / 3 + 1);
            MBOT  := min (NBMPS, (KBOT - KRCOL) / 3);
            M22   := MBOT + 1;
            BMP22 := (MBOT < NBMPS) and (KRCOL + 3 * (M22 - 1)) = (KBOT - 2);
            --
            --           ==== Generate reflections to chase the chain right
            --           .    one column.  (The minimum value of K is KTOP-1.) ====
            --
            M := MTOP - 1;
            loop
               M := M + 1;
               exit when M > MBOT;
               K := KRCOL + 3 * (M - 1);
               if K = KTOP - 1 then
                  ZLAQR1 (3, H (KTOP, KTOP)'Address, LDH, S (2 * M - 1), S (2 * M), V (1, M)'Address);
                  ALPHA := V (1, M);
                  ZLARFG (3, ALPHA, V (2, M)'Address, 1, V (1, M));
               else
                  BETA     := H (K + 1, K);
                  V (2, M) := H (K + 2, K);
                  V (3, M) := H (K + 3, K);
                  ZLARFG (3, BETA, V (2, M)'Address, 1, V (1, M));
                  --
                  --                 ==== A Bulge may collapse because of vigilant
                  --                 .    deflation or destructive underflow.  In the
                  --                 .    underflow case, try the two-small-subdiagonals
                  --                 .    trick to try to reinflate the bulge.  ====
                  --
                  if H (K + 3, K) /= ZERO or H (K + 3, K + 1) /= ZERO or H (K + 3, K + 2) = ZERO then
                     --
                     --                    ==== Typical case: not collapsed (yet). ====
                     --
                     H (K + 1, K) := BETA;
                     H (K + 2, K) := ZERO;
                     H (K + 3, K) := ZERO;
                  else
                     --
                     --                    ==== Atypical case: collapsed.  Attempt to
                     --                    .    reintroduce ignoring H(K+1,K) and H(K+2,K).
                     --                    .    If the fill resulting from the new
                     --                    .    reflector is too large, then abandon it.
                     --                    .    Otherwise, use the new one. ====
                     --
                     ZLAQR1 (3, H (K + 1, K + 1)'Address, LDH, S (2 * M - 1), S (2 * M), VT'Address);
                     ALPHA := VT (1);
                     ZLARFG (3, ALPHA, VT (2)'Address, 1, VT (1));
                     REFSUM := dconjg (VT (1)) * (H (K + 1, K) + dconjg (VT (2)) * H (K + 2, K));
                     --
                     if CABS1 (H (K + 2, K) - REFSUM * VT (2)) + CABS1 (REFSUM * VT (3)) >
                        ULP * (CABS1 (H (K, K)) + CABS1 (H (K + 1, K + 1)) + CABS1 (H (K + 2, K + 2)))
                     then
                        --
                        --                       ==== Starting a new bulge here would
                        --                       .    create non-negligible fill.  Use
                        --                       .    the old one with trepidation. ====
                        --
                        H (K + 1, K) := BETA;
                        H (K + 2, K) := ZERO;
                        H (K + 3, K) := ZERO;
                     else
                        --
                        --                       ==== Stating a new bulge here would
                        --                       .    create only negligible fill.
                        --                       .    Replace the old reflector with
                        --                       .    the new one. ====
                        --
                        H (K + 1, K) := H (K + 1, K) - REFSUM;
                        H (K + 2, K) := ZERO;
                        H (K + 3, K) := ZERO;
                        V (1, M)     := VT (1);
                        V (2, M)     := VT (2);
                        V (3, M)     := VT (3);
                     end if;
                  end if;
               end if;
            end loop;
            --
            --           ==== Generate a 2-by-2 reflection, if needed. ====
            --
            K := KRCOL + 3 * (M22 - 1);
            if BMP22 then
               if K = KTOP - 1 then
                  ZLAQR1 (2, H (K + 1, K + 1)'Address, LDH, S (2 * M22 - 1), S (2 * M22), V (1, M22)'Address);
                  BETA := V (1, M22);
                  ZLARFG (2, BETA, V (2, M22)'Address, 1, V (1, M22));
               else
                  BETA       := H (K + 1, K);
                  V (2, M22) := H (K + 2, K);
                  ZLARFG (2, BETA, V (2, M22)'Address, 1, V (1, M22));
                  H (K + 1, K) := BETA;
                  H (K + 2, K) := ZERO;
               end if;
            end if;
            --
            --           ==== Multiply H by reflections from the left ====
            --
            if ACCUM then
               JBOT := min (NDCOL, KBOT);
            elsif WANTT then
               JBOT := N;
            else
               JBOT := KBOT;
            end if;
            J := max (KTOP, KRCOL) - 1;
            loop
               J := J + 1;
               exit when J > JBOT;
               MEND := min (MBOT, (J - KRCOL + 2) / 3);
               M    := MTOP - 1;
               loop
                  M := M + 1;
                  exit when M > MEND;
                  K            := KRCOL + 3 * (M - 1);
                  REFSUM       := dconjg (V (1, M)) *
                                  (H (K + 1, J) + dconjg (V (2, M)) * H (K + 2, J) + dconjg (V (3, M)) * H (K + 3, J));
                  H (K + 1, J) := H (K + 1, J) - REFSUM;
                  H (K + 2, J) := H (K + 2, J) - REFSUM * V (2, M);
                  H (K + 3, J) := H (K + 3, J) - REFSUM * V (3, M);
               end loop;
            end loop;
            if BMP22 then
               K := KRCOL + 3 * (M22 - 1);
               J := max (K + 1, KTOP) - 1;
               loop
                  J := J + 1;
                  exit when J > JBOT;
                  REFSUM       := dconjg (V (1, M22)) * (H (K + 1, J) + dconjg (V (2, M22)) * H (K + 2, J));
                  H (K + 1, J) := H (K + 1, J) - REFSUM;
                  H (K + 2, J) := H (K + 2, J) - REFSUM * V (2, M22);
               end loop;
            end if;
            --
            --           ==== Multiply H by reflections from the right.
            --           .    Delay filling in the last row until the
            --           .    vigilant deflation check is complete. ====
            --
            if ACCUM then
               JTOP := max (KTOP, INCOL);
            elsif WANTT then
               JTOP := 1;
            else
               JTOP := KTOP;
            end if;
            M := MTOP - 1;
            loop
               M := M + 1;
               exit when M > MBOT;
               if V (1, M) /= ZERO then
                  K := KRCOL + 3 * (M - 1);
                  J := JTOP - 1;
                  loop
                     J := J + 1;
                     exit when J > min (KBOT, K + 3);
                     REFSUM       := V (1, M) * (H (J, K + 1) + V (2, M) * H (J, K + 2) + V (3, M) * H (J, K + 3));
                     H (J, K + 1) := H (J, K + 1) - REFSUM;
                     H (J, K + 2) := H (J, K + 2) - REFSUM * dconjg (V (2, M));
                     H (J, K + 3) := H (J, K + 3) - REFSUM * dconjg (V (3, M));
                  end loop;
                  --
                  if ACCUM then
                     --
                     --                    ==== Accumulate U. (If necessary, update Z later
                     --                    .    with with an efficient matrix-matrix
                     --                    .    multiply.) ====
                     --
                     KMS := K - INCOL;
                     J   := max (1, KTOP - INCOL) - 1;
                     loop
                        J := J + 1;
                        exit when J > KDU;
                        REFSUM         := V (1, M) *
                                          (U (J, KMS + 1) + V (2, M) * U (J, KMS + 2) + V (3, M) * U (J, KMS + 3));
                        U (J, KMS + 1) := U (J, KMS + 1) - REFSUM;
                        U (J, KMS + 2) := U (J, KMS + 2) - REFSUM * dconjg (V (2, M));
                        U (J, KMS + 3) := U (J, KMS + 3) - REFSUM * dconjg (V (3, M));
                     end loop;
                  elsif WANTZ then
                     --
                     --                    ==== U is not accumulated, so update Z
                     --                    .    now by multiplying by reflections
                     --                    .    from the right. ====
                     --
                     J := ILOZ - 1;
                     loop
                        J := J + 1;
                        exit when J > IHIZ;
                        REFSUM       := V (1, M) * (Z (J, K + 1) + V (2, M) * Z (J, K + 2) + V (3, M) * Z (J, K + 3));
                        Z (J, K + 1) := Z (J, K + 1) - REFSUM;
                        Z (J, K + 2) := Z (J, K + 2) - REFSUM * dconjg (V (2, M));
                        Z (J, K + 3) := Z (J, K + 3) - REFSUM * dconjg (V (3, M));
                     end loop;
                  end if;
               end if;
            end loop;
            --
            --           ==== Special case: 2-by-2 reflection (if needed) ====
            --
            K := KRCOL + 3 * (M22 - 1);
            if BMP22 then
               if V (1, M22) /= ZERO then
                  J := JTOP - 1;
                  loop
                     J := J + 1;
                     exit when J > min (KBOT, K + 3);
                     REFSUM       := V (1, M22) * (H (J, K + 1) + V (2, M22) * H (J, K + 2));
                     H (J, K + 1) := H (J, K + 1) - REFSUM;
                     H (J, K + 2) := H (J, K + 2) - REFSUM * dconjg (V (2, M22));
                  end loop;
                  --
                  if ACCUM then
                     KMS := K - INCOL;
                     J   := max (1, KTOP - INCOL) - 1;
                     loop
                        J := J + 1;
                        exit when J > KDU;
                        REFSUM         := V (1, M22) * (U (J, KMS + 1) + V (2, M22) * U (J, KMS + 2));
                        U (J, KMS + 1) := U (J, KMS + 1) - REFSUM;
                        U (J, KMS + 2) := U (J, KMS + 2) - REFSUM * dconjg (V (2, M22));
                     end loop;
                  elsif WANTZ then
                     J := ILOZ - 1;
                     loop
                        J := J + 1;
                        exit when J > IHIZ;
                        REFSUM       := V (1, M22) * (Z (J, K + 1) + V (2, M22) * Z (J, K + 2));
                        Z (J, K + 1) := Z (J, K + 1) - REFSUM;
                        Z (J, K + 2) := Z (J, K + 2) - REFSUM * dconjg (V (2, M22));
                     end loop;
                  end if;
               end if;
            end if;
            --
            --           ==== Vigilant deflation check ====
            --
            MSTART := MTOP;
            if KRCOL + 3 * (MSTART - 1) < KTOP then
               MSTART := MSTART + 1;
            end if;
            MEND := MBOT;
            if BMP22 then
               MEND := MEND + 1;
            end if;
            if KRCOL = KBOT - 2 then
               MEND := MEND + 1;
            end if;
            M := MSTART - 1;
            loop
               M := M + 1;
               exit when M > MEND;
               K := min (KBOT - 1, KRCOL + 3 * (M - 1));
               --
               --              ==== The following convergence test requires that
               --              .    the tradition small-compared-to-nearby-diagonals
               --              .    criterion and the Ahues & Tisseur (LAWN 122, 1997)
               --              .    criteria both be satisfied.  The latter improves
               --              .    accuracy in some examples. Falling back on an
               --              .    alternate convergence criterion when TST1 or TST2
               --              .    is zero (as done here) is traditional but probably
               --              .    unnecessary. ====
               --
               if H (K + 1, K) /= ZERO then
                  TST1 := CABS1 (H (K, K)) + CABS1 (H (K + 1, K + 1));
                  if TST1 = RZERO then
                     if K >= KTOP + 1 then
                        TST1 := TST1 + CABS1 (H (K, K - 1));
                     end if;
                     if K >= KTOP + 2 then
                        TST1 := TST1 + CABS1 (H (K, K - 2));
                     end if;
                     if K >= KTOP + 3 then
                        TST1 := TST1 + CABS1 (H (K, K - 3));
                     end if;
                     if K <= KBOT - 2 then
                        TST1 := TST1 + CABS1 (H (K + 2, K + 1));
                     end if;
                     if K <= KBOT - 3 then
                        TST1 := TST1 + CABS1 (H (K + 3, K + 1));
                     end if;
                     if K <= KBOT - 4 then
                        TST1 := TST1 + CABS1 (H (K + 4, K + 1));
                     end if;
                  end if;
                  if CABS1 (H (K + 1, K)) <= max (SMLNUM, ULP * TST1) then
                     H12  := max (CABS1 (H (K + 1, K)), CABS1 (H (K, K + 1)));
                     H21  := min (CABS1 (H (K + 1, K)), CABS1 (H (K, K + 1)));
                     H11  := max (CABS1 (H (K + 1, K + 1)), CABS1 (H (K, K) - H (K + 1, K + 1)));
                     H22  := min (CABS1 (H (K + 1, K + 1)), CABS1 (H (K, K) - H (K + 1, K + 1)));
                     SCL  := H11 + H12;
                     TST2 := H22 * (H11 / SCL);
                     --
                     if TST2 = RZERO or H21 * (H12 / SCL) <= max (SMLNUM, ULP * TST2) then
                        H (K + 1, K) := ZERO;
                     end if;
                  end if;
               end if;
            end loop;
            --
            --           ==== Fill in the last row of each bulge. ====
            --
            MEND := min (NBMPS, (KBOT - KRCOL - 1) / 3);
            M    := MTOP - 1;
            loop
               M := M + 1;
               exit when M > MEND;
               K                := KRCOL + 3 * (M - 1);
               REFSUM           := V (1, M) * V (3, M) * H (K + 4, K + 3);
               H (K + 4, K + 1) := -REFSUM;
               H (K + 4, K + 2) := -REFSUM * dconjg (V (2, M));
               H (K + 4, K + 3) := H (K + 4, K + 3) - REFSUM * dconjg (V (3, M));
            end loop;
            --
            --           ==== End of near-the-diagonal bulge chase. ====
            --
         end loop;
         --
         --        ==== Use U (if accumulated) to update far-from-diagonal
         --        .    entries in H.  If required, use U to update Z as
         --        .    well. ====
         --
         if ACCUM then
            if WANTT then
               JTOP := 1;
               JBOT := N;
            else
               JTOP := KTOP;
               JBOT := KBOT;
            end if;
            if (not BLK22) or (INCOL < KTOP) or (NDCOL > KBOT) or (NS <= 2) then
               --
               --              ==== Updates not exploiting the 2-by-2 block
               --              .    structure of U.  K1 and NU keep track of
               --              .    the location and size of U in the special
               --              .    cases of introducing bulges and chasing
               --              .    bulges off the bottom.  In these special
               --              .    cases and in case the number of shifts
               --              .    is NS = 2, there is no 2-by-2 block
               --              .    structure to exploit.  ====
               --
               K1 := max (1, KTOP - INCOL);
               NU := (KDU - max (0, NDCOL - KBOT)) - K1 + 1;
               --
               --              ==== Horizontal Multiply ====
               --
               JCOL := min (NDCOL, KBOT) + 1 - NH;
               loop
                  JCOL := JCOL + NH;
                  exit when JCOL > JBOT;
                  JLEN := min (NH, JBOT - JCOL + 1);
                  ZGEMM
                    ('C',
                     'N',
                     NU,
                     JLEN,
                     NU,
                     ONE,
                     U (K1, K1)'Address,
                     LDU,
                     H (INCOL + K1, JCOL)'Address,
                     LDH,
                     ZERO,
                     WH'Address,
                     LDWH);
                  ZLACPY ('A', NU, JLEN, WH'Address, LDWH, H (INCOL + K1, JCOL)'Address, LDH);
               end loop;
               --
               --              ==== Vertical multiply ====
               --
               JROW := JTOP - NV;
               loop
                  JROW := JROW + NV;
                  exit when JROW > max (KTOP, INCOL) - 1;
                  JLEN := min (NV, max (KTOP, INCOL) - JROW);
                  ZGEMM
                    ('N',
                     'N',
                     JLEN,
                     NU,
                     NU,
                     ONE,
                     H (JROW, INCOL + K1)'Address,
                     LDH,
                     U (K1, K1)'Address,
                     LDU,
                     ZERO,
                     WV'Address,
                     LDWV);
                  ZLACPY ('A', JLEN, NU, WV'Address, LDWV, H (JROW, INCOL + K1)'Address, LDH);
               end loop;
               --
               --              ==== Z multiply (also vertical) ====
               --
               if WANTZ then
                  JROW := ILOZ - NV;
                  loop
                     JROW := JROW + NV;
                     exit when JROW > IHIZ;
                     JLEN := min (NV, IHIZ - JROW + 1);
                     ZGEMM
                       ('N',
                        'N',
                        JLEN,
                        NU,
                        NU,
                        ONE,
                        Z (JROW, INCOL + K1)'Address,
                        LDZ,
                        U (K1, K1)'Address,
                        LDU,
                        ZERO,
                        WV'Address,
                        LDWV);
                     ZLACPY ('A', JLEN, NU, WV'Address, LDWV, Z (JROW, INCOL + K1)'Address, LDZ);
                  end loop;
               end if;
            else
               --
               --              ==== Updates exploiting U's 2-by-2 block structure.
               --              .    (I2, I4, J2, J4 are the last rows and columns
               --              .    of the blocks.) ====
               --
               I2 := (KDU + 1) / 2;
               I4 := KDU;
               J2 := I4 - I2;
               J4 := KDU;
               --
               --              ==== KZS and KNZ deal with the band of zeros
               --              .    along the diagonal of one of the triangular
               --              .    blocks. ====
               --
               KZS := (J4 - J2) - (NS + 1);
               KNZ := NS + 1;
               --
               --              ==== Horizontal multiply ====
               --
               JCOL := min (NDCOL, KBOT) + 1 - NH;
               loop
                  JCOL := JCOL + NH;
                  exit when JCOL > JBOT;
                  JLEN := min (NH, JBOT - JCOL + 1);
                  --
                  --                 ==== Copy bottom of H to top+KZS of scratch ====
                  --                  (The first KZS rows get multiplied by zero.) ====
                  --
                  ZLACPY ('A', KNZ, JLEN, H (INCOL + 1 + J2, JCOL)'Address, LDH, WH (KZS + 1, 1)'Address, LDWH);
                  --
                  --                 ==== Multiply by U21**H ====
                  --
                  ZLASET ('A', KZS, JLEN, ZERO, ZERO, WH'Address, LDWH);
                  ZTRMM
                    ('L',
                     'U',
                     'C',
                     'N',
                     KNZ,
                     JLEN,
                     ONE,
                     U (J2 + 1, 1 + KZS)'Address,
                     LDU,
                     WH (KZS + 1, 1)'Address,
                     LDWH);
                  --
                  --                 ==== Multiply top of H by U11**H ====
                  --
                  ZGEMM
                    ('C',
                     'N',
                     I2,
                     JLEN,
                     J2,
                     ONE,
                     U'Address,
                     LDU,
                     H (INCOL + 1, JCOL)'Address,
                     LDH,
                     ONE,
                     WH'Address,
                     LDWH);
                  --
                  --                 ==== Copy top of H to bottom of WH ====
                  --
                  ZLACPY ('A', J2, JLEN, H (INCOL + 1, JCOL)'Address, LDH, WH (I2 + 1, 1)'Address, LDWH);
                  --
                  --                 ==== Multiply by U21**H ====
                  --
                  ZTRMM ('L', 'L', 'C', 'N', J2, JLEN, ONE, U (1, I2 + 1)'Address, LDU, WH (I2 + 1, 1)'Address, LDWH);
                  --
                  --                 ==== Multiply by U22 ====
                  --
                  ZGEMM
                    ('C',
                     'N',
                     I4 - I2,
                     JLEN,
                     J4 - J2,
                     ONE,
                     U (J2 + 1, I2 + 1)'Address,
                     LDU,
                     H (INCOL + 1 + J2, JCOL)'Address,
                     LDH,
                     ONE,
                     WH (I2 + 1, 1)'Address,
                     LDWH);
                  --
                  --                 ==== Copy it back ====
                  --
                  ZLACPY ('A', KDU, JLEN, WH'Address, LDWH, H (INCOL + 1, JCOL)'Address, LDH);
               end loop;
               --
               --              ==== Vertical multiply ====
               --
               JROW := JTOP - NV;
               loop
                  JROW := JROW + NV;
                  exit when JROW > max (INCOL, KTOP) - 1;
                  JLEN := min (NV, max (INCOL, KTOP) - JROW);
                  --
                  --                 ==== Copy right of H to scratch (the first KZS
                  --                 .    columns get multiplied by zero) ====
                  --
                  ZLACPY ('A', JLEN, KNZ, H (JROW, INCOL + 1 + J2)'Address, LDH, WV (1, 1 + KZS)'Address, LDWV);
                  --
                  --                 ==== Multiply by U21 ====
                  --
                  ZLASET ('A', JLEN, KZS, ZERO, ZERO, WV'Address, LDWV);
                  ZTRMM
                    ('R',
                     'U',
                     'N',
                     'N',
                     JLEN,
                     KNZ,
                     ONE,
                     U (J2 + 1, 1 + KZS)'Address,
                     LDU,
                     WV (1, 1 + KZS)'Address,
                     LDWV);
                  --
                  --                 ==== Multiply by U11 ====
                  --
                  ZGEMM
                    ('N',
                     'N',
                     JLEN,
                     I2,
                     J2,
                     ONE,
                     H (JROW, INCOL + 1)'Address,
                     LDH,
                     U'Address,
                     LDU,
                     ONE,
                     WV'Address,
                     LDWV);
                  --
                  --                 ==== Copy left of H to right of scratch ====
                  --
                  ZLACPY ('A', JLEN, J2, H (JROW, INCOL + 1)'Address, LDH, WV (1, 1 + I2)'Address, LDWV);
                  --
                  --                 ==== Multiply by U21 ====
                  --
                  ZTRMM ('R', 'L', 'N', 'N', JLEN, I4 - I2, ONE, U (1, I2 + 1)'Address, LDU, WV (1, 1 + I2)'Address, LDWV);
                  --
                  --                 ==== Multiply by U22 ====
                  --
                  ZGEMM
                    ('N',
                     'N',
                     JLEN,
                     I4 - I2,
                     J4 - J2,
                     ONE,
                     H (JROW, INCOL + 1 + J2)'Address,
                     LDH,
                     U (J2 + 1, I2 + 1)'Address,
                     LDU,
                     ONE,
                     WV (1, 1 + I2)'Address,
                     LDWV);
                  --
                  --                 ==== Copy it back ====
                  --
                  ZLACPY ('A', JLEN, KDU, WV'Address, LDWV, H (JROW, INCOL + 1)'Address, LDH);
               end loop;
               --
               --              ==== Multiply Z (also vertical) ====
               --
               if WANTZ then
                  JROW := ILOZ - NV;
                  loop
                     JROW := JROW + NV;
                     exit when JROW > IHIZ;
                     JLEN := min (NV, IHIZ - JROW + 1);
                     --
                     --                    ==== Copy right of Z to left of scratch (first
                     --                    .     KZS columns get multiplied by zero) ====
                     --
                     ZLACPY ('A', JLEN, KNZ, Z (JROW, INCOL + 1 + J2)'Address, LDZ, WV (1, 1 + KZS)'Address, LDWV);
                     --
                     --                    ==== Multiply by U12 ====
                     --
                     ZLASET ('A', JLEN, KZS, ZERO, ZERO, WV'Address, LDWV);
                     ZTRMM
                       ('R',
                        'U',
                        'N',
                        'N',
                        JLEN,
                        KNZ,
                        ONE,
                        U (J2 + 1, 1 + KZS)'Address,
                        LDU,
                        WV (1, 1 + KZS)'Address,
                        LDWV);
                     --
                     --                    ==== Multiply by U11 ====
                     --
                     ZGEMM
                       ('N',
                        'N',
                        JLEN,
                        I2,
                        J2,
                        ONE,
                        Z (JROW, INCOL + 1)'Address,
                        LDZ,
                        U'Address,
                        LDU,
                        ONE,
                        WV'Address,
                        LDWV);
                     --
                     --                    ==== Copy left of Z to right of scratch ====
                     --
                     ZLACPY ('A', JLEN, J2, Z (JROW, INCOL + 1)'Address, LDZ, WV (1, 1 + I2)'Address, LDWV);
                     --
                     --                    ==== Multiply by U21 ====
                     --
                     ZTRMM
                       ('R',
                        'L',
                        'N',
                        'N',
                        JLEN,
                        I4 - I2,
                        ONE,
                        U (1, I2 + 1)'Address,
                        LDU,
                        WV (1, 1 + I2)'Address,
                        LDWV);
                     --
                     --                    ==== Multiply by U22 ====
                     --
                     ZGEMM
                       ('N',
                        'N',
                        JLEN,
                        I4 - I2,
                        J4 - J2,
                        ONE,
                        Z (JROW, INCOL + 1 + J2)'Address,
                        LDZ,
                        U (J2 + 1, I2 + 1)'Address,
                        LDU,
                        ONE,
                        WV (1, 1 + I2)'Address,
                        LDWV);
                     --
                     --                    ==== Copy the result back to Z ====
                     --
                     ZLACPY ('A', JLEN, KDU, WV'Address, LDWV, Z (JROW, INCOL + 1)'Address, LDZ);
                  end loop;
               end if;
            end if;
         end if;
      end loop;
      --
      --     ==== End of ZLAQR5 ====
      --
   end ZLAQR5;

   procedure ZLARCM
     (M         : Integer;
      N         : Integer;
      A_adr     : Address;
      LDA       : Integer;
      B_adr     : Address;
      LDB       : Integer;
      C_adr     : Address;
      LDC       : Integer;
      RWORK_adr : Address)
   is

      A     : Ftn_Real_Matrix (1 .. LDA, 1 .. N);
      B     : Ftn_Complex_Matrix (1 .. LDB, 1 .. N);
      C     : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      RWORK : Ftn_Real_Vector (1 .. 2 * M * N);

      for A'Address use A_adr;
      for B'Address use B_adr;
      for C'Address use C_adr;
      for RWORK'Address use RWORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, B);
      pragma Import (Ada, C);
      pragma Import (Ada, RWORK);

      ONE  : constant Real := 1.0e0;
      ZERO : constant Real := 0.0e0;
      I    : Integer;
      J    : Integer;
      L    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLARCM( M, N, A, LDA, B, LDB, C, LDC, RWORK)
   --
   --       .. Scalar Arguments ..
   --       INTEGER            LDA, LDB, LDC, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   A( LDA, * ), RWORK( * )
   --       COMPLEX*16         B( LDB, * ), C( LDC, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLARCM performs a very simple matrix-matrix multiplication:
   --           C := A * B,
   --  where A is M by M and real; B is M by N and complex;
   --  C is M by N and complex.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A and of the matrix C.
   --           M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns and rows of the matrix B and
   --           the number of columns of the matrix C.
   --           N >= 0.
   --
   --  [in] A
   --           A is DOUBLE PRECISION array, dimension (LDA, M)
   --           A contains the M by M matrix A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >=max(1,M).
   --
   --  [in] B
   --           B is DOUBLE PRECISION array, dimension (LDB, N)
   --           B contains the M by N matrix B.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B. LDB >=max(1,M).
   --
   --  [in] C
   --           C is COMPLEX*16 array, dimension (LDC, N)
   --           C contains the M by N matrix C.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >=max(1,M).
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array, dimension (2*M*N)
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D0, ZERO = 0.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, DCMPLX, DIMAG
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DGEMM
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible.
   --
   begin
      if (M = 0) or (N = 0) then
         return;
      end if;
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            RWORK ((J - 1) * M + I)   := dble (B (I, J));
         end loop;
      end loop;
      --
      L := M * N + 1;
      DGEMM ('N', 'N', M, N, M, ONE, A'Address, LDA, RWORK'Address, M, ZERO, RWORK (L)'Address, M);
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            C (I, J) := Complex'(RWORK (L + (J - 1) * M + I - 1), 0.0e0);
         end loop;
      end loop;
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            RWORK ((J - 1) * M + I)   := dimag (B (I, J));
         end loop;
      end loop;
      DGEMM ('N', 'N', M, N, M, ONE, A'Address, LDA, RWORK'Address, M, ZERO, RWORK (L)'Address, M);
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > M;
            C (I, J) := dcmplx (dble (C (I, J)), RWORK (L + (J - 1) * M + I - 1));
         end loop;
      end loop;
      --
      return;
      --
      --     End of ZLARCM
      --
   end ZLARCM;

   procedure ZLARF
     (SIDE     : Character;
      M        : Integer;
      N        : Integer;
      V_adr    : Address;
      INCV     : Integer;
      TAU      : Complex;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address)
   is

      V    : Ftn_Complex_Vector (1 .. (1 + max ((M - 1), (N - 1)) * abs (INCV)));
      C    : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      Work : Ftn_Complex_Vector (1 .. max (N, M));

      for V'Address use V_adr;
      for C'Address use C_adr;
      for Work'Address use WORK_adr;

      pragma Import (Ada, V);
      pragma Import (Ada, C);
      pragma Import (Ada, Work);

      ONE       : constant Complex := (1.0e0, 0.0e0);
      ZERO      : constant Complex := (0.0e0, 0.0e0);
      APPLYLEFT : Boolean;
      I         : Integer;
      LASTV     : Integer;
      LASTC     : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK)
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE
   --       INTEGER            INCV, LDC, M, N
   --       COMPLEX*16         TAU
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         C( LDC, * ), V( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLARF applies a complex elementary reflector H to a complex M-by-N
   --  matrix C, from either the left or the right. H is represented in the
   --  form
   --
   --        H = I - tau * v * v**H
   --
   --  where tau is a complex scalar and v is a complex vector.
   --
   --  If tau = 0, then H is taken to be the unit matrix.
   --
   --  To apply H**H, supply conjg(tau) instead
   --  tau.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': form  H * C
   --           = 'R': form  C * H
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C.
   --
   --  [in] V
   --           V is COMPLEX*16 array, dimension
   --                      (1 + (M-1)*abs(INCV)) if SIDE = 'L'
   --                   or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
   --           The vector v in the representation of H. V is not used if
   --           TAU = 0.
   --
   --  [in] INCV
   --           INCV is INTEGER
   --           The increment between elements of v. INCV <> 0.
   --
   --  [in] TAU
   --           TAU is COMPLEX*16
   --           The value tau in the representation of H.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by the matrix H * C if SIDE = 'L',
   --           or C * H if SIDE = 'R'.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension
   --                          (N) if SIDE = 'L'
   --                       or (M) if SIDE = 'R'
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ), ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           ZGEMV, ZGERC
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       INTEGER            ILAZLR, ILAZLC
   --       EXTERNAL           LSAME, ILAZLR, ILAZLC
   --     ..
   --     .. Executable Statements ..
   --
   begin
      APPLYLEFT := LSAME (SIDE, 'L');
      LASTV     := 0;
      LASTC     := 0;
      if TAU /= ZERO then
         --     Set up variables for scanning V.  LASTV begins pointing to the end
         --     of V.
         if APPLYLEFT 
            then LASTV := M;
            else LASTV := N;
         end if;
         if INCV > 0 
            then I := 1 + (LASTV - 1) * INCV;
            else I := 1;
         end if;
         --     Look for the last non-zero row in V.
         while LASTV > 0 and V (I) = ZERO loop
            LASTV := LASTV - 1;
            I     := I - INCV;
         end loop;
         if APPLYLEFT then
            --     Scan for the last non-zero column in C(1:lastv,:).
            LASTC := ILAZLC (LASTV, N, C, LDC);
         else
            --     Scan for the last non-zero row in C(:,1:lastv).
            LASTC := ILAZLR (M, LASTV, C, LDC);
         end if;
      end if;
      --     Note that lastc.eq.0 renders the BLAS operations null; no special
      --     case is needed at this level.
      if APPLYLEFT then
         --
         --        Form  H * C
         --
         if LASTV > 0 then
            --
            --           w(1:lastc,1) := C(1:lastv,1:lastc)**H * v(1:lastv,1)
            --
            ZGEMV ('C', LASTV, LASTC, ONE, C'Address, LDC, V'Address, INCV, ZERO, Work'Address, 1);
            --
            --           C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)**H
            --
            ZGERC (LASTV, LASTC, -TAU, V, INCV, Work, 1, C, LDC);
         end if;
      else
         --
         --        Form  C * H
         --
         if LASTV > 0 then
            --
            --           w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1)
            --
            ZGEMV ('N', LASTC, LASTV, ONE, C'Address, LDC, V'Address, INCV, ZERO, Work'Address, 1);
            --
            --           C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)**H
            --
            ZGERC (LASTC, LASTV, -TAU, Work, 1, V, INCV, C, LDC);
         end if;
      end if;
      return;
      --
      --     End of ZLARF
      --
   end ZLARF;

   procedure ZLARFB
     (SIDE     : Character;
      TRANS    : Character;
      DIRECT   : Character;
      STOREV   : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      V_adr    : Address;
      LDV      : Integer;
      T_adr    : Address;
      LDT      : Integer;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LDWORK   : Integer)
   is

      V    : Ftn_Complex_Matrix (1 .. LDV, 1 .. max (K, M, N));
      T    : Ftn_Complex_Matrix (1 .. LDT, 1 .. K);
      C    : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Complex_Matrix (1 .. LDWORK, 1 .. K);

      for V'Address use V_adr;
      for T'Address use T_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, V);
      pragma Import (Ada, T);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      ONE    : constant Complex := (1.0e0, 0.0e0);
      TRANST : Character;
      I      : Integer;
      J      : Integer;
      LASTV  : Integer;
      LASTC  : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
   --                          T, LDT, C, LDC, WORK, LDWORK )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIRECT, SIDE, STOREV, TRANS
   --       INTEGER            K, LDC, LDT, LDV, LDWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         C( LDC, * ), T( LDT, * ), V( LDV, * ),
   --      $                   WORK( LDWORK, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLARFB applies a complex block reflector H or its transpose H**H to a
   --  complex M-by-N matrix C, from either the left or the right.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply H or H**H from the Left
   --           = 'R': apply H or H**H from the Right
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply H (No transpose)
   --           = 'C': apply H**H (Conjugate transpose)
   --
   --  [in] DIRECT
   --           DIRECT is CHARACTER*1
   --           Indicates how H is formed from a product of elementary
   --           reflectors
   --           = 'F': H = H(1) H(2) . . . H(k) (Forward)
   --           = 'B': H = H(k) . . . H(2) H(1) (Backward)
   --
   --  [in] STOREV
   --           STOREV is CHARACTER*1
   --           Indicates how the vectors which define the elementary
   --           reflectors are stored:
   --           = 'C': Columnwise
   --           = 'R': Rowwise
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C.
   --
   --  [in] K
   --           K is INTEGER
   --           The order of the matrix T (= the number of elementary
   --           reflectors whose product defines the block reflector).
   --
   --  [in] V
   --           V is COMPLEX*16 array, dimension
   --                                 (LDV,K) if STOREV = 'C'
   --                                 (LDV,M) if STOREV = 'R' and SIDE = 'L'
   --                                 (LDV,N) if STOREV = 'R' and SIDE = 'R'
   --           See Further Details.
   --
   --  [in] LDV
   --           LDV is INTEGER
   --           The leading dimension of the array V.
   --           If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
   --           if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
   --           if STOREV = 'R', LDV >= K.
   --
   --  [in] T
   --           T is COMPLEX*16 array, dimension (LDT,K)
   --           The triangular K-by-K matrix T in the representation of the
   --           block reflector.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= K.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by H*C or H**H*C or C*H or C*H**H.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (LDWORK,K)
   --
   --  [in] LDWORK
   --           LDWORK is INTEGER
   --           The leading dimension of the array WORK.
   --           If SIDE = 'L', LDWORK >= max(1,N);
   --           if SIDE = 'R', LDWORK >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The shape of the matrix V and the storage of the vectors which define
   --   the H(i) is best illustrated by the following example with n = 5 and
   --   k = 3. The elements equal to 1 are not stored; the corresponding
   --   array elements are modified but restored on exit. The rest of the
   --   array is not used.
   --
   --   DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
   --
   --                V = (  1       )                 V = (  1 v1 v1 v1 v1 )
   --                    ( v1  1    )                     (     1 v2 v2 v2 )
   --                    ( v1 v2  1 )                     (        1 v3 v3 )
   --                    ( v1 v2 v3 )
   --                    ( v1 v2 v3 )
   --
   --   DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
   --
   --                V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
   --                    ( v1 v2 v3 )                     ( v2 v2 v2  1    )
   --                    (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
   --                    (     1 v3 )
   --                    (        1 )
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       INTEGER            ILAZLR, ILAZLC
   --       EXTERNAL           LSAME, ILAZLR, ILAZLC
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           ZCOPY, ZGEMM, ZLACGV, ZTRMM
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if M <= 0 or N <= 0 then
         return;
      end if;
      --
      if LSAME (TRANS, 'N') 
         then TRANST := 'C';
         else TRANST := 'N';
      end if;
      --
      if LSAME (STOREV, 'C') then
         --
         if LSAME (DIRECT, 'F') then
            --
            --           Let  V =  ( V1 )    (first K rows)
            --                     ( V2 )
            --           where  V1  is unit lower triangular.
            --
            if LSAME (SIDE, 'L') then
               --
               --              Form  H * C  or  H**H * C  where  C = ( C1 )
               --                                                    ( C2 )
               --
               LASTV := max (K, ILAZLR (M, K, V, LDV));
               LASTC := ILAZLC (LASTV, N, C, LDC);
               --
               --              W := C**H * V  =  (C1**H * V1 + C2**H * V2)  (stored in WORK)
               --
               --              W := C1**H
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  ZCOPY (LASTC, C (J, 1)'Address, LDC, WORK (1, J)'Address, 1);
                  ZLACGV (LASTC, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V1
               --
               ZTRMM ('R', 'L', 'N', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C2**H *V2
                  --
                  ZGEMM
                    ('C',
                     'N',
                     LASTC,
                     K,
                     LASTV - K,
                     ONE,
                     C (K + 1, 1)'Address,
                     LDC,
                     V (K + 1, 1)'Address,
                     LDV,
                     ONE,
                     WORK'Address,
                     LDWORK);
               end if;
               --
               --              W := W * T**H  or  W * T
               --
               ZTRMM ('R', 'U', TRANST, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - V * W**H
               --
               if M > K then
                  --
                  --                 C2 := C2 - V2 * W**H
                  --
                  ZGEMM
                    ('N',
                     'C',
                     LASTV - K,
                     LASTC,
                     K,
                     -ONE,
                     V (K + 1, 1)'Address,
                     LDV,
                     WORK'Address,
                     LDWORK,
                     ONE,
                     C (K + 1, 1)'Address,
                     LDC);
               end if;
               --
               --              W := W * V1**H
               --
               ZTRMM ('R', 'L', 'C', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W**H
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (J, I) := C (J, I) - dconjg (WORK (I, J));
                  end loop;
               end loop;
            --
            elsif LSAME (SIDE, 'R') then
               --
               --              Form  C * H  or  C * H**H  where  C = ( C1  C2 )
               --
               LASTV := max (K, ILAZLR (N, K, V, LDV));
               LASTC := ILAZLR (M, LASTV, C, LDC);
               --
               --              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
               --
               --              W := C1
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  ZCOPY (LASTC, C (1, J)'Address, 1, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V1
               --
               ZTRMM ('R', 'L', 'N', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);

               if LASTV > K then
                  --
                  --                 W := W + C2 * V2
                  --
                  ZGEMM
                    ('N',
                     'N',
                     LASTC,
                     K,
                     LASTV - K,
                     ONE,
                     C (1, K + 1)'Address,
                     LDC,
                     V (K + 1, 1)'Address,
                     LDV,
                     ONE,
                     WORK'Address,
                     LDWORK);
               end if;
               --
               --              W := W * T  or  W * T**H
               --
               ZTRMM ('R', 'U', TRANS, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - W * V**H
               --
               if LASTV > K then
                  --
                  --                 C2 := C2 - W * V2**H
                  --
                  ZGEMM
                    ('N',
                     'C',
                     LASTC,
                     LASTV - K,
                     K,
                     -ONE,
                     WORK'Address,
                     LDWORK,
                     V (K + 1, 1)'Address,
                     LDV,
                     ONE,
                     C (1, K + 1)'Address,
                     LDC);
               end if;
               --
               --              W := W * V1**H
               --
               ZTRMM ('R', 'L', 'C', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (I, J) := C (I, J) - WORK (I, J);
                  end loop;
               end loop;
            end if;
         --
         else
            --
            --           Let  V =  ( V1 )
            --                     ( V2 )    (last K rows)
            --           where  V2  is unit upper triangular.
            --
            if LSAME (SIDE, 'L') then
               --
               --              Form  H * C  or  H**H * C  where  C = ( C1 )
               --                                                    ( C2 )
               --
               LASTV := max (K, ILAZLR (M, K, V, LDV));
               LASTC := ILAZLC (LASTV, N, C, LDC);
               --
               --              W := C**H * V  =  (C1**H * V1 + C2**H * V2)  (stored in WORK)
               --
               --              W := C2**H
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  ZCOPY (LASTC, C (LASTV - K + J, 1)'Address, LDC, WORK (1, J)'Address, 1);
                  ZLACGV (LASTC, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V2
               --
               ZTRMM ('R', 'U', 'N', 'U', LASTC, K, ONE, V (LASTV - K + 1, 1)'Address, LDV, WORK'Address, LDWORK);

               if LASTV > K then
                  --
                  --                 W := W + C1**H*V1
                  --
                  ZGEMM ('C', 'N', LASTC, K, LASTV - K, ONE, C'Address, LDC, V'Address, LDV, ONE, WORK'Address, LDWORK);
               end if;
               --
               --              W := W * T**H  or  W * T
               --
               ZTRMM ('R', 'L', TRANST, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - V * W**H
               --
               if LASTV > K then
                  --
                  --                 C1 := C1 - V1 * W**H
                  --
                  ZGEMM ('N', 'C', LASTV - K, LASTC, K, -ONE, V'Address, LDV, WORK'Address, LDWORK, ONE, C'Address, LDC);
               end if;
               --
               --              W := W * V2**H
               --
               ZTRMM ('R', 'U', 'C', 'U', LASTC, K, ONE, V (LASTV - K + 1, 1)'Address, LDV, WORK'Address, LDWORK);
               --
               --              C2 := C2 - W**H
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (LASTV - K + J, I) := C (LASTV - K + J, I) - dconjg (WORK (I, J));
                  end loop;
               end loop;
            --
            elsif LSAME (SIDE, 'R') then
               --
               --              Form  C * H  or  C * H**H  where  C = ( C1  C2 )
               --
               LASTV := max (K, ILAZLR (N, K, V, LDV));
               LASTC := ILAZLR (M, LASTV, C, LDC);
               --
               --              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
               --
               --              W := C2
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  ZCOPY (LASTC, C (1, LASTV - K + J)'Address, 1, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V2
               --
               ZTRMM ('R', 'U', 'N', 'U', LASTC, K, ONE, V (LASTV - K + 1, 1)'Address, LDV, WORK'Address, LDWORK);

               if LASTV > K then
                  --
                  --                 W := W + C1 * V1
                  --
                  ZGEMM ('N', 'N', LASTC, K, LASTV - K, ONE, C'Address, LDC, V'Address, LDV, ONE, WORK'Address, LDWORK);
               end if;
               --
               --              W := W * T  or  W * T**H
               --
               ZTRMM ('R', 'L', TRANS, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - W * V**H
               --
               if LASTV > K then
                  --
                  --                 C1 := C1 - W * V1**H
                  --
                  ZGEMM ('N', 'C', LASTC, LASTV - K, K, -ONE, WORK'Address, LDWORK, V'Address, LDV, ONE, C'Address, LDC);
               end if;
               --
               --              W := W * V2**H
               --
               ZTRMM ('R', 'U', 'C', 'U', LASTC, K, ONE, V (LASTV - K + 1, 1)'Address, LDV, WORK'Address, LDWORK);
               --
               --              C2 := C2 - W
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (I, LASTV - K + J) := C (I, LASTV - K + J) - WORK (I, J);
                  end loop;
               end loop;
            end if;
         end if;
      --
      elsif LSAME (STOREV, 'R') then
         --
         if LSAME (DIRECT, 'F') then
            --
            --           Let  V =  ( V1  V2 )    (V1: first K columns)
            --           where  V1  is unit upper triangular.
            --
            if LSAME (SIDE, 'L') then
               --
               --              Form  H * C  or  H**H * C  where  C = ( C1 )
               --                                                    ( C2 )
               --
               LASTV := max (K, ILAZLC (K, M, V, LDV));
               LASTC := ILAZLC (LASTV, N, C, LDC);
               --
               --              W := C**H * V**H  =  (C1**H * V1**H + C2**H * V2**H) (stored in WORK)
               --
               --              W := C1**H
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  ZCOPY (LASTC, C (J, 1)'Address, LDC, WORK (1, J)'Address, 1);
                  ZLACGV (LASTC, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V1**H
               --
               ZTRMM ('R', 'U', 'C', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);

               if LASTV > K then
                  --
                  --                 W := W + C2**H*V2**H
                  --
                  ZGEMM
                    ('C',
                     'C',
                     LASTC,
                     K,
                     LASTV - K,
                     ONE,
                     C (K + 1, 1)'Address,
                     LDC,
                     V (1, K + 1)'Address,
                     LDV,
                     ONE,
                     WORK'Address,
                     LDWORK);
               end if;
               --
               --              W := W * T**H  or  W * T
               --
               ZTRMM ('R', 'U', TRANST, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - V**H * W**H
               --
               if LASTV > K then
                  --
                  --                 C2 := C2 - V2**H * W**H
                  --
                  ZGEMM
                    ('C',
                     'C',
                     LASTV - K,
                     LASTC,
                     K,
                     -ONE,
                     V (1, K + 1)'Address,
                     LDV,
                     WORK'Address,
                     LDWORK,
                     ONE,
                     C (K + 1, 1)'Address,
                     LDC);
               end if;
               --
               --              W := W * V1
               --
               ZTRMM ('R', 'U', 'N', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W**H
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (J, I) := C (J, I) - dconjg (WORK (I, J));
                  end loop;
               end loop;
            --
            elsif LSAME (SIDE, 'R') then
               --
               --              Form  C * H  or  C * H**H  where  C = ( C1  C2 )
               --
               LASTV := max (K, ILAZLC (K, N, V, LDV));
               LASTC := ILAZLR (M, LASTV, C, LDC);
               --
               --              W := C * V**H  =  (C1*V1**H + C2*V2**H)  (stored in WORK)
               --
               --              W := C1
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  ZCOPY (LASTC, C (1, J)'Address, 1, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V1**H
               --
               ZTRMM ('R', 'U', 'C', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               if LASTV > K then
                  --
                  --                 W := W + C2 * V2**H
                  --
                  ZGEMM
                    ('N',
                     'C',
                     LASTC,
                     K,
                     LASTV - K,
                     ONE,
                     C (1, K + 1)'Address,
                     LDC,
                     V (1, K + 1)'Address,
                     LDV,
                     ONE,
                     WORK'Address,
                     LDWORK);
               end if;
               --
               --              W := W * T  or  W * T**H
               --
               ZTRMM ('R', 'U', TRANS, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - W * V
               --
               if LASTV > K then
                  --
                  --                 C2 := C2 - W * V2
                  --
                  ZGEMM
                    ('N',
                     'N',
                     LASTC,
                     LASTV - K,
                     K,
                     -ONE,
                     WORK'Address,
                     LDWORK,
                     V (1, K + 1)'Address,
                     LDV,
                     ONE,
                     C (1, K + 1)'Address,
                     LDC);
               end if;
               --
               --              W := W * V1
               --
               ZTRMM ('R', 'U', 'N', 'U', LASTC, K, ONE, V'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (I, J) := C (I, J) - WORK (I, J);
                  end loop;
               end loop;
               --
            end if;
         --
         else
            --
            --           Let  V =  ( V1  V2 )    (V2: last K columns)
            --           where  V2  is unit lower triangular.
            --
            if LSAME (SIDE, 'L') then
               --
               --              Form  H * C  or  H**H * C  where  C = ( C1 )
               --                                                    ( C2 )
               --
               LASTV := max (K, ILAZLC (K, M, V, LDV));
               LASTC := ILAZLC (LASTV, N, C, LDC);
               --
               --              W := C**H * V**H  =  (C1**H * V1**H + C2**H * V2**H) (stored in WORK)
               --
               --              W := C2**H
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  ZCOPY (LASTC, C (LASTV - K + J, 1)'Address, LDC, WORK (1, J)'Address, 1);
                  ZLACGV (LASTC, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V2**H
               --
               ZTRMM ('R', 'L', 'C', 'U', LASTC, K, ONE, V (1, LASTV - K + 1)'Address, LDV, WORK'Address, LDWORK);

               if LASTV > K then
                  --
                  --                 W := W + C1**H * V1**H
                  --
                  ZGEMM ('C', 'C', LASTC, K, LASTV - K, ONE, C'Address, LDC, V'Address, LDV, ONE, WORK'Address, LDWORK);
               end if;
               --
               --              W := W * T**H  or  W * T
               --
               ZTRMM ('R', 'L', TRANST, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - V**H * W**H
               --
               if LASTV > K then
                  --
                  --                 C1 := C1 - V1**H * W**H
                  --
                  ZGEMM ('C', 'C', LASTV - K, LASTC, K, -ONE, V'Address, LDV, WORK'Address, LDWORK, ONE, C'Address, LDC);
               end if;
               --
               --              W := W * V2
               --
               ZTRMM ('R', 'L', 'N', 'U', LASTC, K, ONE, V (1, LASTV - K + 1)'Address, LDV, WORK'Address, LDWORK);
               --
               --              C2 := C2 - W**H
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (LASTV - K + J, I) := C (LASTV - K + J, I) - dconjg (WORK (I, J));
                  end loop;
               end loop;
            --
            elsif LSAME (SIDE, 'R') then
               --
               --              Form  C * H  or  C * H**H  where  C = ( C1  C2 )
               --
               LASTV := max (K, ILAZLC (K, N, V, LDV));
               LASTC := ILAZLR (M, LASTV, C, LDC);
               --
               --              W := C * V**H  =  (C1*V1**H + C2*V2**H)  (stored in WORK)
               --
               --              W := C2
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  ZCOPY (LASTC, C (1, LASTV - K + J)'Address, 1, WORK (1, J)'Address, 1);
               end loop;
               --
               --              W := W * V2**H
               --
               ZTRMM ('R', 'L', 'C', 'U', LASTC, K, ONE, V (1, LASTV - K + 1)'Address, LDV, WORK'Address, LDWORK);

               if LASTV > K then
                  --
                  --                 W := W + C1 * V1**H
                  --
                  ZGEMM ('N', 'C', LASTC, K, LASTV - K, ONE, C'Address, LDC, V'Address, LDV, ONE, WORK'Address, LDWORK);
               end if;
               --
               --              W := W * T  or  W * T**H
               --
               ZTRMM ('R', 'L', TRANS, 'N', LASTC, K, ONE, T'Address, LDT, WORK'Address, LDWORK);
               --
               --              C := C - W * V
               --
               if LASTV > K then
                  --
                  --                 C1 := C1 - W * V1
                  --
                  ZGEMM ('N', 'N', LASTC, LASTV - K, K, -ONE, WORK'Address, LDWORK, V'Address, LDV, ONE, C'Address, LDC);
               end if;
               --
               --              W := W * V2
               --
               ZTRMM ('R', 'L', 'N', 'U', LASTC, K, ONE, V (1, LASTV - K + 1)'Address, LDV, WORK'Address, LDWORK);
               --
               --              C1 := C1 - W
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > LASTC;
                     C (I, LASTV - K + J) := C (I, LASTV - K + J) - WORK (I, J);
                  end loop;
               end loop;
               --
            end if;
            --
         end if;
      end if;
      --
      return;
      --
      --     End of ZLARFB
      --
   end ZLARFB;

   procedure ZLARFG
     (N     : Integer;
      ALPHA : in out Complex;
      X_adr : Address;
      INCX  : Integer;
      TAU   : in out Complex)
   is

      X : Ftn_Complex_Vector (1 .. (1 + (N - 2) * abs (INCX)));

      for X'Address use X_adr;

      pragma Import (Ada, X);

      ONE    : constant Real := 1.0e0;
      ZERO   : constant Real := 0.0e0;
      J      : Integer;
      KNT    : Integer;
      ALPHI  : Real;
      ALPHR  : Real;
      BETA   : Real;
      RSAFMN : Real;
      SAFMIN : Real;
      XNORM  : Real;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLARFG( N, ALPHA, X, INCX, TAU )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, N
   --       COMPLEX*16         ALPHA, TAU
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         X( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLARFG generates a complex elementary reflector H of order n, such
   --  that
   --
   --        H**H * ( alpha ) = ( beta ),   H**H * H = I.
   --               (   x   )   (   0  )
   --
   --  where alpha and beta are scalars, with beta real, and x is an
   --  (n-1)-element complex vector. H is represented in the form
   --
   --        H = I - tau * ( 1 ) * ( 1 v**H ),
   --                      ( v )
   --
   --  where tau is a complex scalar and v is a complex (n-1)-element
   --  vector. Note that H is not hermitian.
   --
   --  If the elements of x are all zero and alpha is real, then tau = 0
   --  and H is taken to be the unit matrix.
   --
   --  Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the elementary reflector.
   --
   --  [in,out] ALPHA
   --           ALPHA is COMPLEX*16
   --           On entry, the value alpha.
   --           On exit, it is overwritten with the value beta.
   --
   --  [in,out] X
   --           X is COMPLEX*16 array, dimension
   --                          (1+(N-2)*abs(INCX))
   --           On entry, the vector x.
   --           On exit, it is overwritten with the vector v.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --           The increment between elements of X. INCX > 0.
   --
   --  [out] TAU
   --           TAU is COMPLEX*16
   --           The value tau.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       DOUBLE PRECISION   DLAMCH, DLAPY3, DZNRM2
   --       COMPLEX*16         ZLADIV
   --       EXTERNAL           DLAMCH, DLAPY3, DZNRM2, ZLADIV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCMPLX, DIMAG, SIGN
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           ZDSCAL, ZSCAL
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N <= 0 then
         TAU := Complex'(ZERO, ZERO);
         return;
      end if;
      --
      XNORM := DZNRM2 (N - 1, X'Address, INCX);
      ALPHR := dble (ALPHA);
      ALPHI := dimag (ALPHA);
      --
      if XNORM = ZERO and ALPHI = ZERO then
         --
         --        H  =  I
         --
         TAU := Complex'(ZERO, ZERO);
      else
         --
         --        general case
         --
         BETA   := -sign (DLAPY3 (ALPHR, ALPHI, XNORM), ALPHR);
         SAFMIN := DLAMCH ('S') / DLAMCH ('E');
         RSAFMN := ONE / SAFMIN;
         --
         KNT := 0;
         if abs (BETA) < SAFMIN then
            --
            --           XNORM, BETA may be inaccurate; scale X and recompute them
            --
            <<L10>> null;
            KNT := KNT + 1;
            ZDSCAL (N - 1, RSAFMN, X'Address, INCX);
            BETA  := BETA * RSAFMN;
            ALPHI := ALPHI * RSAFMN;
            ALPHR := ALPHR * RSAFMN;
            if abs (BETA) < SAFMIN then
               goto L10;
            end if;
            --
            --           New BETA is at most 1, at least SAFMIN
            --
            XNORM := DZNRM2 (N - 1, X'Address, INCX);
            ALPHA := dcmplx (ALPHR, ALPHI);
            BETA  := -sign (DLAPY3 (ALPHR, ALPHI, XNORM), ALPHR);
         end if;
         TAU   := dcmplx ((BETA - ALPHR) / BETA, -ALPHI / BETA);
         ALPHA := ZLADIV (Complex'(ONE, 0.0e0), ALPHA - BETA);
         ZSCAL (N - 1, ALPHA, X'Address, INCX);
         --
         --        If ALPHA is subnormal, it may lose relative accuracy
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > KNT;
            BETA := BETA * SAFMIN;
         end loop;
         ALPHA := Complex'(BETA, 0.0e0);
      end if;
      --
      return;
      --
      --     End of ZLARFG
      --
   end ZLARFG;

   procedure ZLARFT
     (DIRECT  : Character;
      STOREV  : Character;
      N       : Integer;
      K       : Integer;
      V_adr   : Address;
      LDV     : Integer;
      TAU_adr : Address;
      T_adr   : Address;
      LDT     : Integer)
   is

      V   : Ftn_Complex_Matrix (1 .. LDV, 1 .. max (K, N));
      TAU : Ftn_Complex_Vector (1 .. K);
      T   : Ftn_Complex_Matrix (1 .. LDT, 1 .. K);

      for V'Address use V_adr;
      for TAU'Address use TAU_adr;
      for T'Address use T_adr;

      pragma Import (Ada, V);
      pragma Import (Ada, TAU);
      pragma Import (Ada, T);

      ONE       : constant Complex := (1.0e0, 0.0e0);
      ZERO      : constant Complex := (0.0e0, 0.0e0);
      I         : Integer;
      J         : Integer;
      PREVLASTV : Integer;
      LASTV     : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIRECT, STOREV
   --       INTEGER            K, LDT, LDV, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         T( LDT, * ), TAU( * ), V( LDV, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLARFT forms the triangular factor T of a complex block reflector H
   --  of order n, which is defined as a product of k elementary reflectors.
   --
   --  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
   --
   --  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
   --
   --  If STOREV = 'C', the vector which defines the elementary reflector
   --  H(i) is stored in the i-th column of the array V, and
   --
   --     H  =  I - V * T * V**H
   --
   --  If STOREV = 'R', the vector which defines the elementary reflector
   --  H(i) is stored in the i-th row of the array V, and
   --
   --     H  =  I - V**H * T * V
   --
   --  Arguments:
   --  ==========
   --
   --  [in] DIRECT
   --           DIRECT is CHARACTER*1
   --           Specifies the order in which the elementary reflectors are
   --           multiplied to form the block reflector:
   --           = 'F': H = H(1) H(2) . . . H(k) (Forward)
   --           = 'B': H = H(k) . . . H(2) H(1) (Backward)
   --
   --  [in] STOREV
   --           STOREV is CHARACTER*1
   --           Specifies how the vectors which define the elementary
   --           reflectors are stored (see also Further Details):
   --           = 'C': columnwise
   --           = 'R': rowwise
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the block reflector H. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The order of the triangular factor T (= the number of
   --           elementary reflectors). K >= 1.
   --
   --  [in] V
   --           V is COMPLEX*16 array, dimension
   --                                (LDV,K) if STOREV = 'C'
   --                                (LDV,N) if STOREV = 'R'
   --           The matrix V. See further details.
   --
   --  [in] LDV
   --           LDV is INTEGER
   --           The leading dimension of the array V.
   --           If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i).
   --
   --  [out] T
   --           T is COMPLEX*16 array, dimension (LDT,K)
   --           The k by k triangular factor T of the block reflector.
   --           If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
   --           lower triangular. The rest of the array is not used.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= K.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The shape of the matrix V and the storage of the vectors which define
   --   the H(i) is best illustrated by the following example with n = 5 and
   --   k = 3. The elements equal to 1 are not stored.
   --
   --   DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
   --
   --                V = (  1       )                 V = (  1 v1 v1 v1 v1 )
   --                    ( v1  1    )                     (     1 v2 v2 v2 )
   --                    ( v1 v2  1 )                     (        1 v3 v3 )
   --                    ( v1 v2 v3 )
   --                    ( v1 v2 v3 )
   --
   --   DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
   --
   --                V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
   --                    ( v1 v2 v3 )                     ( v2 v2 v2  1    )
   --                    (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
   --                    (     1 v3 )
   --                    (        1 )
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ), ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           ZGEMV, ZLACGV, ZTRMV
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       EXTERNAL           LSAME
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if N = 0 then
         return;
      end if;
      --
      if LSAME (DIRECT, 'F') then
         PREVLASTV := N;
         I         := 1 - 1;
         loop
            I := I + 1;
            exit when I > K;
            PREVLASTV := max (PREVLASTV, I);
            if TAU (I) = ZERO then
               --
               --              H(i)  =  I
               --
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > I;
                  T (J, I) := ZERO;
               end loop;
            else
               --
               --              general case
               --
               if LSAME (STOREV, 'C') then
                  --                 Skip any trailing zeros.
                  LASTV := N + 1;
                  loop
                     LASTV := LASTV - 1;
                     exit when LASTV < I + 1;
                     exit when V (LASTV, I) /= ZERO;
                  end loop;
                  J := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > I - 1;
                     T (J, I) := -TAU (I) * conjg (V (I, J));
                  end loop;
                  J := min (LASTV, PREVLASTV);
                  --
                  --                 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)**H * V(i:j,i)
                  --
                  ZGEMV
                    ('C',
                     J - I,
                     I - 1,
                     -TAU (I),
                     V (I + 1, 1)'Address,
                     LDV,
                     V (I + 1, I)'Address,
                     1,
                     ONE,
                     T (1, I)'Address,
                     1);
               else
                  --                 Skip any trailing zeros.
                  LASTV := N + 1;
                  loop
                     LASTV := LASTV - 1;
                     exit when LASTV < I + 1;
                     exit when V (I, LASTV) /= ZERO;
                  end loop;
                  J := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > I - 1;
                     T (J, I) := -TAU (I) * V (J, I);
                  end loop;
                  J := min (LASTV, PREVLASTV);
                  --
                  --                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)**H
                  --
                  ZGEMM
                    ('N',
                     'C',
                     I - 1,
                     1,
                     J - I,
                     -TAU (I),
                     V (1, I + 1)'Address,
                     LDV,
                     V (I, I + 1)'Address,
                     LDV,
                     ONE,
                     T (1, I)'Address,
                     LDT);
               end if;
               --
               --              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)
               --
               ZTRMV ('U', 'N', 'N', I - 1, T'Address, LDT, T (1, I)'Address, 1);
               T (I, I) := TAU (I);
               if I > 1 
                  then PREVLASTV := max (PREVLASTV, LASTV);
                  else PREVLASTV := LASTV;
               end if;
            end if;
         end loop;
      else
         PREVLASTV := 1;
         I         := K + 1;
         loop
            I := I - 1;
            exit when I < 1;
            if TAU (I) = ZERO then
               --
               --              H(i)  =  I
               --
               J := I - 1;
               loop
                  J := J + 1;
                  exit when J > K;
                  T (J, I) := ZERO;
               end loop;
            else
               --
               --              general case
               --
               if I < K then
                  if LSAME (STOREV, 'C') then
                     --                    Skip any leading zeros.
                     LASTV := 1 - 1;
                     loop
                        LASTV := LASTV + 1;
                        exit when LASTV > I - 1;
                        exit when V (LASTV, I) /= ZERO;
                     end loop;
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > K;
                        T (J, I) := -TAU (I) * conjg (V (N - K + I, J));
                     end loop;
                     J := max (LASTV, PREVLASTV);
                     --
                     --                    T(i+1:k,i) = -tau(i) * V(j:n-k+i,i+1:k)**H * V(j:n-k+i,i)
                     --
                     ZGEMV
                       ('C',
                        N - K + I - J,
                        K - I,
                        -TAU (I),
                        V (J, I + 1)'Address,
                        LDV,
                        V (J, I)'Address,
                        1,
                        ONE,
                        T (I + 1, I)'Address,
                        1);
                  else
                     --                    Skip any leading zeros.
                     LASTV := 1 - 1;
                     loop
                        LASTV := LASTV + 1;
                        exit when LASTV > I - 1;
                        exit when V (I, LASTV) /= ZERO;
                     end loop;
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > K;
                        T (J, I) := -TAU (I) * V (J, N - K + I);
                     end loop;
                     J := max (LASTV, PREVLASTV);
                     --
                     --                    T(i+1:k,i) = -tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)**H
                     --
                     ZGEMM
                       ('N',
                        'C',
                        K - I,
                        1,
                        N - K + I - J,
                        -TAU (I),
                        V (I + 1, J)'Address,
                        LDV,
                        V (I, J)'Address,
                        LDV,
                        ONE,
                        T (I + 1, I)'Address,
                        LDT);
                  end if;
                  --
                  --                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)
                  --
                  ZTRMV ('L', 'N', 'N', K - I, T (I + 1, I + 1)'Address, LDT, T (I + 1, I)'Address, 1);

                  if I > 1 
                     then PREVLASTV := min (PREVLASTV, LASTV);
                     else PREVLASTV := LASTV;
                  end if;
               end if;
               T (I, I) := TAU (I);
            end if;
         end loop;
      end if;
      return;
      --
      --     End of ZLARFT
      --
   end ZLARFT;

   procedure ZLARTG
     (F  : Complex;
      G  : Complex;
      CS : in out Real;
      SN : in out Complex;
      R  : in out Complex)
   is
      TWO    : constant Real    := 2.0e0;
      ONE    : constant Real    := 1.0e0;
      ZERO   : constant Real    := 0.0e0;
      CZERO  : constant Complex := (0.0e0, 0.0e0);
      COUNT  : Integer;
      I      : Integer;
      D      : Real;
      DI     : Real;
      DR     : Real;
      EPS    : Real;
      F2     : Real;
      F2S    : Real;
      G2     : Real;
      G2S    : Real;
      SAFMIN : Real;
      SAFMN2 : Real;
      SAFMX2 : Real;
      SCALE  : Real;
      FF     : Complex;
      FS     : Complex;
      GS     : Complex;
   -- ABS1 : Real;
   -- ABSSQ : Real;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLARTG( F, G, CS, SN, R )
   --
   --       .. Scalar Arguments ..
   --       DOUBLE PRECISION   CS
   --       COMPLEX*16         F, G, R, SN
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLARTG generates a plane rotation so that
   --
   --     [  CS  SN  ]     [ F ]     [ R ]
   --     [  __      ]  .  [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.
   --     [ -SN  CS  ]     [ G ]     [ 0 ]
   --
   --  This is a faster version of the BLAS1 routine ZROTG, except for
   --  the following differences:
   --     F and G are unchanged on return.
   --     If G=0, then CS=1 and SN=0.
   --     If F=0, then CS=0 and SN is chosen so that R is real.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] F
   --           F is COMPLEX*16
   --           The first component of vector to be rotated.
   --
   --  [in] G
   --           G is COMPLEX*16
   --           The second component of vector to be rotated.
   --
   --  [out] CS
   --           CS is DOUBLE PRECISION
   --           The cosine of the rotation.
   --
   --  [out] SN
   --           SN is COMPLEX*16
   --           The sine of the rotation.
   --
   --  [out] R
   --           R is COMPLEX*16
   --           The nonzero component of the rotated vector.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   3-5-96 - Modified with a new algorithm by W. Kahan and J. Demmel
   --
   --   This version has a few statements commented out for thread safety
   --   (machine parameters are computed on each entry). 10 feb 03, SJH.
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( TWO = 2.0D+0, ONE = 1.0D+0, ZERO = 0.0D+0 )
   --      PARAMETER          ( CZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     LOGICAL            FIRST
   --     ..
   --     .. External Functions ..
   --       DOUBLE PRECISION   DLAMCH, DLAPY2
   --       EXTERNAL           DLAMCH, DLAPY2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCMPLX, DCONJG, DIMAG, INT, LOG, MAX, SQRT
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Save statement ..
   --     SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
   --     ..
   --     .. Data statements ..
   --     DATA               FIRST / .TRUE. /
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       ABS1(FF) := MAX(ABS(DBLE(FF)), ABS(DIMAG(FF)));
      --       ABSSQ(FF) := DBLE(FF)**2 + DIMAG(FF)**2;
      --     ..
      --     .. Executable Statements ..
      --
      --     IF( FIRST ) THEN
      SAFMIN := DLAMCH ('S');
      EPS    := DLAMCH ('E');
      SAFMN2 := DLAMCH ('B') ** int (Log (SAFMIN / EPS) / Log (DLAMCH ('B')) / TWO);
      SAFMX2 := ONE / SAFMN2;
      --        FIRST = .FALSE.
      --     END IF
      SCALE := max (ABS1 (F), ABS1 (G));
      FS    := F;
      GS    := G;
      COUNT := 0;
      if SCALE >= SAFMX2 then
         <<L10>> null;
         COUNT := COUNT + 1;
         FS    := FS * SAFMN2;
         GS    := GS * SAFMN2;
         SCALE := SCALE * SAFMN2;
         if SCALE >= SAFMX2 then
            goto L10;
         end if;
      elsif SCALE <= SAFMN2 then
         if G = CZERO then
            CS := ONE;
            SN := CZERO;
            R  := F;
            return;
         end if;
         <<L20>> null;
         COUNT := COUNT - 1;
         FS    := FS * SAFMX2;
         GS    := GS * SAFMX2;
         SCALE := SCALE * SAFMX2;
         if SCALE <= SAFMN2 then
            goto L20;
         end if;
      end if;
      F2 := ABSSQ (FS);
      G2 := ABSSQ (GS);
      if F2 <= max (G2, ONE) * SAFMIN then
         --
         --        This is a rare case: F is very small.
         --
         if F = CZERO then
            CS := ZERO;
            R  := Complex'(DLAPY2 (dble (G), dimag (G)), 0.0e0);
            --           Do complex/real division explicitly with two real divisions
            D  := DLAPY2 (dble (GS), dimag (GS));
            SN := dcmplx (dble (GS) / D, -dimag (GS) / D);
            return;
         end if;
         F2S := DLAPY2 (dble (FS), dimag (FS));
         --        G2 and G2S are accurate
         --        G2 is at least SAFMIN, and G2S is at least SAFMN2
         G2S := Sqrt (G2);
         --        Error in CS from underflow in F2S is at most
         --        UNFL / SAFMN2 .lt. sqrt(UNFL*EPS) .lt. EPS
         --        If MAX(G2,ONE)=G2, then F2 .lt. G2*SAFMIN,
         --        and so CS .lt. sqrt(SAFMIN)
         --        If MAX(G2,ONE)=ONE, then F2 .lt. SAFMIN
         --        and so CS .lt. sqrt(SAFMIN)/SAFMN2 = sqrt(EPS)
         --        Therefore, CS = F2S/G2S / sqrt( 1 + (F2S/G2S)**2 ) = F2S/G2S
         CS := F2S / G2S;
         --        Make sure abs(FF) = 1
         --        Do complex/real division explicitly with 2 real divisions
         if ABS1 (F) > ONE then
            D  := DLAPY2 (dble (F), dimag (F));
            FF := dcmplx (dble (F) / D, dimag (F) / D);
         else
            DR := SAFMX2 * dble (F);
            DI := SAFMX2 * dimag (F);
            D  := DLAPY2 (DR, DI);
            FF := dcmplx (DR / D, DI / D);
         end if;
         SN := FF * dcmplx (dble (GS) / G2S, -dimag (GS) / G2S);
         R  := CS * F + SN * G;
      else
         --
         --        This is the most common case.
         --        Neither F2 nor F2/G2 are less than SAFMIN
         --        F2S cannot overflow, and it is accurate
         --
         F2S := Sqrt (ONE + G2 / F2);
         --        Do the F2S(real)*FS(complex) multiply with two real multiplies
         R  := dcmplx (F2S * dble (FS), F2S * dimag (FS));
         CS := ONE / F2S;
         D  := F2 + G2;
         --        Do complex/real division explicitly with two real divisions
         SN := dcmplx (dble (R) / D, dimag (R) / D);
         SN := SN * dconjg (GS);
         if COUNT /= 0 then
            if COUNT > 0 then
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > COUNT;
                  R := R * SAFMX2;
               end loop;
            else
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > -COUNT;
                  R := R * SAFMN2;
               end loop;
            end if;
         end if;
      end if;
      return;
      --
      --     End of ZLARTG
      --
   end ZLARTG;

   procedure ZLASCL
     (the_TYPE : Character;
      KL       : Integer;
      KU       : Integer;
      CFROM    : Real;
      CTO      : Real;
      M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      INFO     : in out Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);

      for A'Address use A_adr;

      pragma Import (Ada, A);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      DONE   : Boolean;
      I      : Integer;
      ITYPE  : Integer;
      J      : Integer;
      K1     : Integer;
      K2     : Integer;
      K3     : Integer;
      K4     : Integer;
      BIGNUM : Real;
      CFROM1 : Real;
      CFROMC : Real;
      CTO1   : Real;
      CTOC   : Real;
      MUL    : Real;
      SMLNUM : Real;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          TYPE
   --       INTEGER            INFO, KL, KU, LDA, M, N
   --       DOUBLE PRECISION   CFROM, CTO
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLASCL multiplies the M by N complex matrix A by the real scalar
   --  CTO/CFROM.  This is done without over/underflow as long as the final
   --  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
   --  A may be full, upper triangular, lower triangular, upper Hessenberg,
   --  or banded.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] TYPE
   --           TYPE is CHARACTER*1
   --           TYPE indices the storage type of the input matrix.
   --           = 'G':  A is a full matrix.
   --           = 'L':  A is a lower triangular matrix.
   --           = 'U':  A is an upper triangular matrix.
   --           = 'H':  A is an upper Hessenberg matrix.
   --           = 'B':  A is a symmetric band matrix with lower bandwidth KL
   --                   and upper bandwidth KU and with the only the lower
   --                   half stored.
   --           = 'Q':  A is a symmetric band matrix with lower bandwidth KL
   --                   and upper bandwidth KU and with the only the upper
   --                   half stored.
   --           = 'Z':  A is a band matrix with lower bandwidth KL and upper
   --                   bandwidth KU. See ZGBTRF for storage details.
   --
   --  [in] KL
   --           KL is INTEGER
   --           The lower bandwidth of A.  Referenced only if TYPE = 'B',
   --           'Q' or 'Z'.
   --
   --  [in] KU
   --           KU is INTEGER
   --           The upper bandwidth of A.  Referenced only if TYPE = 'B',
   --           'Q' or 'Z'.
   --
   --  [in] CFROM
   --           CFROM is DOUBLE PRECISION
   --
   --  [in] CTO
   --           CTO is DOUBLE PRECISION
   --
   --           The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
   --           without over/underflow if the final result CTO*A(I,J)/CFROM
   --           can be represented without over/underflow.  CFROM must be
   --           nonzero.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The matrix to be multiplied by CTO/CFROM.  See TYPE for the
   --           storage type.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           0  - successful exit
   --           <0 - if INFO = -i, the i-th argument had an illegal value.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME, DISNAN
   --       DOUBLE PRECISION   DLAMCH
   --       EXTERNAL           LSAME, DLAMCH, DISNAN
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, MIN
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      --
      if LSAME (the_TYPE, 'G') then
         ITYPE := 0;
      elsif LSAME (the_TYPE, 'L') then
         ITYPE := 1;
      elsif LSAME (the_TYPE, 'U') then
         ITYPE := 2;
      elsif LSAME (the_TYPE, 'H') then
         ITYPE := 3;
      elsif LSAME (the_TYPE, 'B') then
         ITYPE := 4;
      elsif LSAME (the_TYPE, 'Q') then
         ITYPE := 5;
      elsif LSAME (the_TYPE, 'Z') then
         ITYPE := 6;
      else
         ITYPE := -1;
      end if;
      --
      if ITYPE = -1 then
         INFO := -1;
      elsif CFROM = ZERO or DISNAN (CFROM) then
         INFO := -4;
      elsif DISNAN (CTO) then
         INFO := -5;
      elsif M < 0 then
         INFO := -6;
      elsif N < 0 or (ITYPE = 4 and N /= M) or (ITYPE = 5 and N /= M) then
         INFO := -7;
      elsif ITYPE <= 3 and LDA < max (1, M) then
         INFO := -9;
      elsif ITYPE >= 4 then
         if KL < 0 or KL > max (M - 1, 0) then
            INFO := -2;
         elsif KU < 0 or KU > max (N - 1, 0) or ((ITYPE = 4 or ITYPE = 5) and KL /= KU) then
            INFO := -3;
         elsif (ITYPE = 4 and LDA < KL + 1) or (ITYPE = 5 and LDA < KU + 1) or (ITYPE = 6 and LDA < 2 * KL + KU + 1) then
            INFO := -9;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZLASCL", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 or M = 0 then
         return;
      end if;
      --
      --     Get machine parameters
      --
      SMLNUM := DLAMCH ('S');
      BIGNUM := ONE / SMLNUM;
      --
      CFROMC := CFROM;
      CTOC   := CTO;
      --
      <<L10>> null;
      CFROM1 := CFROMC * SMLNUM;
      if CFROM1 = CFROMC then
         --        CFROMC is an inf.  Multiply by a correctly signed zero for
         --        finite CTOC, or a NaN if CTOC is infinite.
         MUL  := CTOC / CFROMC;
         DONE := True;
         CTO1 := CTOC;
      else
         CTO1 := CTOC / BIGNUM;
         if CTO1 = CTOC then
            --           CTOC is either 0 or an inf.  In both cases, CTOC itself
            --           serves as the correct multiplication factor.
            MUL    := CTOC;
            DONE   := True;
            CFROMC := ONE;
         elsif abs (CFROM1) > abs (CTOC) and CTOC /= ZERO then
            MUL    := SMLNUM;
            DONE   := False;
            CFROMC := CFROM1;
         elsif abs (CTO1) > abs (CFROMC) then
            MUL  := BIGNUM;
            DONE := False;
            CTOC := CTO1;
         else
            MUL  := CTOC / CFROMC;
            DONE := True;
         end if;
      end if;
      --
      if ITYPE = 0 then
         --
         --        Full matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 1 then
         --
         --        Lower triangular matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := J - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 2 then
         --
         --        Upper triangular matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J, M);
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 3 then
         --
         --        Upper Hessenberg matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J + 1, M);
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 4 then
         --
         --        Lower half of a symmetric band matrix
         --
         K3 := KL + 1;
         K4 := N + 1;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (K3, K4 - J);
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 5 then
         --
         --        Upper half of a symmetric band matrix
         --
         K1 := KU + 2;
         K3 := KU + 1;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := max (K1 - J, 1) - 1;
            loop
               I := I + 1;
               exit when I > K3;
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
      --
      elsif ITYPE = 6 then
         --
         --        Band matrix
         --
         K1 := KL + KU + 2;
         K2 := KL + 1;
         K3 := 2 * KL + KU + 1;
         K4 := KL + KU + 1 + M;
         J  := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := max (K1 - J, K2) - 1;
            loop
               I := I + 1;
               exit when I > min (K3, K4 - J);
               A (I, J) := A (I, J) * MUL;
            end loop;
         end loop;
         --
      end if;
      --
      if not DONE then
         goto L10;
      end if;
      --
      return;
      --
      --     End of ZLASCL
      --
   end ZLASCL;

   procedure ZLASET
     (UPLO  : Character;
      M     : Integer;
      N     : Integer;
      ALPHA : Complex;
      BETA  : Complex;
      A_adr : Address;
      LDA   : Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);

      for A'Address use A_adr;

      pragma Import (Ada, A);

      I : Integer;
      J : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLASET( UPLO, M, N, ALPHA, BETA, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            LDA, M, N
   --       COMPLEX*16         ALPHA, BETA
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLASET initializes a 2-D array A to BETA on the diagonal and
   --  ALPHA on the offdiagonals.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies the part of the matrix A to be set.
   --           = 'U':      Upper triangular part is set. The lower triangle
   --                       is unchanged.
   --           = 'L':      Lower triangular part is set. The upper triangle
   --                       is unchanged.
   --           Otherwise:  All of the matrix A is set.
   --
   --  [in] M
   --           M is INTEGER
   --           On entry, M specifies the number of rows of A.
   --
   --  [in] N
   --           N is INTEGER
   --           On entry, N specifies the number of columns of A.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --           All the offdiagonal array elements are set to ALPHA.
   --
   --  [in] BETA
   --           BETA is COMPLEX*16
   --           All the diagonal array elements are set to BETA.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the m by n matrix A.
   --           On exit, A(i,j) = ALPHA, 1 <= i <= m, 1 <= j <= n, i.ne.j;
   --                    A(i,i) = BETA, 1 <= i <= min(m,n)
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       EXTERNAL           LSAME
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MIN
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if LSAME (UPLO, 'U') then
         --
         --        Set the diagonal to BETA and the strictly upper triangular
         --        part of the array to ALPHA.
         --
         J := 2 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > min (J - 1, M);
               A (I, J) := ALPHA;
            end loop;
         end loop;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > min (N, M);
            A (I, I) := BETA;
         end loop;
      --
      elsif LSAME (UPLO, 'L') then
         --
         --        Set the diagonal to BETA and the strictly lower triangular
         --        part of the array to ALPHA.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > min (M, N);
            I := J + 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := ALPHA;
            end loop;
         end loop;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > min (N, M);
            A (I, I) := BETA;
         end loop;
      --
      else
         --
         --        Set the array to BETA on the diagonal and ALPHA on the
         --        offdiagonal.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := ALPHA;
            end loop;
         end loop;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > min (M, N);
            A (I, I) := BETA;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZLASET
      --
   end ZLASET;

   procedure ZLASR
     (SIDE   : Character;
      PIVOT  : Character;
      DIRECT : Character;
      M      : Integer;
      N      : Integer;
      C_adr  : Address;
      S_adr  : Address;
      A_adr  : Address;
      LDA    : Integer)
   is

      C : Ftn_Real_Vector (1 .. max (M - 1, N - 1));
      S : Ftn_Real_Vector (1 .. max (M - 1, N - 1));
      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);

      for C'Address use C_adr;
      for S'Address use S_adr;
      for A'Address use A_adr;

      pragma Import (Ada, C);
      pragma Import (Ada, S);
      pragma Import (Ada, A);

      ONE   : constant Real := 1.0e0;
      ZERO  : constant Real := 0.0e0;
      I     : Integer;
      INFO  : Integer;
      J     : Integer;
      CTEMP : Real;
      STEMP : Real;
      TEMP  : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLASR( SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIRECT, PIVOT, SIDE
   --       INTEGER            LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   C( * ), S( * )
   --       COMPLEX*16         A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLASR applies a sequence of real plane rotations to a complex matrix
   --  A, from either the left or the right.
   --
   --  When SIDE = 'L', the transformation takes the form
   --
   --     A := P*A
   --
   --  and when SIDE = 'R', the transformation takes the form
   --
   --     A := A*P**T
   --
   --  where P is an orthogonal matrix consisting of a sequence of z plane
   --  rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
   --  and P**T is the transpose of P.
   --
   --  When DIRECT = 'F' (Forward sequence), then
   --
   --     P = P(z-1) * ... * P(2) * P(1)
   --
   --  and when DIRECT = 'B' (Backward sequence), then
   --
   --     P = P(1) * P(2) * ... * P(z-1)
   --
   --  where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
   --
   --     R(k) = (  c(k)  s(k) )
   --          = ( -s(k)  c(k) ).
   --
   --  When PIVOT = 'V' (Variable pivot), the rotation is performed
   --  for the plane (k,k+1), i.e., P(k) has the form
   --
   --     P(k) = (  1                                            )
   --            (       ...                                     )
   --            (              1                                )
   --            (                   c(k)  s(k)                  )
   --            (                  -s(k)  c(k)                  )
   --            (                                1              )
   --            (                                     ...       )
   --            (                                            1  )
   --
   --  where R(k) appears as a rank-2 modification to the identity matrix in
   --  rows and columns k and k+1.
   --
   --  When PIVOT = 'T' (Top pivot), the rotation is performed for the
   --  plane (1,k+1), so P(k) has the form
   --
   --     P(k) = (  c(k)                    s(k)                 )
   --            (         1                                     )
   --            (              ...                              )
   --            (                     1                         )
   --            ( -s(k)                    c(k)                 )
   --            (                                 1             )
   --            (                                      ...      )
   --            (                                             1 )
   --
   --  where R(k) appears in rows and columns 1 and k+1.
   --
   --  Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
   --  performed for the plane (k,z), giving P(k) the form
   --
   --     P(k) = ( 1                                             )
   --            (      ...                                      )
   --            (             1                                 )
   --            (                  c(k)                    s(k) )
   --            (                         1                     )
   --            (                              ...              )
   --            (                                     1         )
   --            (                 -s(k)                    c(k) )
   --
   --  where R(k) appears in rows and columns k and z.  The rotations are
   --  performed without ever forming P(k) explicitly.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           Specifies whether the plane rotation matrix P is applied to
   --           A on the left or the right.
   --           = 'L':  Left, compute A := P*A
   --           = 'R':  Right, compute A:= A*P**T
   --
   --  [in] PIVOT
   --           PIVOT is CHARACTER*1
   --           Specifies the plane for which P(k) is a plane rotation
   --           matrix.
   --           = 'V':  Variable pivot, the plane (k,k+1)
   --           = 'T':  Top pivot, the plane (1,k+1)
   --           = 'B':  Bottom pivot, the plane (k,z)
   --
   --  [in] DIRECT
   --           DIRECT is CHARACTER*1
   --           Specifies whether P is a forward or backward sequence of
   --           plane rotations.
   --           = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
   --           = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix A.  If m <= 1, an immediate
   --           return is effected.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.  If n <= 1, an
   --           immediate return is effected.
   --
   --  [in] C
   --           C is DOUBLE PRECISION array, dimension
   --                   (M-1) if SIDE = 'L'
   --                   (N-1) if SIDE = 'R'
   --           The cosines c(k) of the plane rotations.
   --
   --  [in] S
   --           S is DOUBLE PRECISION array, dimension
   --                   (M-1) if SIDE = 'L'
   --                   (N-1) if SIDE = 'R'
   --           The sines s(k) of the plane rotations.  The 2-by-2 plane
   --           rotation part of the matrix P(k), R(k), has the form
   --           R(k) = (  c(k)  s(k) )
   --                  ( -s(k)  c(k) ).
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The M-by-N matrix A.  On exit, A is overwritten by P*A if
   --           SIDE = 'R' or by A*P**T if SIDE = 'L'.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,M).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters
   --
   begin
      INFO := 0;
      if not (LSAME (SIDE, 'L') or LSAME (SIDE, 'R')) then
         INFO := 1;
      elsif not (LSAME (PIVOT, 'V') or LSAME (PIVOT, 'T') or LSAME (PIVOT, 'B')) then
         INFO := 2;
      elsif not (LSAME (DIRECT, 'F') or LSAME (DIRECT, 'B')) then
         INFO := 3;
      elsif M < 0 then
         INFO := 4;
      elsif N < 0 then
         INFO := 5;
      elsif LDA < max (1, M) then
         INFO := 9;
      end if;
      if INFO /= 0 then
         XERBLA ("ZLASR ", INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if (M = 0) or (N = 0) then
         return;
      end if;
      if LSAME (SIDE, 'L') then
         --
         --        Form  P * A
         --
         if LSAME (PIVOT, 'V') then
            if LSAME (DIRECT, 'F') then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > M - 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP         := A (J + 1, I);
                        A (J + 1, I) := CTEMP * TEMP - STEMP * A (J, I);
                        A (J, I)     := STEMP * TEMP + CTEMP * A (J, I);
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := M - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP         := A (J + 1, I);
                        A (J + 1, I) := CTEMP * TEMP - STEMP * A (J, I);
                        A (J, I)     := STEMP * TEMP + CTEMP * A (J, I);
                     end loop;
                  end if;
               end loop;
            end if;
         elsif LSAME (PIVOT, 'T') then
            if LSAME (DIRECT, 'F') then
               J := 2 - 1;
               loop
                  J := J + 1;
                  exit when J > M;
                  CTEMP := C (J - 1);
                  STEMP := S (J - 1);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP     := A (J, I);
                        A (J, I) := CTEMP * TEMP - STEMP * A (1, I);
                        A (1, I) := STEMP * TEMP + CTEMP * A (1, I);
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := M + 1;
               loop
                  J := J - 1;
                  exit when J < 2;
                  CTEMP := C (J - 1);
                  STEMP := S (J - 1);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP     := A (J, I);
                        A (J, I) := CTEMP * TEMP - STEMP * A (1, I);
                        A (1, I) := STEMP * TEMP + CTEMP * A (1, I);
                     end loop;
                  end if;
               end loop;
            end if;
         elsif LSAME (PIVOT, 'B') then
            if LSAME (DIRECT, 'F') then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > M - 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP     := A (J, I);
                        A (J, I) := STEMP * A (M, I) + CTEMP * TEMP;
                        A (M, I) := CTEMP * A (M, I) - STEMP * TEMP;
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := M - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        TEMP     := A (J, I);
                        A (J, I) := STEMP * A (M, I) + CTEMP * TEMP;
                        A (M, I) := CTEMP * A (M, I) - STEMP * TEMP;
                     end loop;
                  end if;
               end loop;
            end if;
         end if;
      elsif LSAME (SIDE, 'R') then
         --
         --        Form A * P**T
         --
         if LSAME (PIVOT, 'V') then
            if LSAME (DIRECT, 'F') then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N - 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP         := A (I, J + 1);
                        A (I, J + 1) := CTEMP * TEMP - STEMP * A (I, J);
                        A (I, J)     := STEMP * TEMP + CTEMP * A (I, J);
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := N - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP         := A (I, J + 1);
                        A (I, J + 1) := CTEMP * TEMP - STEMP * A (I, J);
                        A (I, J)     := STEMP * TEMP + CTEMP * A (I, J);
                     end loop;
                  end if;
               end loop;
            end if;
         elsif LSAME (PIVOT, 'T') then
            if LSAME (DIRECT, 'F') then
               J := 2 - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  CTEMP := C (J - 1);
                  STEMP := S (J - 1);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP     := A (I, J);
                        A (I, J) := CTEMP * TEMP - STEMP * A (I, 1);
                        A (I, 1) := STEMP * TEMP + CTEMP * A (I, 1);
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := N + 1;
               loop
                  J := J - 1;
                  exit when J < 2;
                  CTEMP := C (J - 1);
                  STEMP := S (J - 1);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP     := A (I, J);
                        A (I, J) := CTEMP * TEMP - STEMP * A (I, 1);
                        A (I, 1) := STEMP * TEMP + CTEMP * A (I, 1);
                     end loop;
                  end if;
               end loop;
            end if;
         elsif LSAME (PIVOT, 'B') then
            if LSAME (DIRECT, 'F') then
               J := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > N - 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP     := A (I, J);
                        A (I, J) := STEMP * A (I, N) + CTEMP * TEMP;
                        A (I, N) := CTEMP * A (I, N) - STEMP * TEMP;
                     end loop;
                  end if;
               end loop;
            elsif LSAME (DIRECT, 'B') then
               J := N - 1 + 1;
               loop
                  J := J - 1;
                  exit when J < 1;
                  CTEMP := C (J);
                  STEMP := S (J);
                  if (CTEMP /= ONE) or (STEMP /= ZERO) then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > M;
                        TEMP     := A (I, J);
                        A (I, J) := STEMP * A (I, N) + CTEMP * TEMP;
                        A (I, N) := CTEMP * A (I, N) - STEMP * TEMP;
                     end loop;
                  end if;
               end loop;
            end if;
         end if;
      end if;
      --
      return;
      --
      --     End of ZLASR
      --
   end ZLASR;

   procedure ZLASSQ
     (N     : Integer;
      X_adr : Address;
      INCX  : Integer;
      SCALE : in out Real;
      SUMSQ : in out Real)
   is

      X : Ftn_Complex_Vector (1 .. 1 + (N - 1) * INCX);

      for X'Address use X_adr;

      pragma Import (Ada, X);

      ZERO  : constant Real := 0.0e0;
      IX    : Integer;
      TEMP1 : Real;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLASSQ( N, X, INCX, SCALE, SUMSQ )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, N
   --       DOUBLE PRECISION   SCALE, SUMSQ
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         X( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLASSQ returns the values scl and ssq such that
   --
   --     ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
   --
   --  where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
   --  assumed to be at least unity and the value of ssq will then satisfy
   --
   --     1.0 .le. ssq .le. ( sumsq + 2*n ).
   --
   --  scale is assumed to be non-negative and scl returns the value
   --
   --     scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
   --            i
   --
   --  scale and sumsq must be supplied in SCALE and SUMSQ respectively.
   --  SCALE and SUMSQ are overwritten by scl and ssq respectively.
   --
   --  The routine makes only one pass through the vector X.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The number of elements to be used from the vector X.
   --
   --  [in] X
   --           X is COMPLEX*16 array, dimension (N)
   --           The vector x as described above.
   --              x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --           The increment between successive values of the vector X.
   --           INCX > 0.
   --
   --  [in,out] SCALE
   --           SCALE is DOUBLE PRECISION
   --           On entry, the value  scale  in the equation above.
   --           On exit, SCALE is overwritten with the value  scl .
   --
   --  [in,out] SUMSQ
   --           SUMSQ is DOUBLE PRECISION
   --           On entry, the value  sumsq  in the equation above.
   --           On exit, SUMSQ is overwritten with the value  ssq .
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DIMAG
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N > 0 then
         IX := 1 - INCX;
         loop
            IX := IX + INCX;
            exit when IX > 1 + (N - 1) * INCX;
            if dble (X (IX)) /= ZERO then
               TEMP1 := abs (dble (X (IX)));
               if SCALE < TEMP1 then
                  SUMSQ := 1.0e0 + SUMSQ * (SCALE / TEMP1) ** 2;
                  SCALE := TEMP1;
               else
                  SUMSQ := SUMSQ + (TEMP1 / SCALE) ** 2;
               end if;
            end if;
            if dimag (X (IX)) /= ZERO then
               TEMP1 := abs (dimag (X (IX)));
               if SCALE < TEMP1 then
                  SUMSQ := 1.0e0 + SUMSQ * (SCALE / TEMP1) ** 2;
                  SCALE := TEMP1;
               else
                  SUMSQ := SUMSQ + (TEMP1 / SCALE) ** 2;
               end if;
            end if;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZLASSQ
      --
   end ZLASSQ;

   procedure ZLASWP
     (N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      K1       : Integer;
      K2       : Integer;
      IPIV_adr : Address;
      INCX     : Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      IPIV : Ftn_Integer_Vector (1 .. K2 * abs (INCX));

      for A'Address use A_adr;
      for IPIV'Address use IPIV_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, IPIV);

      I    : Integer;
      I1   : Integer;
      I2   : Integer;
      INC  : Integer;
      IP   : Integer;
      IX   : Integer;
      IX0  : Integer;
      J    : Integer;
      K    : Integer;
      N32  : Integer;
      TEMP : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLASWP( N, A, LDA, K1, K2, IPIV, INCX )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, K1, K2, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       Complex*16   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLASWP performs a series of row interchanges on the matrix A.
   --  One row interchange is initiated for each of rows K1 through K2 of A.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix A.
   --
   --  [in,out] A
   --           A is Complex*16 array, dimension (LDA,N)
   --           On entry, the matrix of column dimension N to which the row
   --           interchanges will be applied.
   --           On exit, the permuted matrix.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --
   --  [in] K1
   --           K1 is INTEGER
   --           The first element of IPIV for which a row interchange will
   --           be done.
   --
   --  [in] K2
   --           K2 is INTEGER
   --           The last element of IPIV for which a row interchange will
   --           be done.
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (K2*abs(INCX))
   --           The vector of pivot indices.  Only the elements in positions
   --           K1 through K2 of IPIV are accessed.
   --           IPIV(K) = L implies rows K and L are to be interchanged.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --           The increment between successive values of IPIV.  If IPIV
   --           is negative, the pivots are applied in reverse order.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   Modified by
   --    R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   --     Interchange row I with row IPIV(I) for each of rows K1 through K2.
   --
   begin
      if INCX > 0 then
         IX0 := K1;
         I1  := K1;
         I2  := K2;
         INC := 1;
      elsif INCX < 0 then
         IX0 := 1 + (1 - K2) * INCX;
         I1  := K2;
         I2  := K1;
         INC := -1;
      else
         return;
      end if;
      --
      N32 := (N / 32) * 32;
      if N32 /= 0 then
         J := 1 - 32;
         loop
            J := J + 32;
            exit when J > N32;
            IX := IX0;
            I  := I1 - INC;
            loop
               I := I + INC;
               if INC > 0 
                  then exit when I > I2;
                  else exit when I < I2;
               end if;
               IP := IPIV (IX);
               if IP /= I then
                  K := J - 1;
                  loop
                     K := K + 1;
                     exit when K > J + 31;
                     TEMP      := A (I, K);
                     A (I, K)  := A (IP, K);
                     A (IP, K) := TEMP;
                  end loop;
               end if;
               IX := IX + INCX;
            end loop;
         end loop;
      end if;
      if N32 /= N then
         N32 := N32 + 1;
         IX  := IX0;
         I   := I1 - INC;
         loop
            I := I + INC;
            if INC > 0 
               then exit when I > I2;
               else exit when I < I2;
            end if;
            IP := IPIV (IX);
            if IP /= I then
               K := N32 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  TEMP      := A (I, K);
                  A (I, K)  := A (IP, K);
                  A (IP, K) := TEMP;
               end loop;
            end if;
            IX := IX + INCX;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZLASWP
      --
   end ZLASWP;

   procedure ZLASYF
     (UPLO     : Character;
      N        : Integer;
      NB       : Integer;
      KB       : in out Integer;
      A_adr    : Address;
      LDA      : Integer;
      IPIV_adr : Address;
      W_adr    : Address;
      LDW      : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      IPIV : Ftn_Integer_Vector (1 .. N);
      W    : Ftn_Complex_Matrix (1 .. LDW, 1 .. NB);

      for A'Address use A_adr;
      for IPIV'Address use IPIV_adr;
      for W'Address use W_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, IPIV);
      pragma Import (Ada, W);

      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      EIGHT  : constant Real    := 8.0e0;
      SEVTEN : constant Real    := 17.0e0;
      CONE   : constant Complex := (1.0, 0.0);
      IMAX   : Integer;
      J      : Integer;
      JB     : Integer;
      JJ     : Integer;
      JMAX   : Integer;
      JP     : Integer;
      K      : Integer;
      KK     : Integer;
      KKW    : Integer;
      KP     : Integer;
      KSTEP  : Integer;
      KW     : Integer;
      ABSAKK : Real;
      ALPHA  : Real;
      COLMAX : Real;
      ROWMAX : Real;
      D11    : Complex;
      D21    : Complex;
      D22    : Complex;
      R1     : Complex;
      T      : Complex;
      Z      : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLASYF( UPLO, N, NB, KB, A, LDA, IPIV, W, LDW, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, KB, LDA, LDW, N, NB
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       COMPLEX*16         A( LDA, * ), W( LDW, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLASYF computes a partial factorization of a complex symmetric matrix
   --  A using the Bunch-Kaufman diagonal pivoting method. The partial
   --  factorization has the form:
   --
   --  A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
   --        ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
   --
   --  A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'
   --        ( L21  I ) ( 0   A22 ) (  0       I    )
   --
   --  where the order of D is at most NB. The actual order is returned in
   --  the argument KB, and is either NB or NB-1, or N if N <= NB.
   --  Note that U**T denotes the transpose of U.
   --
   --  ZLASYF is an auxiliary routine called by ZSYTRF. It uses blocked code
   --  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
   --  A22 (if UPLO = 'L').
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the upper or lower triangular part of the
   --           symmetric matrix A is stored:
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] NB
   --           NB is INTEGER
   --           The maximum number of columns of the matrix A that should be
   --           factored.  NB should be at least 2 to allow for 2-by-2 pivot
   --           blocks.
   --
   --  [out] KB
   --           KB is INTEGER
   --           The number of columns of A that were actually factored.
   --           KB is either NB-1 or NB, or N if N <= NB.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           n-by-n upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n-by-n lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --           On exit, A contains details of the partial factorization.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D.
   --           If UPLO = 'U', only the last KB elements of IPIV are set;
   --           if UPLO = 'L', only the first KB elements are set.
   --
   --           If IPIV(k) > 0, then rows and columns k and IPIV(k) were
   --           interchanged and D(k,k) is a 1-by-1 diagonal block.
   --           If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
   --           columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
   --           is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
   --           IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
   --           interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
   --
   --  [out] W
   --           W is COMPLEX*16 array, dimension (LDW,NB)
   --
   --  [in] LDW
   --           LDW is INTEGER
   --           The leading dimension of the array W.  LDW >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
   --                has been completed, but the block diagonal matrix D is
   --                exactly singular.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( EIGHT = 8.0D+0, SEVTEN = 17.0D+0 )
   --      PARAMETER          ( CONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, IZAMAX
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZCOPY, ZGEMM, ZGEMV, ZSCAL, ZSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DIMAG, MAX, MIN, SQRT
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --     ..
      --     .. Executable Statements ..
      --
      INFO := 0;
      --
      --     Initialize ALPHA for use in choosing pivot block size.
      --
      ALPHA := (ONE + Sqrt (SEVTEN)) / EIGHT;
      --
      if LSAME (UPLO, 'U') then
         --
         --        Factorize the trailing columns of A using the upper triangle
         --        of A and working backwards, and compute the matrix W = U12*D
         --        for use in updating A11
         --
         --        K is the main loop index, decreasing from N in steps of 1 or 2
         --
         --        KW is the column of W which corresponds to column K of A
         --
         K := N;
         <<L10>> null;
         KW := NB + K - N;
         --
         --        Exit from loop
         --
         if (K <= N - NB + 1 and NB < N) or K < 1 then
            goto L30;
         end if;
         --
         --        Copy column K of A to column KW of W and update it
         --
         ZCOPY (K, A (1, K)'Address, 1, W (1, KW)'Address, 1);
         if K < N then
            ZGEMV
              ('N',
               K,
               N - K,
               -CONE,
               A (1, K + 1)'Address,
               LDA,
               W (K, KW + 1)'Address,
               LDW,
               CONE,
               W (1, KW)'Address,
               1);
         end if;
         --
         KSTEP := 1;
         --
         --        Determine rows and columns to be interchanged and whether
         --        a 1-by-1 or 2-by-2 pivot block will be used
         --
         ABSAKK := CABS1 (W (K, KW));
         --
         --        IMAX is the row-index of the largest off-diagonal element in
         --        column K, and COLMAX is its absolute value
         --
         if K > 1 then
            IMAX   := IZAMAX (K - 1, W (1, KW)'Address, 1);
            COLMAX := CABS1 (W (IMAX, KW));
         else
            COLMAX := ZERO;
         end if;
         --
         if max (ABSAKK, COLMAX) = ZERO then
            --
            --           Column K is zero: set INFO and continue
            --
            if INFO = 0 then
               INFO := K;
            end if;
            KP := K;
         else
            if ABSAKK >= ALPHA * COLMAX then
               --
               --              no interchange, use 1-by-1 pivot block
               --
               KP := K;
            else
               --
               --              Copy column IMAX to column KW-1 of W and update it
               --
               ZCOPY (IMAX, A (1, IMAX)'Address, 1, W (1, KW - 1)'Address, 1);
               ZCOPY (K - IMAX, A (IMAX, IMAX + 1)'Address, LDA, W (IMAX + 1, KW - 1)'Address, 1);
               if K < N then
                  ZGEMV
                    ('N',
                     K,
                     N - K,
                     -CONE,
                     A (1, K + 1)'Address,
                     LDA,
                     W (IMAX, KW + 1)'Address,
                     LDW,
                     CONE,
                     W (1, KW - 1)'Address,
                     1);
               end if;
               --
               --              JMAX is the column-index of the largest off-diagonal
               --              element in row IMAX, and ROWMAX is its absolute value
               --
               JMAX   := IMAX + IZAMAX (K - IMAX, W (IMAX + 1, KW - 1)'Address, 1);
               ROWMAX := CABS1 (W (JMAX, KW - 1));
               if IMAX > 1 then
                  JMAX   := IZAMAX (IMAX - 1, W (1, KW - 1)'Address, 1);
                  ROWMAX := max (ROWMAX, CABS1 (W (JMAX, KW - 1)));
               end if;
               --
               if ABSAKK >= ALPHA * COLMAX * (COLMAX / ROWMAX) then
                  --
                  --                 no interchange, use 1-by-1 pivot block
                  --
                  KP := K;
               elsif CABS1 (W (IMAX, KW - 1)) >= ALPHA * ROWMAX then
                  --
                  --                 interchange rows and columns K and IMAX, use 1-by-1
                  --                 pivot block
                  --
                  KP := IMAX;
                  --
                  --                 copy column KW-1 of W to column KW
                  --
                  ZCOPY (K, W (1, KW - 1)'Address, 1, W (1, KW)'Address, 1);
               else
                  --
                  --                 interchange rows and columns K-1 and IMAX, use 2-by-2
                  --                 pivot block
                  --
                  KP    := IMAX;
                  KSTEP := 2;
               end if;
            end if;
            --
            KK  := K - KSTEP + 1;
            KKW := NB + KK - N;
            --
            --           Updated column KP is already stored in column KKW of W
            --
            if KP /= KK then
               --
               --              Copy non-updated column KK to column KP
               --
               A (KP, K) := A (KK, K);
               ZCOPY (K - 1 - KP, A (KP + 1, KK)'Address, 1, A (KP, KP + 1)'Address, LDA);
               ZCOPY (KP, A (1, KK)'Address, 1, A (1, KP)'Address, 1);
               --
               --              Interchange rows KK and KP in last KK columns of A and W
               --
               ZSWAP (N - KK + 1, A (KK, KK)'Address, LDA, A (KP, KK)'Address, LDA);
               ZSWAP (N - KK + 1, W (KK, KKW)'Address, LDW, W (KP, KKW)'Address, LDW);
            end if;
            --
            if KSTEP = 1 then
               --
               --              1-by-1 pivot block D(k): column KW of W now holds
               --
               --              W(k) = U(k)*D(k)
               --
               --              where U(k) is the k-th column of U
               --
               --              Store U(k) in column k of A
               --
               ZCOPY (K, W (1, KW)'Address, 1, A (1, K)'Address, 1);
               R1 := CONE / A (K, K);
               ZSCAL (K - 1, R1, A (1, K)'Address, 1);
            else
               --
               --              2-by-2 pivot block D(k): columns KW and KW-1 of W now
               --              hold
               --
               --              ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k)
               --
               --              where U(k) and U(k-1) are the k-th and (k-1)-th columns
               --              of U
               --
               if K > 2 then
                  --
                  --                 Store U(k) and U(k-1) in columns k and k-1 of A
                  --
                  D21 := W (K - 1, KW);
                  D11 := W (K, KW) / D21;
                  D22 := W (K - 1, KW - 1) / D21;
                  T   := CONE / (D11 * D22 - CONE);
                  D21 := T / D21;
                  J   := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > K - 2;
                     A (J, K - 1) := D21 * (D11 * W (J, KW - 1) - W (J, KW));
                     A (J, K)     := D21 * (D22 * W (J, KW) - W (J, KW - 1));
                  end loop;
               end if;
               --
               --              Copy D(k) to A
               --
               A (K - 1, K - 1) := W (K - 1, KW - 1);
               A (K - 1, K)     := W (K - 1, KW);
               A (K, K)         := W (K, KW);
            end if;
         end if;
         --
         --        Store details of the interchanges in IPIV
         --
         if KSTEP = 1 then
            IPIV (K) := KP;
         else
            IPIV (K)     := -KP;
            IPIV (K - 1) := -KP;
         end if;
         --
         --        Decrease K and return to the start of the main loop
         --
         K := K - KSTEP;
         goto L10;
         --
         <<L30>> null;
         --
         --        Update the upper triangle of A11 (= A(1:k,1:k)) as
         --
         --        A11 := A11 - U12*D*U12**T = A11 - U12*W**T
         --
         --        computing blocks of NB columns at a time
         --
         J := ((K - 1) / NB) * NB + 1 + NB;
         loop
            J := J - NB;
            exit when J < 1;
            JB := min (NB, K - J + 1);
            --
            --           Update the upper triangle of the diagonal block
            --
            JJ := J - 1;
            loop
               JJ := JJ + 1;
               exit when JJ > J + JB - 1;
               ZGEMV
                 ('N',
                  JJ - J + 1,
                  N - K,
                  -CONE,
                  A (J, K + 1)'Address,
                  LDA,
                  W (JJ, KW + 1)'Address,
                  LDW,
                  CONE,
                  A (J, JJ)'Address,
                  1);
            end loop;
            --
            --           Update the rectangular superdiagonal block
            --
            ZGEMM
              ('N',
               'T',
               J - 1,
               JB,
               N - K,
               -CONE,
               A (1, K + 1)'Address,
               LDA,
               W (J, KW + 1)'Address,
               LDW,
               CONE,
               A (1, J)'Address,
               LDA);
         end loop;
         --
         --        Put U12 in standard form by partially undoing the interchanges
         --        in columns k+1:n
         --
         J := K + 1;
         <<L60>> null;
         JJ := J;
         JP := IPIV (J);
         if JP < 0 then
            JP := -JP;
            J  := J + 1;
         end if;
         J := J + 1;
         if JP /= JJ and J <= N then
            ZSWAP (N - J + 1, A (JP, J)'Address, LDA, A (JJ, J)'Address, LDA);
         end if;
         if J <= N then
            goto L60;
         end if;
         --
         --        Set KB to the number of columns factorized
         --
         KB := N - K;
      --
      else
         --
         --        Factorize the leading columns of A using the lower triangle
         --        of A and working forwards, and compute the matrix W = L21*D
         --        for use in updating A22
         --
         --        K is the main loop index, increasing from 1 in steps of 1 or 2
         --
         K := 1;
         <<L70>> null;
         --
         --        Exit from loop
         --
         if (K >= NB and NB < N) or K > N then
            goto L90;
         end if;
         --
         --        Copy column K of A to column K of W and update it
         --
         ZCOPY (N - K + 1, A (K, K)'Address, 1, W (K, K)'Address, 1);
         ZGEMV ('N', N - K + 1, K - 1, -CONE, A (K, 1)'Address, LDA, W (K, 1)'Address, LDW, CONE, W (K, K)'Address, 1);
         --
         KSTEP := 1;
         --
         --        Determine rows and columns to be interchanged and whether
         --        a 1-by-1 or 2-by-2 pivot block will be used
         --
         ABSAKK := CABS1 (W (K, K));
         --
         --        IMAX is the row-index of the largest off-diagonal element in
         --        column K, and COLMAX is its absolute value
         --
         if K < N then
            IMAX   := K + IZAMAX (N - K, W (K + 1, K)'Address, 1);
            COLMAX := CABS1 (W (IMAX, K));
         else
            COLMAX := ZERO;
         end if;
         --
         if max (ABSAKK, COLMAX) = ZERO then
            --
            --           Column K is zero: set INFO and continue
            --
            if INFO = 0 then
               INFO := K;
            end if;
            KP := K;
         else
            if ABSAKK >= ALPHA * COLMAX then
               --
               --              no interchange, use 1-by-1 pivot block
               --
               KP := K;
            else
               --
               --              Copy column IMAX to column K+1 of W and update it
               --
               ZCOPY (IMAX - K, A (IMAX, K)'Address, LDA, W (K, K + 1)'Address, 1);
               ZCOPY (N - IMAX + 1, A (IMAX, IMAX)'Address, 1, W (IMAX, K + 1)'Address, 1);
               ZGEMV
                 ('N',
                  N - K + 1,
                  K - 1,
                  -CONE,
                  A (K, 1)'Address,
                  LDA,
                  W (IMAX, 1)'Address,
                  LDW,
                  CONE,
                  W (K, K + 1)'Address,
                  1);
               --
               --              JMAX is the column-index of the largest off-diagonal
               --              element in row IMAX, and ROWMAX is its absolute value
               --
               JMAX   := K - 1 + IZAMAX (IMAX - K, W (K, K + 1)'Address, 1);
               ROWMAX := CABS1 (W (JMAX, K + 1));
               if IMAX < N then
                  JMAX   := IMAX + IZAMAX (N - IMAX, W (IMAX + 1, K + 1)'Address, 1);
                  ROWMAX := max (ROWMAX, CABS1 (W (JMAX, K + 1)));
               end if;
               --
               if ABSAKK >= ALPHA * COLMAX * (COLMAX / ROWMAX) then
                  --
                  --                 no interchange, use 1-by-1 pivot block
                  --
                  KP := K;
               elsif CABS1 (W (IMAX, K + 1)) >= ALPHA * ROWMAX then
                  --
                  --                 interchange rows and columns K and IMAX, use 1-by-1
                  --                 pivot block
                  --
                  KP := IMAX;
                  --
                  --                 copy column K+1 of W to column K
                  --
                  ZCOPY (N - K + 1, W (K, K + 1)'Address, 1, W (K, K)'Address, 1);
               else
                  --
                  --                 interchange rows and columns K+1 and IMAX, use 2-by-2
                  --                 pivot block
                  --
                  KP    := IMAX;
                  KSTEP := 2;
               end if;
            end if;
            --
            KK := K + KSTEP - 1;
            --
            --           Updated column KP is already stored in column KK of W
            --
            if KP /= KK then
               --
               --              Copy non-updated column KK to column KP
               --
               A (KP, K) := A (KK, K);
               ZCOPY (KP - K - 1, A (K + 1, KK)'Address, 1, A (KP, K + 1)'Address, LDA);
               ZCOPY (N - KP + 1, A (KP, KK)'Address, 1, A (KP, KP)'Address, 1);
               --
               --              Interchange rows KK and KP in first KK columns of A and W
               --
               ZSWAP (KK, A (KK, 1)'Address, LDA, A (KP, 1)'Address, LDA);
               ZSWAP (KK, W (KK, 1)'Address, LDW, W (KP, 1)'Address, LDW);
            end if;
            --
            if KSTEP = 1 then
               --
               --              1-by-1 pivot block D(k): column k of W now holds
               --
               --              W(k) = L(k)*D(k)
               --
               --              where L(k) is the k-th column of L
               --
               --              Store L(k) in column k of A
               --
               ZCOPY (N - K + 1, W (K, K)'Address, 1, A (K, K)'Address, 1);
               if K < N then
                  R1 := CONE / A (K, K);
                  ZSCAL (N - K, R1, A (K + 1, K)'Address, 1);
               end if;
            else
               --
               --              2-by-2 pivot block D(k): columns k and k+1 of W now hold
               --
               --              ( W(k) W(k+1) ) = ( L(k) L(k+1) )*D(k)
               --
               --              where L(k) and L(k+1) are the k-th and (k+1)-th columns
               --              of L
               --
               if K < N - 1 then
                  --
                  --                 Store L(k) and L(k+1) in columns k and k+1 of A
                  --
                  D21 := W (K + 1, K);
                  D11 := W (K + 1, K + 1) / D21;
                  D22 := W (K, K) / D21;
                  T   := CONE / (D11 * D22 - CONE);
                  D21 := T / D21;
                  J   := K + 2 - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     A (J, K)     := D21 * (D11 * W (J, K) - W (J, K + 1));
                     A (J, K + 1) := D21 * (D22 * W (J, K + 1) - W (J, K));
                  end loop;
               end if;
               --
               --              Copy D(k) to A
               --
               A (K, K)         := W (K, K);
               A (K + 1, K)     := W (K + 1, K);
               A (K + 1, K + 1) := W (K + 1, K + 1);
            end if;
         end if;
         --
         --        Store details of the interchanges in IPIV
         --
         if KSTEP = 1 then
            IPIV (K) := KP;
         else
            IPIV (K)     := -KP;
            IPIV (K + 1) := -KP;
         end if;
         --
         --        Increase K and return to the start of the main loop
         --
         K := K + KSTEP;
         goto L70;
         --
         <<L90>> null;
         --
         --        Update the lower triangle of A22 (= A(k:n,k:n)) as
         --
         --        A22 := A22 - L21*D*L21**T = A22 - L21*W**T
         --
         --        computing blocks of NB columns at a time
         --
         J := K - NB;
         loop
            J := J + NB;
            exit when J > N;
            JB := min (NB, N - J + 1);
            --
            --           Update the lower triangle of the diagonal block
            --
            JJ := J - 1;
            loop
               JJ := JJ + 1;
               exit when JJ > J + JB - 1;
               ZGEMV
                 ('N',
                  J + JB - JJ,
                  K - 1,
                  -CONE,
                  A (JJ, 1)'Address,
                  LDA,
                  W (JJ, 1)'Address,
                  LDW,
                  CONE,
                  A (JJ, JJ)'Address,
                  1);
            end loop;
            --
            --           Update the rectangular subdiagonal block
            --
            if J + JB <= N then
               ZGEMM
                 ('N',
                  'T',
                  N - J - JB + 1,
                  JB,
                  K - 1,
                  -CONE,
                  A (J + JB, 1)'Address,
                  LDA,
                  W (J, 1)'Address,
                  LDW,
                  CONE,
                  A (J + JB, J)'Address,
                  LDA);
            end if;
         end loop;
         --
         --        Put L21 in standard form by partially undoing the interchanges
         --        in columns 1:k-1
         --
         J := K - 1;
         <<L120>> null;
         JJ := J;
         JP := IPIV (J);
         if JP < 0 then
            JP := -JP;
            J  := J - 1;
         end if;
         J := J - 1;
         if JP /= JJ and J >= 1 then
            ZSWAP (J, A (JP, 1)'Address, LDA, A (JJ, 1)'Address, LDA);
         end if;
         if J >= 1 then
            goto L120;
         end if;
         --
         --        Set KB to the number of columns factorized
         --
         KB := K - 1;
         --
      end if;
      return;
      --
      --     End of ZLASYF
      --
   end ZLASYF;

   procedure ZLATRD
     (UPLO    : Character;
      N       : Integer;
      NB      : Integer;
      A_adr   : Address;
      LDA     : Integer;
      E_adr   : Address;
      TAU_adr : Address;
      W_adr   : Address;
      LDW     : Integer)
   is

      A   : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      E   : Ftn_Real_Vector (1 .. N - 1);
      TAU : Ftn_Complex_Vector (1 .. N - 1);
      W   : Ftn_Complex_Matrix (1 .. LDW, 1 .. NB);

      for A'Address use A_adr;
      for E'Address use E_adr;
      for TAU'Address use TAU_adr;
      for W'Address use W_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, E);
      pragma Import (Ada, TAU);
      pragma Import (Ada, W);

      ZERO  : constant Complex := (0.0, 0.0);
      ONE   : constant Complex := (1.0, 0.0);
      HALF  : constant Complex := (0.5, 0.0);
      I     : Integer;
      IW    : Integer;
      ALPHA : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            LDA, LDW, N, NB
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   E( * )
   --       COMPLEX*16         A( LDA, * ), TAU( * ), W( LDW, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLATRD reduces NB rows and columns of a complex Hermitian matrix A to
   --  Hermitian tridiagonal form by a unitary similarity
   --  transformation Q**H * A * Q, and returns the matrices V and W which are
   --  needed to apply the transformation to the unreduced part of A.
   --
   --  If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a
   --  matrix, of which the upper triangle is supplied;
   --  if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a
   --  matrix, of which the lower triangle is supplied.
   --
   --  This is an auxiliary routine called by ZHETRD.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the upper or lower triangular part of the
   --           Hermitian matrix A is stored:
   --           = 'U': Upper triangular
   --           = 'L': Lower triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.
   --
   --  [in] NB
   --           NB is INTEGER
   --           The number of rows and columns to be reduced.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
   --           n-by-n upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n-by-n lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --           On exit:
   --           if UPLO = 'U', the last NB columns have been reduced to
   --             tridiagonal form, with the diagonal elements overwriting
   --             the diagonal elements of A; the elements above the diagonal
   --             with the array TAU, represent the unitary matrix Q as a
   --             product of elementary reflectors;
   --           if UPLO = 'L', the first NB columns have been reduced to
   --             tridiagonal form, with the diagonal elements overwriting
   --             the diagonal elements of A; the elements below the diagonal
   --             with the array TAU, represent the  unitary matrix Q as a
   --             product of elementary reflectors.
   --           See Further Details.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
   --           elements of the last NB columns of the reduced matrix;
   --           if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
   --           the first NB columns of the reduced matrix.
   --
   --  [out] TAU
   --           TAU is COMPLEX*16 array, dimension (N-1)
   --           The scalar factors of the elementary reflectors, stored in
   --           TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
   --           See Further Details.
   --
   --  [out] W
   --           W is COMPLEX*16 array, dimension (LDW,NB)
   --           The n-by-nb matrix W required to update the unreduced part
   --           of A.
   --
   --  [in] LDW
   --           LDW is INTEGER
   --           The leading dimension of the array W. LDW >= max(1,N).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(n) H(n-1) . . . H(n-nb+1).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
   --   and tau in TAU(i-1).
   --
   --   If UPLO = 'L', the matrix Q is represented as a product of elementary
   --   reflectors
   --
   --      Q = H(1) H(2) . . . H(nb).
   --
   --   Each H(i) has the form
   --
   --      H(i) = I - tau * v * v**H
   --
   --   where tau is a complex scalar, and v is a complex vector with
   --   v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
   --   and tau in TAU(i).
   --
   --   The elements of the vectors v together form the n-by-nb matrix V
   --   which is needed, with W, to apply the transformation to the unreduced
   --   part of the matrix, using a Hermitian rank-2k update of the form:
   --   A := A - V*W**H - W*V**H.
   --
   --   The contents of A on exit are illustrated by the following examples
   --   with n = 5 and nb = 2:
   --
   --   if UPLO = 'U':                       if UPLO = 'L':
   --
   --     (  a   a   a   v4  v5 )              (  d                  )
   --     (      a   a   v4  v5 )              (  1   d              )
   --     (          a   1   v5 )              (  v1  1   a          )
   --     (              d   1  )              (  v1  v2  a   a      )
   --     (                  d  )              (  v1  v2  a   a   a  )
   --
   --   where d denotes a diagonal element of the reduced matrix, a denotes
   --   an element of the original matrix that is unchanged, and vi denotes
   --   an element of the vector defining H(i).
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ), ONE = ( 1.0D+0, 0.0D+0 ), HALF = ( 0.5D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZAXPY, ZGEMV, ZHEMV, ZLACGV, ZLARFG, ZSCAL
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ZDOTC
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DBLE, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Quick return if possible
   --
   begin
      if N <= 0 then
         return;
      end if;
      --
      if LSAME (UPLO, 'U') then
         --
         --        Reduce last NB columns of upper triangle
         --
         I := N + 1;
         loop
            I := I - 1;
            exit when I < N - NB + 1;
            IW := I - N + NB;
            if I < N then
               --
               --              Update A(1:i,i)
               --
               A (I, I) := Pure_Real (A (I, I));
               ZLACGV (N - I, W (I, IW + 1)'Address, LDW);
               ZGEMV
                 ('N',
                  I,
                  N - I,
                  -ONE,
                  A (1, I + 1)'Address,
                  LDA,
                  W (I, IW + 1)'Address,
                  LDW,
                  ONE,
                  A (1, I)'Address,
                  1);
               ZLACGV (N - I, W (I, IW + 1)'Address, LDW);
               ZLACGV (N - I, A (I, I + 1)'Address, LDA);
               ZGEMV
                 ('N',
                  I,
                  N - I,
                  -ONE,
                  W (1, IW + 1)'Address,
                  LDW,
                  A (I, I + 1)'Address,
                  LDA,
                  ONE,
                  A (1, I)'Address,
                  1);
               ZLACGV (N - I, A (I, I + 1)'Address, LDA);
               A (I, I) := Pure_Real (A (I, I));
            end if;
            if I > 1 then
               --
               --              Generate elementary reflector H(i) to annihilate
               --              A(1:i-2,i)
               --
               ALPHA := A (I - 1, I);
               ZLARFG (I - 1, ALPHA, A (1, I)'Address, 1, TAU (I - 1));
               E (I - 1)    := real_part (ALPHA);
               A (I - 1, I) := ONE;
               --
               --              Compute W(1:i-1,i)
               --
               ZHEMV ('U', I - 1, ONE, A'Address, LDA, A (1, I)'Address, 1, ZERO, W (1, IW)'Address, 1);
               if I < N then
                  ZGEMV
                    ('C',
                     I - 1,
                     N - I,
                     ONE,
                     W (1, IW + 1)'Address,
                     LDW,
                     A (1, I)'Address,
                     1,
                     ZERO,
                     W (I + 1, IW)'Address,
                     1);
                  ZGEMV
                    ('N',
                     I - 1,
                     N - I,
                     -ONE,
                     A (1, I + 1)'Address,
                     LDA,
                     W (I + 1, IW)'Address,
                     1,
                     ONE,
                     W (1, IW)'Address,
                     1);
                  ZGEMV
                    ('C',
                     I - 1,
                     N - I,
                     ONE,
                     A (1, I + 1)'Address,
                     LDA,
                     A (1, I)'Address,
                     1,
                     ZERO,
                     W (I + 1, IW)'Address,
                     1);
                  ZGEMV
                    ('N',
                     I - 1,
                     N - I,
                     -ONE,
                     W (1, IW + 1)'Address,
                     LDW,
                     W (I + 1, IW)'Address,
                     1,
                     ONE,
                     W (1, IW)'Address,
                     1);
               end if;
               ZSCAL (I - 1, TAU (I - 1), W (1, IW)'Address, 1);
               ALPHA := -HALF * TAU (I - 1) * ZDOTC (I - 1, W (1, IW)'Address, 1, A (1, I)'Address, 1);
               ZAXPY (I - 1, ALPHA, A (1, I)'Address, 1, W (1, IW)'Address, 1);
            end if;
            --
         end loop;
      else
         --
         --        Reduce first NB columns of lower triangle
         --
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > NB;
            --
            --           Update A(i:n,i)
            --
            A (I, I) := Pure_Real (A (I, I));
            ZLACGV (I - 1, W (I, 1)'Address, LDW);
            ZGEMV ('N', N - I + 1, I - 1, -ONE, A (I, 1)'Address, LDA, W (I, 1)'Address, LDW, ONE, A (I, I)'Address, 1);
            ZLACGV (I - 1, W (I, 1)'Address, LDW);
            ZLACGV (I - 1, A (I, 1)'Address, LDA);
            ZGEMV ('N', N - I + 1, I - 1, -ONE, W (I, 1)'Address, LDW, A (I, 1)'Address, LDA, ONE, A (I, I)'Address, 1);
            ZLACGV (I - 1, A (I, 1)'Address, LDA);
            A (I, I) := Pure_Real (A (I, I));
            if I < N then
               --
               --              Generate elementary reflector H(i) to annihilate
               --              A(i+2:n,i)
               --
               ALPHA := A (I + 1, I);
               ZLARFG (N - I, ALPHA, A (min (I + 2, N), I)'Address, 1, TAU (I));
               E (I)        := real_part (ALPHA);
               A (I + 1, I) := ONE;
               --
               --              Compute W(i+1:n,i)
               --
               ZHEMV
                 ('L',
                  N - I,
                  ONE,
                  A (I + 1, I + 1)'Address,
                  LDA,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  W (I + 1, I)'Address,
                  1);
               ZGEMV
                 ('C',
                  N - I,
                  I - 1,
                  ONE,
                  W (I + 1, 1)'Address,
                  LDW,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  W (1, I)'Address,
                  1);
               ZGEMV
                 ('N',
                  N - I,
                  I - 1,
                  -ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  W (1, I)'Address,
                  1,
                  ONE,
                  W (I + 1, I)'Address,
                  1);
               ZGEMV
                 ('C',
                  N - I,
                  I - 1,
                  ONE,
                  A (I + 1, 1)'Address,
                  LDA,
                  A (I + 1, I)'Address,
                  1,
                  ZERO,
                  W (1, I)'Address,
                  1);
               ZGEMV
                 ('N',
                  N - I,
                  I - 1,
                  -ONE,
                  W (I + 1, 1)'Address,
                  LDW,
                  W (1, I)'Address,
                  1,
                  ONE,
                  W (I + 1, I)'Address,
                  1);
               ZSCAL (N - I, TAU (I), W (I + 1, I)'Address, 1);
               ALPHA := -HALF * TAU (I) * ZDOTC (N - I, W (I + 1, I)'Address, 1, A (I + 1, I)'Address, 1);
               ZAXPY (N - I, ALPHA, A (I + 1, I)'Address, 1, W (I + 1, I)'Address, 1);
            end if;
            --
         end loop;
      end if;
      --
      return;
      --
      --     End of ZLATRD
      --
   end ZLATRD;

   procedure ZLATRS
     (UPLO      : Character;
      TRANS     : Character;
      DIAG      : Character;
      NORMIN    : Character;
      N         : Integer;
      A_adr     : Address;
      LDA       : Integer;
      X_adr     : Address;
      SCALE     : in out Real;
      CNORM_adr : Address;
      INFO      : in out Integer)
   is

      A     : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      X     : Ftn_Complex_Vector (1 .. N);
      CNORM : Ftn_Real_Vector (1 .. N);

      for A'Address use A_adr;
      for X'Address use X_adr;
      for CNORM'Address use CNORM_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, X);
      pragma Import (Ada, CNORM);

      ZERO   : constant Real := 0.0e0;
      HALF   : constant Real := 0.5e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      NOTRAN : Boolean;
      NOUNIT : Boolean;
      UPPER  : Boolean;
      I      : Integer;
      IMAX   : Integer;
      J      : Integer;
      JFIRST : Integer;
      JINC   : Integer;
      JLAST  : Integer;
      BIGNUM : Real;
      GROW   : Real;
      REC    : Real;
      SMLNUM : Real;
      TJJ    : Real;
      TMAX   : Real;
      TSCAL  : Real;
      XBND   : Real;
      XJ     : Real;
      XMAX   : Real;
      CSUMJ  : Complex;
      TJJS   : Complex;
      USCAL  : Complex;
      ZDUM   : Complex;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZLATRS( UPLO, TRANS, DIAG, NORMIN, N, A, LDA, X, SCALE,
   --                          CNORM, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIAG, NORMIN, TRANS, UPLO
   --       INTEGER            INFO, LDA, N
   --       DOUBLE PRECISION   SCALE
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   CNORM( * )
   --       COMPLEX*16         A( LDA, * ), X( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZLATRS solves one of the triangular systems
   --
   --     A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
   --
   --  with scaling to prevent overflow.  Here A is an upper or lower
   --  triangular matrix, A**T denotes the transpose of A, A**H denotes the
   --  conjugate transpose of A, x and b are n-element vectors, and s is a
   --  scaling factor, usually less than or equal to 1, chosen so that the
   --  components of x will be less than the overflow threshold.  If the
   --  unscaled problem will not cause overflow, the Level 2 BLAS routine
   --  ZTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
   --  then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the matrix A is upper or lower triangular.
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           Specifies the operation applied to A.
   --           = 'N':  Solve A * x = s*b     (No transpose)
   --           = 'T':  Solve A**T * x = s*b  (Transpose)
   --           = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --           Specifies whether or not the matrix A is unit triangular.
   --           = 'N':  Non-unit triangular
   --           = 'U':  Unit triangular
   --
   --  [in] NORMIN
   --           NORMIN is CHARACTER*1
   --           Specifies whether CNORM has been set or not.
   --           = 'Y':  CNORM contains the column norms on entry
   --           = 'N':  CNORM is not set on entry.  On exit, the norms will
   --                   be computed and stored in CNORM.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The triangular matrix A.  If UPLO = 'U', the leading n by n
   --           upper triangular part of the array A contains the upper
   --           triangular matrix, and the strictly lower triangular part of
   --           A is not referenced.  If UPLO = 'L', the leading n by n lower
   --           triangular part of the array A contains the lower triangular
   --           matrix, and the strictly upper triangular part of A is not
   --           referenced.  If DIAG = 'U', the diagonal elements of A are
   --           also not referenced and are assumed to be 1.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max (1,N).
   --
   --  [in,out] X
   --           X is COMPLEX*16 array, dimension (N)
   --           On entry, the right hand side b of the triangular system.
   --           On exit, X is overwritten by the solution vector x.
   --
   --  [out] SCALE
   --           SCALE is DOUBLE PRECISION
   --           The scaling factor s for the triangular system
   --              A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
   --           If SCALE = 0, the matrix A is singular or badly scaled, and
   --           the vector x is an exact or approximate solution to A*x = 0.
   --
   --  [in,out] CNORM
   --           CNORM is DOUBLE PRECISION array, dimension (N)
   --
   --           If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
   --           contains the norm of the off-diagonal part of the j-th column
   --           of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
   --           to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
   --           must be greater than or equal to the 1-norm.
   --
   --           If NORMIN = 'N', CNORM is an output argument and CNORM(j)
   --           returns the 1-norm of the offdiagonal part of the j-th column
   --           of A.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -k, the k-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   A rough bound on x is computed; if that is less than overflow, ZTRSV
   --   is called, otherwise, specific code is used which checks for possible
   --   overflow or divide-by-zero at every operation.
   --
   --   A columnwise scheme is used for solving A*x = b.  The basic algorithm
   --   if A is lower triangular is
   --
   --        x[1:n] := b[1:n]
   --        for j = 1, ..., n
   --             x(j) := x(j) / A(j,j)
   --             x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
   --        end
   --
   --   Define bounds on the components of x after j iterations of the loop:
   --      M(j) = bound on x[1:j]
   --      G(j) = bound on x[j+1:n]
   --   Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
   --
   --   Then for iteration j+1 we have
   --      M(j+1) <= G(j) / | A(j+1,j+1) |
   --      G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] |
   --             <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
   --
   --   where CNORM(j+1) is greater than or equal to the infinity-norm of
   --   column j+1 of A, not counting the diagonal.  Hence
   --
   --      G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
   --                   1<=i<=j
   --   and
   --
   --      |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
   --                                    1<=i< j
   --
   --   Since |x(j)| <= M(j), we use the Level 2 BLAS routine ZTRSV if the
   --   reciprocal of the largest M(j), j=1,..,n, is larger than
   --   max(underflow, 1/overflow).
   --
   --   The bound on x(j) is also used to determine when a step in the
   --   columnwise method can be performed without fear of overflow.  If
   --   the computed bound is greater than a large constant, x is scaled to
   --   prevent overflow, but if the bound overflows, x is set to 0, x(j) to
   --   1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
   --
   --   Similarly, a row-wise scheme is used to solve A**T *x = b  or
   --   A**H *x = b.  The basic algorithm for A upper triangular is
   --
   --        for j = 1, ..., n
   --             x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
   --        end
   --
   --   We simultaneously compute two bounds
   --        G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j
   --        M(j) = bound on x(i), 1<=i<=j
   --
   --   The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
   --   add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
   --   Then the bound on x(j) is
   --
   --        M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
   --
   --             <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
   --                       1<=i<=j
   --
   --   and we can safely call ZTRSV if 1/M(n) and 1/G(n) are both greater
   --   than max(underflow, 1/overflow).
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, HALF = 0.5D+0, ONE = 1.0D+0, TWO = 2.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       INTEGER            IDAMAX, IZAMAX
   --       DOUBLE PRECISION   DLAMCH, DZASUM
   --       COMPLEX*16         ZDOTC, ZDOTU, ZLADIV
   --       EXTERNAL           LSAME, IDAMAX, IZAMAX, DLAMCH, DZASUM, ZDOTC,
   --      $                   ZDOTU, ZLADIV
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           DSCAL, XERBLA, ZAXPY, ZDSCAL, ZTRSV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCMPLX, DCONJG, DIMAG, MAX, MIN
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(ZDUM) := ABS(DBLE(ZDUM)) + ABS(DIMAG(ZDUM));
      --       CABS2(ZDUM) := ABS(DBLE(ZDUM) / 2.0e0) + ABS(DIMAG(ZDUM) / 2.0e0);
      --     ..
      --     .. Executable Statements ..
      --
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      NOTRAN := LSAME (TRANS, 'N');
      NOUNIT := LSAME (DIAG, 'N');
      --
      --     Test the input parameters.
      --
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'T') and not LSAME (TRANS, 'C') then
         INFO := -2;
      elsif not NOUNIT and not LSAME (DIAG, 'U') then
         INFO := -3;
      elsif not LSAME (NORMIN, 'Y') and not LSAME (NORMIN, 'N') then
         INFO := -4;
      elsif N < 0 then
         INFO := -5;
      elsif LDA < max (1, N) then
         INFO := -7;
      end if;
      if INFO /= 0 then
         XERBLA ("ZLATRS", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     Determine machine dependent parameters to control overflow.
      --
      SMLNUM := DLAMCH ('S');
      BIGNUM := ONE / SMLNUM;
      DLABAD (SMLNUM, BIGNUM);
      SMLNUM := SMLNUM / DLAMCH ('S');
      BIGNUM := ONE / SMLNUM;
      SCALE  := ONE;
      --
      if LSAME (NORMIN, 'N') then
         --
         --        Compute the 1-norm of each column, not including the diagonal.
         --
         if UPPER then
            --
            --           A is upper triangular.
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               CNORM (J) := DZASUM (J - 1, A (1, J)'Address, 1);
            end loop;
         else
            --
            --           A is lower triangular.
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N - 1;
               CNORM (J) := DZASUM (N - J, A (J + 1, J)'Address, 1);
            end loop;
            CNORM (N) := ZERO;
         end if;
      end if;
      --
      --     Scale the column norms by TSCAL if the maximum element in CNORM is
      --     greater than BIGNUM/2.
      --
      IMAX := IDAMAX (N, CNORM'Address, 1);
      TMAX := CNORM (IMAX);
      if TMAX <= BIGNUM * HALF then
         TSCAL := ONE;
      else
         TSCAL := HALF / (SMLNUM * TMAX);
         DSCAL (N, TSCAL, CNORM'Address, 1);
      end if;
      --
      --     Compute a bound on the computed solution vector to see if the
      --     Level 2 BLAS routine ZTRSV can be used.
      --
      XMAX := ZERO;
      J    := 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         XMAX := max (XMAX, CABS2 (X (J)));
      end loop;
      XBND := XMAX;
      --
      if NOTRAN then
         --
         --        Compute the growth in A * x = b.
         --
         if UPPER then
            JFIRST := N;
            JLAST  := 1;
            JINC   := -1;
         else
            JFIRST := 1;
            JLAST  := N;
            JINC   := 1;
         end if;
         --
         if TSCAL /= ONE then
            GROW := ZERO;
            goto L60;
         end if;
         --
         if NOUNIT then
            --
            --           A is non-unit triangular.
            --
            --           Compute GROW = 1/G(j) and XBND = 1/M(j).
            --           Initially, G(0) = max{x(i), i=1,...,n}.
            --
            GROW := HALF / max (XBND, SMLNUM);
            XBND := GROW;
            J    := JFIRST - JINC;
            loop
               J := J + JINC;
               if JINC > 0 
                  then exit when J > JLAST;
                  else exit when J < JLAST;
               end if;
               --
               --              Exit the loop if the growth factor is too small.
               --
               if GROW <= SMLNUM then
                  goto L60;
               end if;
               --
               TJJS := A (J, J);
               TJJ  := CABS1 (TJJS);
               --
               if TJJ >= SMLNUM then
                  --
                  --                 M(j) = G(j-1) / abs(A(j,j))
                  --
                  XBND := min (XBND, min (ONE, TJJ) * GROW);
               else
                  --
                  --                 M(j) could overflow, set XBND to 0.
                  --
                  XBND := ZERO;
               end if;
               --
               if TJJ + CNORM (J) >= SMLNUM then
                  --
                  --                 G(j) = G(j-1)*( 1 + CNORM(j) / abs(A(j,j)) )
                  --
                  GROW := GROW * (TJJ / (TJJ + CNORM (J)));
               else
                  --
                  --                 G(j) could overflow, set GROW to 0.
                  --
                  GROW := ZERO;
               end if;
            end loop;
            GROW := XBND;
         else
            --
            --           A is unit triangular.
            --
            --           Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.
            --
            GROW := min (ONE, HALF / max (XBND, SMLNUM));
            J    := JFIRST - JINC;
            loop
               J := J + JINC;
               if JINC > 0 
                  then exit when J > JLAST;
                  else exit when J < JLAST;
               end if;
               --
               --              Exit the loop if the growth factor is too small.
               --
               if GROW <= SMLNUM then
                  goto L60;
               end if;
               --
               --              G(j) = G(j-1)*( 1 + CNORM(j) )
               --
               GROW := GROW * (ONE / (ONE + CNORM (J)));
            end loop;
         end if;
         <<L60>> null;
      --
      else
         --
         --        Compute the growth in A**T * x = b  or  A**H * x = b.
         --
         if UPPER then
            JFIRST := 1;
            JLAST  := N;
            JINC   := 1;
         else
            JFIRST := N;
            JLAST  := 1;
            JINC   := -1;
         end if;
         --
         if TSCAL /= ONE then
            GROW := ZERO;
            goto L90;
         end if;
         --
         if NOUNIT then
            --
            --           A is non-unit triangular.
            --
            --           Compute GROW = 1/G(j) and XBND = 1/M(j).
            --           Initially, M(0) = max{x(i), i=1,...,n}.
            --
            GROW := HALF / max (XBND, SMLNUM);
            XBND := GROW;
            J    := JFIRST - JINC;
            loop
               J := J + JINC;
               if JINC > 0 
                  then exit when J > JLAST;
                  else exit when J < JLAST;
               end if;
               --
               --              Exit the loop if the growth factor is too small.
               --
               if GROW <= SMLNUM then
                  goto L90;
               end if;
               --
               --              G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) )
               --
               XJ   := ONE + CNORM (J);
               GROW := min (GROW, XBND / XJ);
               --
               TJJS := A (J, J);
               TJJ  := CABS1 (TJJS);
               --
               if TJJ >= SMLNUM then
                  --
                  --                 M(j) = M(j-1)*( 1 + CNORM(j) ) / abs(A(j,j))
                  --
                  if XJ > TJJ then
                     XBND := XBND * (TJJ / XJ);
                  end if;
               else
                  --
                  --                 M(j) could overflow, set XBND to 0.
                  --
                  XBND := ZERO;
               end if;
            end loop;
            GROW := min (GROW, XBND);
         else
            --
            --           A is unit triangular.
            --
            --           Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}.
            --
            GROW := min (ONE, HALF / max (XBND, SMLNUM));
            J    := JFIRST - JINC;
            loop
               J := J + JINC;
               if JINC > 0 
                  then exit when J > JLAST;
                  else exit when J < JLAST;
               end if;
               --
               --              Exit the loop if the growth factor is too small.
               --
               if GROW <= SMLNUM then
                  goto L90;
               end if;
               --
               --              G(j) = ( 1 + CNORM(j) )*G(j-1)
               --
               XJ   := ONE + CNORM (J);
               GROW := GROW / XJ;
            end loop;
         end if;
         <<L90>> null;
      end if;
      --
      if (GROW * TSCAL) > SMLNUM then
         --
         --        Use the Level 2 BLAS solve if the reciprocal of the bound on
         --        elements of X is not too small.
         --
         ZTRSV (UPLO, TRANS, DIAG, N, A, LDA, X, 1);
      else
         --
         --        Use a Level 1 BLAS solve, scaling intermediate results.
         --
         if XMAX > BIGNUM * HALF then
            --
            --           Scale X so that its components are less than or equal to
            --           BIGNUM in absolute value.
            --
            SCALE := (BIGNUM * HALF) / XMAX;
            ZDSCAL (N, SCALE, X'Address, 1);
            XMAX := BIGNUM;
         else
            XMAX := XMAX * TWO;
         end if;
         --
         if NOTRAN then
            --
            --           Solve A * x = b
            --
            J := JFIRST - JINC;
            loop
               J := J + JINC;
               if JINC > 0 
                  then exit when J > JLAST;
                  else exit when J < JLAST;
               end if;
               --
               --              Compute x(j) = b(j) / A(j,j), scaling x if necessary.
               --
               XJ := CABS1 (X (J));
               if NOUNIT then
                  TJJS := A (J, J) * TSCAL;
               else
                  TJJS := Complex'(TSCAL, 0.0e0);
                  if TSCAL = ONE then
                     goto L110;
                  end if;
               end if;
               TJJ := CABS1 (TJJS);
               if TJJ > SMLNUM then
                  --
                  --                    abs(A(j,j)) > SMLNUM:
                  --
                  if TJJ < ONE then
                     if XJ > TJJ * BIGNUM then
                        --
                        --                          Scale x by 1/b(j).
                        --
                        REC := ONE / XJ;
                        ZDSCAL (N, REC, X'Address, 1);
                        SCALE := SCALE * REC;
                        XMAX  := XMAX * REC;
                     end if;
                  end if;
                  X (J) := ZLADIV (X (J), TJJS);
                  XJ    := CABS1 (X (J));
               elsif TJJ > ZERO then
                  --
                  --                    0 < abs(A(j,j)) <= SMLNUM:
                  --
                  if XJ > TJJ * BIGNUM then
                     --
                     --                       Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM
                     --                       to avoid overflow when dividing by A(j,j).
                     --
                     REC := (TJJ * BIGNUM) / XJ;
                     if CNORM (J) > ONE then
                        --
                        --                          Scale by 1/CNORM(j) to avoid overflow when
                        --                          multiplying x(j) times column j.
                        --
                        REC := REC / CNORM (J);
                     end if;
                     ZDSCAL (N, REC, X'Address, 1);
                     SCALE := SCALE * REC;
                     XMAX  := XMAX * REC;
                  end if;
                  X (J) := ZLADIV (X (J), TJJS);
                  XJ    := CABS1 (X (J));
               else
                  --
                  --                    A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                  --                    scale = 0, and compute a solution to A*x = 0.
                  --
                  I := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     X (I) := Complex'(ZERO, ZERO);
                  end loop;
                  X (J) := Complex'(ONE, ZERO);
                  XJ    := ONE;
                  SCALE := ZERO;
                  XMAX  := ZERO;
               end if;
               <<L110>> null;
               --
               --              Scale x if necessary to avoid overflow when adding a
               --              multiple of column j of A.
               --
               if XJ > ONE then
                  REC := ONE / XJ;
                  if CNORM (J) > (BIGNUM - XMAX) * REC then
                     --
                     --                    Scale x by 1/(2*abs(x(j))).
                     --
                     REC := REC * HALF;
                     ZDSCAL (N, REC, X'Address, 1);
                     SCALE := SCALE * REC;
                  end if;
               elsif XJ * CNORM (J) > (BIGNUM - XMAX) then
                  --
                  --                 Scale x by 1/2.
                  --
                  ZDSCAL (N, HALF, X'Address, 1);
                  SCALE := SCALE * HALF;
               end if;
               --
               if UPPER then
                  if J > 1 then
                     --
                     --                    Compute the update
                     --                       x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j)
                     --
                     ZAXPY (J - 1, -X (J) * TSCAL, A (1, J)'Address, 1, X'Address, 1);
                     I    := IZAMAX (J - 1, X'Address, 1);
                     XMAX := CABS1 (X (I));
                  end if;
               else
                  if J < N then
                     --
                     --                    Compute the update
                     --                       x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j)
                     --
                     ZAXPY (N - J, -X (J) * TSCAL, A (J + 1, J)'Address, 1, X (J + 1)'Address, 1);
                     I    := J + IZAMAX (N - J, X (J + 1)'Address, 1);
                     XMAX := CABS1 (X (I));
                  end if;
               end if;
            end loop;
         --
         elsif LSAME (TRANS, 'T') then
            --
            --           Solve A**T * x = b
            --
            J := JFIRST - JINC;
            loop
               J := J + JINC;
               if JINC > 0 
                  then exit when J > JLAST;
                  else exit when J < JLAST;
               end if;
               --
               --              Compute x(j) = b(j) - sum A(k,j)*x(k).
               --                                    k<>j
               --
               XJ    := CABS1 (X (J));
               USCAL := Complex'(TSCAL, 0.0e0);
               REC   := ONE / max (XMAX, ONE);
               if CNORM (J) > (BIGNUM - XJ) * REC then
                  --
                  --                 If x(j) could overflow, scale x by 1/(2*XMAX).
                  --
                  REC := REC * HALF;
                  if NOUNIT 
                     then TJJS := A (J, J) * TSCAL;
                     else TJJS := Complex'(TSCAL, 0.0e0);
                  end if;
                  TJJ := CABS1 (TJJS);
                  if TJJ > ONE then
                     --
                     --                       Divide by A(j,j) when scaling x if A(j,j) > 1.
                     --
                     REC   := min (ONE, REC * TJJ);
                     USCAL := ZLADIV (USCAL, TJJS);
                  end if;
                  if REC < ONE then
                     ZDSCAL (N, REC, X'Address, 1);
                     SCALE := SCALE * REC;
                     XMAX  := XMAX * REC;
                  end if;
               end if;
               --
               CSUMJ := Complex'(ZERO, ZERO);
               if USCAL = Complex'(ONE, 0.0e0) then
                  --
                  --                 If the scaling needed for A in the dot product is 1,
                  --                 call ZDOTU to perform the dot product.
                  --
                  if UPPER then
                     CSUMJ := ZDOTU (J - 1, A (1, J)'Address, 1, X'Address, 1);
                  elsif J < N then
                     CSUMJ := ZDOTU (N - J, A (J + 1, J)'Address, 1, X (J + 1)'Address, 1);
                  end if;
               else
                  --
                  --                 Otherwise, use in-line code for the dot product.
                  --
                  if UPPER then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        CSUMJ := CSUMJ + (A (I, J) * USCAL) * X (I);
                     end loop;
                  elsif J < N then
                     I := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        CSUMJ := CSUMJ + (A (I, J) * USCAL) * X (I);
                     end loop;
                  end if;
               end if;
               --
               if USCAL = Complex'(TSCAL, 0.0e0) then
                  --
                  --                 Compute x(j) := ( x(j) - CSUMJ ) / A(j,j) if 1/A(j,j)
                  --                 was not used to scale the dotproduct.
                  --
                  X (J) := X (J) - CSUMJ;
                  XJ    := CABS1 (X (J));
                  if NOUNIT then
                     TJJS := A (J, J) * TSCAL;
                  else
                     TJJS := Complex'(TSCAL, 0.0e0);
                     if TSCAL = ONE then
                        goto L160;
                     end if;
                  end if;
                  --
                  --                    Compute x(j) = x(j) / A(j,j), scaling if necessary.
                  --
                  TJJ := CABS1 (TJJS);
                  if TJJ > SMLNUM then
                     --
                     --                       abs(A(j,j)) > SMLNUM:
                     --
                     if TJJ < ONE then
                        if XJ > TJJ * BIGNUM then
                           --
                           --                             Scale X by 1/abs(x(j)).
                           --
                           REC := ONE / XJ;
                           ZDSCAL (N, REC, X'Address, 1);
                           SCALE := SCALE * REC;
                           XMAX  := XMAX * REC;
                        end if;
                     end if;
                     X (J) := ZLADIV (X (J), TJJS);
                  elsif TJJ > ZERO then
                     --
                     --                       0 < abs(A(j,j)) <= SMLNUM:
                     --
                     if XJ > TJJ * BIGNUM then
                        --
                        --                          Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM.
                        --
                        REC := (TJJ * BIGNUM) / XJ;
                        ZDSCAL (N, REC, X'Address, 1);
                        SCALE := SCALE * REC;
                        XMAX  := XMAX * REC;
                     end if;
                     X (J) := ZLADIV (X (J), TJJS);
                  else
                     --
                     --                       A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                     --                       scale = 0 and compute a solution to A**T *x = 0.
                     --
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        X (I) := Complex'(ZERO, ZERO);
                     end loop;
                     X (J) := Complex'(ONE, ZERO);
                     SCALE := ZERO;
                     XMAX  := ZERO;
                  end if;
                  <<L160>> null;
               else
                  --
                  --                 Compute x(j) := x(j) / A(j,j) - CSUMJ if the dot
                  --                 product has already been divided by 1/A(j,j).
                  --
                  X (J) := ZLADIV (X (J), TJJS) - CSUMJ;
               end if;
               XMAX := max (XMAX, CABS1 (X (J)));
            end loop;
         --
         else
            --
            --           Solve A**H * x = b
            --
            J := JFIRST - JINC;
            loop
               J := J + JINC;
               if JINC > 0 
                  then exit when J > JLAST;
                  else exit when J < JLAST;
               end if;
               --
               --              Compute x(j) = b(j) - sum A(k,j)*x(k).
               --                                    k<>j
               --
               XJ    := CABS1 (X (J));
               USCAL := Complex'(TSCAL, 0.0e0);
               REC   := ONE / max (XMAX, ONE);
               if CNORM (J) > (BIGNUM - XJ) * REC then
                  --
                  --                 If x(j) could overflow, scale x by 1/(2*XMAX).
                  --
                  REC := REC * HALF;
                  if NOUNIT 
                     then TJJS := dconjg (A (J, J)) * TSCAL;
                     else TJJS := Complex'(TSCAL, 0.0e0);
                  end if;
                  TJJ := CABS1 (TJJS);
                  if TJJ > ONE then
                     --
                     --                       Divide by A(j,j) when scaling x if A(j,j) > 1.
                     --
                     REC   := min (ONE, REC * TJJ);
                     USCAL := ZLADIV (USCAL, TJJS);
                  end if;
                  if REC < ONE then
                     ZDSCAL (N, REC, X'Address, 1);
                     SCALE := SCALE * REC;
                     XMAX  := XMAX * REC;
                  end if;
               end if;
               --
               CSUMJ := Complex'(ZERO, ZERO);
               if USCAL = Complex'(ONE, 0.0e0) then
                  --
                  --                 If the scaling needed for A in the dot product is 1,
                  --                 call ZDOTC to perform the dot product.
                  --
                  if UPPER then
                     CSUMJ := ZDOTC (J - 1, A (1, J)'Address, 1, X'Address, 1);
                  elsif J < N then
                     CSUMJ := ZDOTC (N - J, A (J + 1, J)'Address, 1, X (J + 1)'Address, 1);
                  end if;
               else
                  --
                  --                 Otherwise, use in-line code for the dot product.
                  --
                  if UPPER then
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > J - 1;
                        CSUMJ := CSUMJ + (dconjg (A (I, J)) * USCAL) * X (I);
                     end loop;
                  elsif J < N then
                     I := J + 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        CSUMJ := CSUMJ + (dconjg (A (I, J)) * USCAL) * X (I);
                     end loop;
                  end if;
               end if;
               --
               if USCAL = Complex'(TSCAL, 0.0e0) then
                  --
                  --                 Compute x(j) := ( x(j) - CSUMJ ) / A(j,j) if 1/A(j,j)
                  --                 was not used to scale the dotproduct.
                  --
                  X (J) := X (J) - CSUMJ;
                  XJ    := CABS1 (X (J));
                  if NOUNIT then
                     TJJS := dconjg (A (J, J)) * TSCAL;
                  else
                     TJJS := Complex'(TSCAL, 0.0e0);
                     if TSCAL = ONE then
                        goto L210;
                     end if;
                  end if;
                  --
                  --                    Compute x(j) = x(j) / A(j,j), scaling if necessary.
                  --
                  TJJ := CABS1 (TJJS);
                  if TJJ > SMLNUM then
                     --
                     --                       abs(A(j,j)) > SMLNUM:
                     --
                     if TJJ < ONE then
                        if XJ > TJJ * BIGNUM then
                           --
                           --                             Scale X by 1/abs(x(j)).
                           --
                           REC := ONE / XJ;
                           ZDSCAL (N, REC, X'Address, 1);
                           SCALE := SCALE * REC;
                           XMAX  := XMAX * REC;
                        end if;
                     end if;
                     X (J) := ZLADIV (X (J), TJJS);
                  elsif TJJ > ZERO then
                     --
                     --                       0 < abs(A(j,j)) <= SMLNUM:
                     --
                     if XJ > TJJ * BIGNUM then
                        --
                        --                          Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM.
                        --
                        REC := (TJJ * BIGNUM) / XJ;
                        ZDSCAL (N, REC, X'Address, 1);
                        SCALE := SCALE * REC;
                        XMAX  := XMAX * REC;
                     end if;
                     X (J) := ZLADIV (X (J), TJJS);
                  else
                     --
                     --                       A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and
                     --                       scale = 0 and compute a solution to A**H *x = 0.
                     --
                     I := 1 - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        X (I) := Complex'(ZERO, ZERO);
                     end loop;
                     X (J) := Complex'(ONE, ZERO);
                     SCALE := ZERO;
                     XMAX  := ZERO;
                  end if;
                  <<L210>> null;
               else
                  --
                  --                 Compute x(j) := x(j) / A(j,j) - CSUMJ if the dot
                  --                 product has already been divided by 1/A(j,j).
                  --
                  X (J) := ZLADIV (X (J), TJJS) - CSUMJ;
               end if;
               XMAX := max (XMAX, CABS1 (X (J)));
            end loop;
         end if;
         SCALE := SCALE / TSCAL;
      end if;
      --
      --     Scale the column norms by 1/TSCAL for return.
      --
      if TSCAL /= ONE then
         DSCAL (N, ONE / TSCAL, CNORM'Address, 1);
      end if;
      --
      return;
      --
      --     End of ZLATRS
      --
   end ZLATRS;

   procedure ZROT
     (N      : Integer;
      CX_adr : Address;
      INCX   : Integer;
      CY_adr : Address;
      INCY   : Integer;
      C      : Real;
      S      : Complex)
   is

      CX : Ftn_Complex_Vector (1 .. N);
      CY : Ftn_Complex_Vector (1 .. N);

      for CX'Address use CX_adr;
      for CY'Address use CY_adr;

      pragma Import (Ada, CX);
      pragma Import (Ada, CY);

      I     : Integer;
      IX    : Integer;
      IY    : Integer;
      STEMP : Complex;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZROT( N, CX, INCX, CY, INCY, C, S )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INCX, INCY, N
   --       DOUBLE PRECISION   C
   --       COMPLEX*16         S
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         CX( * ), CY( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZROT   applies a plane rotation, where the cos (C) is real and the
   --  sin (S) is complex, and the vectors CX and CY are complex.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The number of elements in the vectors CX and CY.
   --
   --  [in,out] CX
   --           CX is COMPLEX*16 array, dimension (N)
   --           On input, the vector X.
   --           On output, CX is overwritten with C*X + S*Y.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --           The increment between successive values of CY.  INCX <> 0.
   --
   --  [in,out] CY
   --           CY is COMPLEX*16 array, dimension (N)
   --           On input, the vector Y.
   --           On output, CY is overwritten with -CONJG(S)*X + C*Y.
   --
   --  [in] INCY
   --           INCY is INTEGER
   --           The increment between successive values of CY.  INCX <> 0.
   --
   --  [in] C
   --           C is DOUBLE PRECISION
   --
   --  [in] S
   --           S is COMPLEX*16
   --           C and S define a rotation
   --              [  C          S  ]
   --              [ -conjg(S)   C  ]
   --           where C*C + S*CONJG(S) = 1.0.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG
   --     ..
   --     .. Executable Statements ..
   --
   begin
      if N <= 0 then
         return;
      end if;
      if INCX = 1 and INCY = 1 then
         goto L20;
      end if;
      --
      --     Code for unequal increments or equal increments not equal to 1
      --
      IX := 1;
      IY := 1;
      if INCX < 0 then
         IX := (-N + 1) * INCX + 1;
      end if;
      if INCY < 0 then
         IY := (-N + 1) * INCY + 1;
      end if;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         STEMP   := C * CX (IX) + S * CY (IY);
         CY (IY) := C * CY (IY) - dconjg (S) * CX (IX);
         CX (IX) := STEMP;
         IX      := IX + INCX;
         IY      := IY + INCY;
      end loop;
      return;
      --
      --     Code for both increments equal to 1
      --
      <<L20>> null;
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         STEMP  := C * CX (I) + S * CY (I);
         CY (I) := C * CY (I) - dconjg (S) * CX (I);
         CX (I) := STEMP;
      end loop;
   end ZROT;

   procedure ZSTEDC
     (COMPZ     : Character;
      N         : Integer;
      D_adr     : Address;
      E_adr     : Address;
      Z_adr     : Address;
      LDZ       : Integer;
      WORK_adr  : Address;
      LWORK     : Integer;
      RWORK_adr : Address;
      LRWORK    : Integer;
      IWORK_adr : Address;
      LIWORK    : Integer;
      INFO      : in out Integer)
   is

      D     : Ftn_Real_Vector (1 .. N);
      E     : Ftn_Real_Vector (1 .. N - 1);
      Z     : Ftn_Complex_Matrix (1 .. LDZ, 1 .. N);
      WORK  : Ftn_Complex_Vector (1 .. max (1, LWORK));
      RWORK : Ftn_Real_Vector (1 .. max (1, LRWORK));
      IWORK : Ftn_Integer_Vector (1 .. max (1, LIWORK));

      for D'Address use D_adr;
      for E'Address use E_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;
      for RWORK'Address use RWORK_adr;
      for IWORK'Address use IWORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);
      pragma Import (Ada, RWORK);
      pragma Import (Ada, IWORK);

      ZERO   : constant Real := 0.0e0;
      ONE    : constant Real := 1.0e0;
      TWO    : constant Real := 2.0e0;
      LQUERY : Boolean;
      FINISH : Integer;
      I      : Integer;
      ICOMPZ : Integer;
      II     : Integer;
      J      : Integer;
      K      : Integer;
      LGN    : Integer;
      LIWMIN : Integer;
      LL     : Integer;
      LRWMIN : Integer;
      LWMIN  : Integer;
      M      : Integer;
      SMLSIZ : Integer;
      START  : Integer;
      EPS    : Real;
      ORGNRM : Real;
      P      : Real;
      TINY   : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSTEDC( COMPZ, N, D, E, Z, LDZ, WORK, LWORK, RWORK,
   --                          LRWORK, IWORK, LIWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          COMPZ
   --       INTEGER            INFO, LDZ, LIWORK, LRWORK, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IWORK( * )
   --       DOUBLE PRECISION   D( * ), E( * ), RWORK( * )
   --       COMPLEX*16         WORK( * ), Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSTEDC computes all eigenvalues and, optionally, eigenvectors of a
   --  symmetric tridiagonal matrix using the divide and conquer method.
   --  The eigenvectors of a full or band complex Hermitian matrix can also
   --  be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
   --  matrix to tridiagonal form.
   --
   --  This code makes very mild assumptions about floating point
   --  arithmetic. It will work on machines with a guard digit in
   --  add/subtract, or on those binary machines without guard digits
   --  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
   --  It could conceivably fail on hexadecimal or decimal machines
   --  without guard digits, but we know of none.  See DLAED3 for details.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] COMPZ
   --           COMPZ is CHARACTER*1
   --           = 'N':  Compute eigenvalues only.
   --           = 'I':  Compute eigenvectors of tridiagonal matrix also.
   --           = 'V':  Compute eigenvectors of original Hermitian matrix
   --                   also.  On entry, Z contains the unitary matrix used
   --                   to reduce the original matrix to tridiagonal form.
   --
   --  [in] N
   --           N is INTEGER
   --           The dimension of the symmetric tridiagonal matrix.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the diagonal elements of the tridiagonal matrix.
   --           On exit, if INFO = 0, the eigenvalues in ascending order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           On entry, the subdiagonal elements of the tridiagonal matrix.
   --           On exit, E has been destroyed.
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array, dimension (LDZ,N)
   --           On entry, if COMPZ = 'V', then Z contains the unitary
   --           matrix used in the reduction to tridiagonal form.
   --           On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
   --           orthonormal eigenvectors of the original Hermitian matrix,
   --           and if COMPZ = 'I', Z contains the orthonormal eigenvectors
   --           of the symmetric tridiagonal matrix.
   --           If  COMPZ = 'N', then Z is not referenced.
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --           The leading dimension of the array Z.  LDZ >= 1.
   --           If eigenvectors are desired, then LDZ >= max(1,N).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If COMPZ = 'N' or 'I', or N <= 1, LWORK must be at least 1.
   --           If COMPZ = 'V' and N > 1, LWORK must be at least N*N.
   --           Note that for COMPZ = 'V', then if N is less than or
   --           equal to the minimum divide size, usually 25, then LWORK need
   --           only be 1.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal sizes of the WORK, RWORK and
   --           IWORK arrays, returns these values as the first entries of
   --           the WORK, RWORK and IWORK arrays, and no error message
   --           related to LWORK or LRWORK or LIWORK is issued by XERBLA.
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array,
   --                                          dimension (LRWORK)
   --           On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
   --
   --  [in] LRWORK
   --           LRWORK is INTEGER
   --           The dimension of the array RWORK.
   --           If COMPZ = 'N' or N <= 1, LRWORK must be at least 1.
   --           If COMPZ = 'V' and N > 1, LRWORK must be at least
   --                          1 + 3*N + 2*N*lg N + 4*N**2 ,
   --                          where lg( N ) = smallest integer k such
   --                          that 2**k >= N.
   --           If COMPZ = 'I' and N > 1, LRWORK must be at least
   --                          1 + 4*N + 2*N**2 .
   --           Note that for COMPZ = 'I' or 'V', then if N is less than or
   --           equal to the minimum divide size, usually 25, then LRWORK
   --           need only be max(1,2*(N-1)).
   --
   --           If LRWORK = -1, then a workspace query is assumed; the
   --           routine only calculates the optimal sizes of the WORK, RWORK
   --           and IWORK arrays, returns these values as the first entries
   --           of the WORK, RWORK and IWORK arrays, and no error message
   --           related to LWORK or LRWORK or LIWORK is issued by XERBLA.
   --
   --  [out] IWORK
   --           IWORK is INTEGER array, dimension (MAX(1,LIWORK))
   --           On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
   --
   --  [in] LIWORK
   --           LIWORK is INTEGER
   --           The dimension of the array IWORK.
   --           If COMPZ = 'N' or N <= 1, LIWORK must be at least 1.
   --           If COMPZ = 'V' or N > 1,  LIWORK must be at least
   --                                     6 + 6*N + 5*N*lg N.
   --           If COMPZ = 'I' or N > 1,  LIWORK must be at least
   --                                     3 + 5*N .
   --           Note that for COMPZ = 'I' or 'V', then if N is less than or
   --           equal to the minimum divide size, usually 25, then LIWORK
   --           need only be 1.
   --
   --           If LIWORK = -1, then a workspace query is assumed; the
   --           routine only calculates the optimal sizes of the WORK, RWORK
   --           and IWORK arrays, returns these values as the first entries
   --           of the WORK, RWORK and IWORK arrays, and no error message
   --           related to LWORK or LRWORK or LIWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit.
   --           < 0:  if INFO = -i, the i-th argument had an illegal value.
   --           > 0:  The algorithm failed to compute an eigenvalue while
   --                 working on the submatrix lying in rows and columns
   --                 INFO/(N+1) through mod(INFO,N+1).
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Contributors:
   --  ==================
   --
   --  Jeff Rutter, Computer Science Division, University of California
   --  at Berkeley, USA
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANST
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLASCL, DLASET, DSTEDC, DSTEQR, DSTERF, XERBLA, ZLACPY, ZLACRM, ZLAED0, ZSTEQR, ZSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, INT, LOG, MAX, MOD, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1 or LRWORK = -1 or LIWORK = -1);
      --
      if LSAME (COMPZ, 'N') then
         ICOMPZ := 0;
      elsif LSAME (COMPZ, 'V') then
         ICOMPZ := 1;
      elsif LSAME (COMPZ, 'I') then
         ICOMPZ := 2;
      else
         ICOMPZ := -1;
      end if;
      if ICOMPZ < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif (LDZ < 1) or (ICOMPZ > 0 and LDZ < max (1, N)) then
         INFO := -6;
      end if;
      --
      if INFO = 0 then
         --
         --        Compute the workspace requirements
         --
         SMLSIZ := ILAENV (9, "ZSTEDC", " ", 0, 0, 0, 0);
         if N <= 1 or ICOMPZ = 0 then
            LWMIN  := 1;
            LIWMIN := 1;
            LRWMIN := 1;
         elsif N <= SMLSIZ then
            LWMIN  := 1;
            LIWMIN := 1;
            LRWMIN := 2 * (N - 1);
         elsif ICOMPZ = 1 then
            LGN := int (Log (Real (N)) / Log (TWO));
            if 2 ** LGN < N then
               LGN := LGN + 1;
            end if;
            if 2 ** LGN < N then
               LGN := LGN + 1;
            end if;
            LWMIN  := N * N;
            LRWMIN := 1 + 3 * N + 2 * N * LGN + 4 * N ** 2;
            LIWMIN := 6 + 6 * N + 5 * N * LGN;
         elsif ICOMPZ = 2 then
            LWMIN  := 1;
            LRWMIN := 1 + 4 * N + 2 * N ** 2;
            LIWMIN := 3 + 5 * N;
         end if;
         WORK (1)  := Complex'(Real (LWMIN), 0.0);
         RWORK (1) := Real (LRWMIN);
         IWORK (1) := LIWMIN;
         --
         if LWORK < LWMIN and not LQUERY then
            INFO := -8;
         elsif LRWORK < LRWMIN and not LQUERY then
            INFO := -10;
         elsif LIWORK < LIWMIN and not LQUERY then
            INFO := -12;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZSTEDC", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      if N = 1 then
         if ICOMPZ /= 0 then
            Z (1, 1) := Complex'(ONE, 0.0);
         end if;
         return;
      end if;
      --
      --     If the following conditional clause is removed, then the routine
      --     will use the Divide and Conquer routine to compute only the
      --     eigenvalues, which requires (3N + 3N**2) real workspace and
      --     (2 + 5N + 2N lg(N)) integer workspace.
      --     Since on many architectures DSTERF is much faster than any other
      --     algorithm for finding eigenvalues only, it is used here
      --     as the default. If the conditional clause is removed, then
      --     information on the size of workspace needs to be changed.
      --
      --     If COMPZ = 'N', use DSTERF to compute the eigenvalues.
      --
      if ICOMPZ = 0 then
         DSTERF (N, D'Address, E'Address, INFO);
         goto L70;
      end if;
      --
      --     If N is smaller than the minimum divide size (SMLSIZ+1), then
      --     solve the problem with another solver.
      --
      if N <= SMLSIZ then
         --
         ZSTEQR (COMPZ, N, D'Address, E'Address, Z'Address, LDZ, RWORK'Address, INFO);
      --
      else
         --
         --        If COMPZ = 'I', we simply call DSTEDC instead.
         --
         if ICOMPZ = 2 then
            DLASET ('F', N, N, ZERO, ONE, RWORK'Address, N);
            LL := N * N + 1;
            DSTEDC
              ('I',
               N,
               D'Address,
               E'Address,
               RWORK'Address,
               N,
               RWORK (LL)'Address,
               LRWORK - LL + 1,
               IWORK'Address,
               LIWORK,
               INFO);
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := 1 - 1;
               loop
                  I := I + 1;
                  exit when I > N;
                  Z (I, J) := Complex'(RWORK ((J - 1) * N + I), 0.0);
               end loop;
            end loop;
            goto L70;
         end if;
         --
         --        From now on, only option left to be handled is COMPZ = 'V',
         --        i.e. ICOMPZ = 1.
         --
         --        Scale.
         --
         ORGNRM := DLANST ('M', N, D'Address, E'Address);
         if ORGNRM = ZERO then
            goto L70;
         end if;
         --
         EPS := DLAMCH ('E');
         --
         START := 1;
         --
         --        while ( START <= N )
         --
         <<L30>> null;
         if START <= N then
            --
            --           Let FINISH be the position of the next subdiagonal entry
            --           such that E( FINISH ) <= TINY or FINISH = N if no such
            --           subdiagonal exists.  The matrix identified by the elements
            --           between START and FINISH constitutes an independent
            --           sub-problem.
            --
            FINISH := START;
            <<L40>> null;
            if FINISH < N then
               TINY := EPS * Sqrt (abs (D (FINISH))) * Sqrt (abs (D (FINISH + 1)));
               if abs (E (FINISH)) > TINY then
                  FINISH := FINISH + 1;
                  goto L40;
               end if;
            end if;
            --
            --           (Sub) Problem determined.  Compute its size and solve it.
            --
            M := FINISH - START + 1;
            if M > SMLSIZ then
               --
               --              Scale.
               --
               ORGNRM := DLANST ('M', M, D (START)'Address, E (START)'Address);
               DLASCL ('G', 0, 0, ORGNRM, ONE, M, 1, D (START)'Address, M, INFO);
               DLASCL ('G', 0, 0, ORGNRM, ONE, M - 1, 1, E (START)'Address, M - 1, INFO);
               --
               ZLAED0
                 (N,
                  M,
                  D (START)'Address,
                  E (START)'Address,
                  Z (1, START)'Address,
                  LDZ,
                  WORK'Address,
                  N,
                  RWORK'Address,
                  IWORK'Address,
                  INFO);
               if INFO > 0 then
                  INFO := (INFO / (M + 1) + START - 1) * (N + 1) + "mod" (INFO, (M + 1)) + START - 1;
                  goto L70;
               end if;
               --
               --              Scale back.
               --
               DLASCL ('G', 0, 0, ONE, ORGNRM, M, 1, D (START)'Address, M, INFO);
            --
            else
               DSTEQR ('I', M, D (START)'Address, E (START)'Address, RWORK'Address, M, RWORK (M * M + 1)'Address, INFO);
               ZLACRM (N, M, Z (1, START)'Address, LDZ, RWORK'Address, M, WORK'Address, N, RWORK (M * M + 1)'Address);
               ZLACPY ('A', N, M, WORK'Address, N, Z (1, START)'Address, LDZ);
               if INFO > 0 then
                  INFO := START * (N + 1) + FINISH;
                  goto L70;
               end if;
            end if;
            --
            START := FINISH + 1;
            goto L30;
         end if;
         --
         --        endwhile
         --
         --        If the problem split any number of times, then the eigenvalues
         --        will not be properly ordered.  Here we permute the eigenvalues
         --        (and the associated eigenvectors) into ascending order.
         --
         if M /= N then
            --
            --           Use Selection Sort to minimize swaps of eigenvectors
            --
            II := 2 - 1;
            loop
               II := II + 1;
               exit when II > N;
               I := II - 1;
               K := I;
               P := D (I);
               J := II - 1;
               loop
                  J := J + 1;
                  exit when J > N;
                  if D (J) < P then
                     K := J;
                     P := D (J);
                  end if;
               end loop;
               if K /= I then
                  D (K) := D (I);
                  D (I) := P;
                  ZSWAP (N, Z (1, I)'Address, 1, Z (1, K)'Address, 1);
               end if;
            end loop;
         end if;
      end if;
      --
      <<L70>> null;
      WORK (1)  := Complex'(Real (LWMIN), 0.0);
      RWORK (1) := Real (LRWMIN);
      IWORK (1) := LIWMIN;
      --
      return;
      --
      --     End of ZSTEDC
      --
   end ZSTEDC;

   procedure ZSTEQR
     (COMPZ    : Character;
      N        : Integer;
      D_adr    : Address;
      E_adr    : Address;
      Z_adr    : Address;
      LDZ      : Integer;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      D    : Ftn_Real_Vector (1 .. N);
      E    : Ftn_Real_Vector (1 .. N - 1);
      Z    : Ftn_Complex_Matrix (1 .. LDZ, 1 .. N);
      WORK : Ftn_Real_Vector (1 .. max (1, 2 * N - 2));

      for D'Address use D_adr;
      for E'Address use E_adr;
      for Z'Address use Z_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, D);
      pragma Import (Ada, E);
      pragma Import (Ada, Z);
      pragma Import (Ada, WORK);

      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      TWO    : constant Real    := 2.0e0;
      THREE  : constant Real    := 3.0e0;
      CZERO  : constant Complex := (0.0, 0.0);
      CONE   : constant Complex := (1.0, 0.0);
      MAXIT  : constant Integer := 30;
      I      : Integer;
      ICOMPZ : Integer;
      II     : Integer;
      ISCALE : Integer;
      J      : Integer;
      JTOT   : Integer;
      K      : Integer;
      L      : Integer;
      L1     : Integer;
      LEND   : Integer;
      LENDM1 : Integer;
      LENDP1 : Integer;
      LENDSV : Integer;
      LM1    : Integer;
      LSV    : Integer;
      M      : Integer;
      MM     : Integer;
      MM1    : Integer;
      NM1    : Integer;
      NMAXIT : Integer;
      ANORM  : Real;
      B      : Real;
      C      : Real;
      EPS    : Real;
      EPS2   : Real;
      F      : Real;
      G      : Real;
      P      : Real;
      R      : Real;
      RT1    : Real;
      RT2    : Real;
      S      : Real;
      SAFMAX : Real;
      SAFMIN : Real;
      SSFMAX : Real;
      SSFMIN : Real;
      TST    : Real;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSTEQR( COMPZ, N, D, E, Z, LDZ, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          COMPZ
   --       INTEGER            INFO, LDZ, N
   --       ..
   --       .. Array Arguments ..
   --       DOUBLE PRECISION   D( * ), E( * ), WORK( * )
   --       COMPLEX*16         Z( LDZ, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSTEQR computes all eigenvalues and, optionally, eigenvectors of a
   --  symmetric tridiagonal matrix using the implicit QL or QR method.
   --  The eigenvectors of a full or band complex Hermitian matrix can also
   --  be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
   --  matrix to tridiagonal form.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] COMPZ
   --           COMPZ is CHARACTER*1
   --           = 'N':  Compute eigenvalues only.
   --           = 'V':  Compute eigenvalues and eigenvectors of the original
   --                   Hermitian matrix.  On entry, Z must contain the
   --                   unitary matrix used to reduce the original matrix
   --                   to tridiagonal form.
   --           = 'I':  Compute eigenvalues and eigenvectors of the
   --                   tridiagonal matrix.  Z is initialized to the identity
   --                   matrix.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix.  N >= 0.
   --
   --  [in,out] D
   --           D is DOUBLE PRECISION array, dimension (N)
   --           On entry, the diagonal elements of the tridiagonal matrix.
   --           On exit, if INFO = 0, the eigenvalues in ascending order.
   --
   --  [in,out] E
   --           E is DOUBLE PRECISION array, dimension (N-1)
   --           On entry, the (n-1) subdiagonal elements of the tridiagonal
   --           matrix.
   --           On exit, E has been destroyed.
   --
   --  [in,out] Z
   --           Z is COMPLEX*16 array, dimension (LDZ, N)
   --           On entry, if  COMPZ = 'V', then Z contains the unitary
   --           matrix used in the reduction to tridiagonal form.
   --           On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
   --           orthonormal eigenvectors of the original Hermitian matrix,
   --           and if COMPZ = 'I', Z contains the orthonormal eigenvectors
   --           of the symmetric tridiagonal matrix.
   --           If COMPZ = 'N', then Z is not referenced.
   --
   --  [in] LDZ
   --           LDZ is INTEGER
   --           The leading dimension of the array Z.  LDZ >= 1, and if
   --           eigenvectors are desired, then  LDZ >= max(1,N).
   --
   --  [out] WORK
   --           WORK is DOUBLE PRECISION array, dimension (max(1,2*N-2))
   --           If COMPZ = 'N', then WORK is not referenced.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  the algorithm has failed to find all the eigenvalues in
   --                 a total of 30*N iterations; if INFO = i, then i
   --                 elements of E have not converged to zero; on exit, D
   --                 and E contain the elements of a symmetric tridiagonal
   --                 matrix which is unitarily similar to the original
   --                 matrix.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0, THREE = 3.0D0 )
   --      PARAMETER          ( CZERO = ( 0.0D0, 0.0D0 ), CONE = ( 1.0D0, 0.0D0 ) )
   --      PARAMETER          ( MAXIT = 30 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, DLAMCH, DLANST, DLAPY2
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           DLAE2, DLAEV2, DLARTG, DLASCL, DLASRT, XERBLA, ZLASET, ZLASR, ZSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, MAX, SIGN, SQRT
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      --
      if LSAME (COMPZ, 'N') then
         ICOMPZ := 0;
      elsif LSAME (COMPZ, 'V') then
         ICOMPZ := 1;
      elsif LSAME (COMPZ, 'I') then
         ICOMPZ := 2;
      else
         ICOMPZ := -1;
      end if;
      if ICOMPZ < 0 then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif (LDZ < 1) or (ICOMPZ > 0 and LDZ < max (1, N)) then
         INFO := -6;
      end if;
      if INFO /= 0 then
         XERBLA ("ZSTEQR", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      if N = 1 then
         if ICOMPZ = 2 then
            Z (1, 1) := CONE;
         end if;
         return;
      end if;
      --
      --     Determine the unit roundoff and over/underflow thresholds.
      --
      EPS    := DLAMCH ('E');
      EPS2   := EPS ** 2;
      SAFMIN := DLAMCH ('S');
      SAFMAX := ONE / SAFMIN;
      SSFMAX := Sqrt (SAFMAX) / THREE;
      SSFMIN := Sqrt (SAFMIN) / EPS2;
      --
      --     Compute the eigenvalues and eigenvectors of the tridiagonal
      --     matrix.
      --
      if ICOMPZ = 2 then
         ZLASET ('F', N, N, CZERO, CONE, Z'Address, LDZ);
      end if;
      --
      NMAXIT := N * MAXIT;
      JTOT   := 0;
      --
      --     Determine where the matrix splits and choose QL or QR iteration
      --     for each block, according to whether top or bottom diagonal
      --     element is smaller.
      --
      L1  := 1;
      NM1 := N - 1;
      --
      <<L10>> null;
      if L1 > N then
         goto L160;
      end if;
      if L1 > 1 then
         E (L1 - 1) := ZERO;
      end if;
      if L1 <= NM1 then
         M := L1 - 1;
         loop
            M := M + 1;
            exit when M > NM1;
            TST := abs (E (M));
            if TST = ZERO then
               goto L30;
            end if;
            if TST <= (Sqrt (abs (D (M))) * Sqrt (abs (D (M + 1)))) * EPS then
               E (M) := ZERO;
               goto L30;
            end if;
         end loop;
      end if;
      M := N;
      --
      <<L30>> null;
      L      := L1;
      LSV    := L;
      LEND   := M;
      LENDSV := LEND;
      L1     := M + 1;
      if LEND = L then
         goto L10;
      end if;
      --
      --     Scale submatrix in rows and columns L to LEND
      --
      ANORM  := DLANST ('I', LEND - L + 1, D (L)'Address, E (L)'Address);
      ISCALE := 0;
      if ANORM = ZERO then
         goto L10;
      end if;
      if ANORM > SSFMAX then
         ISCALE := 1;
         DLASCL ('G', 0, 0, ANORM, SSFMAX, LEND - L + 1, 1, D (L)'Address, N, INFO);
         DLASCL ('G', 0, 0, ANORM, SSFMAX, LEND - L, 1, E (L)'Address, N, INFO);
      elsif ANORM < SSFMIN then
         ISCALE := 2;
         DLASCL ('G', 0, 0, ANORM, SSFMIN, LEND - L + 1, 1, D (L)'Address, N, INFO);
         DLASCL ('G', 0, 0, ANORM, SSFMIN, LEND - L, 1, E (L)'Address, N, INFO);
      end if;
      --
      --     Choose between QL and QR iteration
      --
      if abs (D (LEND)) < abs (D (L)) then
         LEND := LSV;
         L    := LENDSV;
      end if;
      --
      if LEND > L then
         --
         --        QL Iteration
         --
         --        Look for small subdiagonal element.
         --
         <<L40>> null;
         if L /= LEND then
            LENDM1 := LEND - 1;
            M      := L - 1;
            loop
               M := M + 1;
               exit when M > LENDM1;
               TST := abs (E (M)) * abs (E (M));
               if TST <= (EPS2 * abs (D (M))) * abs (D (M + 1)) + SAFMIN then
                  goto L60;
               end if;
            end loop;
         end if;
         --
         M := LEND;
         --
         <<L60>> null;
         if M < LEND then
            E (M) := ZERO;
         end if;
         P := D (L);
         if M = L then
            goto L80;
         end if;
         --
         --        If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
         --        to compute its eigensystem.
         --
         if M = L + 1 then
            if ICOMPZ > 0 then
               DLAEV2 (D (L), E (L), D (L + 1), RT1, RT2, C, S);
               WORK (L)         := C;
               WORK (N - 1 + L) := S;
               ZLASR ('R', 'V', 'B', N, 2, WORK (L)'Address, WORK (N - 1 + L)'Address, Z (1, L)'Address, LDZ);
            else
               DLAE2 (D (L), E (L), D (L + 1), RT1, RT2);
            end if;
            D (L)     := RT1;
            D (L + 1) := RT2;
            E (L)     := ZERO;
            L         := L + 2;
            if L <= LEND then
               goto L40;
            end if;
            goto L140;
         end if;
         --
         if JTOT = NMAXIT then
            goto L140;
         end if;
         JTOT := JTOT + 1;
         --
         --        Form shift.
         --
         G := (D (L + 1) - P) / (TWO * E (L));
         R := DLAPY2 (G, ONE);
         G := D (M) - P + (E (L) / (G + sign (R, G)));
         --
         S := ONE;
         C := ONE;
         P := ZERO;
         --
         --        Inner loop
         --
         MM1 := M - 1;
         I   := MM1 + 1;
         loop
            I := I - 1;
            exit when I < L;
            F := S * E (I);
            B := C * E (I);
            DLARTG (G, F, C, S, R);
            if I /= M - 1 then
               E (I + 1) := R;
            end if;
            G         := D (I + 1) - P;
            R         := (D (I) - G) * S + TWO * C * B;
            P         := S * R;
            D (I + 1) := G + P;
            G         := C * R - B;
            --
            --           If eigenvectors are desired, then save rotations.
            --
            if ICOMPZ > 0 then
               WORK (I)         := C;
               WORK (N - 1 + I) := -S;
            end if;
            --
         end loop;
         --
         --        If eigenvectors are desired, then apply saved rotations.
         --
         if ICOMPZ > 0 then
            MM := M - L + 1;
            ZLASR ('R', 'V', 'B', N, MM, WORK (L)'Address, WORK (N - 1 + L)'Address, Z (1, L)'Address, LDZ);
         end if;
         --
         D (L) := D (L) - P;
         E (L) := G;
         goto L40;
         --
         --        Eigenvalue found.
         --
         <<L80>> null;
         D (L) := P;
         --
         L := L + 1;
         if L <= LEND then
            goto L40;
         end if;
         goto L140;
      --
      else
         --
         --        QR Iteration
         --
         --        Look for small superdiagonal element.
         --
         <<L90>> null;
         if L /= LEND then
            LENDP1 := LEND + 1;
            M      := L + 1;
            loop
               M := M - 1;
               exit when M < LENDP1;
               TST := abs (E (M - 1)) * abs (E (M - 1));
               if TST <= (EPS2 * abs (D (M))) * abs (D (M - 1)) + SAFMIN then
                  goto L110;
               end if;
            end loop;
         end if;
         --
         M := LEND;
         --
         <<L110>> null;
         if M > LEND then
            E (M - 1) := ZERO;
         end if;
         P := D (L);
         if M = L then
            goto L130;
         end if;
         --
         --        If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
         --        to compute its eigensystem.
         --
         if M = L - 1 then
            if ICOMPZ > 0 then
               DLAEV2 (D (L - 1), E (L - 1), D (L), RT1, RT2, C, S);
               WORK (M)         := C;
               WORK (N - 1 + M) := S;
               ZLASR ('R', 'V', 'F', N, 2, WORK (M)'Address, WORK (N - 1 + M)'Address, Z (1, L - 1)'Address, LDZ);
            else
               DLAE2 (D (L - 1), E (L - 1), D (L), RT1, RT2);
            end if;
            D (L - 1) := RT1;
            D (L)     := RT2;
            E (L - 1) := ZERO;
            L         := L - 2;
            if L >= LEND then
               goto L90;
            end if;
            goto L140;
         end if;
         --
         if JTOT = NMAXIT then
            goto L140;
         end if;
         JTOT := JTOT + 1;
         --
         --        Form shift.
         --
         G := (D (L - 1) - P) / (TWO * E (L - 1));
         R := DLAPY2 (G, ONE);
         G := D (M) - P + (E (L - 1) / (G + sign (R, G)));
         --
         S := ONE;
         C := ONE;
         P := ZERO;
         --
         --        Inner loop
         --
         LM1 := L - 1;
         I   := M - 1;
         loop
            I := I + 1;
            exit when I > LM1;
            F := S * E (I);
            B := C * E (I);
            DLARTG (G, F, C, S, R);
            if I /= M then
               E (I - 1) := R;
            end if;
            G     := D (I) - P;
            R     := (D (I + 1) - G) * S + TWO * C * B;
            P     := S * R;
            D (I) := G + P;
            G     := C * R - B;
            --
            --           If eigenvectors are desired, then save rotations.
            --
            if ICOMPZ > 0 then
               WORK (I)         := C;
               WORK (N - 1 + I) := S;
            end if;
            --
         end loop;
         --
         --        If eigenvectors are desired, then apply saved rotations.
         --
         if ICOMPZ > 0 then
            MM := L - M + 1;
            ZLASR ('R', 'V', 'F', N, MM, WORK (M)'Address, WORK (N - 1 + M)'Address, Z (1, M)'Address, LDZ);
         end if;
         --
         D (L)   := D (L) - P;
         E (LM1) := G;
         goto L90;
         --
         --        Eigenvalue found.
         --
         <<L130>> null;
         D (L) := P;
         --
         L := L - 1;
         if L >= LEND then
            goto L90;
         end if;
         goto L140;
         --
      end if;
      --
      --     Undo scaling if necessary
      --
      <<L140>> null;
      if ISCALE = 1 then
         DLASCL ('G', 0, 0, SSFMAX, ANORM, LENDSV - LSV + 1, 1, D (LSV)'Address, N, INFO);
         DLASCL ('G', 0, 0, SSFMAX, ANORM, LENDSV - LSV, 1, E (LSV)'Address, N, INFO);
      elsif ISCALE = 2 then
         DLASCL ('G', 0, 0, SSFMIN, ANORM, LENDSV - LSV + 1, 1, D (LSV)'Address, N, INFO);
         DLASCL ('G', 0, 0, SSFMIN, ANORM, LENDSV - LSV, 1, E (LSV)'Address, N, INFO);
      end if;
      --
      --     Check for no convergence to an eigenvalue after a total
      --     of N*MAXIT iterations.
      --
      if JTOT = NMAXIT then
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            if E (I) /= ZERO then
               INFO := INFO + 1;
            end if;
         end loop;
         return;
      end if;
      goto L10;
      --
      --     Order eigenvalues and eigenvectors.
      --
      <<L160>> null;
      if ICOMPZ = 0 then
         --
         --        Use Quick Sort
         --
         DLASRT ('I', N, D, INFO);
      --
      else
         --
         --        Use Selection Sort to minimize swaps of eigenvectors
         --
         II := 2 - 1;
         loop
            II := II + 1;
            exit when II > N;
            I := II - 1;
            K := I;
            P := D (I);
            J := II - 1;
            loop
               J := J + 1;
               exit when J > N;
               if D (J) < P then
                  K := J;
                  P := D (J);
               end if;
            end loop;
            if K /= I then
               D (K) := D (I);
               D (I) := P;
               ZSWAP (N, Z (1, I)'Address, 1, Z (1, K)'Address, 1);
            end if;
         end loop;
      end if;
      return;
      --
      --     End of ZSTEQR
      --
   end ZSTEQR;

   procedure ZSYCONV
     (UPLO : Character;
      WAY  : Character;
      N    : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer;
      IPIV : Ftn_Integer_Vector;
      WORK : in out Ftn_Complex_Vector;
      INFO : in out Integer)
   is
      ZERO    : constant Complex := (0.0, 0.0);
      UPPER   : Boolean;
      CONVERT : Boolean;
      I       : Integer;
      IP      : Integer;
      J       : Integer;
      TEMP    : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSYCONV( UPLO, WAY, N, A, LDA, IPIV, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO, WAY
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       COMPLEX*16         A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSYCONV converts A given by ZHETRF into L and D or vice-versa.
   --  Get nondiagonal elements of D (returned in workspace) and
   --  apply or reverse permutation done in TRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the details of the factorization are stored
   --           as an upper or lower triangular matrix.
   --           = 'U':  Upper triangular, form is A = U*D*U**T;
   --           = 'L':  Lower triangular, form is A = L*D*L**T.
   --
   --  [in] WAY
   --           WAY is CHARACTER*1
   --           = 'C': Convert
   --           = 'R': Revert
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The block diagonal matrix D and the multipliers used to
   --           obtain the factor U or L as computed by ZSYTRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D
   --           as determined by ZSYTRF.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = (0.0D+0,0.0D+0) )
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA
   --     .. Local Scalars ..
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO    := 0;
      UPPER   := LSAME (UPLO, 'U');
      CONVERT := LSAME (WAY, 'C');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif not CONVERT and not LSAME (WAY, 'R') then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("ZSYCONV", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      if UPPER then
         --
         --        A is UPPER
         --
         if CONVERT then
            --
            --           Convert A (A is upper)
            --
            --           Convert VALUE
            --
            I        := N;
            WORK (1) := ZERO;
            while I > 1 loop
               if IPIV (I) < 0 then
                  WORK (I)     := A (I - 1, I);
                  A (I - 1, I) := ZERO;
                  I            := I - 1;
               else
                  WORK (I) := ZERO;
               end if;
               I := I - 1;
            end loop;
            --
            --           Convert PERMUTATIONS
            --
            I := N;
            while I >= 1 loop
               if IPIV (I) > 0 then
                  IP := IPIV (I);
                  if I < N then
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > N;
                        TEMP      := A (IP, J);
                        A (IP, J) := A (I, J);
                        A (I, J)  := TEMP;
                     end loop;
                  end if;
               else
                  IP := -IPIV (I);
                  if I < N then
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > N;
                        TEMP         := A (IP, J);
                        A (IP, J)    := A (I - 1, J);
                        A (I - 1, J) := TEMP;
                     end loop;
                  end if;
                  I := I - 1;
               end if;
               I := I - 1;
            end loop;
         --
         else
            --
            --           Revert A (A is upper)
            --
            --           Revert PERMUTATIONS
            --
            I := 1;
            while I <= N loop
               if IPIV (I) > 0 then
                  IP := IPIV (I);
                  if I < N then
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > N;
                        TEMP      := A (IP, J);
                        A (IP, J) := A (I, J);
                        A (I, J)  := TEMP;
                     end loop;
                  end if;
               else
                  IP := -IPIV (I);
                  I  := I + 1;
                  if I < N then
                     J := I + 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > N;
                        TEMP         := A (IP, J);
                        A (IP, J)    := A (I - 1, J);
                        A (I - 1, J) := TEMP;
                     end loop;
                  end if;
               end if;
               I := I + 1;
            end loop;
            --
            --           Revert VALUE
            --
            I := N;
            while I > 1 loop
               if IPIV (I) < 0 then
                  A (I - 1, I) := WORK (I);
                  I            := I - 1;
               end if;
               I := I - 1;
            end loop;
         end if;
      --
      else
         --
         --        A is LOWER
         --
         if CONVERT then
            --
            --           Convert A (A is lower)
            --
            --           Convert VALUE
            --
            I        := 1;
            WORK (N) := ZERO;
            while I <= N loop
               if I < N and IPIV (I) < 0 then
                  WORK (I)     := A (I + 1, I);
                  A (I + 1, I) := ZERO;
                  I            := I + 1;
               else
                  WORK (I) := ZERO;
               end if;
               I := I + 1;
            end loop;
            --
            --           Convert PERMUTATIONS
            --
            I := 1;
            while I <= N loop
               if IPIV (I) > 0 then
                  IP := IPIV (I);
                  if I > 1 then
                     J := 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > I - 1;
                        TEMP      := A (IP, J);
                        A (IP, J) := A (I, J);
                        A (I, J)  := TEMP;
                     end loop;
                  end if;
               else
                  IP := -IPIV (I);
                  if I > 1 then
                     J := 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > I - 1;
                        TEMP         := A (IP, J);
                        A (IP, J)    := A (I + 1, J);
                        A (I + 1, J) := TEMP;
                     end loop;
                  end if;
                  I := I + 1;
               end if;
               I := I + 1;
            end loop;
         --
         else
            --
            --           Revert A (A is lower)
            --
            --           Revert PERMUTATIONS
            --
            I := N;
            while I >= 1 loop
               if IPIV (I) > 0 then
                  IP := IPIV (I);
                  if I > 1 then
                     J := 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > I - 1;
                        TEMP      := A (I, J);
                        A (I, J)  := A (IP, J);
                        A (IP, J) := TEMP;
                     end loop;
                  end if;
               else
                  IP := -IPIV (I);
                  I  := I - 1;
                  if I > 1 then
                     J := 1 - 1;
                     loop
                        J := J + 1;
                        exit when J > I - 1;
                        TEMP         := A (I + 1, J);
                        A (I + 1, J) := A (IP, J);
                        A (IP, J)    := TEMP;
                     end loop;
                  end if;
               end if;
               I := I - 1;
            end loop;
            --
            --           Revert VALUE
            --
            I := 1;
            while I <= N - 1 loop
               if IPIV (I) < 0 then
                  A (I + 1, I) := WORK (I);
                  I            := I + 1;
               end if;
               I := I + 1;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZSYCONV
      --
   end ZSYCONV;

   procedure ZSYR
     (UPLO  : Character;
      N     : Integer;
      ALPHA : Complex;
      X_adr : Address;
      INCX  : Integer;
      A_adr : Address;
      LDA   : Integer)
   is

      X : Ftn_Complex_Vector (1 .. 1 + (N - 1) * abs (INCX));
      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);

      for X'Address use X_adr;
      for A'Address use A_adr;

      pragma Import (Ada, X);
      pragma Import (Ada, A);

      ZERO : constant Complex := (0.0, 0.0);
      I    : Integer;
      INFO : Integer;
      IX   : Integer;
      J    : Integer;
      JX   : Integer;
      KX   : Integer;
      TEMP : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSYR( UPLO, N, ALPHA, X, INCX, A, LDA )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INCX, LDA, N
   --       COMPLEX*16         ALPHA
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), X( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSYR   performs the symmetric rank 1 operation
   --
   --     A := alpha*x*x**H + A,
   --
   --  where alpha is a complex scalar, x is an n element vector and A is an
   --  n by n symmetric matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --            On entry, UPLO specifies whether the upper or lower
   --            triangular part of the array A is to be referenced as
   --            follows:
   --
   --               UPLO = 'U' or 'u'   Only the upper triangular part of A
   --                                   is to be referenced.
   --
   --               UPLO = 'L' or 'l'   Only the lower triangular part of A
   --                                   is to be referenced.
   --
   --            Unchanged on exit.
   --
   --  [in] N
   --           N is INTEGER
   --            On entry, N specifies the order of the matrix A.
   --            N must be at least zero.
   --            Unchanged on exit.
   --
   --  [in] ALPHA
   --           ALPHA is COMPLEX*16
   --            On entry, ALPHA specifies the scalar alpha.
   --            Unchanged on exit.
   --
   --  [in] X
   --           X is COMPLEX*16 array, dimension at least
   --            ( 1 + ( N - 1 )*abs( INCX ) ).
   --            Before entry, the incremented array X must contain the N-
   --            element vector x.
   --            Unchanged on exit.
   --
   --  [in] INCX
   --           INCX is INTEGER
   --            On entry, INCX specifies the increment for the elements of
   --            X. INCX must not be zero.
   --            Unchanged on exit.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension ( LDA, N )
   --            Before entry, with  UPLO = 'U' or 'u', the leading n by n
   --            upper triangular part of the array A must contain the upper
   --            triangular part of the symmetric matrix and the strictly
   --            lower triangular part of A is not referenced. On exit, the
   --            upper triangular part of the array A is overwritten by the
   --            upper triangular part of the updated matrix.
   --            Before entry, with UPLO = 'L' or 'l', the leading n by n
   --            lower triangular part of the array A must contain the lower
   --            triangular part of the symmetric matrix and the strictly
   --            upper triangular part of A is not referenced. On exit, the
   --            lower triangular part of the array A is overwritten by the
   --            lower triangular part of the updated matrix.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --            On entry, LDA specifies the first dimension of A as declared
   --            in the calling (sub) program. LDA must be at least
   --            max( 1, N ).
   --            Unchanged on exit.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK auxiliary routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   -- =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO := 0;
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := 1;
      elsif N < 0 then
         INFO := 2;
      elsif INCX = 0 then
         INFO := 5;
      elsif LDA < max (1, N) then
         INFO := 7;
      end if;
      if INFO /= 0 then
         XERBLA ("ZSYR  ", INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if (N = 0) or (ALPHA = ZERO) then
         return;
      end if;
      --
      --     Set the start point in X if the increment is not unity.
      --
      if INCX <= 0 then
         KX := 1 - (N - 1) * INCX;
      elsif INCX /= 1 then
         KX := 1;
      end if;
      --
      --     Start the operations. In this version the elements of A are
      --     accessed sequentially with one pass through the triangular part
      --     of A.
      --
      if LSAME (UPLO, 'U') then
         --
         --        Form  A  when A is stored in upper triangle.
         --
         if INCX = 1 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (J) /= ZERO then
                  TEMP := ALPHA * X (J);
                  I    := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     A (I, J) := A (I, J) + X (I) * TEMP;
                  end loop;
               end if;
            end loop;
         else
            JX := KX;
            J  := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (JX) /= ZERO then
                  TEMP := ALPHA * X (JX);
                  IX   := KX;
                  I    := 1 - 1;
                  loop
                     I := I + 1;
                     exit when I > J;
                     A (I, J) := A (I, J) + X (IX) * TEMP;
                     IX       := IX + INCX;
                  end loop;
               end if;
               JX := JX + INCX;
            end loop;
         end if;
      else
         --
         --        Form  A  when A is stored in lower triangle.
         --
         if INCX = 1 then
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (J) /= ZERO then
                  TEMP := ALPHA * X (J);
                  I    := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     A (I, J) := A (I, J) + X (I) * TEMP;
                  end loop;
               end if;
            end loop;
         else
            JX := KX;
            J  := 1 - 1;
            loop
               J := J + 1;
               exit when J > N;
               if X (JX) /= ZERO then
                  TEMP := ALPHA * X (JX);
                  IX   := JX;
                  I    := J - 1;
                  loop
                     I := I + 1;
                     exit when I > N;
                     A (I, J) := A (I, J) + X (IX) * TEMP;
                     IX       := IX + INCX;
                  end loop;
               end if;
               JX := JX + INCX;
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZSYR
      --
   end ZSYR;

   procedure ZSYSV
     (UPLO  : Character;
      N     : Integer;
      NRHS  : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      IPIV  : out Ftn_Integer_Vector;
      B     : in out Ftn_Complex_Matrix;
      LDB   : Integer;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      LQUERY : Boolean;
      LWKOPT : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,
   --                         LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LDB, LWORK, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSYSV computes the solution to a complex system of linear equations
   --     A * X = B,
   --  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
   --  matrices.
   --
   --  The diagonal pivoting method is used to factor A as
   --     A = U * D * U**T,  if UPLO = 'U', or
   --     A = L * D * L**T,  if UPLO = 'L',
   --  where U (or L) is a product of permutation and unit upper (lower)
   --  triangular matrices, and D is symmetric and block diagonal with
   --  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
   --  used to solve the system of equations A * X = B.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of linear equations, i.e., the order of the
   --           matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           N-by-N upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading N-by-N lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --
   --           On exit, if INFO = 0, the block diagonal matrix D and the
   --           multipliers used to obtain the factor U or L from the
   --           factorization A = U*D*U**T or A = L*D*L**T as computed by
   --           ZSYTRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D, as
   --           determined by ZSYTRF.  If IPIV(k) > 0, then rows and columns
   --           k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
   --           diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0,
   --           then rows and columns k-1 and -IPIV(k) were interchanged and
   --           D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
   --           IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and
   --           -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
   --           diagonal block.
   --
   --  [in,out] B
   --           B is COMPLEX*16 array, dimension (LDB,NRHS)
   --           On entry, the N-by-NRHS right hand side matrix B.
   --           On exit, if INFO = 0, the N-by-NRHS solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of WORK.  LWORK >= 1, and for best performance
   --           LWORK >= max(1,N*NB), where NB is the optimal blocksize for
   --           ZSYTRF.
   --           for LWORK < N, TRS will be done with Level BLAS 2
   --           for LWORK >= N, TRS will be done with Level BLAS 3
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --           > 0: if INFO = i, D(i,i) is exactly zero.  The factorization
   --                has been completed, but the block diagonal matrix D is
   --                exactly singular, so the solution could not be computed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK driver routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZSYTRF, ZSYTRS, ZSYTRS2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1);
      if not LSAME (UPLO, 'U') and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NRHS < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDB < max (1, N) then
         INFO := -8;
      elsif LWORK < 1 and not LQUERY then
         INFO := -10;
      end if;
      --
      if INFO = 0 then
         if N = 0 then
            LWKOPT := 1;
         else
            ZSYTRF (UPLO, N, A, LDA, IPIV, WORK, -1, INFO);
            LWKOPT := Integer (real_part (WORK (1)));
         end if;
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZSYSV ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Compute the factorization A = U*D*U**T or A = L*D*L**T.
      --
      ZSYTRF (UPLO, N, A, LDA, IPIV, WORK, LWORK, INFO);
      if INFO = 0 then
         --
         --        Solve the system A*X = B, overwriting B with X.
         --
         if LWORK < N then
            --
            --        Solve with TRS ( Use Level BLAS 2)
            --
            ZSYTRS (UPLO, N, NRHS, A, LDA, IPIV, B, LDB, INFO);
         --
         else
            --
            --        Solve with TRS2 ( Use Level BLAS 3)
            --
            ZSYTRS2 (UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK, INFO);
            --
         end if;
         --
      end if;
      --
      WORK (1) := Complex'(Real (LWKOPT), 0.0);
      --
      return;
      --
      --     End of ZSYSV
      --
   end ZSYSV;

   procedure ZSYTF2
     (UPLO     : Character;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      IPIV_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      IPIV : Ftn_Integer_Vector (1 .. N);

      for A'Address use A_adr;
      for IPIV'Address use IPIV_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, IPIV);

      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      EIGHT  : constant Real    := 8.0e0;
      SEVTEN : constant Real    := 17.0e0;
      CONE   : constant Complex := (1.0, 0.0);
      UPPER  : Boolean;
      I      : Integer;
      IMAX   : Integer;
      J      : Integer;
      JMAX   : Integer;
      K      : Integer;
      KK     : Integer;
      KP     : Integer;
      KSTEP  : Integer;
      ABSAKK : Real;
      ALPHA  : Real;
      COLMAX : Real;
      ROWMAX : Real;
      D11    : Complex;
      D12    : Complex;
      D21    : Complex;
      D22    : Complex;
      R1     : Complex;
      T      : Complex;
      WK     : Complex;
      WKM1   : Complex;
      WKP1   : Complex;
      Z      : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSYTF2( UPLO, N, A, LDA, IPIV, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       COMPLEX*16         A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSYTF2 computes the factorization of a complex symmetric matrix A
   --  using the Bunch-Kaufman diagonal pivoting method:
   --
   --     A = U*D*U**T  or  A = L*D*L**T
   --
   --  where U (or L) is a product of permutation and unit upper (lower)
   --  triangular matrices, U**T is the transpose of U, and D is symmetric and
   --  block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
   --
   --  This is the unblocked version of the algorithm, calling Level 2 BLAS.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the upper or lower triangular part of the
   --           symmetric matrix A is stored:
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           n-by-n upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n-by-n lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --
   --           On exit, the block diagonal matrix D and the multipliers used
   --           to obtain the factor U or L (see below for further details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D.
   --           If IPIV(k) > 0, then rows and columns k and IPIV(k) were
   --           interchanged and D(k,k) is a 1-by-1 diagonal block.
   --           If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
   --           columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
   --           is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
   --           IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
   --           interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -k, the k-th argument had an illegal value
   --           > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
   --                has been completed, but the block diagonal matrix D is
   --                exactly singular, and division by zero will occur if it
   --                is used to solve a system of equations.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', then A = U*D*U**T, where
   --      U = P(n)*U(n)* ... *P(k)U(k)* ...,
   --   i.e., U is a product of terms P(k)*U(k), where k decreases from n to
   --   1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
   --   and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
   --   defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
   --   that if the diagonal block D(k) is of order s (s = 1 or 2), then
   --
   --              (   I    v    0   )   k-s
   --      U(k) =  (   0    I    0   )   s
   --              (   0    0    I   )   n-k
   --                 k-s   s   n-k
   --
   --   If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
   --   If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
   --   and A(k,k), and v overwrites A(1:k-2,k-1:k).
   --
   --   If UPLO = 'L', then A = L*D*L**T, where
   --      L = P(1)*L(1)* ... *P(k)*L(k)* ...,
   --   i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
   --   n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
   --   and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
   --   defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
   --   that if the diagonal block D(k) is of order s (s = 1 or 2), then
   --
   --              (   I    0     0   )  k-1
   --      L(k) =  (   0    I     0   )  s
   --              (   0    v     I   )  n-k-s+1
   --                 k-1   s  n-k-s+1
   --
   --   If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
   --   If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
   --   and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
   --
   --  Contributors:
   --  ==================
   --
   --
   --   09-29-06 - patch from
   --     Bobby Cheng, MathWorks
   --
   --     Replace l.209 and l.377
   --          IF( MAX( ABSAKK, COLMAX ).EQ.ZERO ) THEN
   --     by
   --          IF( (MAX( ABSAKK, COLMAX ).EQ.ZERO) .OR. DISNAN(ABSAKK) ) THEN
   --
   --   1-96 - Based on modifications by J. Lewis, Boeing Computer Services
   --          Company
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( EIGHT = 8.0D+0, SEVTEN = 17.0D+0 )
   --      PARAMETER          ( CONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           DISNAN, LSAME, IZAMAX
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZSCAL, ZSWAP, ZSYR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DIMAG, MAX, SQRT
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --     ..
      --     .. Executable Statements ..
      --
      --     Test the input parameters.
      --
      INFO  := 0;
      UPPER := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      end if;
      if INFO /= 0 then
         XERBLA ("ZSYTF2", -INFO);
         return;
      end if;
      --
      --     Initialize ALPHA for use in choosing pivot block size.
      --
      ALPHA := (ONE + Sqrt (SEVTEN)) / EIGHT;
      --
      if UPPER then
         --
         --        Factorize A as U*D*U**T using the upper triangle of A
         --
         --        K is the main loop index, decreasing from N to 1 in steps of
         --        1 or 2
         --
         K := N;
         <<L10>> null;
         --
         --        If K < 1, exit from loop
         --
         if K < 1 then
            goto L70;
         end if;
         KSTEP := 1;
         --
         --        Determine rows and columns to be interchanged and whether
         --        a 1-by-1 or 2-by-2 pivot block will be used
         --
         ABSAKK := CABS1 (A (K, K));
         --
         --        IMAX is the row-index of the largest off-diagonal element in
         --        column K, and COLMAX is its absolute value
         --
         if K > 1 then
            IMAX   := IZAMAX (K - 1, A (1, K)'Address, 1);
            COLMAX := CABS1 (A (IMAX, K));
         else
            COLMAX := ZERO;
         end if;
         --
         if max (ABSAKK, COLMAX) = ZERO or DISNAN (ABSAKK) then
            --
            --           Column K is zero or NaN: set INFO and continue
            --
            if INFO = 0 then
               INFO := K;
            end if;
            KP := K;
         else
            if ABSAKK >= ALPHA * COLMAX then
               --
               --              no interchange, use 1-by-1 pivot block
               --
               KP := K;
            else
               --
               --              JMAX is the column-index of the largest off-diagonal
               --              element in row IMAX, and ROWMAX is its absolute value
               --
               JMAX   := IMAX + IZAMAX (K - IMAX, A (IMAX, IMAX + 1)'Address, LDA);
               ROWMAX := CABS1 (A (IMAX, JMAX));
               if IMAX > 1 then
                  JMAX   := IZAMAX (IMAX - 1, A (1, IMAX)'Address, 1);
                  ROWMAX := max (ROWMAX, CABS1 (A (JMAX, IMAX)));
               end if;
               --
               if ABSAKK >= ALPHA * COLMAX * (COLMAX / ROWMAX) then
                  --
                  --                 no interchange, use 1-by-1 pivot block
                  --
                  KP := K;
               elsif CABS1 (A (IMAX, IMAX)) >= ALPHA * ROWMAX then
                  --
                  --                 interchange rows and columns K and IMAX, use 1-by-1
                  --                 pivot block
                  --
                  KP := IMAX;
               else
                  --
                  --                 interchange rows and columns K-1 and IMAX, use 2-by-2
                  --                 pivot block
                  --
                  KP    := IMAX;
                  KSTEP := 2;
               end if;
            end if;
            --
            KK := K - KSTEP + 1;
            if KP /= KK then
               --
               --              Interchange rows and columns KK and KP in the leading
               --              submatrix A(1:k,1:k)
               --
               ZSWAP (KP - 1, A (1, KK)'Address, 1, A (1, KP)'Address, 1);
               ZSWAP (KK - KP - 1, A (KP + 1, KK)'Address, 1, A (KP, KP + 1)'Address, LDA);
               T          := A (KK, KK);
               A (KK, KK) := A (KP, KP);
               A (KP, KP) := T;
               if KSTEP = 2 then
                  T            := A (K - 1, K);
                  A (K - 1, K) := A (KP, K);
                  A (KP, K)    := T;
               end if;
            end if;
            --
            --           Update the leading submatrix
            --
            if KSTEP = 1 then
               --
               --              1-by-1 pivot block D(k): column k now holds
               --
               --              W(k) = U(k)*D(k)
               --
               --              where U(k) is the k-th column of U
               --
               --              Perform a rank-1 update of A(1:k-1,1:k-1) as
               --
               --              A := A - U(k)*D(k)*U(k)**T = A - W(k)*1/D(k)*W(k)**T
               --
               R1 := CONE / A (K, K);
               ZSYR (UPLO, K - 1, -R1, A (1, K)'Address, 1, A'Address, LDA);
               --
               --              Store U(k) in column k
               --
               ZSCAL (K - 1, R1, A (1, K)'Address, 1);
            else
               --
               --              2-by-2 pivot block D(k): columns k and k-1 now hold
               --
               --              ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k)
               --
               --              where U(k) and U(k-1) are the k-th and (k-1)-th columns
               --              of U
               --
               --              Perform a rank-2 update of A(1:k-2,1:k-2) as
               --
               --              A := A - ( U(k-1) U(k) )*D(k)*( U(k-1) U(k) )**T
               --                 = A - ( W(k-1) W(k) )*inv(D(k))*( W(k-1) W(k) )**T
               --
               if K > 2 then
                  --
                  D12 := A (K - 1, K);
                  D22 := A (K - 1, K - 1) / D12;
                  D11 := A (K, K) / D12;
                  T   := CONE / (D11 * D22 - CONE);
                  D12 := T / D12;
                  --
                  J := K - 2 + 1;
                  loop
                     J := J - 1;
                     exit when J < 1;
                     WKM1 := D12 * (D11 * A (J, K - 1) - A (J, K));
                     WK   := D12 * (D22 * A (J, K) - A (J, K - 1));
                     I    := J + 1;
                     loop
                        I := I - 1;
                        exit when I < 1;
                        A (I, J) := A (I, J) - A (I, K) * WK - A (I, K - 1) * WKM1;
                     end loop;
                     A (J, K)     := WK;
                     A (J, K - 1) := WKM1;
                  end loop;
                  --
               end if;
               --
            end if;
         end if;
         --
         --        Store details of the interchanges in IPIV
         --
         if KSTEP = 1 then
            IPIV (K) := KP;
         else
            IPIV (K)     := -KP;
            IPIV (K - 1) := -KP;
         end if;
         --
         --        Decrease K and return to the start of the main loop
         --
         K := K - KSTEP;
         goto L10;
      --
      else
         --
         --        Factorize A as L*D*L**T using the lower triangle of A
         --
         --        K is the main loop index, increasing from 1 to N in steps of
         --        1 or 2
         --
         K := 1;
         <<L40>> null;
         --
         --        If K > N, exit from loop
         --
         if K > N then
            goto L70;
         end if;
         KSTEP := 1;
         --
         --        Determine rows and columns to be interchanged and whether
         --        a 1-by-1 or 2-by-2 pivot block will be used
         --
         ABSAKK := CABS1 (A (K, K));
         --
         --        IMAX is the row-index of the largest off-diagonal element in
         --        column K, and COLMAX is its absolute value
         --
         if K < N then
            IMAX   := K + IZAMAX (N - K, A (K + 1, K)'Address, 1);
            COLMAX := CABS1 (A (IMAX, K));
         else
            COLMAX := ZERO;
         end if;
         --
         if max (ABSAKK, COLMAX) = ZERO or DISNAN (ABSAKK) then
            --
            --           Column K is zero or NaN: set INFO and continue
            --
            if INFO = 0 then
               INFO := K;
            end if;
            KP := K;
         else
            if ABSAKK >= ALPHA * COLMAX then
               --
               --              no interchange, use 1-by-1 pivot block
               --
               KP := K;
            else
               --
               --              JMAX is the column-index of the largest off-diagonal
               --              element in row IMAX, and ROWMAX is its absolute value
               --
               JMAX   := K - 1 + IZAMAX (IMAX - K, A (IMAX, K)'Address, LDA);
               ROWMAX := CABS1 (A (IMAX, JMAX));
               if IMAX < N then
                  JMAX   := IMAX + IZAMAX (N - IMAX, A (IMAX + 1, IMAX)'Address, 1);
                  ROWMAX := max (ROWMAX, CABS1 (A (JMAX, IMAX)));
               end if;
               --
               if ABSAKK >= ALPHA * COLMAX * (COLMAX / ROWMAX) then
                  --
                  --                 no interchange, use 1-by-1 pivot block
                  --
                  KP := K;
               elsif CABS1 (A (IMAX, IMAX)) >= ALPHA * ROWMAX then
                  --
                  --                 interchange rows and columns K and IMAX, use 1-by-1
                  --                 pivot block
                  --
                  KP := IMAX;
               else
                  --
                  --                 interchange rows and columns K+1 and IMAX, use 2-by-2
                  --                 pivot block
                  --
                  KP    := IMAX;
                  KSTEP := 2;
               end if;
            end if;
            --
            KK := K + KSTEP - 1;
            if KP /= KK then
               --
               --              Interchange rows and columns KK and KP in the trailing
               --              submatrix A(k:n,k:n)
               --
               if KP < N then
                  ZSWAP (N - KP, A (KP + 1, KK)'Address, 1, A (KP + 1, KP)'Address, 1);
               end if;
               ZSWAP (KP - KK - 1, A (KK + 1, KK)'Address, 1, A (KP, KK + 1)'Address, LDA);
               T          := A (KK, KK);
               A (KK, KK) := A (KP, KP);
               A (KP, KP) := T;
               if KSTEP = 2 then
                  T            := A (K + 1, K);
                  A (K + 1, K) := A (KP, K);
                  A (KP, K)    := T;
               end if;
            end if;
            --
            --           Update the trailing submatrix
            --
            if KSTEP = 1 then
               --
               --              1-by-1 pivot block D(k): column k now holds
               --
               --              W(k) = L(k)*D(k)
               --
               --              where L(k) is the k-th column of L
               --
               if K < N then
                  --
                  --                 Perform a rank-1 update of A(k+1:n,k+1:n) as
                  --
                  --                 A := A - L(k)*D(k)*L(k)**T = A - W(k)*(1/D(k))*W(k)**T
                  --
                  R1 := CONE / A (K, K);
                  ZSYR (UPLO, N - K, -R1, A (K + 1, K)'Address, 1, A (K + 1, K + 1)'Address, LDA);
                  --
                  --                 Store L(k) in column K
                  --
                  ZSCAL (N - K, R1, A (K + 1, K)'Address, 1);
               end if;
            else
               --
               --              2-by-2 pivot block D(k)
               --
               if K < N - 1 then
                  --
                  --                 Perform a rank-2 update of A(k+2:n,k+2:n) as
                  --
                  --                 A := A - ( L(k) L(k+1) )*D(k)*( L(k) L(k+1) )**T
                  --                    = A - ( W(k) W(k+1) )*inv(D(k))*( W(k) W(k+1) )**T
                  --
                  --                 where L(k) and L(k+1) are the k-th and (k+1)-th
                  --                 columns of L
                  --
                  D21 := A (K + 1, K);
                  D11 := A (K + 1, K + 1) / D21;
                  D22 := A (K, K) / D21;
                  T   := CONE / (D11 * D22 - CONE);
                  D21 := T / D21;
                  --
                  J := K + 2 - 1;
                  loop
                     J := J + 1;
                     exit when J > N;
                     WK   := D21 * (D11 * A (J, K) - A (J, K + 1));
                     WKP1 := D21 * (D22 * A (J, K + 1) - A (J, K));
                     I    := J - 1;
                     loop
                        I := I + 1;
                        exit when I > N;
                        A (I, J) := A (I, J) - A (I, K) * WK - A (I, K + 1) * WKP1;
                     end loop;
                     A (J, K)     := WK;
                     A (J, K + 1) := WKP1;
                  end loop;
               end if;
            end if;
         end if;
         --
         --        Store details of the interchanges in IPIV
         --
         if KSTEP = 1 then
            IPIV (K) := KP;
         else
            IPIV (K)     := -KP;
            IPIV (K + 1) := -KP;
         end if;
         --
         --        Increase K and return to the start of the main loop
         --
         K := K + KSTEP;
         goto L40;
         --
      end if;
      --
      <<L70>> null;
      return;
      --
      --     End of ZSYTF2
      --
   end ZSYTF2;

   procedure ZSYTRF
     (UPLO  : Character;
      N     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      IPIV  : in out Ftn_Integer_Vector;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      LQUERY : Boolean;
      UPPER  : Boolean;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      K      : Integer;
      KB     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSYTRF( UPLO, N, A, LDA, IPIV, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       COMPLEX*16         A( LDA, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSYTRF computes the factorization of a complex symmetric matrix A
   --  using the Bunch-Kaufman diagonal pivoting method.  The form of the
   --  factorization is
   --
   --     A = U*D*U**T  or  A = L*D*L**T
   --
   --  where U (or L) is a product of permutation and unit upper (lower)
   --  triangular matrices, and D is symmetric and block diagonal with
   --  with 1-by-1 and 2-by-2 diagonal blocks.
   --
   --  This is the blocked version of the algorithm, calling Level 3 BLAS.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  Upper triangle of A is stored;
   --           = 'L':  Lower triangle of A is stored.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the symmetric matrix A.  If UPLO = 'U', the leading
   --           N-by-N upper triangular part of A contains the upper
   --           triangular part of the matrix A, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading N-by-N lower triangular part of A contains the lower
   --           triangular part of the matrix A, and the strictly upper
   --           triangular part of A is not referenced.
   --
   --           On exit, the block diagonal matrix D and the multipliers used
   --           to obtain the factor U or L (see below for further details).
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D.
   --           If IPIV(k) > 0, then rows and columns k and IPIV(k) were
   --           interchanged and D(k,k) is a 1-by-1 diagonal block.
   --           If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and
   --           columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
   --           is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
   --           IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were
   --           interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The length of WORK.  LWORK >=1.  For best performance
   --           LWORK >= N*NB, where NB is the block size returned by ILAENV.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --           > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
   --                 has been completed, but the block diagonal matrix D is
   --                 exactly singular, and division by zero will occur if it
   --                 is used to solve a system of equations.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   If UPLO = 'U', then A = U*D*U**T, where
   --      U = P(n)*U(n)* ... *P(k)U(k)* ...,
   --   i.e., U is a product of terms P(k)*U(k), where k decreases from n to
   --   1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
   --   and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
   --   defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
   --   that if the diagonal block D(k) is of order s (s = 1 or 2), then
   --
   --              (   I    v    0   )   k-s
   --      U(k) =  (   0    I    0   )   s
   --              (   0    0    I   )   n-k
   --                 k-s   s   n-k
   --
   --   If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
   --   If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
   --   and A(k,k), and v overwrites A(1:k-2,k-1:k).
   --
   --   If UPLO = 'L', then A = L*D*L**T, where
   --      L = P(1)*L(1)* ... *P(k)*L(k)* ...,
   --   i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
   --   n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
   --   and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
   --   defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
   --   that if the diagonal block D(k) is of order s (s = 1 or 2), then
   --
   --              (   I    0     0   )  k-1
   --      L(k) =  (   0    I     0   )  s
   --              (   0    v     I   )  n-k-s+1
   --                 k-1   s  n-k-s+1
   --
   --   If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
   --   If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
   --   and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLASYF, ZSYTF2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      LQUERY := (LWORK = -1);
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      elsif LWORK < 1 and not LQUERY then
         INFO := -7;
      end if;
      --
      if INFO = 0 then
         --
         --        Determine the block size
         --
         declare
            str_UPLO : String (1 .. 1);
         begin
            str_UPLO (1) := UPLO;
            NB           := ILAENV (1, "ZSYTRF", str_UPLO, N, -1, -1, -1);
         end;
         LWKOPT   := N * NB;
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZSYTRF", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := N;
      if NB > 1 and NB < N then
         IWS := LDWORK * NB;
         if LWORK < IWS then
            NB := max (LWORK / LDWORK, 1);
            declare
               str_UPLO : String (1 .. 1);
            begin
               str_UPLO (1) := UPLO;
               NBMIN        := max (2, ILAENV (2, "ZSYTRF", str_UPLO, N, -1, -1, -1));
            end;
         end if;
      else
         IWS := 1;
      end if;
      if NB < NBMIN then
         NB := N;
      end if;
      --
      if UPPER then
         --
         --        Factorize A as U*D*U**T using the upper triangle of A
         --
         --        K is the main loop index, decreasing from N to 1 in steps of
         --        KB, where KB is the number of columns factorized by ZLASYF;
         --        KB is either NB or NB-1, or K for the last block
         --
         K := N;
         <<L10>> null;
         --
         --        If K < 1, exit from loop
         --
         if K < 1 then
            goto L40;
         end if;
         --
         if K > NB then
            --
            --           Factorize columns k-kb+1:k of A and use blocked code to
            --           update columns 1:k-kb
            --
            ZLASYF (UPLO, K, NB, KB, A'Address, LDA, IPIV'Address, WORK'Address, N, IINFO);
         else
            --
            --           Use unblocked code to factorize columns 1:k of A
            --
            ZSYTF2 (UPLO, K, A'Address, LDA, IPIV'Address, IINFO);
            KB := K;
         end if;
         --
         --        Set INFO on the first occurrence of a zero pivot
         --
         if INFO = 0 and IINFO > 0 then
            INFO := IINFO;
         end if;
         --
         --        Decrease K and return to the start of the main loop
         --
         K := K - KB;
         goto L10;
      --
      else
         --
         --        Factorize A as L*D*L**T using the lower triangle of A
         --
         --        K is the main loop index, increasing from 1 to N in steps of
         --        KB, where KB is the number of columns factorized by ZLASYF;
         --        KB is either NB or NB-1, or N-K+1 for the last block
         --
         K := 1;
         <<L20>> null;
         --
         --        If K > N, exit from loop
         --
         if K > N then
            goto L40;
         end if;
         --
         if K <= N - NB then
            --
            --           Factorize columns k:k+kb-1 of A and use blocked code to
            --           update columns k+kb:n
            --
            ZLASYF (UPLO, N - K + 1, NB, KB, A (K, K)'Address, LDA, IPIV (K)'Address, WORK'Address, N, IINFO);
         else
            --
            --           Use unblocked code to factorize columns k:n of A
            --
            ZSYTF2 (UPLO, N - K + 1, A (K, K)'Address, LDA, IPIV (K)'Address, IINFO);
            KB := N - K + 1;
         end if;
         --
         --        Set INFO on the first occurrence of a zero pivot
         --
         if INFO = 0 and IINFO > 0 then
            INFO := IINFO + K - 1;
         end if;
         --
         --        Adjust IPIV
         --
         J := K - 1;
         loop
            J := J + 1;
            exit when J > K + KB - 1;
            if IPIV (J) > 0 
               then IPIV (J) := IPIV (J) + K - 1;
               else IPIV (J) := IPIV (J) - K + 1;
            end if;
         end loop;
         --
         --        Increase K and return to the start of the main loop
         --
         K := K + KB;
         goto L20;
         --
      end if;
      --
      <<L40>> null;
      WORK (1) := Complex'(Real (LWKOPT), 0.0);
      return;
      --
      --     End of ZSYTRF
      --
   end ZSYTRF;

   procedure ZSYTRS
     (UPLO : Character;
      N    : Integer;
      NRHS : Integer;
      A    : Ftn_Complex_Matrix;
      LDA  : Integer;
      IPIV : Ftn_Integer_Vector;
      B    : in out Ftn_Complex_Matrix;
      LDB  : Integer;
      INFO : in out Integer)
   is
      ONE   : constant Complex := (1.0, 0.0);
      UPPER : Boolean;
      J     : Integer;
      K     : Integer;
      KP    : Integer;
      AK    : Complex;
      AKM1  : Complex;
      AKM1K : Complex;
      BK    : Complex;
      BKM1  : Complex;
      DENOM : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSYTRS( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LDB, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       COMPLEX*16         A( LDA, * ), B( LDB, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSYTRS solves a system of linear equations A*X = B with a complex
   --  symmetric matrix A using the factorization A = U*D*U**T or
   --  A = L*D*L**T computed by ZSYTRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the details of the factorization are stored
   --           as an upper or lower triangular matrix.
   --           = 'U':  Upper triangular, form is A = U*D*U**T;
   --           = 'L':  Lower triangular, form is A = L*D*L**T.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The block diagonal matrix D and the multipliers used to
   --           obtain the factor U or L as computed by ZSYTRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D
   --           as determined by ZSYTRF.
   --
   --  [in,out] B
   --           B is COMPLEX*16 array, dimension (LDB,NRHS)
   --           On entry, the right hand side matrix B.
   --           On exit, the solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZGEMV, ZGERU, ZSCAL, ZSWAP
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO  := 0;
      UPPER := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NRHS < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDB < max (1, N) then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZSYTRS", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 or NRHS = 0 then
         return;
      end if;
      --
      if UPPER then
         --
         --        Solve A*X = B, where A = U*D*U**T.
         --
         --        First solve U*D*X = B, overwriting B with X.
         --
         --        K is the main loop index, decreasing from N to 1 in steps of
         --        1 or 2, depending on the size of the diagonal blocks.
         --
         K := N;
         <<L10>> null;
         --
         --        If K < 1, exit from loop.
         --
         if K < 1 then
            goto L30;
         end if;
         --
         if IPIV (K) > 0 then
            --
            --           1 x 1 diagonal block
            --
            --           Interchange rows K and IPIV(K).
            --
            KP := IPIV (K);
            if KP /= K then
               ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            --
            --           Multiply by inv(U(K)), where U(K) is the transformation
            --           stored in column K of A.
            --
            ZGERU (K - 1, NRHS, -ONE, A (1, K)'Address, 1, B (K, 1)'Address, LDB, B (1, 1)'Address, LDB);
            --
            --           Multiply by the inverse of the diagonal block.
            --
            ZSCAL (NRHS, ONE / A (K, K), B (K, 1)'Address, LDB);
            K := K - 1;
         else
            --
            --           2 x 2 diagonal block
            --
            --           Interchange rows K-1 and -IPIV(K).
            --
            KP := -IPIV (K);
            if KP /= K - 1 then
               ZSWAP (NRHS, B (K - 1, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            --
            --           Multiply by inv(U(K)), where U(K) is the transformation
            --           stored in columns K-1 and K of A.
            --
            ZGERU (K - 2, NRHS, -ONE, A (1, K)'Address, 1, B (K, 1)'Address, LDB, B (1, 1)'Address, LDB);
            ZGERU (K - 2, NRHS, -ONE, A (1, K - 1)'Address, 1, B (K - 1, 1)'Address, LDB, B (1, 1)'Address, LDB);
            --
            --           Multiply by the inverse of the diagonal block.
            --
            AKM1K := A (K - 1, K);
            AKM1  := A (K - 1, K - 1) / AKM1K;
            AK    := A (K, K) / AKM1K;
            DENOM := AKM1 * AK - ONE;
            J     := 1 - 1;
            loop
               J := J + 1;
               exit when J > NRHS;
               BKM1         := B (K - 1, J) / AKM1K;
               BK           := B (K, J) / AKM1K;
               B (K - 1, J) := (AK * BKM1 - BK) / DENOM;
               B (K, J)     := (AKM1 * BK - BKM1) / DENOM;
            end loop;
            K := K - 2;
         end if;
         --
         goto L10;
         <<L30>> null;
         --
         --        Next solve U**T *X = B, overwriting B with X.
         --
         --        K is the main loop index, increasing from 1 to N in steps of
         --        1 or 2, depending on the size of the diagonal blocks.
         --
         K := 1;
         <<L40>> null;
         --
         --        If K > N, exit from loop.
         --
         if K > N then
            goto L50;
         end if;
         --
         if IPIV (K) > 0 then
            --
            --           1 x 1 diagonal block
            --
            --           Multiply by inv(U**T(K)), where U(K) is the transformation
            --           stored in column K of A.
            --
            ZGEMV ('T', K - 1, NRHS, -ONE, B'Address, LDB, A (1, K)'Address, 1, ONE, B (K, 1)'Address, LDB);
            --
            --           Interchange rows K and IPIV(K).
            --
            KP := IPIV (K);
            if KP /= K then
               ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            K := K + 1;
         else
            --
            --           2 x 2 diagonal block
            --
            --           Multiply by inv(U**T(K+1)), where U(K+1) is the transformation
            --           stored in columns K and K+1 of A.
            --
            ZGEMV ('T', K - 1, NRHS, -ONE, B'Address, LDB, A (1, K)'Address, 1, ONE, B (K, 1)'Address, LDB);
            ZGEMV ('T', K - 1, NRHS, -ONE, B'Address, LDB, A (1, K + 1)'Address, 1, ONE, B (K + 1, 1)'Address, LDB);
            --
            --           Interchange rows K and -IPIV(K).
            --
            KP := -IPIV (K);
            if KP /= K then
               ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            K := K + 2;
         end if;
         --
         goto L40;
         <<L50>> null;
      --
      else
         --
         --        Solve A*X = B, where A = L*D*L**T.
         --
         --        First solve L*D*X = B, overwriting B with X.
         --
         --        K is the main loop index, increasing from 1 to N in steps of
         --        1 or 2, depending on the size of the diagonal blocks.
         --
         K := 1;
         <<L60>> null;
         --
         --        If K > N, exit from loop.
         --
         if K > N then
            goto L80;
         end if;
         --
         if IPIV (K) > 0 then
            --
            --           1 x 1 diagonal block
            --
            --           Interchange rows K and IPIV(K).
            --
            KP := IPIV (K);
            if KP /= K then
               ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            --
            --           Multiply by inv(L(K)), where L(K) is the transformation
            --           stored in column K of A.
            --
            if K < N then
               ZGERU (N - K, NRHS, -ONE, A (K + 1, K)'Address, 1, B (K, 1)'Address, LDB, B (K + 1, 1)'Address, LDB);
            end if;
            --
            --           Multiply by the inverse of the diagonal block.
            --
            ZSCAL (NRHS, ONE / A (K, K), B (K, 1)'Address, LDB);
            K := K + 1;
         else
            --
            --           2 x 2 diagonal block
            --
            --           Interchange rows K+1 and -IPIV(K).
            --
            KP := -IPIV (K);
            if KP /= K + 1 then
               ZSWAP (NRHS, B (K + 1, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            --
            --           Multiply by inv(L(K)), where L(K) is the transformation
            --           stored in columns K and K+1 of A.
            --
            if K < N - 1 then
               ZGERU (N - K - 1, NRHS, -ONE, A (K + 2, K)'Address, 1, B (K, 1)'Address, LDB, B (K + 2, 1)'Address, LDB);
               ZGERU
                 (N - K - 1,
                  NRHS,
                  -ONE,
                  A (K + 2, K + 1)'Address,
                  1,
                  B (K + 1, 1)'Address,
                  LDB,
                  B (K + 2, 1)'Address,
                  LDB);
            end if;
            --
            --           Multiply by the inverse of the diagonal block.
            --
            AKM1K := A (K + 1, K);
            AKM1  := A (K, K) / AKM1K;
            AK    := A (K + 1, K + 1) / AKM1K;
            DENOM := AKM1 * AK - ONE;
            J     := 1 - 1;
            loop
               J := J + 1;
               exit when J > NRHS;
               BKM1         := B (K, J) / AKM1K;
               BK           := B (K + 1, J) / AKM1K;
               B (K, J)     := (AK * BKM1 - BK) / DENOM;
               B (K + 1, J) := (AKM1 * BK - BKM1) / DENOM;
            end loop;
            K := K + 2;
         end if;
         --
         goto L60;
         <<L80>> null;
         --
         --        Next solve L**T *X = B, overwriting B with X.
         --
         --        K is the main loop index, decreasing from N to 1 in steps of
         --        1 or 2, depending on the size of the diagonal blocks.
         --
         K := N;
         <<L90>> null;
         --
         --        If K < 1, exit from loop.
         --
         if K < 1 then
            goto L100;
         end if;
         --
         if IPIV (K) > 0 then
            --
            --           1 x 1 diagonal block
            --
            --           Multiply by inv(L**T(K)), where L(K) is the transformation
            --           stored in column K of A.
            --
            if K < N then
               ZGEMV
                 ('T',
                  N - K,
                  NRHS,
                  -ONE,
                  B (K + 1, 1)'Address,
                  LDB,
                  A (K + 1, K)'Address,
                  1,
                  ONE,
                  B (K, 1)'Address,
                  LDB);
            end if;
            --
            --           Interchange rows K and IPIV(K).
            --
            KP := IPIV (K);
            if KP /= K then
               ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            K := K - 1;
         else
            --
            --           2 x 2 diagonal block
            --
            --           Multiply by inv(L**T(K-1)), where L(K-1) is the transformation
            --           stored in columns K-1 and K of A.
            --
            if K < N then
               ZGEMV
                 ('T',
                  N - K,
                  NRHS,
                  -ONE,
                  B (K + 1, 1)'Address,
                  LDB,
                  A (K + 1, K)'Address,
                  1,
                  ONE,
                  B (K, 1)'Address,
                  LDB);
               ZGEMV
                 ('T',
                  N - K,
                  NRHS,
                  -ONE,
                  B (K + 1, 1)'Address,
                  LDB,
                  A (K + 1, K - 1)'Address,
                  1,
                  ONE,
                  B (K - 1, 1)'Address,
                  LDB);
            end if;
            --
            --           Interchange rows K and -IPIV(K).
            --
            KP := -IPIV (K);
            if KP /= K then
               ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
            end if;
            K := K - 2;
         end if;
         --
         goto L90;
         <<L100>> null;
      end if;
      --
      return;
      --
      --     End of ZSYTRS
      --
   end ZSYTRS;

   procedure ZSYTRS2
     (UPLO : Character;
      N    : Integer;
      NRHS : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer;
      IPIV : Ftn_Integer_Vector;
      B    : in out Ftn_Complex_Matrix;
      LDB  : Integer;
      WORK : out Ftn_Complex_Vector;
      INFO : in out Integer)
   is
      ONE   : constant Complex := (1.0, 0.0);
      UPPER : Boolean;
      I     : Integer;
      IINFO : Integer;
      J     : Integer;
      K     : Integer;
      KP    : Integer;
      AK    : Complex;
      AKM1  : Complex;
      AKM1K : Complex;
      BK    : Complex;
      BKM1  : Complex;
      DENOM : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZSYTRS2( UPLO, N, NRHS, A, LDA, IPIV, B, LDB,
   --                           WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LDB, N, NRHS
   --       ..
   --       .. Array Arguments ..
   --       INTEGER            IPIV( * )
   --       COMPLEX*16       A( LDA, * ), B( LDB, * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZSYTRS2 solves a system of linear equations A*X = B with a real
   --  symmetric matrix A using the factorization A = U*D*U**T or
   --  A = L*D*L**T computed by ZSYTRF and converted by ZSYCONV.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the details of the factorization are stored
   --           as an upper or lower triangular matrix.
   --           = 'U':  Upper triangular, form is A = U*D*U**T;
   --           = 'L':  Lower triangular, form is A = L*D*L**T.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in] NRHS
   --           NRHS is INTEGER
   --           The number of right hand sides, i.e., the number of columns
   --           of the matrix B.  NRHS >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           The block diagonal matrix D and the multipliers used to
   --           obtain the factor U or L as computed by ZSYTRF.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [in] IPIV
   --           IPIV is INTEGER array, dimension (N)
   --           Details of the interchanges and the block structure of D
   --           as determined by ZSYTRF.
   --
   --  [in,out] B
   --           B is COMPLEX*16 array, dimension (LDB,NRHS)
   --           On entry, the right hand side matrix B.
   --           On exit, the solution matrix X.
   --
   --  [in] LDB
   --           LDB is INTEGER
   --           The leading dimension of the array B.  LDB >= max(1,N).
   --
   --  [out] WORK
   --           WORK is REAL array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = (1.0D+0,0.0D+0) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZSCAL, ZSYCONV, ZSWAP, ZTRSM, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   begin
      INFO  := 0;
      UPPER := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif NRHS < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LDB < max (1, N) then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZSYTRS2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 or NRHS = 0 then
         return;
      end if;
      --
      --     Convert A
      --
      ZSYCONV (UPLO, 'C', N, A, LDA, IPIV, WORK, IINFO);
      --
      if UPPER then
         --
         --        Solve A*X = B, where A = U*D*U**T.
         --
         --       P**T * B
         K := N;
         while K >= 1 loop
            if IPIV (K) > 0 then
               --           1 x 1 diagonal block
               --           Interchange rows K and IPIV(K).
               KP := IPIV (K);
               if KP /= K then
                  ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K - 1;
            else
               --           2 x 2 diagonal block
               --           Interchange rows K-1 and -IPIV(K).
               KP := -IPIV (K);
               if KP = -IPIV (K - 1) then
                  ZSWAP (NRHS, B (K - 1, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K - 2;
            end if;
         end loop;
         --
         --  Compute (U \P**T * B) -> B    [ (U \P**T * B) ]
         --
         ZTRSM ('L', 'U', 'N', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --  Compute D \ B -> B   [ D \ (U \P**T * B) ]
         --
         I := N;
         while I >= 1 loop
            if IPIV (I) > 0 then
               ZSCAL (NRHS, ONE / A (I, I), B (I, 1)'Address, LDB);
            elsif I > 1 then
               if IPIV (I - 1) = IPIV (I) then
                  AKM1K := WORK (I);
                  AKM1  := A (I - 1, I - 1) / AKM1K;
                  AK    := A (I, I) / AKM1K;
                  DENOM := AKM1 * AK - ONE;
                  J     := 1 - 1;
                  loop
                     J := J + 1;
                     exit when J > NRHS;
                     BKM1         := B (I - 1, J) / AKM1K;
                     BK           := B (I, J) / AKM1K;
                     B (I - 1, J) := (AK * BKM1 - BK) / DENOM;
                     B (I, J)     := (AKM1 * BK - BKM1) / DENOM;
                  end loop;
                  I := I - 1;
               end if;
            end if;
            I := I - 1;
         end loop;
         --
         --      Compute (U**T \ B) -> B   [ U**T \ (D \ (U \P**T * B) ) ]
         --
         ZTRSM ('L', 'U', 'T', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --       P * B  [ P * (U**T \ (D \ (U \P**T * B) )) ]
         --
         K := 1;
         while K <= N loop
            if IPIV (K) > 0 then
               --           1 x 1 diagonal block
               --           Interchange rows K and IPIV(K).
               KP := IPIV (K);
               if KP /= K then
                  ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K + 1;
            else
               --           2 x 2 diagonal block
               --           Interchange rows K-1 and -IPIV(K).
               KP := -IPIV (K);
               if K < N and KP = -IPIV (K + 1) then
                  ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K + 2;
            end if;
         end loop;
      --
      else
         --
         --        Solve A*X = B, where A = L*D*L**T.
         --
         --       P**T * B
         K := 1;
         while K <= N loop
            if IPIV (K) > 0 then
               --           1 x 1 diagonal block
               --           Interchange rows K and IPIV(K).
               KP := IPIV (K);
               if KP /= K then
                  ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K + 1;
            else
               --           2 x 2 diagonal block
               --           Interchange rows K and -IPIV(K+1).
               KP := -IPIV (K + 1);
               if KP = -IPIV (K) then
                  ZSWAP (NRHS, B (K + 1, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K + 2;
            end if;
         end loop;
         --
         --  Compute (L \P**T * B) -> B    [ (L \P**T * B) ]
         --
         ZTRSM ('L', 'L', 'N', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --  Compute D \ B -> B   [ D \ (L \P**T * B) ]
         --
         I := 1;
         while I <= N loop
            if IPIV (I) > 0 then
               ZSCAL (NRHS, ONE / A (I, I), B (I, 1)'Address, LDB);
            else
               AKM1K := WORK (I);
               AKM1  := A (I, I) / AKM1K;
               AK    := A (I + 1, I + 1) / AKM1K;
               DENOM := AKM1 * AK - ONE;
               J     := 1 - 1;
               loop
                  J := J + 1;
                  exit when J > NRHS;
                  BKM1         := B (I, J) / AKM1K;
                  BK           := B (I + 1, J) / AKM1K;
                  B (I, J)     := (AK * BKM1 - BK) / DENOM;
                  B (I + 1, J) := (AKM1 * BK - BKM1) / DENOM;
               end loop;
               I := I + 1;
            end if;
            I := I + 1;
         end loop;
         --
         --  Compute (L**T \ B) -> B   [ L**T \ (D \ (L \P**T * B) ) ]
         --
         ZTRSM ('L', 'L', 'T', 'U', N, NRHS, ONE, A'Address, LDA, B'Address, LDB);
         --
         --       P * B  [ P * (L**T \ (D \ (L \P**T * B) )) ]
         --
         K := N;
         while K >= 1 loop
            if IPIV (K) > 0 then
               --           1 x 1 diagonal block
               --           Interchange rows K and IPIV(K).
               KP := IPIV (K);
               if KP /= K then
                  ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K - 1;
            else
               --           2 x 2 diagonal block
               --           Interchange rows K-1 and -IPIV(K).
               KP := -IPIV (K);
               if K > 1 and KP = -IPIV (K - 1) then
                  ZSWAP (NRHS, B (K, 1)'Address, LDB, B (KP, 1)'Address, LDB);
               end if;
               K := K - 2;
            end if;
         end loop;
         --
      end if;
      --
      --     Revert A
      --
      ZSYCONV (UPLO, 'R', N, A, LDA, IPIV, WORK, IINFO);
      --
      return;
      --
      --     End of ZSYTRS2
      --
   end ZSYTRS2;

   procedure ZTREVC
     (SIDE           : Character;
      HOWMNY         : Character;
      the_SELECT_adr : Address;
      N              : Integer;
      T_adr          : Address;
      LDT            : Integer;
      VL_adr         : Address;
      LDVL           : Integer;
      VR_adr         : Address;
      LDVR           : Integer;
      MM             : Integer;
      M              : in out Integer;
      WORK_adr       : Address;
      RWORK_adr      : Address;
      INFO           : in out Integer)
   is

      the_SELECT : Ftn_Boolean_Vector (1 .. N);
      T          : Ftn_Complex_Matrix (1 .. LDT, 1 .. N);
      VL         : Ftn_Complex_Matrix (1 .. LDVL, 1 .. MM);
      VR         : Ftn_Complex_Matrix (1 .. LDVR, 1 .. MM);
      WORK       : Ftn_Complex_Vector (1 .. 2 * N);
      RWORK      : Ftn_Real_Vector (1 .. N);

      for the_SELECT'Address use the_SELECT_adr;
      for T'Address use T_adr;
      for VL'Address use VL_adr;
      for VR'Address use VR_adr;
      for WORK'Address use WORK_adr;
      for RWORK'Address use RWORK_adr;

      pragma Import (Ada, the_SELECT);
      pragma Import (Ada, T);
      pragma Import (Ada, VL);
      pragma Import (Ada, VR);
      pragma Import (Ada, WORK);
      pragma Import (Ada, RWORK);

      ZERO   : constant Real    := 0.0e0;
      ONE    : constant Real    := 1.0e0;
      CMZERO : constant Complex := (0.0e0, 0.0e0);
      CMONE  : constant Complex := (1.0e0, 0.0e0);
      ALLV   : Boolean;
      BOTHV  : Boolean;
      LEFTV  : Boolean;
      OVER   : Boolean;
      RIGHTV : Boolean;
      SOMEV  : Boolean;
      I      : Integer;
      II     : Integer;
      the_IS : Integer;
      J      : Integer;
      K      : Integer;
      KI     : Integer;
      OVFL   : Real;
      REMAX  : Real;
      SCALE  : Real;
      SMIN   : Real;
      SMLNUM : Real;
      ULP    : Real;
      UNFL   : Real;
      CDUM   : Complex;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZTREVC( SIDE, HOWMNY, SELECT, N, T, LDT, VL, LDVL, VR,
   --                          LDVR, MM, M, WORK, RWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          HOWMNY, SIDE
   --       INTEGER            INFO, LDT, LDVL, LDVR, M, MM, N
   --       ..
   --       .. Array Arguments ..
   --       LOGICAL            SELECT( * )
   --       DOUBLE PRECISION   RWORK( * )
   --       COMPLEX*16         T( LDT, * ), VL( LDVL, * ), VR( LDVR, * ),
   --      $                   WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZTREVC computes some or all of the right and/or left eigenvectors of
   --  a complex upper triangular matrix T.
   --  Matrices of this type are produced by the Schur factorization of
   --  a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
   --
   --  The right eigenvector x and the left eigenvector y of T corresponding
   --  to an eigenvalue w are defined by:
   --
   --               T*x = w*x,     (y**H)*T = w*(y**H)
   --
   --  where y**H denotes the conjugate transpose of the vector y.
   --  The eigenvalues are not input to this routine, but are read directly
   --  from the diagonal of T.
   --
   --  This routine returns the matrices X and/or Y of right and left
   --  eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
   --  input matrix.  If Q is the unitary factor that reduces a matrix A to
   --  Schur form T, then Q*X and Q*Y are the matrices of right and left
   --  eigenvectors of A.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'R':  compute right eigenvectors only;
   --           = 'L':  compute left eigenvectors only;
   --           = 'B':  compute both right and left eigenvectors.
   --
   --  [in] HOWMNY
   --           HOWMNY is CHARACTER*1
   --           = 'A':  compute all right and/or left eigenvectors;
   --           = 'B':  compute all right and/or left eigenvectors,
   --                   backtransformed using the matrices supplied in
   --                   VR and/or VL;
   --           = 'S':  compute selected right and/or left eigenvectors,
   --                   as indicated by the LOGICAL array SELECT.
   --
   --  [in] SELECT
   --           SELECT is LOGICAL array, dimension (N)
   --           If HOWMNY = 'S', SELECT specifies the eigenvectors to be
   --           computed.
   --           The eigenvector corresponding to the j-th eigenvalue is
   --           computed if SELECT(j) = .TRUE..
   --           Not referenced if HOWMNY = 'A' or 'B'.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix T. N >= 0.
   --
   --  [in,out] T
   --           T is COMPLEX*16 array, dimension (LDT,N)
   --           The upper triangular matrix T.  T is modified, but restored
   --           on exit.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= max(1,N).
   --
   --  [in,out] VL
   --           VL is COMPLEX*16 array, dimension (LDVL,MM)
   --           On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
   --           contain an N-by-N matrix Q (usually the unitary matrix Q of
   --           Schur vectors returned by ZHSEQR).
   --           On exit, if SIDE = 'L' or 'B', VL contains:
   --           if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
   --           if HOWMNY = 'B', the matrix Q*Y;
   --           if HOWMNY = 'S', the left eigenvectors of T specified by
   --                            SELECT, stored consecutively in the columns
   --                            of VL, in the same order as their
   --                            eigenvalues.
   --           Not referenced if SIDE = 'R'.
   --
   --  [in] LDVL
   --           LDVL is INTEGER
   --           The leading dimension of the array VL.  LDVL >= 1, and if
   --           SIDE = 'L' or 'B', LDVL >= N.
   --
   --  [in,out] VR
   --           VR is COMPLEX*16 array, dimension (LDVR,MM)
   --           On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
   --           contain an N-by-N matrix Q (usually the unitary matrix Q of
   --           Schur vectors returned by ZHSEQR).
   --           On exit, if SIDE = 'R' or 'B', VR contains:
   --           if HOWMNY = 'A', the matrix X of right eigenvectors of T;
   --           if HOWMNY = 'B', the matrix Q*X;
   --           if HOWMNY = 'S', the right eigenvectors of T specified by
   --                            SELECT, stored consecutively in the columns
   --                            of VR, in the same order as their
   --                            eigenvalues.
   --           Not referenced if SIDE = 'L'.
   --
   --  [in] LDVR
   --           LDVR is INTEGER
   --           The leading dimension of the array VR.  LDVR >= 1, and if
   --           SIDE = 'R' or 'B'; LDVR >= N.
   --
   --  [in] MM
   --           MM is INTEGER
   --           The number of columns in the arrays VL and/or VR. MM >= M.
   --
   --  [out] M
   --           M is INTEGER
   --           The number of columns in the arrays VL and/or VR actually
   --           used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
   --           is set to N.  Each selected eigenvector occupies one
   --           column.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (2*N)
   --
   --  [out] RWORK
   --           RWORK is DOUBLE PRECISION array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  Further Details:
   --  ================
   --
   --
   --   The algorithm used in this program is basically backward (forward)
   --   substitution, with scaling to make the the code robust against
   --   possible overflow.
   --
   --   Each eigenvector is normalized so that the element of largest
   --   magnitude has magnitude 1; here the magnitude of a complex number
   --   (x,y) is taken to be |x| + |y|.
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
   --      PARAMETER          ( CMZERO = ( 0.0D+0, 0.0D+0 ), CMONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       INTEGER            IZAMAX
   --       DOUBLE PRECISION   DLAMCH, DZASUM
   --       EXTERNAL           LSAME, IZAMAX, DLAMCH, DZASUM
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZCOPY, ZDSCAL, ZGEMV, ZLATRS
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          ABS, DBLE, DCMPLX, DCONJG, DIMAG, MAX
   --     ..
   --     .. Statement Functions ..
   --     ..
   --     .. Statement Function definitions ..
   begin
      --       CABS1(CDUM) := ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM));
      --     ..
      --     .. Executable Statements ..
      --
      --     Decode and test the input parameters
      --
      BOTHV  := LSAME (SIDE, 'B');
      RIGHTV := LSAME (SIDE, 'R') or BOTHV;
      LEFTV  := LSAME (SIDE, 'L') or BOTHV;
      --
      ALLV  := LSAME (HOWMNY, 'A');
      OVER  := LSAME (HOWMNY, 'B');
      SOMEV := LSAME (HOWMNY, 'S');
      --
      --     Set M to the number of columns required to store the selected
      --     eigenvectors.
      --
      if SOMEV then
         M := 0;
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if the_SELECT (J) then
               M := M + 1;
            end if;
         end loop;
      else
         M := N;
      end if;
      --
      INFO := 0;
      if not RIGHTV and not LEFTV then
         INFO := -1;
      elsif not ALLV and not OVER and not SOMEV then
         INFO := -2;
      elsif N < 0 then
         INFO := -4;
      elsif LDT < max (1, N) then
         INFO := -6;
      elsif LDVL < 1 or (LEFTV and LDVL < N) then
         INFO := -8;
      elsif LDVR < 1 or (RIGHTV and LDVR < N) then
         INFO := -10;
      elsif MM < M then
         INFO := -11;
      end if;
      if INFO /= 0 then
         XERBLA ("ZTREVC", -INFO);
         return;
      end if;
      --
      --     Quick return if possible.
      --
      if N = 0 then
         return;
      end if;
      --
      --     Set the constants to control overflow.
      --
      UNFL := DLAMCH ('S');
      OVFL := ONE / UNFL;
      DLABAD (UNFL, OVFL);
      ULP    := DLAMCH ('P');
      SMLNUM := UNFL * (Real (N) / ULP);
      --
      --     Store the diagonal elements of T in working array WORK.
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > N;
         WORK (I + N) := T (I, I);
      end loop;
      --
      --     Compute 1-norm of each column of strictly upper triangular
      --     part of T to control overflow in triangular solver.
      --
      RWORK (1) := ZERO;
      J         := 2 - 1;
      loop
         J := J + 1;
         exit when J > N;
         RWORK (J) := DZASUM (J - 1, T (1, J)'Address, 1);
      end loop;
      --
      if RIGHTV then
         --
         --        Compute right eigenvectors.
         --
         the_IS := M;
         KI     := N + 1;
         loop
            KI := KI - 1;
            exit when KI < 1;
            --
            if SOMEV then
               if not the_SELECT (KI) then
                  goto L80;
               end if;
            end if;
            SMIN := max (ULP * (CABS1 (T (KI, KI))), SMLNUM);
            --
            WORK (1) := CMONE;
            --
            --           Form right-hand side.
            --
            K := 1 - 1;
            loop
               K := K + 1;
               exit when K > KI - 1;
               WORK (K) := -T (K, KI);
            end loop;
            --
            --           Solve the triangular system:
            --              (T(1:KI-1,1:KI-1) - T(KI,KI))*X = SCALE*WORK.
            --
            K := 1 - 1;
            loop
               K := K + 1;
               exit when K > KI - 1;
               T (K, K) := T (K, K) - T (KI, KI);
               if CABS1 (T (K, K)) < SMIN then
                  T (K, K) := Complex'(SMIN, 0.0e0);
               end if;
            end loop;
            --
            if KI > 1 then
               ZLATRS ('U', 'N', 'N', 'Y', KI - 1, T'Address, LDT, WORK (1)'Address, SCALE, RWORK'Address, INFO);
               WORK (KI) := Complex'(SCALE, 0.0e0);
            end if;
            --
            --           Copy the vector x or Q*x to VR and normalize.
            --
            if not OVER then
               ZCOPY (KI, WORK (1)'Address, 1, VR (1, the_IS)'Address, 1);
               --
               II    := IZAMAX (KI, VR (1, the_IS)'Address, 1);
               REMAX := ONE / CABS1 (VR (II, the_IS));
               ZDSCAL (KI, REMAX, VR (1, the_IS)'Address, 1);
               --
               K := KI + 1 - 1;
               loop
                  K := K + 1;
                  exit when K > N;
                  VR (K, the_IS) := CMZERO;
               end loop;
            else
               if KI > 1 then
                  ZGEMV
                    ('N',
                     N,
                     KI - 1,
                     CMONE,
                     VR'Address,
                     LDVR,
                     WORK (1)'Address,
                     1,
                     dcmplx (SCALE, 0.0e0),
                     VR (1, KI)'Address,
                     1);
               end if;
               --
               II    := IZAMAX (N, VR (1, KI)'Address, 1);
               REMAX := ONE / CABS1 (VR (II, KI));
               ZDSCAL (N, REMAX, VR (1, KI)'Address, 1);
            end if;
            --
            --           Set back the original diagonal elements of T.
            --
            K := 1 - 1;
            loop
               K := K + 1;
               exit when K > KI - 1;
               T (K, K) := WORK (K + N);
            end loop;
            --
            the_IS := the_IS - 1;
            <<L80>> null;
         end loop;
      end if;
      --
      if LEFTV then
         --
         --        Compute left eigenvectors.
         --
         the_IS := 1;
         KI     := 1 - 1;
         loop
            KI := KI + 1;
            exit when KI > N;
            --
            if SOMEV then
               if not the_SELECT (KI) then
                  goto L130;
               end if;
            end if;
            SMIN := max (ULP * (CABS1 (T (KI, KI))), SMLNUM);
            --
            WORK (N) := CMONE;
            --
            --           Form right-hand side.
            --
            K := KI + 1 - 1;
            loop
               K := K + 1;
               exit when K > N;
               WORK (K) := -dconjg (T (KI, K));
            end loop;
            --
            --           Solve the triangular system:
            --              (T(KI+1:N,KI+1:N) - T(KI,KI))**H * X = SCALE*WORK.
            --
            K := KI + 1 - 1;
            loop
               K := K + 1;
               exit when K > N;
               T (K, K) := T (K, K) - T (KI, KI);
               if CABS1 (T (K, K)) < SMIN then
                  T (K, K) := Complex'(SMIN, 0.0e0);
               end if;
            end loop;
            --
            if KI < N then
               ZLATRS
                 ('U',
                  'C',
                  'N',
                  'Y',
                  N - KI,
                  T (KI + 1, KI + 1)'Address,
                  LDT,
                  WORK (KI + 1)'Address,
                  SCALE,
                  RWORK'Address,
                  INFO);
               WORK (KI) := Complex'(SCALE, 0.0e0);
            end if;
            --
            --           Copy the vector x or Q*x to VL and normalize.
            --
            if not OVER then
               ZCOPY (N - KI + 1, WORK (KI)'Address, 1, VL (KI, the_IS)'Address, 1);
               --
               II    := IZAMAX (N - KI + 1, VL (KI, the_IS)'Address, 1) + KI - 1;
               REMAX := ONE / CABS1 (VL (II, the_IS));
               ZDSCAL (N - KI + 1, REMAX, VL (KI, the_IS)'Address, 1);
               --
               K := 1 - 1;
               loop
                  K := K + 1;
                  exit when K > KI - 1;
                  VL (K, the_IS) := CMZERO;
               end loop;
            else
               if KI < N then
                  ZGEMV
                    ('N',
                     N,
                     N - KI,
                     CMONE,
                     VL (1, KI + 1)'Address,
                     LDVL,
                     WORK (KI + 1)'Address,
                     1,
                     dcmplx (SCALE, 0.0e0),
                     VL (1, KI)'Address,
                     1);
               end if;
               --
               II    := IZAMAX (N, VL (1, KI)'Address, 1);
               REMAX := ONE / CABS1 (VL (II, KI));
               ZDSCAL (N, REMAX, VL (1, KI)'Address, 1);
            end if;
            --
            --           Set back the original diagonal elements of T.
            --
            K := KI + 1 - 1;
            loop
               K := K + 1;
               exit when K > N;
               T (K, K) := WORK (K + N);
            end loop;
            --
            the_IS := the_IS + 1;
            <<L130>> null;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZTREVC
      --
   end ZTREVC;

   procedure ZTREXC
     (COMPQ : Character;
      N     : Integer;
      T     : in out Ftn_Complex_Matrix;
      LDT   : Integer;
      Q     : in out Ftn_Complex_Matrix;
      LDQ   : Integer;
      IFST  : Integer;
      ILST  : Integer;
      INFO  : in out Integer)
   is
      WANTQ : Boolean;
      K     : Integer;
      M1    : Integer;
      M2    : Integer;
      M3    : Integer;
      CS    : Real;
      SN    : Complex;
      T11   : Complex;
      T22   : Complex;
      TEMP  : Complex;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZTREXC( COMPQ, N, T, LDT, Q, LDQ, IFST, ILST, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          COMPQ
   --       INTEGER            IFST, ILST, INFO, LDQ, LDT, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         Q( LDQ, * ), T( LDT, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZTREXC reorders the Schur factorization of a complex matrix
   --  A = Q*T*Q**H, so that the diagonal element of T with row index IFST
   --  is moved to row ILST.
   --
   --  The Schur form T is reordered by a unitary similarity transformation
   --  Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
   --  postmultplying it with Z.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] COMPQ
   --           COMPQ is CHARACTER*1
   --           = 'V':  update the matrix Q of Schur vectors;
   --           = 'N':  do not update Q.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix T. N >= 0.
   --
   --  [in,out] T
   --           T is COMPLEX*16 array, dimension (LDT,N)
   --           On entry, the upper triangular matrix T.
   --           On exit, the reordered upper triangular matrix.
   --
   --  [in] LDT
   --           LDT is INTEGER
   --           The leading dimension of the array T. LDT >= max(1,N).
   --
   --  [in,out] Q
   --           Q is COMPLEX*16 array, dimension (LDQ,N)
   --           On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
   --           On exit, if COMPQ = 'V', Q has been postmultiplied by the
   --           unitary transformation matrix Z which reorders T.
   --           If COMPQ = 'N', Q is not referenced.
   --
   --  [in] LDQ
   --           LDQ is INTEGER
   --           The leading dimension of the array Q.  LDQ >= max(1,N).
   --
   --  [in] IFST
   --           IFST is INTEGER
   --
   --  [in] ILST
   --           ILST is INTEGER
   --
   --           Specify the reordering of the diagonal elements of T:
   --           The element with row index IFST is moved to row ILST by a
   --           sequence of transpositions between adjacent elements.
   --           1 <= IFST <= N; 1 <= ILST <= N.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZLARTG, ZROT
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Decode and test the input parameters.
   --
   begin
      INFO  := 0;
      WANTQ := LSAME (COMPQ, 'V');
      if not LSAME (COMPQ, 'N') and not WANTQ then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDT < max (1, N) then
         INFO := -4;
      elsif LDQ < 1 or (WANTQ and LDQ < max (1, N)) then
         INFO := -6;
      elsif IFST < 1 or IFST > N then
         INFO := -7;
      elsif ILST < 1 or ILST > N then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZTREXC", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 1 or IFST = ILST then
         return;
      end if;
      --
      if IFST < ILST then
         --
         --        Move the IFST-th diagonal element forward down the diagonal.
         --
         M1 := 0;
         M2 := -1;
         M3 := 1;
      else
         --
         --        Move the IFST-th diagonal element backward up the diagonal.
         --
         M1 := -1;
         M2 := 0;
         M3 := -1;
      end if;
      --
      K := IFST + M1 - M3;
      loop
         K := K + M3;
         if M3 > 0 
            then exit when K > ILST + M2;
            else exit when K < ILST + M2;
         end if;
         --
         --        Interchange the k-th and (k+1)-th diagonal elements.
         --
         T11 := T (K, K);
         T22 := T (K + 1, K + 1);
         --
         --        Determine the transformation to perform the interchange.
         --
         ZLARTG (T (K, K + 1), T22 - T11, CS, SN, TEMP);
         --
         --        Apply transformation to the matrix T.
         --
         if K + 2 <= N then
            ZROT (N - K - 1, T (K, K + 2)'Address, LDT, T (K + 1, K + 2)'Address, LDT, CS, SN);
         end if;
         ZROT (K - 1, T (1, K)'Address, 1, T (1, K + 1)'Address, 1, CS, dconjg (SN));
         --
         T (K, K)         := T22;
         T (K + 1, K + 1) := T11;
         --
         if WANTQ then
            --
            --           Accumulate transformation in the matrix Q.
            --
            ZROT (N, Q (1, K)'Address, 1, Q (1, K + 1)'Address, 1, CS, dconjg (SN));
         end if;
         --
      end loop;
      --
      return;
      --
      --     End of ZTREXC
      --
   end ZTREXC;

   procedure ZTRTI2
     (UPLO  : Character;
      DIAG  : Character;
      N     : Integer;
      A_adr : Address;
      LDA   : Integer;
      INFO  : in out Integer)
   is

      A : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);

      for A'Address use A_adr;

      pragma Import (Ada, A);

      ONE    : constant Complex := (1.0e0, 0.0e0);
      NOUNIT : Boolean;
      UPPER  : Boolean;
      J      : Integer;
      AJJ    : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZTRTI2( UPLO, DIAG, N, A, LDA, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIAG, UPLO
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       Complex*16   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZTRTI2 computes the inverse of a complex upper or lower triangular
   --  matrix.
   --
   --  This is the Level 2 BLAS version of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           Specifies whether the matrix A is upper or lower triangular.
   --           = 'U':  Upper triangular
   --           = 'L':  Lower triangular
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --           Specifies whether or not the matrix A is unit triangular.
   --           = 'N':  Non-unit triangular
   --           = 'U':  Unit triangular
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is Complex*16 array, dimension (LDA,N)
   --           On entry, the triangular matrix A.  If UPLO = 'U', the
   --           leading n by n upper triangular part of the array A contains
   --           the upper triangular matrix, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading n by n lower triangular part of the array A contains
   --           the lower triangular matrix, and the strictly upper
   --           triangular part of A is not referenced.  If DIAG = 'U', the
   --           diagonal elements of A are also not referenced and are
   --           assumed to be 1.
   --
   --           On exit, the (triangular) inverse of the original matrix, in
   --           the same storage format.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -k, the k-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZSCAL, ZTRMV, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      NOUNIT := LSAME (DIAG, 'N');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif not NOUNIT and not LSAME (DIAG, 'U') then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("ZTRTI2", -INFO);
         return;
      end if;
      --
      if UPPER then
         --
         --        Compute inverse of upper triangular matrix.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            if NOUNIT then
               A (J, J) := ONE / A (J, J);
               AJJ      := -A (J, J);
            else
               AJJ := -ONE;
            end if;
            --
            --           Compute elements 1:j-1 of j-th column.
            --
            ZTRMV ('U', 'N', DIAG, J - 1, A'Address, LDA, A (1, J)'Address, 1);
            ZSCAL (J - 1, AJJ, A (1, J)'Address, 1);
         end loop;
      else
         --
         --        Compute inverse of lower triangular matrix.
         --
         J := N + 1;
         loop
            J := J - 1;
            exit when J < 1;
            if NOUNIT then
               A (J, J) := ONE / A (J, J);
               AJJ      := -A (J, J);
            else
               AJJ := -ONE;
            end if;
            if J < N then
               --
               --              Compute elements j+1:n of j-th column.
               --
               ZTRMV ('L', 'N', DIAG, N - J, A (J + 1, J + 1)'Address, LDA, A (J + 1, J)'Address, 1);
               ZSCAL (N - J, AJJ, A (J + 1, J)'Address, 1);
            end if;
         end loop;
      end if;
      --
      return;
      --
      --     End of ZTRTI2
      --
   end ZTRTI2;

   procedure ZTRTRI
     (UPLO : Character;
      DIAG : Character;
      N    : Integer;
      A    : in out Ftn_Complex_Matrix;
      LDA  : Integer;
      INFO : in out Integer)
   is
      ONE    : constant Complex := (1.0e0, 0.0e0);
      ZERO   : constant Complex := (0.0e0, 0.0e0);
      NOUNIT : Boolean;
      UPPER  : Boolean;
      J      : Integer;
      JB     : Integer;
      NB     : Integer;
      NN     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZTRTRI( UPLO, DIAG, N, A, LDA, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          DIAG, UPLO
   --       INTEGER            INFO, LDA, N
   --       ..
   --       .. Array Arguments ..
   --       Complex*16   A( LDA, * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZTRTRI computes the inverse of a complex upper or lower triangular
   --  matrix A.
   --
   --  This is the Level 3 BLAS version of the algorithm.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U':  A is upper triangular;
   --           = 'L':  A is lower triangular.
   --
   --  [in] DIAG
   --           DIAG is CHARACTER*1
   --           = 'N':  A is non-unit triangular;
   --           = 'U':  A is unit triangular.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix A.  N >= 0.
   --
   --  [in,out] A
   --           A is Complex*16 array, dimension (LDA,N)
   --           On entry, the triangular matrix A.  If UPLO = 'U', the
   --           leading N-by-N upper triangular part of the array A contains
   --           the upper triangular matrix, and the strictly lower
   --           triangular part of A is not referenced.  If UPLO = 'L', the
   --           leading N-by-N lower triangular part of the array A contains
   --           the lower triangular matrix, and the strictly upper
   --           triangular part of A is not referenced.  If DIAG = 'U', the
   --           diagonal elements of A are also not referenced and are
   --           assumed to be 1.
   --           On exit, the (triangular) inverse of the original matrix, in
   --           the same storage format.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.  LDA >= max(1,N).
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --           > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
   --                matrix is singular and its inverse can not be computed.
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           ZTRMM, ZTRSM, ZTRTI2, XERBLA
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input parameters.
   --
   begin
      INFO   := 0;
      UPPER  := LSAME (UPLO, 'U');
      NOUNIT := LSAME (DIAG, 'N');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif not NOUNIT and not LSAME (DIAG, 'U') then
         INFO := -2;
      elsif N < 0 then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("ZTRTRI", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         return;
      end if;
      --
      --     Check for singularity if non-unit.
      --
      if NOUNIT then
         INFO := 1 - 1;
         loop
            INFO := INFO + 1;
            exit when INFO > N;
            if A (INFO, INFO) = ZERO then
               return;
            end if;
         end loop;
         INFO := 0;
      end if;
      --
      --     Determine the block size for this environment.
      --
      NB := ILAENV (1, "ZTRTRI", UPLO & DIAG, N, -1, -1, -1);
      if NB <= 1 or NB >= N then
         --
         --        Use unblocked code
         --
         ZTRTI2 (UPLO, DIAG, N, A'Address, LDA, INFO);
      else
         --
         --        Use blocked code
         --
         if UPPER then
            --
            --           Compute inverse of upper triangular matrix
            --
            J := 1 - NB;
            loop
               J := J + NB;
               exit when J > N;
               JB := min (NB, N - J + 1);
               --
               --              Compute rows 1:j-1 of current block column
               --
               ZTRMM ('L', 'U', 'N', DIAG, J - 1, JB, ONE, A'Address, LDA, A (1, J)'Address, LDA);
               ZTRSM ('R', 'U', 'N', DIAG, J - 1, JB, -ONE, A (J, J)'Address, LDA, A (1, J)'Address, LDA);
               --
               --              Compute inverse of current diagonal block
               --
               ZTRTI2 ('U', DIAG, JB, A (J, J)'Address, LDA, INFO);
            end loop;
         else
            --
            --           Compute inverse of lower triangular matrix
            --
            NN := ((N - 1) / NB) * NB + 1;
            J  := NN + NB;
            loop
               J := J - NB;
               exit when J < 1;
               JB := min (NB, N - J + 1);
               if J + JB <= N then
                  --
                  --                 Compute rows j+jb:n of current block column
                  --
                  ZTRMM
                    ('L',
                     'L',
                     'N',
                     DIAG,
                     N - J - JB + 1,
                     JB,
                     ONE,
                     A (J + JB, J + JB)'Address,
                     LDA,
                     A (J + JB, J)'Address,
                     LDA);
                  ZTRSM ('R', 'L', 'N', DIAG, N - J - JB + 1, JB, -ONE, A (J, J)'Address, LDA, A (J + JB, J)'Address, LDA);
               end if;
               --
               --              Compute inverse of current diagonal block
               --
               ZTRTI2 ('L', DIAG, JB, A (J, J)'Address, LDA, INFO);
            end loop;
         end if;
      end if;
      --
      return;
      --
      --     End of ZTRTRI
      --
   end ZTRTRI;

   procedure ZUNG2L
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. K);
      WORK : Ftn_Complex_Vector (1 .. N);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE  : constant Complex := (1.0, 0.0);
      ZERO : constant Complex := (0.0, 0.0);
      I    : Integer;
      II   : Integer;
      J    : Integer;
      L    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNG2L( M, N, K, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNG2L generates an m by n complex matrix Q with orthonormal columns,
   --  which is defined as the last n columns of a product of k elementary
   --  reflectors of order m
   --
   --        Q  =  H(k) . . . H(2) H(1)
   --
   --  as returned by ZGEQLF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. M >= N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. N >= K >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the (n-k+i)-th column must contain the vector which
   --           defines the elementary reflector H(i), for i = 1,2,...,k, as
   --           returned by ZGEQLF in the last k columns of its array
   --           argument A.
   --           On exit, the m-by-n matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEQLF.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ), ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLARF, ZSCAL
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 or N > M then
         INFO := -2;
      elsif K < 0 or K > N then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("ZUNG2L", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         return;
      end if;
      --
      --     Initialise columns 1:n-k to columns of the unit matrix
      --
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > N - K;
         L := 1 - 1;
         loop
            L := L + 1;
            exit when L > M;
            A (L, J) := ZERO;
         end loop;
         A (M - N + J, J) := ONE;
      end loop;
      --
      I := 1 - 1;
      loop
         I := I + 1;
         exit when I > K;
         II := N - K + I;
         --
         --        Apply H(i) to A(1:m-k+i,1:n-k+i) from the left
         --
         A (M - N + II, II) := ONE;
         ZLARF ('L', M - N + II, II - 1, A (1, II)'Address, 1, TAU (I), A'Address, LDA, WORK'Address);
         ZSCAL (M - N + II - 1, -TAU (I), A (1, II)'Address, 1);
         A (M - N + II, II) := ONE - TAU (I);
         --
         --        Set A(m-k+i+1:m,n-k+i) to zero
         --
         L := M - N + II + 1 - 1;
         loop
            L := L + 1;
            exit when L > M;
            A (L, II) := ZERO;
         end loop;
      end loop;
      return;
      --
      --     End of ZUNG2L
      --
   end ZUNG2L;

   procedure ZUNG2R
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. K);
      WORK : Ftn_Complex_Vector (1 .. N);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE  : constant Complex := (1.0e0, 0.0e0);
      ZERO : constant Complex := (0.0e0, 0.0e0);
      I    : Integer;
      J    : Integer;
      L    : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNG2R( M, N, K, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNG2R generates an m by n complex matrix Q with orthonormal columns,
   --  which is defined as the first n columns of a product of k elementary
   --  reflectors of order m
   --
   --        Q  =  H(1) H(2) . . . H(k)
   --
   --  as returned by ZGEQRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. M >= N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. N >= K >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the i-th column must contain the vector which
   --           defines the elementary reflector H(i), for i = 1,2,...,k, as
   --           returned by ZGEQRF in the first k columns of its array
   --           argument A.
   --           On exit, the m by n matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEQRF.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (N)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ), ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZLARF, ZSCAL
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < 0 or N > M then
         INFO := -2;
      elsif K < 0 or K > N then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("ZUNG2R", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         return;
      end if;
      --
      --     Initialise columns k+1:n to columns of the unit matrix
      --
      J := K + 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         L := 1 - 1;
         loop
            L := L + 1;
            exit when L > M;
            A (L, J) := ZERO;
         end loop;
         A (J, J) := ONE;
      end loop;
      --
      I := K + 1;
      loop
         I := I - 1;
         exit when I < 1;
         --
         --        Apply H(i) to A(i:m,i:n) from the left
         --
         if I < N then
            A (I, I) := ONE;
            ZLARF ('L', M - I + 1, N - I, A (I, I)'Address, 1, TAU (I), A (I, I + 1)'Address, LDA, WORK'Address);
         end if;
         if I < M then
            ZSCAL (M - I, -TAU (I), A (I + 1, I)'Address, 1);
         end if;
         A (I, I) := ONE - TAU (I);
         --
         --        Set A(1:i-1,i) to zero
         --
         L := 1 - 1;
         loop
            L := L + 1;
            exit when L > I - 1;
            A (L, I) := ZERO;
         end loop;
      end loop;
      return;
      --
      --     End of ZUNG2R
      --
   end ZUNG2R;

   procedure ZUNGBR
     (VECT     : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. max (min (M, K), min (N, K)));
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      LQUERY : Boolean;
      WANTQ  : Boolean;
      I      : Integer;
      IINFO  : Integer;
      J      : Integer;
      LWKOPT : Integer;
      MN     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNGBR( VECT, M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          VECT
   --       INTEGER            INFO, K, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNGBR generates one of the complex unitary matrices Q or P**H
   --  determined by ZGEBRD when reducing a complex matrix A to bidiagonal
   --  form: A = Q * B * P**H.  Q and P**H are defined as products of
   --  elementary reflectors H(i) or G(i) respectively.
   --
   --  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
   --  is of order M:
   --  if m >= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n
   --  columns of Q, where m >= n >= k;
   --  if m < k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an
   --  M-by-M matrix.
   --
   --  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
   --  is of order N:
   --  if k < n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m
   --  rows of P**H, where n >= m >= k;
   --  if k >= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as
   --  an N-by-N matrix.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] VECT
   --           VECT is CHARACTER*1
   --           Specifies whether the matrix Q or the matrix P**H is
   --           required, as defined in the transformation applied by ZGEBRD:
   --           = 'Q':  generate Q;
   --           = 'P':  generate P**H.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q or P**H to be returned.
   --           M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q or P**H to be returned.
   --           N >= 0.
   --           If VECT = 'Q', M >= N >= min(M,K);
   --           if VECT = 'P', N >= M >= min(N,K).
   --
   --  [in] K
   --           K is INTEGER
   --           If VECT = 'Q', the number of columns in the original M-by-K
   --           matrix reduced by ZGEBRD.
   --           If VECT = 'P', the number of rows in the original K-by-N
   --           matrix reduced by ZGEBRD.
   --           K >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the vectors which define the elementary reflectors,
   --           as returned by ZGEBRD.
   --           On exit, the M-by-N matrix Q or P**H.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= M.
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension
   --                                 (min(M,K)) if VECT = 'Q'
   --                                 (min(N,K)) if VECT = 'P'
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i) or G(i), which determines Q or P**H, as
   --           returned by ZGEBRD in its array argument TAUQ or TAUP.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,min(M,N)).
   --           For optimum performance LWORK >= min(M,N)*NB, where NB
   --           is the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  April 2012
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.1) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     April 2012
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ), ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZUNGLQ, ZUNGQR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      WANTQ  := LSAME (VECT, 'Q');
      MN     := min (M, N);
      LQUERY := (LWORK = -1);
      if not WANTQ and not LSAME (VECT, 'P') then
         INFO := -1;
      elsif M < 0 then
         INFO := -2;
      elsif N < 0 or (WANTQ and (N > M or N < min (M, K))) or (not WANTQ and (M > N or M < min (N, K))) then
         INFO := -3;
      elsif K < 0 then
         INFO := -4;
      elsif LDA < max (1, M) then
         INFO := -6;
      elsif LWORK < max (1, MN) and not LQUERY then
         INFO := -9;
      end if;
      --
      if INFO = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         if WANTQ then
            if M >= K then
               ZUNGQR (M, N, K, A'Address, LDA, TAU'Address, WORK'Address, -1, IINFO);
            else
               if M > 1 then
                  ZUNGQR (M - 1, M - 1, M - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, -1, IINFO);
               end if;
            end if;
         else
            if K < N then
               ZUNGLQ (M, N, K, A'Address, LDA, TAU'Address, WORK'Address, -1, IINFO);
            else
               if N > 1 then
                  ZUNGLQ (N - 1, N - 1, N - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, -1, IINFO);
               end if;
            end if;
         end if;
         LWKOPT := int (real_part (WORK (1)));
         LWKOPT := max (LWKOPT, MN);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNGBR", -INFO);
         return;
      elsif LQUERY then
         WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      if WANTQ then
         --
         --        Form Q, determined by a call to ZGEBRD to reduce an m-by-k
         --        matrix
         --
         if M >= K then
            --
            --           If m >= k, assume m >= n >= k
            --
            ZUNGQR (M, N, K, A'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
         --
         else
            --
            --           If m < k, assume m = n
            --
            --           Shift the vectors which define the elementary reflectors one
            --           column to the right, and set the first row and column of Q
            --           to those of the unit matrix
            --
            J := M + 1;
            loop
               J := J - 1;
               exit when J < 2;
               A (1, J) := ZERO;
               I        := J + 1 - 1;
               loop
                  I := I + 1;
                  exit when I > M;
                  A (I, J) := A (I, J - 1);
               end loop;
            end loop;
            A (1, 1) := ONE;
            I        := 2 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, 1) := ZERO;
            end loop;
            if M > 1 then
               --
               --              Form Q(2:m,2:m)
               --
               ZUNGQR (M - 1, M - 1, M - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
            end if;
         end if;
      else
         --
         --        Form P**H, determined by a call to ZGEBRD to reduce a k-by-n
         --        matrix
         --
         if K < N then
            --
            --           If k < n, assume k <= m <= n
            --
            ZUNGLQ (M, N, K, A'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
         --
         else
            --
            --           If k >= n, assume m = n
            --
            --           Shift the vectors which define the elementary reflectors one
            --           row downward, and set the first row and column of P**H to
            --           those of the unit matrix
            --
            A (1, 1) := ONE;
            I        := 2 - 1;
            loop
               I := I + 1;
               exit when I > N;
               A (I, 1) := ZERO;
            end loop;
            J := 2 - 1;
            loop
               J := J + 1;
               exit when J > N;
               I := J - 1 + 1;
               loop
                  I := I - 1;
                  exit when I < 2;
                  A (I, J) := A (I - 1, J);
               end loop;
               A (1, J) := ZERO;
            end loop;
            if N > 1 then
               --
               --              Form P**H(2:n,2:n)
               --
               ZUNGLQ (N - 1, N - 1, N - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
            end if;
         end if;
      end if;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      return;
      --
      --     End of ZUNGBR
      --
   end ZUNGBR;

   procedure ZUNGHR
     (N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. N - 1);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Complex := (0.0e0, 0.0e0);
      ONE    : constant Complex := (1.0e0, 0.0e0);
      LQUERY : Boolean;
      I      : Integer;
      IINFO  : Integer;
      J      : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NH     : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNGHR( N, ILO, IHI, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            IHI, ILO, INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNGHR generates a complex unitary matrix Q which is defined as the
   --  product of IHI-ILO elementary reflectors of order N, as returned by
   --  ZGEHRD:
   --
   --  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix Q. N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --           ILO and IHI must have the same values as in the previous call
   --           of ZGEHRD. Q is equal to the unit matrix except in the
   --           submatrix Q(ilo+1:ihi,ilo+1:ihi).
   --           1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the vectors which define the elementary reflectors,
   --           as returned by ZGEHRD.
   --           On exit, the N-by-N unitary matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (N-1)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEHRD.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= IHI-ILO.
   --           For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
   --           the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ), ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZUNGQR
   --     ..
   --     .. External Functions ..
   --       INTEGER            ILAENV
   --       EXTERNAL           ILAENV
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      NH     := IHI - ILO;
      LQUERY := (LWORK = -1);
      if N < 0 then
         INFO := -1;
      elsif ILO < 1 or ILO > max (1, N) then
         INFO := -2;
      elsif IHI < min (ILO, N) or IHI > N then
         INFO := -3;
      elsif LDA < max (1, N) then
         INFO := -5;
      elsif LWORK < max (1, NH) and not LQUERY then
         INFO := -8;
      end if;
      --
      if INFO = 0 then
         NB       := ILAENV (1, "ZUNGQR", " ", NH, NH, NH, -1);
         LWKOPT   := max (1, NH) * NB;
         WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNGHR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      --     Shift the vectors which define the elementary reflectors one
      --     column to the right, and set the first ilo and the last n-ihi
      --     rows and columns to those of the unit matrix
      --
      J := IHI + 1;
      loop
         J := J - 1;
         exit when J < ILO + 1;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > J - 1;
            A (I, J) := ZERO;
         end loop;
         I := J + 1 - 1;
         loop
            I := I + 1;
            exit when I > IHI;
            A (I, J) := A (I, J - 1);
         end loop;
         I := IHI + 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            A (I, J) := ZERO;
         end loop;
      end loop;
      J := 1 - 1;
      loop
         J := J + 1;
         exit when J > ILO;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            A (I, J) := ZERO;
         end loop;
         A (J, J) := ONE;
      end loop;
      J := IHI + 1 - 1;
      loop
         J := J + 1;
         exit when J > N;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N;
            A (I, J) := ZERO;
         end loop;
         A (J, J) := ONE;
      end loop;
      --
      if NH > 0 then
         --
         --        Generate Q(ilo+1:ihi,ilo+1:ihi)
         --
         ZUNGQR (NH, NH, NH, A (ILO + 1, ILO + 1)'Address, LDA, TAU (ILO)'Address, WORK'Address, LWORK, IINFO);
      end if;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      return;
      --
      --     End of ZUNGHR
      --
   end ZUNGHR;

   procedure ZUNGL2
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. K);
      WORK : Ftn_Complex_Vector (1 .. M);

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ONE  : constant Complex := (1.0e0, 0.0e0);
      ZERO : constant Complex := (0.0e0, 0.0e0);
      I    : Integer;
      J    : Integer;
      L    : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNGL2( M, N, K, A, LDA, TAU, WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,
   --  which is defined as the first m rows of a product of k elementary
   --  reflectors of order n
   --
   --        Q  =  H(k)**H . . . H(2)**H H(1)**H
   --
   --  as returned by ZGELQF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. N >= M.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. M >= K >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the i-th row must contain the vector which defines
   --           the elementary reflector H(i), for i = 1,2,...,k, as returned
   --           by ZGELQF in the first k rows of its array argument A.
   --           On exit, the m by n matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGELQF.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (M)
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ), ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLACGV, ZLARF, ZSCAL
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO := 0;
      if M < 0 then
         INFO := -1;
      elsif N < M then
         INFO := -2;
      elsif K < 0 or K > M then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      end if;
      if INFO /= 0 then
         XERBLA ("ZUNGL2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M <= 0 then
         return;
      end if;
      --
      if K < M then
         --
         --        Initialise rows k+1:m to rows of the unit matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            L := K + 1 - 1;
            loop
               L := L + 1;
               exit when L > M;
               A (L, J) := ZERO;
            end loop;
            if J > K and J <= M then
               A (J, J) := ONE;
            end if;
         end loop;
      end if;
      --
      I := K + 1;
      loop
         I := I - 1;
         exit when I < 1;
         --
         --        Apply H(i)**H to A(i:m,i:n) from the right
         --
         if I < N then
            ZLACGV (N - I, A (I, I + 1)'Address, LDA);
            if I < M then
               A (I, I) := ONE;
               ZLARF
                 ('R',
                  M - I,
                  N - I + 1,
                  A (I, I)'Address,
                  LDA,
                  dconjg (TAU (I)),
                  A (I + 1, I)'Address,
                  LDA,
                  WORK'Address);
            end if;
            ZSCAL (N - I, -TAU (I), A (I, I + 1)'Address, LDA);
            ZLACGV (N - I, A (I, I + 1)'Address, LDA);
         end if;
         A (I, I) := ONE - dconjg (TAU (I));
         --
         --        Set A(i,1:i-1) to zero
         --
         L := 1 - 1;
         loop
            L := L + 1;
            exit when L > I - 1;
            A (I, L) := ZERO;
         end loop;
      end loop;
      return;
      --
      --     End of ZUNGL2
      --
   end ZUNGL2;

   procedure ZUNGLQ
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. K);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Complex := (0.0e0, 0.0e0);
      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      KI     : Integer;
      KK     : Integer;
      L      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNGLQ( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
   --  which is defined as the first M rows of a product of K elementary
   --  reflectors of order N
   --
   --        Q  =  H(k)**H . . . H(2)**H H(1)**H
   --
   --  as returned by ZGELQF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. N >= M.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. M >= K >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the i-th row must contain the vector which defines
   --           the elementary reflector H(i), for i = 1,2,...,k, as returned
   --           by ZGELQF in the first k rows of its array argument A.
   --           On exit, the M-by-N matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGELQF.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,M).
   --           For optimum performance LWORK >= M*NB, where NB is
   --           the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit;
   --           < 0:  if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLARFB, ZLARFT, ZUNGL2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "ZUNGLQ", "   ", M, N, K, -1);
      LWKOPT   := max (1, M) * NB;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < M then
         INFO := -2;
      elsif K < 0 or K > M then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      elsif LWORK < max (1, M) and not LQUERY then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZUNGLQ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M <= 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := M;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "ZUNGLQ", "   ", M, N, K, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := M;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "ZUNGLQ", "   ", M, N, K, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code after the last block.
         --        The first kk rows are handled by the block method.
         --
         KI := ((K - NX - 1) / NB) * NB;
         KK := min (K, KI + NB);
         --
         --        Set A(kk+1:m,1:kk) to zero.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > KK;
            I := KK + 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := ZERO;
            end loop;
         end loop;
      else
         KK := 0;
      end if;
      --
      --     Use unblocked code for the last or only block.
      --
      if KK < M then
         ZUNGL2 (M - KK, N - KK, K - KK, A (KK + 1, KK + 1)'Address, LDA, TAU (KK + 1)'Address, WORK'Address, IINFO);
      end if;
      --
      if KK > 0 then
         --
         --        Use blocked code
         --
         I := KI + 1 + NB;
         loop
            I := I - NB;
            exit when I < 1;
            IB := min (NB, K - I + 1);
            if I + IB <= M then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i) H(i+1) . . . H(i+ib-1)
               --
               ZLARFT ('F', 'R', N - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, LDWORK);
               --
               --              Apply H**H to A(i+ib:m,i:n) from the right
               --
               ZLARFB
                 ('R',
                  'C',
                  'F',
                  'R',
                  M - I - IB + 1,
                  N - I + 1,
                  IB,
                  A (I, I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A (I + IB, I)'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
            --
            --           Apply H**H to columns i:n of current block
            --
            ZUNGL2 (IB, N - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            --
            --           Set columns 1:i-1 of current block to zero
            --
            J := 1 - 1;
            loop
               J := J + 1;
               exit when J > I - 1;
               L := I - 1;
               loop
                  L := L + 1;
                  exit when L > I + IB - 1;
                  A (L, J) := ZERO;
               end loop;
            end loop;
         end loop;
      end if;
      --
      WORK (1) := Complex'(Real (IWS), 0.0e0);
      return;
      --
      --     End of ZUNGLQ
      --
   end ZUNGLQ;

   procedure ZUNGQL
     (M     : Integer;
      N     : Integer;
      K     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      TAU   : Ftn_Complex_Vector;
      WORK  : in out Ftn_Complex_Vector;
      LWORK : Integer;
      INFO  : in out Integer)
   is
      ZERO   : constant Complex := (0.0, 0.0);
      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      KK     : Integer;
      L      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNGQL( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
   --  which is defined as the last N columns of a product of K elementary
   --  reflectors of order M
   --
   --        Q  =  H(k) . . . H(2) H(1)
   --
   --  as returned by ZGEQLF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. M >= N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. N >= K >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the (n-k+i)-th column must contain the vector which
   --           defines the elementary reflector H(i), for i = 1,2,...,k, as
   --           returned by ZGEQLF in the last k columns of its array
   --           argument A.
   --           On exit, the M-by-N matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEQLF.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,N).
   --           For optimum performance LWORK >= N*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLARFB, ZLARFT, ZUNG2L
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 or N > M then
         INFO := -2;
      elsif K < 0 or K > N then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      end if;
      --
      if INFO = 0 then
         if N = 0 then
            LWKOPT := 1;
         else
            NB     := ILAENV (1, "ZUNGQL", " ", M, N, K, -1);
            LWKOPT := N * NB;
         end if;
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
         --
         if LWORK < max (1, N) and not LQUERY then
            INFO := -8;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNGQL", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := N;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "ZUNGQL", " ", M, N, K, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := N;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "ZUNGQL", " ", M, N, K, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code after the first block.
         --        The last kk columns are handled by the block method.
         --
         KK := min (K, ((K - NX + NB - 1) / NB) * NB);
         --
         --        Set A(m-kk+1:m,1:n-kk) to zero.
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N - KK;
            I := M - KK + 1 - 1;
            loop
               I := I + 1;
               exit when I > M;
               A (I, J) := ZERO;
            end loop;
         end loop;
      else
         KK := 0;
      end if;
      --
      --     Use unblocked code for the first or only block.
      --
      ZUNG2L (M - KK, N - KK, K - KK, A'Address, LDA, TAU'Address, WORK'Address, IINFO);
      --
      if KK > 0 then
         --
         --        Use blocked code
         --
         I := K - KK + 1 - NB;
         loop
            I := I + NB;
            exit when I > K;
            IB := min (NB, K - I + 1);
            if N - K + I > 1 then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i+ib-1) . . . H(i+1) H(i)
               --
               ZLARFT
                 ('B',
                  'C',
                  M - K + I + IB - 1,
                  IB,
                  A (1, N - K + I)'Address,
                  LDA,
                  TAU (I)'Address,
                  WORK'Address,
                  LDWORK);
               --
               --              Apply H to A(1:m-k+i+ib-1,1:n-k+i-1) from the left
               --
               ZLARFB
                 ('L',
                  'N',
                  'B',
                  'C',
                  M - K + I + IB - 1,
                  N - K + I - 1,
                  IB,
                  A (1, N - K + I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
            --
            --           Apply H to rows 1:m-k+i+ib-1 of current block
            --
            ZUNG2L (M - K + I + IB - 1, IB, IB, A (1, N - K + I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            --
            --           Set rows m-k+i+ib:m of current block to zero
            --
            J := N - K + I - 1;
            loop
               J := J + 1;
               exit when J > N - K + I + IB - 1;
               L := M - K + I + IB - 1;
               loop
                  L := L + 1;
                  exit when L > M;
                  A (L, J) := ZERO;
               end loop;
            end loop;
         end loop;
      end if;
      --
      WORK (1) := Complex'(Real (IWS), 0.0);
      return;
      --
      --     End of ZUNGQL
      --
   end ZUNGQL;

   procedure ZUNGQR
     (M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. K);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Complex := (0.0e0, 0.0e0);
      LQUERY : Boolean;
      I      : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      J      : Integer;
      KI     : Integer;
      KK     : Integer;
      L      : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NX     : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       INTEGER            INFO, K, LDA, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
   --  which is defined as the first N columns of a product of K elementary
   --  reflectors of order M
   --
   --        Q  =  H(1) H(2) . . . H(k)
   --
   --  as returned by ZGEQRF.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix Q. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix Q. M >= N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines the
   --           matrix Q. N >= K >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the i-th column must contain the vector which
   --           defines the elementary reflector H(i), for i = 1,2,...,k, as
   --           returned by ZGEQRF in the first k columns of its array
   --           argument A.
   --           On exit, the M-by-N matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The first dimension of the array A. LDA >= max(1,M).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEQRF.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= max(1,N).
   --           For optimum performance LWORK >= N*NB, where NB is the
   --           optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument has an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZLARFB, ZLARFT, ZUNG2R
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. External Functions ..
   --       INTEGER            ILAENV
   --       EXTERNAL           ILAENV
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO     := 0;
      NB       := ILAENV (1, "ZUNGQR", " ", M, N, K, -1);
      LWKOPT   := max (1, N) * NB;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      LQUERY   := (LWORK = -1);
      if M < 0 then
         INFO := -1;
      elsif N < 0 or N > M then
         INFO := -2;
      elsif K < 0 or K > N then
         INFO := -3;
      elsif LDA < max (1, M) then
         INFO := -5;
      elsif LWORK < max (1, N) and not LQUERY then
         INFO := -8;
      end if;
      if INFO /= 0 then
         XERBLA ("ZUNGQR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N <= 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      NBMIN := 2;
      NX    := 0;
      IWS   := N;
      if NB > 1 and NB < K then
         --
         --        Determine when to cross over from blocked to unblocked code.
         --
         NX := max (0, ILAENV (3, "ZUNGQR", " ", M, N, K, -1));
         if NX < K then
            --
            --           Determine if workspace is large enough for blocked code.
            --
            LDWORK := N;
            IWS    := LDWORK * NB;
            if LWORK < IWS then
               --
               --              Not enough workspace to use optimal NB:  reduce NB and
               --              determine the minimum value of NB.
               --
               NB    := LWORK / LDWORK;
               NBMIN := max (2, ILAENV (2, "ZUNGQR", " ", M, N, K, -1));
            end if;
         end if;
      end if;
      --
      if NB >= NBMIN and NB < K and NX < K then
         --
         --        Use blocked code after the last block.
         --        The first kk columns are handled by the block method.
         --
         KI := ((K - NX - 1) / NB) * NB;
         KK := min (K, KI + NB);
         --
         --        Set A(1:kk,kk+1:n) to zero.
         --
         J := KK + 1 - 1;
         loop
            J := J + 1;
            exit when J > N;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > KK;
               A (I, J) := ZERO;
            end loop;
         end loop;
      else
         KK := 0;
      end if;
      --
      --     Use unblocked code for the last or only block.
      --
      if KK < N then
         ZUNG2R (M - KK, N - KK, K - KK, A (KK + 1, KK + 1)'Address, LDA, TAU (KK + 1)'Address, WORK'Address, IINFO);
      end if;
      --
      if KK > 0 then
         --
         --        Use blocked code
         --
         I := KI + 1 + NB;
         loop
            I := I - NB;
            exit when I < 1;
            IB := min (NB, K - I + 1);
            if I + IB <= N then
               --
               --              Form the triangular factor of the block reflector
               --              H = H(i) H(i+1) . . . H(i+ib-1)
               --
               ZLARFT ('F', 'C', M - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, LDWORK);
               --
               --              Apply H to A(i:m,i+ib:n) from the left
               --
               ZLARFB
                 ('L',
                  'N',
                  'F',
                  'C',
                  M - I + 1,
                  N - I - IB + 1,
                  IB,
                  A (I, I)'Address,
                  LDA,
                  WORK'Address,
                  LDWORK,
                  A (I, I + IB)'Address,
                  LDA,
                  WORK (IB + 1)'Address,
                  LDWORK);
            end if;
            --
            --           Apply H to rows i:m of current block
            --
            ZUNG2R (M - I + 1, IB, IB, A (I, I)'Address, LDA, TAU (I)'Address, WORK'Address, IINFO);
            --
            --           Set rows 1:i-1 of current block to zero
            --
            J := I - 1;
            loop
               J := J + 1;
               exit when J > I + IB - 1;
               L := 1 - 1;
               loop
                  L := L + 1;
                  exit when L > I - 1;
                  A (L, J) := ZERO;
               end loop;
            end loop;
         end loop;
      end if;
      --
      WORK (1) := Complex'(Real (IWS), 0.0e0);
      return;
      --
      --     End of ZUNGQR
      --
   end ZUNGQR;

   procedure ZUNGTR
     (UPLO     : Character;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. N);
      TAU  : Ftn_Complex_Vector (1 .. N - 1);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, WORK);

      ZERO   : constant Complex := (0.0, 0.0);
      ONE    : constant Complex := (1.0, 0.0);
      LQUERY : Boolean;
      UPPER  : Boolean;
      I      : Integer;
      IINFO  : Integer;
      J      : Integer;
      LWKOPT : Integer;
      NB     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNGTR( UPLO, N, A, LDA, TAU, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          UPLO
   --       INTEGER            INFO, LDA, LWORK, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNGTR generates a complex unitary matrix Q which is defined as the
   --  product of n-1 elementary reflectors of order N, as returned by
   --  ZHETRD:
   --
   --  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
   --
   --  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U': Upper triangle of A contains elementary reflectors
   --                  from ZHETRD;
   --           = 'L': Lower triangle of A contains elementary reflectors
   --                  from ZHETRD.
   --
   --  [in] N
   --           N is INTEGER
   --           The order of the matrix Q. N >= 0.
   --
   --  [in,out] A
   --           A is COMPLEX*16 array, dimension (LDA,N)
   --           On entry, the vectors which define the elementary reflectors,
   --           as returned by ZHETRD.
   --           On exit, the N-by-N unitary matrix Q.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= N.
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (N-1)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZHETRD.
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK. LWORK >= N-1.
   --           For optimum performance LWORK >= (N-1)*NB, where NB is
   --           the optimal blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ZERO = ( 0.0D+0, 0.0D+0 ), ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZUNGQL, ZUNGQR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LQUERY := (LWORK = -1);
      UPPER  := LSAME (UPLO, 'U');
      if not UPPER and not LSAME (UPLO, 'L') then
         INFO := -1;
      elsif N < 0 then
         INFO := -2;
      elsif LDA < max (1, N) then
         INFO := -4;
      elsif LWORK < max (1, N - 1) and not LQUERY then
         INFO := -7;
      end if;
      --
      if INFO = 0 then
         if UPPER 
            then NB := ILAENV (1, "ZUNGQL", " ", N - 1, N - 1, N - 1, -1);
            else NB := ILAENV (1, "ZUNGQR", " ", N - 1, N - 1, N - 1, -1);
         end if;
         LWKOPT   := max (1, N - 1) * NB;
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNGTR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if N = 0 then
         WORK (1) := Complex'(1.0, 0.0);
         return;
      end if;
      --
      if UPPER then
         --
         --        Q was determined by a call to ZHETRD with UPLO = 'U'
         --
         --        Shift the vectors which define the elementary reflectors one
         --        column to the left, and set the last row and column of Q to
         --        those of the unit matrix
         --
         J := 1 - 1;
         loop
            J := J + 1;
            exit when J > N - 1;
            I := 1 - 1;
            loop
               I := I + 1;
               exit when I > J - 1;
               A (I, J) := A (I, J + 1);
            end loop;
            A (N, J) := ZERO;
         end loop;
         I := 1 - 1;
         loop
            I := I + 1;
            exit when I > N - 1;
            A (I, N) := ZERO;
         end loop;
         A (N, N) := ONE;
         --
         --        Generate Q(1:n-1,1:n-1)
         --
         ZUNGQL (N - 1, N - 1, N - 1, A, LDA, TAU, WORK, LWORK, IINFO);
      --
      else
         --
         --        Q was determined by a call to ZHETRD with UPLO = 'L'.
         --
         --        Shift the vectors which define the elementary reflectors one
         --        column to the right, and set the first row and column of Q to
         --        those of the unit matrix
         --
         J := N + 1;
         loop
            J := J - 1;
            exit when J < 2;
            A (1, J) := ZERO;
            I        := J + 1 - 1;
            loop
               I := I + 1;
               exit when I > N;
               A (I, J) := A (I, J - 1);
            end loop;
         end loop;
         A (1, 1) := ONE;
         I        := 2 - 1;
         loop
            I := I + 1;
            exit when I > N;
            A (I, 1) := ZERO;
         end loop;
         if N > 1 then
            --
            --           Generate Q(2:n,2:n)
            --
            ZUNGQR (N - 1, N - 1, N - 1, A (2, 2)'Address, LDA, TAU'Address, WORK'Address, LWORK, IINFO);
         end if;
      end if;
      WORK (1) := Complex'(Real (LWKOPT), 0.0);
      return;
      --
      --     End of ZUNGTR
      --
   end ZUNGTR;

   procedure ZUNM2L
     (SIDE  : Character;
      TRANS : Character;
      M     : Integer;
      N     : Integer;
      K     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      TAU   : Ftn_Complex_Vector;
      C     : Ftn_Complex_Matrix;
      LDC   : Integer;
      WORK  : Ftn_Complex_Vector;
      INFO  : in out Integer)
   is
      ONE    : constant Complex := (1.0, 0.0);
      LEFT   : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      MI     : Integer;
      NI     : Integer;
      NQ     : Integer;
      AII    : Complex;
      TAUI   : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNM2L overwrites the general complex m-by-n matrix C with
   --
   --        Q * C  if SIDE = 'L' and TRANS = 'N', or
   --
   --        Q**H* C  if SIDE = 'L' and TRANS = 'C', or
   --
   --        C * Q  if SIDE = 'R' and TRANS = 'N', or
   --
   --        C * Q**H if SIDE = 'R' and TRANS = 'C',
   --
   --  where Q is a complex unitary matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(k) . . . H(2) H(1)
   --
   --  as returned by ZGEQLF. Q is of order m if SIDE = 'L' and of order n
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**H from the Left
   --           = 'R': apply Q or Q**H from the Right
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply Q  (No transpose)
   --           = 'C': apply Q**H (Conjugate transpose)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,K)
   --           The i-th column must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           ZGEQLF in the last k columns of its array argument A.
   --           A is modified by the routine but restored on exit.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If SIDE = 'L', LDA >= max(1,M);
   --           if SIDE = 'R', LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEQLF.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the m-by-n matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension
   --                                    (N) if SIDE = 'L',
   --                                    (M) if SIDE = 'R'
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLARF
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      --
      --     NQ is the order of Q
      --
      if LEFT 
         then NQ := M;
         else NQ := N;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'C') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      end if;
      if INFO /= 0 then
         XERBLA ("ZUNM2L", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         return;
      end if;
      --
      -- Fortran code: IF( ( LEFT .AND. NOTRAN .OR. .NOT.LEFT .AND. .NOT.NOTRAN ) ) THEN
      -- LCB: is this what they really meant?

      if ((LEFT and NOTRAN) or ((not LEFT) and (not NOTRAN))) then
         I1 := 1;
         I2 := K;
         I3 := 1;
      else
         I1 := K;
         I2 := 1;
         I3 := -1;
      end if;
      --
      if LEFT 
         then NI := N;
         else MI := M;
      end if;
      --
      I := I1 - I3;
      loop
         I := I + I3;
         if I3 > 0 
            then exit when I > I2;
            else exit when I < I2;
         end if;
         if LEFT then
            --
            --           H(i) or H(i)**H is applied to C(1:m-k+i,1:n)
            --
            MI := M - K + I;
         else
            --
            --           H(i) or H(i)**H is applied to C(1:m,1:n-k+i)
            --
            NI := N - K + I;
         end if;
         --
         --        Apply H(i) or H(i)**H
         --
         if NOTRAN 
            then TAUI := TAU (I);
            else TAUI := dconjg (TAU (I));
         end if;
         AII               := A (NQ - K + I, I);
         A (NQ - K + I, I) := ONE;
         ZLARF (SIDE, MI, NI, A (1, I)'Address, 1, TAUI, C'Address, LDC, WORK'Address);
         A (NQ - K + I, I) := AII;
      end loop;
      return;
      --
      --     End of ZUNM2L
      --
   end ZUNM2L;

   procedure ZUNM2R
     (SIDE  : Character;
      TRANS : Character;
      M     : Integer;
      N     : Integer;
      K     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      TAU   : in out Ftn_Complex_Vector;
      C     : in out Ftn_Complex_Matrix;
      LDC   : Integer;
      WORK  : in out Ftn_Complex_Vector;
      INFO  : in out Integer)
   is
      ONE    : constant Complex := (1.0e0, 0.0e0);
      LEFT   : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IC     : Integer;
      JC     : Integer;
      MI     : Integer;
      NI     : Integer;
      NQ     : Integer;
      AII    : Complex;
      TAUI   : Complex;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNM2R overwrites the general complex m-by-n matrix C with
   --
   --        Q * C  if SIDE = 'L' and TRANS = 'N', or
   --
   --        Q**H* C  if SIDE = 'L' and TRANS = 'C', or
   --
   --        C * Q  if SIDE = 'R' and TRANS = 'N', or
   --
   --        C * Q**H if SIDE = 'R' and TRANS = 'C',
   --
   --  where Q is a complex unitary matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(1) H(2) . . . H(k)
   --
   --  as returned by ZGEQRF. Q is of order m if SIDE = 'L' and of order n
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**H from the Left
   --           = 'R': apply Q or Q**H from the Right
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply Q  (No transpose)
   --           = 'C': apply Q**H (Conjugate transpose)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,K)
   --           The i-th column must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           ZGEQRF in the first k columns of its array argument A.
   --           A is modified by the routine but restored on exit.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If SIDE = 'L', LDA >= max(1,M);
   --           if SIDE = 'R', LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEQRF.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the m-by-n matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension
   --                                    (N) if SIDE = 'L',
   --                                    (M) if SIDE = 'R'
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZLARF
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      --
      --     NQ is the order of Q
      --
      if LEFT 
         then NQ := M;
         else NQ := N;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'C') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      end if;
      if INFO /= 0 then
         XERBLA ("ZUNM2R", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         return;
      end if;
      --
      if (LEFT and not NOTRAN) or (not LEFT and NOTRAN) then
         I1 := 1;
         I2 := K;
         I3 := 1;
      else
         I1 := K;
         I2 := 1;
         I3 := -1;
      end if;
      --
      if LEFT then
         NI := N;
         JC := 1;
      else
         MI := M;
         IC := 1;
      end if;
      --
      I := I1 - I3;
      loop
         I := I + I3;
         if I3 > 0 
            then exit when I > I2;
            else exit when I < I2;
         end if;
         if LEFT then
            --
            --           H(i) or H(i)**H is applied to C(i:m,1:n)
            --
            MI := M - I + 1;
            IC := I;
         else
            --
            --           H(i) or H(i)**H is applied to C(1:m,i:n)
            --
            NI := N - I + 1;
            JC := I;
         end if;
         --
         --        Apply H(i) or H(i)**H
         --
         if NOTRAN 
            then TAUI := TAU (I);
            else TAUI := dconjg (TAU (I));
         end if;
         AII      := A (I, I);
         A (I, I) := ONE;
         ZLARF (SIDE, MI, NI, A (I, I)'Address, 1, TAUI, C (IC, JC)'Address, LDC, WORK'Address);
         A (I, I) := AII;
      end loop;
      return;
      --
      --     End of ZUNM2R
      --
   end ZUNM2R;

   procedure ZUNMBR
     (VECT     : Character;
      SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. max (M, N)); -- doc. says (1..LDA,1..NQ) or (1..LDA,1..min(NQ,K))
      TAU  : Ftn_Complex_Vector (1 .. min (max (M, N), K)); -- using NQ = max(M,N) as worst case
      C    : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      APPLYQ : Boolean;
      LEFT   : Boolean;
      LQUERY : Boolean;
      NOTRAN : Boolean;
      TRANST : Character;
      I1     : Integer;
      I2     : Integer;
      IINFO  : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNMBR( VECT, SIDE, TRANS, M, N, K, A, LDA, TAU, C,
   --                          LDC, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS, VECT
   --       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C
   --  with
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'C':      Q**H * C       C * Q**H
   --
   --  If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C
   --  with
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      P * C          C * P
   --  TRANS = 'C':      P**H * C       C * P**H
   --
   --  Here Q and P**H are the unitary matrices determined by ZGEBRD when
   --  reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
   --  and P**H are defined as products of elementary reflectors H(i) and
   --  G(i) respectively.
   --
   --  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
   --  order of the unitary matrix Q or P**H that is applied.
   --
   --  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
   --  if nq >= k, Q = H(1) H(2) . . . H(k);
   --  if nq < k, Q = H(1) H(2) . . . H(nq-1).
   --
   --  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
   --  if k < nq, P = G(1) G(2) . . . G(k);
   --  if k >= nq, P = G(1) G(2) . . . G(nq-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] VECT
   --           VECT is CHARACTER*1
   --           = 'Q': apply Q or Q**H;
   --           = 'P': apply P or P**H.
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q, Q**H, P or P**H from the Left;
   --           = 'R': apply Q, Q**H, P or P**H from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q or P;
   --           = 'C':  Conjugate transpose, apply Q**H or P**H.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           If VECT = 'Q', the number of columns in the original
   --           matrix reduced by ZGEBRD.
   --           If VECT = 'P', the number of rows in the original
   --           matrix reduced by ZGEBRD.
   --           K >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension
   --                                 (LDA,min(nq,K)) if VECT = 'Q'
   --                                 (LDA,nq)        if VECT = 'P'
   --           The vectors which define the elementary reflectors H(i) and
   --           G(i), whose products determine the matrices Q and P, as
   --           returned by ZGEBRD.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If VECT = 'Q', LDA >= max(1,nq);
   --           if VECT = 'P', LDA >= max(1,min(nq,K)).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (min(nq,K))
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i) or G(i) which determines Q or P, as returned
   --           by ZGEBRD in the array argument TAUQ or TAUP.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
   --           or P*C or P**H*C or C*P or C*P**H.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M);
   --           if N = 0 or M = 0, LWORK >= 1.
   --           For optimum performance LWORK >= max(1,N*NB) if SIDE = 'L',
   --           and LWORK >= max(1,M*NB) if SIDE = 'R', where NB is the
   --           optimal blocksize. (NB = 0 if M = 0 or N = 0.)
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZUNMLQ, ZUNMQR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      APPLYQ := LSAME (VECT, 'Q');
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q or P and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if M = 0 or N = 0 then
         NW := 0;
      end if;
      if not APPLYQ and not LSAME (VECT, 'P') then
         INFO := -1;
      elsif not LEFT and not LSAME (SIDE, 'R') then
         INFO := -2;
      elsif not NOTRAN and not LSAME (TRANS, 'C') then
         INFO := -3;
      elsif M < 0 then
         INFO := -4;
      elsif N < 0 then
         INFO := -5;
      elsif K < 0 then
         INFO := -6;
      elsif (APPLYQ and LDA < max (1, NQ)) or (not APPLYQ and LDA < max (1, min (NQ, K))) then
         INFO := -8;
      elsif LDC < max (1, M) then
         INFO := -11;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -13;
      end if;
      --
      if INFO = 0 then
         if NW > 0 then
            if APPLYQ then
               if LEFT 
                  then NB := ILAENV (1, "ZUNMQR", SIDE & TRANS, M - 1, N, M - 1, -1);
                  else NB := ILAENV (1, "ZUNMQR", SIDE & TRANS, M, N - 1, N - 1, -1);
               end if;
            else
               if LEFT 
                  then NB := ILAENV (1, "ZUNMLQ", SIDE & TRANS, M - 1, N, M - 1, -1);
                  else NB := ILAENV (1, "ZUNMLQ", SIDE & TRANS, M, N - 1, N - 1, -1);
               end if;
            end if;
            LWKOPT := max (1, NW * NB);
         else
            LWKOPT := 1;
         end if;
         WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNMBR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      if APPLYQ then
         --
         --        Apply Q
         --
         if NQ >= K then
            --
            --           Q was determined by a call to ZGEBRD with nq >= k
            --
            ZUNMQR (SIDE, TRANS, M, N, K, A'Address, LDA, TAU'Address, C'Address, LDC, WORK'Address, LWORK, IINFO);
         elsif NQ > 1 then
            --
            --           Q was determined by a call to ZGEBRD with nq < k
            --
            if LEFT then
               MI := M - 1;
               NI := N;
               I1 := 2;
               I2 := 1;
            else
               MI := M;
               NI := N - 1;
               I1 := 1;
               I2 := 2;
            end if;
            ZUNMQR
              (SIDE,
               TRANS,
               MI,
               NI,
               NQ - 1,
               A (2, 1)'Address,
               LDA,
               TAU'Address,
               C (I1, I2)'Address,
               LDC,
               WORK'Address,
               LWORK,
               IINFO);
         end if;
      else
         --
         --        Apply P
         --
         if NOTRAN 
            then TRANST := 'C';
            else TRANST := 'N';
         end if;
         if NQ > K then
            --
            --           P was determined by a call to ZGEBRD with nq > k
            --
            ZUNMLQ (SIDE, TRANST, M, N, K, A'Address, LDA, TAU'Address, C'Address, LDC, WORK'Address, LWORK, IINFO);
         elsif NQ > 1 then
            --
            --           P was determined by a call to ZGEBRD with nq <= k
            --
            if LEFT then
               MI := M - 1;
               NI := N;
               I1 := 2;
               I2 := 1;
            else
               MI := M;
               NI := N - 1;
               I1 := 1;
               I2 := 2;
            end if;
            ZUNMLQ
              (SIDE,
               TRANST,
               MI,
               NI,
               NQ - 1,
               A (1, 2)'Address,
               LDA,
               TAU'Address,
               C (I1, I2)'Address,
               LDC,
               WORK'Address,
               LWORK,
               IINFO);
         end if;
      end if;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      return;
      --
      --     End of ZUNMBR
      --
   end ZUNMBR;

   procedure ZUNMHR
     (SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      ILO      : Integer;
      IHI      : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. max (M, N));
      TAU  : Ftn_Complex_Vector (1 .. max (M - 1, N - 1));
      C    : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      LEFT   : Boolean;
      LQUERY : Boolean;
      I1     : Integer;
      I2     : Integer;
      IINFO  : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NH     : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNMHR( SIDE, TRANS, M, N, ILO, IHI, A, LDA, TAU, C,
   --                          LDC, WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            IHI, ILO, INFO, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNMHR overwrites the general complex M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'C':      Q**H * C       C * Q**H
   --
   --  where Q is a complex unitary matrix of order nq, with nq = m if
   --  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
   --  IHI-ILO elementary reflectors, as returned by ZGEHRD:
   --
   --  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**H from the Left;
   --           = 'R': apply Q or Q**H from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply Q  (No transpose)
   --           = 'C': apply Q**H (Conjugate transpose)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] ILO
   --           ILO is INTEGER
   --
   --  [in] IHI
   --           IHI is INTEGER
   --
   --           ILO and IHI must have the same values as in the previous call
   --           of ZGEHRD. Q is equal to the unit matrix except in the
   --           submatrix Q(ilo+1:ihi,ilo+1:ihi).
   --           If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
   --           ILO = 1 and IHI = 0, if M = 0;
   --           if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
   --           ILO = 1 and IHI = 0, if N = 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension
   --                                (LDA,M) if SIDE = 'L'
   --                                (LDA,N) if SIDE = 'R'
   --           The vectors which define the elementary reflectors, as
   --           returned by ZGEHRD.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension
   --                                (M-1) if SIDE = 'L'
   --                                (N-1) if SIDE = 'R'
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEHRD.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       INTEGER            ILAENV
   --       EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZUNMQR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      NH     := IHI - ILO;
      LEFT   := LSAME (SIDE, 'L');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not LSAME (TRANS, 'N') and not LSAME (TRANS, 'C') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif ILO < 1 or ILO > max (1, NQ) then
         INFO := -5;
      elsif IHI < min (ILO, NQ) or IHI > NQ then
         INFO := -6;
      elsif LDA < max (1, NQ) then
         INFO := -8;
      elsif LDC < max (1, M) then
         INFO := -11;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -13;
      end if;
      --
      if INFO = 0 then
         if LEFT 
            then NB := ILAENV (1, "ZUNMQR", SIDE & TRANS, NH, N, NH, -1);
            else NB := ILAENV (1, "ZUNMQR", SIDE & TRANS, M, NH, NH, -1);
         end if;
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNMHR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or NH = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      if LEFT then
         MI := NH;
         NI := N;
         I1 := ILO + 1;
         I2 := 1;
      else
         MI := M;
         NI := NH;
         I1 := 1;
         I2 := ILO + 1;
      end if;
      --
      ZUNMQR
        (SIDE,
         TRANS,
         MI,
         NI,
         NH,
         A (ILO + 1, ILO)'Address,
         LDA,
         TAU (ILO)'Address,
         C (I1, I2)'Address,
         LDC,
         WORK'Address,
         LWORK,
         IINFO);
      --
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      return;
      --
      --     End of ZUNMHR
      --
   end ZUNMHR;

   procedure ZUNML2
     (SIDE  : Character;
      TRANS : Character;
      M     : Integer;
      N     : Integer;
      K     : Integer;
      A     : in out Ftn_Complex_Matrix;
      LDA   : Integer;
      TAU   : in out Ftn_Complex_Vector;
      C     : in out Ftn_Complex_Matrix;
      LDC   : Integer;
      WORK  : in out Ftn_Complex_Vector;
      INFO  : in out Integer)
   is
      ONE    : constant Complex := (1.0e0, 0.0e0);
      LEFT   : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IC     : Integer;
      JC     : Integer;
      MI     : Integer;
      NI     : Integer;
      NQ     : Integer;
      AII    : Complex;
      TAUI   : Complex;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNML2( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNML2 overwrites the general complex m-by-n matrix C with
   --
   --        Q * C  if SIDE = 'L' and TRANS = 'N', or
   --
   --        Q**H* C  if SIDE = 'L' and TRANS = 'C', or
   --
   --        C * Q  if SIDE = 'R' and TRANS = 'N', or
   --
   --        C * Q**H if SIDE = 'R' and TRANS = 'C',
   --
   --  where Q is a complex unitary matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(k)**H . . . H(2)**H H(1)**H
   --
   --  as returned by ZGELQF. Q is of order m if SIDE = 'L' and of order n
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**H from the Left
   --           = 'R': apply Q or Q**H from the Right
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N': apply Q  (No transpose)
   --           = 'C': apply Q**H (Conjugate transpose)
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension
   --                                (LDA,M) if SIDE = 'L',
   --                                (LDA,N) if SIDE = 'R'
   --           The i-th row must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           ZGELQF in the first k rows of its array argument A.
   --           A is modified by the routine but restored on exit.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,K).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGELQF.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the m-by-n matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension
   --                                    (N) if SIDE = 'L',
   --                                    (M) if SIDE = 'R'
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0: successful exit
   --           < 0: if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( ONE = ( 1.0D+0, 0.0D+0 ) )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLACGV, ZLARF
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          DCONJG, MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      --
      --     NQ is the order of Q
      --
      if LEFT 
         then NQ := M;
         else NQ := N;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'C') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, K) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      end if;
      if INFO /= 0 then
         XERBLA ("ZUNML2", -INFO);
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         return;
      end if;
      --
      if (LEFT and NOTRAN) or (not LEFT and not NOTRAN) then
         I1 := 1;
         I2 := K;
         I3 := 1;
      else
         I1 := K;
         I2 := 1;
         I3 := -1;
      end if;
      --
      if LEFT then
         NI := N;
         JC := 1;
      else
         MI := M;
         IC := 1;
      end if;
      --
      I := I1 - I3;
      loop
         I := I + I3;
         if I3 > 0 
            then exit when I > I2;
            else exit when I < I2;
         end if;
         if LEFT then
            --
            --           H(i) or H(i)**H is applied to C(i:m,1:n)
            --
            MI := M - I + 1;
            IC := I;
         else
            --
            --           H(i) or H(i)**H is applied to C(1:m,i:n)
            --
            NI := N - I + 1;
            JC := I;
         end if;
         --
         --        Apply H(i) or H(i)**H
         --
         if NOTRAN 
            then TAUI := dconjg (TAU (I));
            else TAUI := TAU (I);
         end if;
         if I < NQ then
            ZLACGV (NQ - I, A (I, I + 1)'Address, LDA);
         end if;
         AII      := A (I, I);
         A (I, I) := ONE;
         ZLARF (SIDE, MI, NI, A (I, I)'Address, LDA, TAUI, C (IC, JC)'Address, LDC, WORK'Address);
         A (I, I) := AII;
         if I < NQ then
            ZLACGV (NQ - I, A (I, I + 1)'Address, LDA);
         end if;
      end loop;
      return;
      --
      --     End of ZUNML2
      --
   end ZUNML2;

   procedure ZUNMLQ
     (SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. max (M, N));
      TAU  : Ftn_Complex_Vector (1 .. K);
      C    : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      NBMAX  : constant Integer := 64;
      LDT    : constant Integer := NBMAX + 1;
      LEFT   : Boolean;
      LQUERY : Boolean;
      NOTRAN : Boolean;
      TRANST : Character;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IB     : Integer;
      IC     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      JC     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
      T      : Ftn_Complex_Matrix (1 .. LDT, 1 .. NBMAX);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNMLQ( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNMLQ overwrites the general complex M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'C':      Q**H * C       C * Q**H
   --
   --  where Q is a complex unitary matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(k)**H . . . H(2)**H H(1)**H
   --
   --  as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**H from the Left;
   --           = 'R': apply Q or Q**H from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'C':  Conjugate transpose, apply Q**H.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension
   --                                (LDA,M) if SIDE = 'L',
   --                                (LDA,N) if SIDE = 'R'
   --           The i-th row must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           ZGELQF in the first k rows of its array argument A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A. LDA >= max(1,K).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGELQF.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLARFB, ZLARFT, ZUNML2
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'C') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, K) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -12;
      end if;
      --
      if INFO = 0 then
         --
         --        Determine the block size.  NB may be at most NBMAX, where NBMAX
         --        is used to define the local array T.
         --
         NB       := min (NBMAX, ILAENV (1, "ZUNMLQ", SIDE & TRANS, M, N, K, -1));
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNMLQ", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := NW;
      if NB > 1 and NB < K then
         IWS := NW * NB;
         if LWORK < IWS then
            NB    := LWORK / LDWORK;
            NBMIN := max (2, ILAENV (2, "ZUNMLQ", SIDE & TRANS, M, N, K, -1));
         end if;
      else
         IWS := NW;
      end if;
      --
      if NB < NBMIN or NB >= K then
         --
         --        Use unblocked code
         --
         ZUNML2 (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, IINFO);
      else
         --
         --        Use blocked code
         --
         if (LEFT and NOTRAN) or (not LEFT and not NOTRAN) then
            I1 := 1;
            I2 := K;
            I3 := NB;
         else
            I1 := ((K - 1) / NB) * NB + 1;
            I2 := 1;
            I3 := -NB;
         end if;
         --
         if LEFT then
            NI := N;
            JC := 1;
         else
            MI := M;
            IC := 1;
         end if;
         --
         if NOTRAN 
            then TRANST := 'C';
            else TRANST := 'N';
         end if;
         --
         I := I1 - I3;
         loop
            I := I + I3;
            if I3 > 0 
               then exit when I > I2;
               else exit when I < I2;
            end if;
            IB := min (NB, K - I + 1);
            --
            --           Form the triangular factor of the block reflector
            --           H = H(i) H(i+1) . . . H(i+ib-1)
            --
            ZLARFT ('F', 'R', NQ - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, T'Address, LDT);
            if LEFT then
               --
               --              H or H**H is applied to C(i:m,1:n)
               --
               MI := M - I + 1;
               IC := I;
            else
               --
               --              H or H**H is applied to C(1:m,i:n)
               --
               NI := N - I + 1;
               JC := I;
            end if;
            --
            --           Apply H or H**H
            --
            ZLARFB
              (SIDE,
               TRANST,
               'F',
               'R',
               MI,
               NI,
               IB,
               A (I, I)'Address,
               LDA,
               T'Address,
               LDT,
               C (IC, JC)'Address,
               LDC,
               WORK'Address,
               LDWORK);
         end loop;
      end if;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      return;
      --
      --     End of ZUNMLQ
      --
   end ZUNMLQ;

   procedure ZUNMQL
     (SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. K);
      TAU  : Ftn_Complex_Vector (1 .. K);
      C    : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      NBMAX  : constant Integer := 64;
      LDT    : constant Integer := NBMAX + 1;
      LEFT   : Boolean;
      LQUERY : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IB     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
      T      : Ftn_Complex_Matrix (1 .. LDT, 1 .. NBMAX);
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNMQL overwrites the general complex M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'C':      Q**H * C       C * Q**H
   --
   --  where Q is a complex unitary matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(k) . . . H(2) H(1)
   --
   --  as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**H from the Left;
   --           = 'R': apply Q or Q**H from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'C':  Transpose, apply Q**H.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,K)
   --           The i-th column must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           ZGEQLF in the last k columns of its array argument A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If SIDE = 'L', LDA >= max(1,M);
   --           if SIDE = 'R', LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEQLF.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZLARFB, ZLARFT, ZUNM2L
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := max (1, N);
      else
         NQ := N;
         NW := max (1, M);
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'C') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      end if;
      --
      if INFO = 0 then
         if M = 0 or N = 0 then
            LWKOPT := 1;
         else
            --
            --           Determine the block size.  NB may be at most NBMAX, where
            --           NBMAX is used to define the local array T.
            --
            NB     := min (NBMAX, ILAENV (1, "ZUNMQL", SIDE & TRANS, M, N, K, -1));
            LWKOPT := NW * NB;
         end if;
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
         --
         if LWORK < NW and not LQUERY then
            INFO := -12;
         end if;
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNMQL", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 then
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := NW;
      if NB > 1 and NB < K then
         IWS := NW * NB;
         if LWORK < IWS then
            NB    := LWORK / LDWORK;
            NBMIN := max (2, ILAENV (2, "ZUNMQL", SIDE & TRANS, M, N, K, -1));
         end if;
      else
         IWS := NW;
      end if;
      --
      if NB < NBMIN or NB >= K then
         --
         --        Use unblocked code
         --
         ZUNM2L (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, IINFO);
      else
         --
         --        Use blocked code
         --
         if (LEFT and NOTRAN) or (not LEFT and not NOTRAN) then
            I1 := 1;
            I2 := K;
            I3 := NB;
         else
            I1 := ((K - 1) / NB) * NB + 1;
            I2 := 1;
            I3 := -NB;
         end if;
         --
         if LEFT 
            then NI := N;
            else MI := M;
         end if;
         --
         I := I1 - I3;
         loop
            I := I + I3;
            if I3 > 0 
               then exit when I > I2;
               else exit when I < I2;
            end if;
            IB := min (NB, K - I + 1);
            --
            --           Form the triangular factor of the block reflector
            --           H = H(i+ib-1) . . . H(i+1) H(i)
            --
            ZLARFT ('B', 'C', NQ - K + I + IB - 1, IB, A (1, I)'Address, LDA, TAU (I)'Address, T'Address, LDT);
            if LEFT then
               --
               --              H or H**H is applied to C(1:m-k+i+ib-1,1:n)
               --
               MI := M - K + I + IB - 1;
            else
               --
               --              H or H**H is applied to C(1:m,1:n-k+i+ib-1)
               --
               NI := N - K + I + IB - 1;
            end if;
            --
            --           Apply H or H**H
            --
            ZLARFB
              (SIDE,
               TRANS,
               'B',
               'C',
               MI,
               NI,
               IB,
               A (1, I)'Address,
               LDA,
               T'Address,
               LDT,
               C'Address,
               LDC,
               WORK'Address,
               LDWORK);
         end loop;
      end if;
      WORK (1) := Complex'(Real (LWKOPT), 0.0);
      return;
      --
      --     End of ZUNMQL
      --
   end ZUNMQL;

   procedure ZUNMQR
     (SIDE     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      K        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. K);
      TAU  : Ftn_Complex_Vector (1 .. K);
      C    : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      NBMAX  : constant Integer := 64;
      LDT    : constant Integer := NBMAX + 1;
      LEFT   : Boolean;
      LQUERY : Boolean;
      NOTRAN : Boolean;
      I      : Integer;
      I1     : Integer;
      I2     : Integer;
      I3     : Integer;
      IB     : Integer;
      IC     : Integer;
      IINFO  : Integer;
      IWS    : Integer;
      JC     : Integer;
      LDWORK : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NBMIN  : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
      T      : Ftn_Complex_Matrix (1 .. LDT, 1 .. NBMAX);

   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS
   --       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNMQR overwrites the general complex M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'C':      Q**H * C       C * Q**H
   --
   --  where Q is a complex unitary matrix defined as the product of k
   --  elementary reflectors
   --
   --        Q = H(1) H(2) . . . H(k)
   --
   --  as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
   --  if SIDE = 'R'.
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**H from the Left;
   --           = 'R': apply Q or Q**H from the Right.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'C':  Conjugate transpose, apply Q**H.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] K
   --           K is INTEGER
   --           The number of elementary reflectors whose product defines
   --           the matrix Q.
   --           If SIDE = 'L', M >= K >= 0;
   --           if SIDE = 'R', N >= K >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension (LDA,K)
   --           The i-th column must contain the vector which defines the
   --           elementary reflector H(i), for i = 1,2,...,k, as returned by
   --           ZGEQRF in the first k columns of its array argument A.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           If SIDE = 'L', LDA >= max(1,M);
   --           if SIDE = 'R', LDA >= max(1,N).
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension (K)
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZGEQRF.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >= M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Parameters ..
   --      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )
   --     ..
   --     .. Local Scalars ..
   --     ..
   --     .. Local Arrays ..
   --     ..
   --     .. External Functions ..
   --       LOGICAL            LSAME
   --       INTEGER            ILAENV
   --       EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --       EXTERNAL           XERBLA, ZLARFB, ZLARFT, ZUNM2R
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX, MIN
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      NOTRAN := LSAME (TRANS, 'N');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not NOTRAN and not LSAME (TRANS, 'C') then
         INFO := -2;
      elsif M < 0 then
         INFO := -3;
      elsif N < 0 then
         INFO := -4;
      elsif K < 0 or K > NQ then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -12;
      end if;
      --
      if INFO = 0 then
         --
         --        Determine the block size.  NB may be at most NBMAX, where NBMAX
         --        is used to define the local array T.
         --
         NB       := min (NBMAX, ILAENV (1, "ZUNMQR", SIDE & TRANS, M, N, K, -1));
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNMQR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or K = 0 then
         WORK (1) := Complex'(1.0e0, 0.0e0);
         return;
      end if;
      --
      NBMIN  := 2;
      LDWORK := NW;
      if NB > 1 and NB < K then
         IWS := NW * NB;
         if LWORK < IWS then
            NB    := LWORK / LDWORK;
            NBMIN := max (2, ILAENV (2, "ZUNMQR", SIDE & TRANS, M, N, K, -1));
         end if;
      else
         IWS := NW;
      end if;
      --
      if NB < NBMIN or NB >= K then
         --
         --        Use unblocked code
         --
         ZUNM2R (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, IINFO);
      else
         --
         --        Use blocked code
         --
         if (LEFT and not NOTRAN) or (not LEFT and NOTRAN) then
            I1 := 1;
            I2 := K;
            I3 := NB;
         else
            I1 := ((K - 1) / NB) * NB + 1;
            I2 := 1;
            I3 := -NB;
         end if;
         --
         if LEFT then
            NI := N;
            JC := 1;
         else
            MI := M;
            IC := 1;
         end if;
         --
         I := I1 - I3;
         loop
            I := I + I3;
            if I3 > 0 
               then exit when I > I2;
               else exit when I < I2;
            end if;
            IB := min (NB, K - I + 1);
            --
            --           Form the triangular factor of the block reflector
            --           H = H(i) H(i+1) . . . H(i+ib-1)
            --
            ZLARFT ('F', 'C', NQ - I + 1, IB, A (I, I)'Address, LDA, TAU (I)'Address, T'Address, LDT);
            if LEFT then
               --
               --              H or H**H is applied to C(i:m,1:n)
               --
               MI := M - I + 1;
               IC := I;
            else
               --
               --              H or H**H is applied to C(1:m,i:n)
               --
               NI := N - I + 1;
               JC := I;
            end if;
            --
            --           Apply H or H**H
            --
            ZLARFB
              (SIDE,
               TRANS,
               'F',
               'C',
               MI,
               NI,
               IB,
               A (I, I)'Address,
               LDA,
               T'Address,
               LDT,
               C (IC, JC)'Address,
               LDC,
               WORK'Address,
               LDWORK);
         end loop;
      end if;
      WORK (1) := Complex'(Real (LWKOPT), 0.0e0);
      return;
      --
      --     End of ZUNMQR
      --
   end ZUNMQR;

   procedure ZUNMTR
     (SIDE     : Character;
      UPLO     : Character;
      TRANS    : Character;
      M        : Integer;
      N        : Integer;
      A_adr    : Address;
      LDA      : Integer;
      TAU_adr  : Address;
      C_adr    : Address;
      LDC      : Integer;
      WORK_adr : Address;
      LWORK    : Integer;
      INFO     : in out Integer)
   is

      A    : Ftn_Complex_Matrix (1 .. LDA, 1 .. max (N, M));
      TAU  : Ftn_Complex_Vector (1 .. max (N - 1, M - 1));
      C    : Ftn_Complex_Matrix (1 .. LDC, 1 .. N);
      WORK : Ftn_Complex_Vector (1 .. max (1, LWORK));

      for A'Address use A_adr;
      for TAU'Address use TAU_adr;
      for C'Address use C_adr;
      for WORK'Address use WORK_adr;

      pragma Import (Ada, A);
      pragma Import (Ada, TAU);
      pragma Import (Ada, C);
      pragma Import (Ada, WORK);

      LEFT   : Boolean;
      LQUERY : Boolean;
      UPPER  : Boolean;
      I1     : Integer;
      I2     : Integer;
      IINFO  : Integer;
      LWKOPT : Integer;
      MI     : Integer;
      NB     : Integer;
      NI     : Integer;
      NQ     : Integer;
      NW     : Integer;
   --
   --  =========== DOCUMENTATION ===========
   --
   -- Online html documentation available at
   --            http://www.netlib.org/lapack/explore-html/
   --
   --
   --  Definition:
   --  ===========
   --
   --       SUBROUTINE ZUNMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,
   --                          WORK, LWORK, INFO )
   --
   --       .. Scalar Arguments ..
   --       CHARACTER          SIDE, TRANS, UPLO
   --       INTEGER            INFO, LDA, LDC, LWORK, M, N
   --       ..
   --       .. Array Arguments ..
   --       COMPLEX*16         A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
   --       ..
   --
   --
   --  Purpose:
   --  ========
   --
   --
   --  ZUNMTR overwrites the general complex M-by-N matrix C with
   --
   --                  SIDE = 'L'     SIDE = 'R'
   --  TRANS = 'N':      Q * C          C * Q
   --  TRANS = 'C':      Q**H * C       C * Q**H
   --
   --  where Q is a complex unitary matrix of order nq, with nq = m if
   --  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
   --  nq-1 elementary reflectors, as returned by ZHETRD:
   --
   --  if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
   --
   --  if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
   --
   --  Arguments:
   --  ==========
   --
   --  [in] SIDE
   --           SIDE is CHARACTER*1
   --           = 'L': apply Q or Q**H from the Left;
   --           = 'R': apply Q or Q**H from the Right.
   --
   --  [in] UPLO
   --           UPLO is CHARACTER*1
   --           = 'U': Upper triangle of A contains elementary reflectors
   --                  from ZHETRD;
   --           = 'L': Lower triangle of A contains elementary reflectors
   --                  from ZHETRD.
   --
   --  [in] TRANS
   --           TRANS is CHARACTER*1
   --           = 'N':  No transpose, apply Q;
   --           = 'C':  Conjugate transpose, apply Q**H.
   --
   --  [in] M
   --           M is INTEGER
   --           The number of rows of the matrix C. M >= 0.
   --
   --  [in] N
   --           N is INTEGER
   --           The number of columns of the matrix C. N >= 0.
   --
   --  [in] A
   --           A is COMPLEX*16 array, dimension
   --                                (LDA,M) if SIDE = 'L'
   --                                (LDA,N) if SIDE = 'R'
   --           The vectors which define the elementary reflectors, as
   --           returned by ZHETRD.
   --
   --  [in] LDA
   --           LDA is INTEGER
   --           The leading dimension of the array A.
   --           LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
   --
   --  [in] TAU
   --           TAU is COMPLEX*16 array, dimension
   --                                (M-1) if SIDE = 'L'
   --                                (N-1) if SIDE = 'R'
   --           TAU(i) must contain the scalar factor of the elementary
   --           reflector H(i), as returned by ZHETRD.
   --
   --  [in,out] C
   --           C is COMPLEX*16 array, dimension (LDC,N)
   --           On entry, the M-by-N matrix C.
   --           On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
   --
   --  [in] LDC
   --           LDC is INTEGER
   --           The leading dimension of the array C. LDC >= max(1,M).
   --
   --  [out] WORK
   --           WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
   --           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
   --
   --  [in] LWORK
   --           LWORK is INTEGER
   --           The dimension of the array WORK.
   --           If SIDE = 'L', LWORK >= max(1,N);
   --           if SIDE = 'R', LWORK >= max(1,M).
   --           For optimum performance LWORK >= N*NB if SIDE = 'L', and
   --           LWORK >=M*NB if SIDE = 'R', where NB is the optimal
   --           blocksize.
   --
   --           If LWORK = -1, then a workspace query is assumed; the routine
   --           only calculates the optimal size of the WORK array, returns
   --           this value as the first entry of the WORK array, and no error
   --           message related to LWORK is issued by XERBLA.
   --
   --  [out] INFO
   --           INFO is INTEGER
   --           = 0:  successful exit
   --           < 0:  if INFO = -i, the i-th argument had an illegal value
   --
   --  Authors:
   --  ========
   --
   --     Univ. of Tennessee
   --     Univ. of California Berkeley
   --     Univ. of Colorado Denver
   --     NAG Ltd.
   --
   --  November 2011
   --
   --
   --  =====================================================================
   --
   --  -- LAPACK computational routine (version 3.4.0) --
   --  -- LAPACK is a software package provided by Univ. of Tennessee,    --
   --  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
   --     November 2011
   --
   --     .. Scalar Arguments ..
   --     ..
   --     .. Array Arguments ..
   --     ..
   --
   --  =====================================================================
   --
   --     .. Local Scalars ..
   --     ..
   --     .. External Functions ..
   --      EXTERNAL           LSAME, ILAENV
   --     ..
   --     .. External Subroutines ..
   --      EXTERNAL           XERBLA, ZUNMQL, ZUNMQR
   --     ..
   --     .. Intrinsic Functions ..
   --      INTRINSIC          MAX
   --     ..
   --     .. Executable Statements ..
   --
   --     Test the input arguments
   --
   begin
      INFO   := 0;
      LEFT   := LSAME (SIDE, 'L');
      UPPER  := LSAME (UPLO, 'U');
      LQUERY := (LWORK = -1);
      --
      --     NQ is the order of Q and NW is the minimum dimension of WORK
      --
      if LEFT then
         NQ := M;
         NW := N;
      else
         NQ := N;
         NW := M;
      end if;
      if not LEFT and not LSAME (SIDE, 'R') then
         INFO := -1;
      elsif not UPPER and not LSAME (UPLO, 'L') then
         INFO := -2;
      elsif not LSAME (TRANS, 'N') and not LSAME (TRANS, 'C') then
         INFO := -3;
      elsif M < 0 then
         INFO := -4;
      elsif N < 0 then
         INFO := -5;
      elsif LDA < max (1, NQ) then
         INFO := -7;
      elsif LDC < max (1, M) then
         INFO := -10;
      elsif LWORK < max (1, NW) and not LQUERY then
         INFO := -12;
      end if;
      --
      if INFO = 0 then
         if UPPER then
            if LEFT 
               then NB := ILAENV (1, "ZUNMQL", SIDE & TRANS, M - 1, N, M - 1, -1);
               else NB := ILAENV (1, "ZUNMQL", SIDE & TRANS, M, N - 1, N - 1, -1);
            end if;
         else
            if LEFT 
               then NB := ILAENV (1, "ZUNMQR", SIDE & TRANS, M - 1, N, M - 1, -1);
               else NB := ILAENV (1, "ZUNMQR", SIDE & TRANS, M, N - 1, N - 1, -1);
            end if;
         end if;
         LWKOPT   := max (1, NW) * NB;
         WORK (1) := Complex'(Real (LWKOPT), 0.0);
      end if;
      --
      if INFO /= 0 then
         XERBLA ("ZUNMTR", -INFO);
         return;
      elsif LQUERY then
         return;
      end if;
      --
      --     Quick return if possible
      --
      if M = 0 or N = 0 or NQ = 1 then
         WORK (1) := Complex'(1.0, 0.0);
         return;
      end if;
      --
      if LEFT then
         MI := M - 1;
         NI := N;
      else
         MI := M;
         NI := N - 1;
      end if;
      --
      if UPPER then
         --
         --        Q was determined by a call to ZHETRD with UPLO = 'U'
         --
         ZUNMQL (SIDE, TRANS, MI, NI, NQ - 1, A (1, 2)'Address, LDA, TAU'Address, C'Address, LDC, WORK'Address, LWORK, IINFO);
      else
         --
         --        Q was determined by a call to ZHETRD with UPLO = 'L'
         --
         if LEFT then
            I1 := 2;
            I2 := 1;
         else
            I1 := 1;
            I2 := 2;
         end if;
         ZUNMQR
           (SIDE,
            TRANS,
            MI,
            NI,
            NQ - 1,
            A (2, 1)'Address,
            LDA,
            TAU'Address,
            C (I1, I2)'Address,
            LDC,
            WORK'Address,
            LWORK,
            IINFO);
      end if;
      WORK (1) := Complex'(Real (LWKOPT), 0.0);
      return;
      --
      --     End of ZUNMTR
      --
   end ZUNMTR;

end Ada_Lapack;
